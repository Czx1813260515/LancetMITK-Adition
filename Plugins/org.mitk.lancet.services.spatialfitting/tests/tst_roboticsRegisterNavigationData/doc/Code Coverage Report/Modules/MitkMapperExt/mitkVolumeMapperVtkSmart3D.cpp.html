<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkVolumeMapperVtkSmart3D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkVolumeMapperVtkSmart3D.h"
#include "mitkTransferFunctionProperty.h"
#include "mitkTransferFunctionInitializer.h"
#include "mitkLevelWindowProperty.h"
#include &lt;vtkObjectFactory.h&gt;
#include &lt;vtkColorTransferFunction.h&gt;
#include &lt;vtkPiecewiseFunction.h&gt;
#include &lt;vtkAutoInit.h&gt;

void mitk::VolumeMapperVtkSmart3D::GenerateDataForRenderer(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{</span>
  bool value;
<span style = "background-color:#fdd">  this-&gt;GetDataNode()-&gt;GetBoolProperty("volumerendering", value, renderer);
  if (!value)</span>
  {
<span style = "background-color:#fdd">    m_Volume-&gt;VisibilityOff();
    return;
  }</span>
  else
  {
<span style = "background-color:#fdd">    createMapper(GetInputImage());
    m_Volume-&gt;VisibilityOn();</span>
  }

<span style = "background-color:#fdd">  UpdateTransferFunctions(renderer);
  UpdateRenderMode(renderer);
  this-&gt;Modified();
}</span>

vtkProp* mitk::VolumeMapperVtkSmart3D::GetVtkProp(mitk::BaseRenderer *)
<span style = "background-color:#fdd">{
  if (!m_Volume-&gt;GetMapper())</span>
  {
<span style = "background-color:#fdd">    createMapper(GetInputImage());
    createVolume();
    createVolumeProperty();</span>
  }

<span style = "background-color:#fdd">  return m_Volume;
}</span>

void mitk::VolumeMapperVtkSmart3D::ApplyProperties(vtkActor *, mitk::BaseRenderer *)
<span style = "background-color:#fdd">{</span>

<span style = "background-color:#fdd">}</span>

void mitk::VolumeMapperVtkSmart3D::SetDefaultProperties(mitk::DataNode *node, mitk::BaseRenderer *renderer, bool overwrite)
<span style = "background-color:#fdd">{</span>
  // GPU_INFO &lt;&lt; "SetDefaultProperties";

<span style = "background-color:#fdd">  node-&gt;AddProperty("volumerendering", mitk::BoolProperty::New(false), renderer, overwrite);</span>

<span style = "background-color:#fdd">  node-&gt;AddProperty("volumerendering.ambient", mitk::FloatProperty::New(0.25f), renderer, overwrite);
  node-&gt;AddProperty("volumerendering.diffuse", mitk::FloatProperty::New(0.50f), renderer, overwrite);
  node-&gt;AddProperty("volumerendering.specular", mitk::FloatProperty::New(0.40f), renderer, overwrite);
  node-&gt;AddProperty("volumerendering.specular.power", mitk::FloatProperty::New(16.0f), renderer, overwrite);</span>

<span style = "background-color:#fdd">  node-&gt;AddProperty("binary", mitk::BoolProperty::New(false), renderer, overwrite);</span>

<span style = "background-color:#fdd">  mitk::Image::Pointer image = dynamic_cast&lt;mitk::Image *&gt;(node-&gt;GetData());
  if (image.IsNotNull() &amp;&amp; image-&gt;IsInitialized())</span>
  {
<span style = "background-color:#fdd">    if ((overwrite) || (node-&gt;GetProperty("TransferFunction", renderer) == nullptr))</span>
    {
      // add a default transfer function
<span style = "background-color:#fdd">      mitk::TransferFunction::Pointer tf = mitk::TransferFunction::New();
      mitk::TransferFunctionInitializer::Pointer tfInit = mitk::TransferFunctionInitializer::New(tf);
      tfInit-&gt;SetTransferFunctionMode(0);
      node-&gt;SetProperty("TransferFunction", mitk::TransferFunctionProperty::New(tf.GetPointer()));
    }</span>
  }

<span style = "background-color:#fdd">  Superclass::SetDefaultProperties(node, renderer, overwrite);
}</span>

vtkImageData* mitk::VolumeMapperVtkSmart3D::GetInputImage()
<span style = "background-color:#fdd">{
  auto input = dynamic_cast&lt;mitk::Image*&gt;(this-&gt;GetDataNode()-&gt;GetData());
  return input-&gt;GetVtkImageData(this-&gt;GetTimestep());
}</span>

void mitk::VolumeMapperVtkSmart3D::createMapper(vtkImageData* imageData)
<span style = "background-color:#fdd">{
  Vector3D spacing;
  FillVector3D(spacing, 1.0, 1.0, 1.0);</span>

<span style = "background-color:#fdd">  m_ImageChangeInformation-&gt;SetInputData(imageData);
  m_ImageChangeInformation-&gt;SetOutputSpacing(spacing.GetDataPointer());</span>

<span style = "background-color:#fdd">  m_SmartVolumeMapper-&gt;SetBlendModeToComposite();
  m_SmartVolumeMapper-&gt;SetInputConnection(m_ImageChangeInformation-&gt;GetOutputPort());
}</span>

void mitk::VolumeMapperVtkSmart3D::createVolume()
<span style = "background-color:#fdd">{
  m_Volume-&gt;SetMapper(m_SmartVolumeMapper);
  m_Volume-&gt;SetProperty(m_VolumeProperty);
}</span>

void mitk::VolumeMapperVtkSmart3D::createVolumeProperty()
<span style = "background-color:#fdd">{
  m_VolumeProperty-&gt;ShadeOn();
  m_VolumeProperty-&gt;SetInterpolationType(VTK_CUBIC_INTERPOLATION);
}</span>

void mitk::VolumeMapperVtkSmart3D::UpdateTransferFunctions(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkPiecewiseFunction&gt; opacityTransferFunction;
  vtkSmartPointer&lt;vtkPiecewiseFunction&gt; gradientTransferFunction;
  vtkSmartPointer&lt;vtkColorTransferFunction&gt; colorTransferFunction;</span>

<span style = "background-color:#fdd">  bool isBinary = false;</span>

<span style = "background-color:#fdd">  this-&gt;GetDataNode()-&gt;GetBoolProperty("binary", isBinary, renderer);</span>

<span style = "background-color:#fdd">  if (isBinary)</span>
  {
<span style = "background-color:#fdd">    colorTransferFunction = vtkSmartPointer&lt;vtkColorTransferFunction&gt;::New();</span>

    float rgb[3];
<span style = "background-color:#fdd">    if (!GetDataNode()-&gt;GetColor(rgb, renderer))
      rgb[0] = rgb[1] = rgb[2] = 1;
    colorTransferFunction-&gt;AddRGBPoint(0, rgb[0], rgb[1], rgb[2]);
    colorTransferFunction-&gt;Modified();</span>

<span style = "background-color:#fdd">    opacityTransferFunction = vtkSmartPointer&lt;vtkPiecewiseFunction&gt;::New();
    gradientTransferFunction = vtkSmartPointer&lt;vtkPiecewiseFunction&gt;::New();
  }</span>
  else
  {
<span style = "background-color:#fdd">    auto *transferFunctionProp =</span>
      dynamic_cast&lt;mitk::TransferFunctionProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("TransferFunction", renderer));

<span style = "background-color:#fdd">    if (transferFunctionProp)</span>
    {
<span style = "background-color:#fdd">      opacityTransferFunction = transferFunctionProp-&gt;GetValue()-&gt;GetScalarOpacityFunction();
      gradientTransferFunction = transferFunctionProp-&gt;GetValue()-&gt;GetGradientOpacityFunction();
      colorTransferFunction = transferFunctionProp-&gt;GetValue()-&gt;GetColorTransferFunction();
    }</span>
    else
    {
<span style = "background-color:#fdd">      opacityTransferFunction = vtkSmartPointer&lt;vtkPiecewiseFunction&gt;::New();
      gradientTransferFunction = vtkSmartPointer&lt;vtkPiecewiseFunction&gt;::New();
      colorTransferFunction = vtkSmartPointer&lt;vtkColorTransferFunction&gt;::New();</span>
    }
  }
<span style = "background-color:#fdd">  m_VolumeProperty-&gt;SetColor(colorTransferFunction);
  m_VolumeProperty-&gt;SetScalarOpacity(opacityTransferFunction);
  m_VolumeProperty-&gt;SetGradientOpacity(gradientTransferFunction);
}</span>


void mitk::VolumeMapperVtkSmart3D::UpdateRenderMode(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  m_SmartVolumeMapper-&gt;SetRequestedRenderModeToGPU();</span>

  int blendMode;
<span style = "background-color:#fdd">  if (this-&gt;GetDataNode()-&gt;GetIntProperty("volumerendering.blendmode", blendMode))</span>
  {
<span style = "background-color:#fdd">    m_SmartVolumeMapper-&gt;SetBlendMode(blendMode);</span>
  }

  // shading parameter
<span style = "background-color:#fdd">  float value = 0;
  if (this-&gt;GetDataNode()-&gt;GetFloatProperty("volumerendering.ambient", value, renderer))
    m_VolumeProperty-&gt;SetAmbient(value);
  if (this-&gt;GetDataNode()-&gt;GetFloatProperty("volumerendering.diffuse", value, renderer))
    m_VolumeProperty-&gt;SetDiffuse(value);
  if (this-&gt;GetDataNode()-&gt;GetFloatProperty("volumerendering.specular", value, renderer))
    m_VolumeProperty-&gt;SetSpecular(value);
  if (this-&gt;GetDataNode()-&gt;GetFloatProperty("volumerendering.specular.power", value, renderer))
    m_VolumeProperty-&gt;SetSpecularPower(value);
}</span>

mitk::VolumeMapperVtkSmart3D::VolumeMapperVtkSmart3D()
<span style = "background-color:#fdd">{
  m_SmartVolumeMapper = vtkSmartPointer&lt;vtkSmartVolumeMapper&gt;::New();
  m_SmartVolumeMapper-&gt;SetBlendModeToComposite();
  m_ImageChangeInformation = vtkSmartPointer&lt;vtkImageChangeInformation&gt;::New();
  m_VolumeProperty = vtkSmartPointer&lt;vtkVolumeProperty&gt;::New();
  m_Volume = vtkSmartPointer&lt;vtkVolume&gt;::New();
}</span>

mitk::VolumeMapperVtkSmart3D::~VolumeMapperVtkSmart3D()
<span style = "background-color:#fdd">{</span>

<span style = "background-color:#fdd">}</span>

</pre>
	</body>
</html>