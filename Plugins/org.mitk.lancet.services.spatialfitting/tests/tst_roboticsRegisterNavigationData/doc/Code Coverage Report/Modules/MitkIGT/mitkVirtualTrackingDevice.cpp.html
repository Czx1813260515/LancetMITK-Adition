<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkVirtualTrackingDevice.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkVirtualTrackingDevice.h"
#include "mitkIGTTimeStamp.h"
#include "mitkIGTException.h"

#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;ctime&gt;
#include &lt;itksys/SystemTools.hxx&gt;
#include &lt;random&gt;

#include &lt;mitkVirtualTrackerTypeInformation.h&gt;

<span style = "background-color:#fdd">mitk::VirtualTrackingDevice::VirtualTrackingDevice() : mitk::TrackingDevice(),
m_AllTools(), m_RefreshRate(100), m_NumberOfControlPoints(20), m_GaussianNoiseEnabled(false),
m_MeanDistributionParam(0.0), m_DeviationDistributionParam(1.0)
{
  m_Data = mitk::VirtualTrackerTypeInformation::GetDeviceDataVirtualTracker();
  m_Bounds[0] = m_Bounds[2] = m_Bounds[4] = -400.0;  // initialize bounds to -400 ... +400 (mm) cube
  m_Bounds[1] = m_Bounds[3] = m_Bounds[5] = 400.0;
}</span>

mitk::VirtualTrackingDevice::~VirtualTrackingDevice()
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() == Tracking)</span>
  {
<span style = "background-color:#fdd">    this-&gt;StopTracking();</span>
  }
<span style = "background-color:#fdd">  if (this-&gt;GetState() == Ready)</span>
  {
<span style = "background-color:#fdd">    this-&gt;CloseConnection();</span>
  }
  /* cleanup tracking thread */
<span style = "background-color:#fdd">  if (m_Thread.joinable())
    m_Thread.join();</span>

<span style = "background-color:#fdd">  m_AllTools.clear();
}</span>

mitk::TrackingTool* mitk::VirtualTrackingDevice::AddTool(const char* toolName)
<span style = "background-color:#fdd">{</span>
  //if (this-&gt;GetState() == Tracking)
  //{
  //  return nullptr;
  //}
<span style = "background-color:#fdd">  mitk::VirtualTrackingTool::Pointer t = mitk::VirtualTrackingTool::New();
  t-&gt;SetToolName(toolName);
  t-&gt;SetVelocity(0.1);
  this-&gt;InitializeSpline(t);
  std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex); // lock and unlock the mutex
  m_AllTools.push_back(t);
  return t;
}</span>


bool mitk::VirtualTrackingDevice::StartTracking()
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Ready)
    return false;
  this-&gt;SetState(Tracking);            // go to mode Tracking
  this-&gt;m_StopTrackingMutex.lock();
  this-&gt;m_StopTracking = false;
  this-&gt;m_StopTrackingMutex.unlock();</span>

<span style = "background-color:#fdd">  mitk::IGTTimeStamp::GetInstance()-&gt;Start(this);</span>

<span style = "background-color:#fdd">  if (m_Thread.joinable())
    m_Thread.detach();</span>

<span style = "background-color:#fdd">  m_Thread = std::thread(&amp;VirtualTrackingDevice::ThreadStartTracking, this); // start a new thread that executes the TrackTools() method
  return true;
}</span>

bool mitk::VirtualTrackingDevice::StopTracking()
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() == Tracking) // Only if the object is in the correct state</span>
  {
<span style = "background-color:#fdd">    m_StopTrackingMutex.lock();  // m_StopTracking is used by two threads, so we have to ensure correct thread handling
    m_StopTracking = true;
    m_StopTrackingMutex.unlock();</span>

<span style = "background-color:#fdd">    m_TrackingFinishedMutex.lock();
    this-&gt;SetState(Ready);
    m_TrackingFinishedMutex.unlock();</span>
  }

<span style = "background-color:#fdd">  mitk::IGTTimeStamp::GetInstance()-&gt;Stop(this);</span>

<span style = "background-color:#fdd">  return true;
}</span>

unsigned int mitk::VirtualTrackingDevice::GetToolCount() const
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex); // lock and unlock the mutex
  return static_cast&lt;unsigned int&gt;(this-&gt;m_AllTools.size());
}</span>

mitk::TrackingTool* mitk::VirtualTrackingDevice::GetTool(unsigned int toolNumber) const
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex); // lock and unlock the mutex
  if (toolNumber &lt; m_AllTools.size())
    return this-&gt;m_AllTools.at(toolNumber);
  return nullptr;
}</span>

bool mitk::VirtualTrackingDevice::OpenConnection()
<span style = "background-color:#fdd">{
  if (m_NumberOfControlPoints &lt; 1)</span>
  {
<span style = "background-color:#fdd">    mitkThrowException(mitk::IGTException) &lt;&lt; "to few control points for spline interpolation";</span>
  }
<span style = "background-color:#fdd">  srand(time(nullptr)); //Init random number generator</span>

<span style = "background-color:#fdd">  this-&gt;SetState(Ready);
  return true;
}</span>

void mitk::VirtualTrackingDevice::InitializeSpline(mitk::VirtualTrackingTool* t)
<span style = "background-color:#fdd">{
  if (t == nullptr)
    return;</span>

  typedef mitk::VirtualTrackingTool::SplineType SplineType;
  /* create random control points */
<span style = "background-color:#fdd">  SplineType::ControlPointListType controlPoints;
  controlPoints.reserve(m_NumberOfControlPoints + 1);</span>

<span style = "background-color:#fdd">  controlPoints.push_back(this-&gt;GetRandomPoint()); // insert point 0
  double length = 0.0;  // estimate spline length by calculating line segments lengths
  for (unsigned int i = 1; i &lt; m_NumberOfControlPoints - 1; ++i) // set points 1..n-2</span>
  {
    SplineType::ControlPointType pos;
<span style = "background-color:#fdd">    pos = this-&gt;GetRandomPoint();
    length += controlPoints.at(i - 1).EuclideanDistanceTo(pos);
    controlPoints.push_back(pos);
  }
  controlPoints.push_back(controlPoints.at(0));  // close spline --&gt; insert point last control point with same value as first control point
  length += controlPoints.at(controlPoints.size() - 2).EuclideanDistanceTo(controlPoints.at(controlPoints.size() - 1));</span>

  /* Create knot list. TODO: rethink knot list values and list size. Is there a better solution? */
<span style = "background-color:#fdd">  SplineType::KnotListType knotList;
  knotList.push_back(0.0);
  for (unsigned int i = 1; i &lt; controlPoints.size() + t-&gt;GetSpline()-&gt;GetSplineOrder() + 1; ++i)
    knotList.push_back(i);
  knotList.push_back(controlPoints.size() + t-&gt;GetSpline()-&gt;GetSplineOrder() + 1);</span>

<span style = "background-color:#fdd">  t-&gt;GetSpline()-&gt;SetControlPoints(controlPoints);
  t-&gt;GetSpline()-&gt;SetKnots(knotList);
  t-&gt;SetSplineLength(length);
}</span>

bool mitk::VirtualTrackingDevice::CloseConnection()
<span style = "background-color:#fdd">{
  bool returnValue = true;
  if (this-&gt;GetState() == Setup)
    return true;</span>

<span style = "background-color:#fdd">  this-&gt;SetState(Setup);
  return returnValue;
}</span>

mitk::ScalarType mitk::VirtualTrackingDevice::GetSplineChordLength(unsigned int idx)
<span style = "background-color:#fdd">{
  mitk::VirtualTrackingTool* t = this-&gt;GetInternalTool(idx);
  if (t != nullptr)
    return t-&gt;GetSplineLength();</span>
  else
<span style = "background-color:#fdd">    throw std::invalid_argument("invalid index");
}</span>

void mitk::VirtualTrackingDevice::SetToolSpeed(unsigned int idx, mitk::ScalarType roundsPerSecond)
<span style = "background-color:#fdd">{
  if (roundsPerSecond &lt; 0.0001)
    throw std::invalid_argument("Minimum tool speed is 0.0001 rounds per second");</span>

<span style = "background-color:#fdd">  mitk::VirtualTrackingTool* t = this-&gt;GetInternalTool(idx);
  if (t != nullptr)
    t-&gt;SetVelocity(roundsPerSecond);</span>
  else
<span style = "background-color:#fdd">    throw std::invalid_argument("invalid index");
}</span>

mitk::VirtualTrackingTool* mitk::VirtualTrackingDevice::GetInternalTool(unsigned int idx)
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; toolsMutexLockHolder(m_ToolsMutex); // lock and unlock the mutex
  if (idx &lt; m_AllTools.size())
    return m_AllTools.at(idx);</span>
  else
<span style = "background-color:#fdd">    return nullptr;
}</span>

void mitk::VirtualTrackingDevice::TrackTools()
<span style = "background-color:#fdd">{</span>
  /* lock the TrackingFinishedMutex to signal that the execution rights are now transfered to the tracking thread */
<span style = "background-color:#fdd">  std::lock_guard&lt;std::mutex&gt; trackingFinishedLockHolder(m_TrackingFinishedMutex); // keep lock until end of scope</span>

<span style = "background-color:#fdd">  if (this-&gt;GetState() != Tracking)
    return;</span>

  bool localStopTracking;       // Because m_StopTracking is used by two threads, access has to be guarded by a mutex. To minimize thread locking, a local copy is used here

<span style = "background-color:#fdd">  this-&gt;m_StopTrackingMutex.lock();  // update the local copy of m_StopTracking
  localStopTracking = this-&gt;m_StopTracking;
  this-&gt;m_StopTrackingMutex.unlock();</span>

<span style = "background-color:#fdd">  mitk::ScalarType t = 0.0;
  while ((this-&gt;GetState() == Tracking) &amp;&amp; (localStopTracking == false))</span>
  {
    //for (ToolContainer::iterator itAllTools = m_AllTools.begin(); itAllTools != m_AllTools.end(); itAllTools++)
<span style = "background-color:#fdd">    for (unsigned int i = 0; i &lt; this-&gt;GetToolCount(); ++i)  // use mutexed methods to access tool container</span>
    {
<span style = "background-color:#fdd">      mitk::VirtualTrackingTool::Pointer currentTool = this-&gt;GetInternalTool(i);</span>
      mitk::VirtualTrackingTool::SplineType::PointType pos;
      /* calculate tool position with spline interpolation */
<span style = "background-color:#fdd">      pos = currentTool-&gt;GetSpline()-&gt;EvaluateSpline(t);
      mitk::Point3D mp;
      mitk::itk2vtk(pos, mp); // convert from SplineType::PointType to mitk::Point3D</span>

      //Add Gaussian Noise to Tracking Coordinates if enabled
<span style = "background-color:#fdd">      if (this-&gt;m_GaussianNoiseEnabled)</span>
      {
<span style = "background-color:#fdd">        std::random_device rd;
        std::mt19937 generator(rd());
        std::normal_distribution&lt;double&gt; dist(this-&gt;m_MeanDistributionParam, this-&gt;m_DeviationDistributionParam);
        double noise = dist(generator);
        mp = mp + noise;</span>
      }

<span style = "background-color:#fdd">      currentTool-&gt;SetPosition(mp);</span>
      // Currently, a constant speed is used. TODO: use tool velocity setting
<span style = "background-color:#fdd">      t += 0.001;
      if (t &gt;= 1.0)
        t = 0.0;</span>

      mitk::Quaternion quat;
      /* fix quaternion rotation */
<span style = "background-color:#fdd">      quat.x() = 0.0;
      quat.y() = 0.0;
      quat.z() = 0.0;
      quat.r() = 1.0;
      quat.normalize();
      currentTool-&gt;SetOrientation(quat);</span>
      // TODO: rotate once per cycle around a fixed rotation vector

<span style = "background-color:#fdd">      currentTool-&gt;SetTrackingError(2 * (rand() / (RAND_MAX + 1.0)));  // tracking error in 0 .. 2 Range
      currentTool-&gt;SetDataValid(true);
      currentTool-&gt;Modified();
    }
    itksys::SystemTools::Delay(m_RefreshRate);</span>
    /* Update the local copy of m_StopTracking */
<span style = "background-color:#fdd">    this-&gt;m_StopTrackingMutex.lock();
    localStopTracking = m_StopTracking;
    this-&gt;m_StopTrackingMutex.unlock();
  } // tracking ends if we pass this line
}</span>

void mitk::VirtualTrackingDevice::ThreadStartTracking()
<span style = "background-color:#fdd">{
  this-&gt;TrackTools();
}</span>

mitk::VirtualTrackingDevice::ControlPointType mitk::VirtualTrackingDevice::GetRandomPoint()
<span style = "background-color:#fdd">{</span>
  ControlPointType pos;
<span style = "background-color:#fdd">  pos[0] = m_Bounds[0] + (m_Bounds[1] - m_Bounds[0]) * (rand() / (RAND_MAX + 1.0));  // X =  xMin + xRange * (random number between 0 and 1)
  pos[1] = m_Bounds[2] + (m_Bounds[3] - m_Bounds[2]) * (rand() / (RAND_MAX + 1.0));  // Y
  pos[2] = m_Bounds[4] + (m_Bounds[5] - m_Bounds[4]) * (rand() / (RAND_MAX + 1.0));  // Z</span>

<span style = "background-color:#fdd">  return pos;
}</span>

void mitk::VirtualTrackingDevice::EnableGaussianNoise()
<span style = "background-color:#fdd">{
  this-&gt;m_GaussianNoiseEnabled = true;
}</span>

void mitk::VirtualTrackingDevice::DisableGaussianNoise()
<span style = "background-color:#fdd">{
  this-&gt;m_GaussianNoiseEnabled = false;
}</span>

void mitk::VirtualTrackingDevice::SetParamsForGaussianNoise(double meanDistribution, double deviationDistribution)
<span style = "background-color:#fdd">{
  this-&gt;m_MeanDistributionParam = meanDistribution;
  this-&gt;m_DeviationDistributionParam = deviationDistribution;
}</span>

double mitk::VirtualTrackingDevice::GetDeviationDistribution()
<span style = "background-color:#fdd">{
  return m_DeviationDistributionParam;
}</span>

double mitk::VirtualTrackingDevice::GetMeanDistribution()
<span style = "background-color:#fdd">{
  return m_MeanDistributionParam;
}</span></pre>
	</body>
</html>