<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNDIProtocol.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkNDIProtocol.h"
#include "mitkNDITrackingDevice.h"
#include "mitkNDIAuroraTypeInformation.h"
#include "mitkNDIPolarisTypeInformation.h"
#include "mitkUnspecifiedTrackingTypeInformation.h"
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;itksys/SystemTools.hxx&gt;
#include &lt;cstdio&gt;

mitk::NDIProtocol::NDIProtocol()
<span style = "background-color:#fdd">: itk::Object(), m_TrackingDevice(nullptr), m_UseCRC(true)
{
}</span>


mitk::NDIProtocol::~NDIProtocol()
<span style = "background-color:#fdd">{
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::COMM(mitk::SerialCommunication::BaudRate baudRate , mitk::SerialCommunication::DataBits dataBits, mitk::SerialCommunication::Parity parity, mitk::SerialCommunication::StopBits stopBits, mitk::SerialCommunication::HardwareHandshake hardwareHandshake)
<span style = "background-color:#fdd">{</span>
  /* Build parameter string */
<span style = "background-color:#fdd">  std::string param;
  switch (baudRate)</span>
  {
  case mitk::SerialCommunication::BaudRate14400:
<span style = "background-color:#fdd">    param += "1";
    break;</span>
  case mitk::SerialCommunication::BaudRate19200:
<span style = "background-color:#fdd">    param += "2";
    break;</span>
  case mitk::SerialCommunication::BaudRate38400:
<span style = "background-color:#fdd">    param += "3";
    break;</span>
  case mitk::SerialCommunication::BaudRate57600:
<span style = "background-color:#fdd">    param += "4";
    break;</span>
  case mitk::SerialCommunication::BaudRate115200:
<span style = "background-color:#fdd">    param += "5";
    break;</span>
  case mitk::SerialCommunication::BaudRate9600:
  default:            // assume 9600 Baud as default
<span style = "background-color:#fdd">    param += "0";</span>
    break;
  }
<span style = "background-color:#fdd">  switch (dataBits)</span>
  {
  case mitk::SerialCommunication::DataBits7:
<span style = "background-color:#fdd">    param += "1";
    break;</span>
  case mitk::SerialCommunication::DataBits8:
  default:            // set 8 data bits as default
<span style = "background-color:#fdd">    param += "0";</span>
    break;
  }
<span style = "background-color:#fdd">  switch (parity)</span>
  {
  case mitk::SerialCommunication::Odd:
<span style = "background-color:#fdd">    param += "1";
    break;</span>
  case mitk::SerialCommunication::Even:
<span style = "background-color:#fdd">    param += "2";
    break;</span>
  case mitk::SerialCommunication::None:
  default:            // set no parity as default
<span style = "background-color:#fdd">    param += "0";</span>
    break;
  }
<span style = "background-color:#fdd">  switch (stopBits)</span>
  {
  case mitk::SerialCommunication::StopBits2:
<span style = "background-color:#fdd">    param += "1";
    break;</span>
  case mitk::SerialCommunication::StopBits1:
  default:            // set 1 stop bit as default
<span style = "background-color:#fdd">    param += "0";</span>
    break;
  }
<span style = "background-color:#fdd">  switch (hardwareHandshake)</span>
  {
  case mitk::SerialCommunication::HardwareHandshakeOn:
<span style = "background-color:#fdd">    param += "1";
    break;</span>
  case mitk::SerialCommunication::HardwareHandshakeOff:
  default:            // set no hardware handshake as default
<span style = "background-color:#fdd">    param += "0";</span>
    break;
  }
<span style = "background-color:#fdd">  return GenericCommand("COMM", &amp;param);
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::INIT()
<span style = "background-color:#fdd">{
  return GenericCommand("INIT");
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::DSTART()
<span style = "background-color:#fdd">{
  return GenericCommand("DSTART");
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::DSTOP()
<span style = "background-color:#fdd">{
  return GenericCommand("DSTOP");
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::IRINIT()
<span style = "background-color:#fdd">{
  return GenericCommand("IRINIT");
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::IRCHK(bool* IRdetected)
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from trackingsystem</span>

<span style = "background-color:#fdd">  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

  /* send command */
<span style = "background-color:#fdd">  std::string fullcommand;
  if (m_UseCRC == true)
    fullcommand = "IRCHK:0001";     // command string format 1: with crc</span>
  else
<span style = "background-color:#fdd">    fullcommand = "IRCHK 0001";     // command string format 2: without crc</span>

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;fullcommand, m_UseCRC);</span>

<span style = "background-color:#fdd">  if (returnValue != NDIOKAY)       // check for send error</span>
  {
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove any reply
    return returnValue;</span>
  }
  /* wait for the trackingsystem to process the command */
<span style = "background-color:#fdd">  itksys::SystemTools::Delay(100);</span>
  /* read and parse the reply from tracking device */
  // the reply for IRCHK can be either Infrared Source Information or ERROR##
  // because we use the simple reply format, the answer will be only one char:
  // "0" - no IR detected
  // "1" - IR detected
<span style = "background-color:#fdd">  std::string reply;</span>
  char b;
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ReceiveByte(&amp;b);// read the first byte
  reply = b;
  if ((b == '0') || (b == '1'))     // normal answer</span>
  {
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);  // calculate crc for received reply string
    std::string readCRC;                                          // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);                       // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)                                   // if the read CRC is correct, return normal error code</span>
    {
<span style = "background-color:#fdd">      if ( b == '0')
        *IRdetected = false;</span>
      else
<span style = "background-color:#fdd">        *IRdetected = true;
      returnValue = NDIOKAY;
    }</span>
    else                            // return error in CRC
    {
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
      *IRdetected = false;          // IRdetected is only valid if return code of this function is NDIOKAY</span>
    }
<span style = "background-color:#fdd">  }
  else if (b =='E')                 // expect ERROR##</span>
  {
<span style = "background-color:#fdd">    std::string errorstring;
    m_TrackingDevice-&gt;Receive(&amp;errorstring, 4);   // read the remaining 4 characters of ERROR
    reply += errorstring;
    static const std::string error("ERROR");
    if (error.compare(0, 5, reply) == 0)          // check for "ERROR"</span>
    {
<span style = "background-color:#fdd">      std::string errorcode;
      m_TrackingDevice-&gt;Receive(&amp;errorcode, 2);   // now read 2 bytes error code</span>
      /* perform CRC checking */
<span style = "background-color:#fdd">      reply += errorcode;                         // build complete reply string
      std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
      std::string readCRC;                        // read attached crc value
      m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);     // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
      if (expectedCRC == readCRC)                 // if the read CRC is correct, return normal error code
        returnValue = this-&gt;GetErrorCode(&amp;errorcode);</span>
      else
<span style = "background-color:#fdd">        returnValue = NDICRCERROR;                // return error in CRC
    }
  } else  // something else, that we do not expect
    returnValue = NDIUNEXPECTEDREPLY;</span>

  /* cleanup and return */
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ClearReceiveBuffer();        // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::PHSR(PHSRQueryType queryType, std::string* portHandles)
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue = NDIUNKNOWNERROR;</span>

<span style = "background-color:#fdd">  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

  /* send command */
<span style = "background-color:#fdd">  std::string command;</span>
  char stringQueryType[3];
<span style = "background-color:#fdd">  sprintf(stringQueryType, "%02X", queryType);// convert numerical queryType to string in hexadecimal format</span>

<span style = "background-color:#fdd">  if (m_UseCRC == true)
    command = std::string("PHSR:")  + std::string(stringQueryType);</span>
  else //if (m_UseCRC != true)
<span style = "background-color:#fdd">    command = std::string("PHSR ")  + std::string(stringQueryType); // command string format 2: without crc</span>

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;command, m_UseCRC);</span>

<span style = "background-color:#fdd">  if (returnValue != NDIOKAY)                 // check for send error</span>
  {
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove any reply
    return returnValue;</span>
  }

<span style = "background-color:#fdd">  itksys::SystemTools::Delay(100);</span>

<span style = "background-color:#fdd">  std::string reply;
  m_TrackingDevice-&gt;Receive(&amp;reply, 2);       // read first 2 characters of reply ("Number of Handles" as a 2 digit hexadecimal number)
  static const std::string error("ERROR");
  if (error.compare(0, 2, reply) == 0)        // check for "ERROR" (compare for "ER" because we can not be sure that the reply is more than 2 characters (in case of 0 port handles returned)</span>
  {
<span style = "background-color:#fdd">    std::string ror;
    m_TrackingDevice-&gt;Receive(&amp;ror, 3);       // read rest of ERROR (=&gt; "ROR")
    reply += ror;                             // build complete reply string
    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2); // now read 2 bytes error code
    reply += errorcode;                       // build complete reply string</span>
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)               // if the read CRC is correct, return normal error code
      returnValue = this-&gt;GetErrorCode(&amp;errorcode);</span>
    else                                      // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }</span>
  else  // No error, expect number of handles as a 2 character hexadecimal value
  {
<span style = "background-color:#fdd">    unsigned int numberOfHandles = 0;</span>
    // convert the hexadecimal string representation to a numerical using a stringstream
<span style = "background-color:#fdd">    std::stringstream s;
    s &lt;&lt; reply;
    s &gt;&gt; numberOfHandles;
    if (numberOfHandles &gt; 16)  // there can not be more than 16 handles ToDo: exact maximum number depend on tracking device and firmware revision. these data could be read with VER and used here</span>
    {
<span style = "background-color:#fdd">      returnValue = NDIUNKNOWNERROR;
    }</span>
    else
    {
<span style = "background-color:#fdd">      std::string handleInformation;
      portHandles-&gt;clear();
      for (unsigned int i = 0; i &lt; numberOfHandles; i++)  // read 5 characters for each handle and extract port handle</span>
      {
<span style = "background-color:#fdd">        m_TrackingDevice-&gt;Receive(&amp;handleInformation, 5);
        *portHandles += handleInformation.substr(0, 2);   // Append the port handle to the portHandles string
        reply += handleInformation;                       // build complete reply string for crc checking
      }</span>
      /* perform CRC checking */
<span style = "background-color:#fdd">      std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
      std::string readCRC;                                // read attached crc value
      m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);             // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
      if (expectedCRC == readCRC)                         // if the read CRC is correct, return okay
        returnValue = NDIOKAY;</span>
      else                                                // return error in CRC
<span style = "background-color:#fdd">        returnValue = NDICRCERROR;
    }
  }</span>
  /* cleanup and return */
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ClearReceiveBuffer();                 // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::PHRQ(std::string* portHandle)
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from tracking device</span>

<span style = "background-color:#fdd">  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

  /* send command */
<span style = "background-color:#fdd">  std::string command;
  if (m_UseCRC == true)
    command = "PHRQ:*********1****";          // command string format 1: with crc</span>
  else
<span style = "background-color:#fdd">    command = "PHRQ *********1****";          // command string format 2: without crc</span>

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;command, m_UseCRC);</span>

<span style = "background-color:#fdd">  if (returnValue != NDIOKAY)                 // check for send error</span>
  {
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove any reply
    return returnValue;</span>
  }

<span style = "background-color:#fdd">  itksys::SystemTools::Delay(100);            // give the tracking device some time to process the command</span>

<span style = "background-color:#fdd">  std::string reply;
  m_TrackingDevice-&gt;Receive(&amp;reply, 2);       // read first 2 characters of reply ("Number of Handles" as a 2 digit hexadecimal number)
  static const std::string error("ERROR");
  if (error.compare(0, 2, reply) == 0)        // check for "ERROR" (compare for "ER" because we can not be sure that the reply is more than 2 characters (in case of 0 port handles returned)</span>
  {
<span style = "background-color:#fdd">    std::string ror;
    m_TrackingDevice-&gt;Receive(&amp;ror, 3);       // read rest of ERROR (=&gt; "ROR")
    reply += ror;                             // build complete reply string
    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2); // now read 2 bytes error code
    reply += errorcode;                       // build complete reply string</span>
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)               // if the read CRC is correct, return normal error code
      returnValue = this-&gt;GetErrorCode(&amp;errorcode);</span>
    else                                      // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }</span>
  else  // No error, expect port handle as a 2 character hexadecimal value
  {
<span style = "background-color:#fdd">    *portHandle = reply;                      // assign the port handle to the return string</span>
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)               // if the read CRC is correct, return okay
      returnValue = NDIOKAY;</span>
    else                                      // else return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }</span>
  /* cleanup and return */
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ClearReceiveBuffer();     // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::PVWR(std::string* portHandle, const unsigned char* sromData, unsigned int sromDataLength)
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from trackingsystem</span>

<span style = "background-color:#fdd">  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

<span style = "background-color:#fdd">  if (sromDataLength &gt; 1024)
    return SROMFILETOOLARGE;</span>

<span style = "background-color:#fdd">  if (sromDataLength == 0)
    return SROMFILETOOSMALL;</span>

  /* build send commands */
<span style = "background-color:#fdd">  std::string basecommand;
  if (m_UseCRC == true)
    basecommand = "PVWR:";                        // command string format 1: with crc</span>
  else
<span style = "background-color:#fdd">    basecommand = "PVWR ";                        // command string format 2: without crc</span>

<span style = "background-color:#fdd">  std::string hexSROMData;
  hexSROMData.reserve(2 * sromDataLength);</span>
  char hexcharacter[20];  // 7 bytes should be enough (in send loop)
<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; sromDataLength; i++)</span>
  {
<span style = "background-color:#fdd">    sprintf(hexcharacter, "%02X", sromData[i]);   // convert srom byte to string in hexadecimal format</span>
    //hexSROMData += "12";
<span style = "background-color:#fdd">    hexSROMData += hexcharacter;                  // append hex string to srom data in hex format
  }</span>
  /* data must be written in chunks of 64 byte (128 hex characters). To ensure 64 byte chunks the last chunk must be padded with 00 */
<span style = "background-color:#fdd">  unsigned int zerosToPad = 128 - (hexSROMData.size() % 128);  // hexSROMData must be a multiple of 128
  if (zerosToPad &gt; 0)
    hexSROMData.append(zerosToPad, '0');</span>
  /* now we have all the data, send it in 128 character chunks */
<span style = "background-color:#fdd">  std::string fullcommand;
  for (unsigned int j = 0; j &lt; hexSROMData.size(); j += 128)</span>
  {
<span style = "background-color:#fdd">    sprintf(hexcharacter, "%s%04X", portHandle-&gt;c_str(), j/2);              // build the first two parameters: PortHandle and SROM device adress (not in hex characters, but in bytes)
    fullcommand = basecommand + hexcharacter + hexSROMData.substr(j, 128);  // build complete command string
    returnValue = m_TrackingDevice-&gt;Send(&amp;fullcommand, m_UseCRC);           // send command
    itksys::SystemTools::Delay(50);               // Wait for trackingsystem to process the data
    if (returnValue != NDIOKAY)                   // check for send error
      break;
    returnValue = this-&gt;ParseOkayError();         // parse answer
    if (returnValue != NDIOKAY)                   // check for error returned from tracking device
      break;
  }</span>
  /* cleanup and return */
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ClearReceiveBuffer();         // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::PINIT(std::string* portHandle)
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from trackingsystem</span>

<span style = "background-color:#fdd">  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

  /* send command */
<span style = "background-color:#fdd">  std::string fullcommand;
  if (m_UseCRC == true)
    fullcommand = std::string("PINIT:") + *portHandle;  // command string format 1: with crc</span>
  else
<span style = "background-color:#fdd">    fullcommand = std::string("PINIT ") + *portHandle;  // command string format 2: without crc</span>

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;fullcommand, m_UseCRC);</span>

<span style = "background-color:#fdd">  if (returnValue != NDIOKAY)                           // check for send error</span>
  {
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();             // flush the buffer to remove any reply
    return returnValue;</span>
  }

  /* wait for the trackingsystem to process the command */
<span style = "background-color:#fdd">  itksys::SystemTools::Delay(100);
  std::string reply;
  m_TrackingDevice-&gt;Receive(&amp;reply, 4);                 // read first 4 characters of reply</span>

  /* Parse reply from tracking device */
<span style = "background-color:#fdd">  static const std::string okay("OKAYA896");            // OKAY is static, so we can perform a static crc check
  static const std::string error("ERROR");
  static const std::string warning("WARNING7423");      // WARNING has a static crc too</span>

<span style = "background-color:#fdd">  if (okay.compare(0, 4, reply) == 0)                   // check for "OKAY": compare first 4 characters from okay with reply</span>
  {
    // OKAY was found, now check the CRC16 too
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;Receive(&amp;reply, 4);               // read 4 hexadecimal characters for CRC16
    if (okay.compare(4, 4, reply, 0, 4) == 0)           // first 4 from new reply should match last 4 from okay
      returnValue = NDIOKAY;</span>
    else
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }
  else if (warning.compare(0, 4, reply) == 0)           // check for "WARNING"</span>
  {
    // WARN was found, now check remaining characters and CRC16
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;Receive(&amp;reply, 4);               // read 4 hexadecimal characters for CRC16
    if (warning.compare(4, 7, reply, 0, 7) == 0)        // first 7 from new reply should match last 7 from okay
      returnValue = NDIWARNING;</span>
    else
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }
  else if (error.compare(0, 4, reply) == 0)             // check for "ERRO"</span>
  {
    char b;                                             // The ERROR reply is not static, so we can not use a static crc check.
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ReceiveByte(&amp;b);                  // read next character ("R" from ERROR)
    reply += b;                                         // to build complete reply string
    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2);           // now read 2 bytes error code
    reply += errorcode;                                 // build complete reply string</span>
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                                // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);             // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)                         // if the read CRC is correct, return normal error code
      returnValue = this-&gt;GetErrorCode(&amp;errorcode);</span>
    else                                                // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  } else                                                // else it is something else, that we do not expect
    returnValue = NDIUNEXPECTEDREPLY;</span>


  //read cr carriage return
  char b;
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ReceiveByte(&amp;b);</span>

  /* cleanup and return */
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ClearReceiveBuffer();               // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::PENA(std::string* portHandle, TrackingPriority prio)
<span style = "background-color:#fdd">{
  std::string param;
  if (portHandle != nullptr)
    param = *portHandle + (char) prio;</span>
  else
<span style = "background-color:#fdd">    param = "";
  return this-&gt;GenericCommand("PENA", &amp;param);
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::PHINF(std::string portHandle, std::string* portInfo)
<span style = "background-color:#fdd">{
  std::string command;
  if (m_UseCRC) command = "PHINF:" + portHandle;
  else command = "PHINF " + portHandle;
  mitk::NDIErrorCode returnValue = m_TrackingDevice-&gt;Send(&amp;command, m_UseCRC);
  if (returnValue==NDIOKAY)</span>
    {
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();
    m_TrackingDevice-&gt;Receive(portInfo, 33);
    m_TrackingDevice-&gt;ClearReceiveBuffer();
    }
  else m_TrackingDevice-&gt;ClearReceiveBuffer();
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::PDIS(std::string* portHandle)
<span style = "background-color:#fdd">{
  return this-&gt;GenericCommand("PDIS", portHandle);
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::PHF(std::string* portHandle)
<span style = "background-color:#fdd">{
  return this-&gt;GenericCommand("PHF", portHandle);
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::IRATE(IlluminationActivationRate rate)
<span style = "background-color:#fdd">{
  std::string param;
  switch (rate)</span>
  {
  case Hz60:
<span style = "background-color:#fdd">    param = "2";
    break;</span>
  case Hz30:
<span style = "background-color:#fdd">    param = "1";
    break;</span>
  case Hz20:
  default:
<span style = "background-color:#fdd">    param = "0";</span>
    break;
  }
<span style = "background-color:#fdd">  return this-&gt;GenericCommand("IRATE", &amp;param);
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::BEEP(unsigned char count)
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from trackingsystem</span>

<span style = "background-color:#fdd">  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

<span style = "background-color:#fdd">  std::string p;
  if ((count &gt;= 1) &amp;&amp; (count &lt;= 9))
    p = (count + '0');                        // convert the number count to a character representation</span>
  else
<span style = "background-color:#fdd">    return NDICOMMANDPARAMETEROUTOFRANGE;</span>

  /* send command */
<span style = "background-color:#fdd">  std::string fullcommand;
  if (m_UseCRC == true)
    fullcommand = "BEEP:" + p;                // command string format 1: with crc</span>
  else
<span style = "background-color:#fdd">    fullcommand = "BEEP " + p;                // command string format 2: without crc</span>

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;fullcommand, m_UseCRC);</span>

<span style = "background-color:#fdd">  if (returnValue != NDIOKAY)                 // check for send error</span>
  {
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove any reply
    return returnValue;</span>
  }

  /* wait for the trackingsystem to process the command */
<span style = "background-color:#fdd">  itksys::SystemTools::Delay(100);</span>

<span style = "background-color:#fdd">  std::string reply;</span>
  char b;
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ReceiveByte(&amp;b);          // read the first byte
  reply = b;
  if ((b == '0') || (b == '1'))               // normal answer</span>
  {
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);  // calculate crc for received reply string
    std::string readCRC;                                          // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);                       // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)                                   // if the read CRC is correct, return normal error code
      returnValue = NDIOKAY;</span>
    else                                      // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }
  else if (b =='E')                           // expect ERROR##</span>
  {
<span style = "background-color:#fdd">    std::string errorstring;
    m_TrackingDevice-&gt;Receive(&amp;errorstring, 4);   // read the remaining 4 characters of ERROR
    reply += errorstring;
    static const std::string error("ERROR");
    if (error.compare(0, 5, reply) == 0)          // check for "ERROR"</span>
    {
<span style = "background-color:#fdd">      std::string errorcode;
      m_TrackingDevice-&gt;Receive(&amp;errorcode, 2);   // now read 2 bytes error code</span>
      /* perform CRC checking */
<span style = "background-color:#fdd">      reply += errorcode;                         // build complete reply string
      std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
      std::string readCRC;                        // read attached crc value
      m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);     // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
      if (expectedCRC == readCRC)                 // if the read CRC is correct, return normal error code
        returnValue = this-&gt;GetErrorCode(&amp;errorcode);</span>
      else
<span style = "background-color:#fdd">        returnValue = NDICRCERROR;                // return error in CRC
    }
  } else  // something else, that we do not expect
    returnValue = NDIUNEXPECTEDREPLY;</span>

  /* cleanup and return */
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ClearReceiveBuffer();         // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::TSTART(bool resetFrameCounter)
<span style = "background-color:#fdd">{
  std::string param = "80";
  if (resetFrameCounter == true)
    return this-&gt;GenericCommand("TSTART", &amp;param);</span>
  else
<span style = "background-color:#fdd">    return this-&gt;GenericCommand("TSTART");
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::TSTOP()
<span style = "background-color:#fdd">{
  return this-&gt;GenericCommand("TSTOP");
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::PSOUT(std::string portHandle, std::string state)
<span style = "background-color:#fdd">{
  std::string param = portHandle + state;
  return this-&gt;GenericCommand("PSOUT", &amp;param);
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::TX(bool trackIndividualMarkers, MarkerPointContainerType* markerPositions)
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from tracking device</span>

<span style = "background-color:#fdd">  if(trackIndividualMarkers)
    markerPositions-&gt;clear();</span>

<span style = "background-color:#fdd">  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

  /* send command */
<span style = "background-color:#fdd">  std::string fullcommand;
  if (trackIndividualMarkers)</span>
  {
<span style = "background-color:#fdd">    if (m_UseCRC == true)
      fullcommand = "TX:1001";          // command string format 1: with crc</span>
    else
<span style = "background-color:#fdd">      fullcommand = "TX 1001";          // command string format 2: without crc
  } else</span>
  {
<span style = "background-color:#fdd">    if (m_UseCRC == true)
      fullcommand = "TX:";          // command string format 1: with crc</span>
    else
<span style = "background-color:#fdd">      fullcommand = "TX ";          // command string format 2: without crc</span>
  }

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;fullcommand, m_UseCRC);
  if (returnValue != NDIOKAY)</span>
  {
    /* cleanup and return */
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
    return returnValue;</span>
  }
  /* read number of handles returned */
<span style = "background-color:#fdd">  std::string reply;
  std::string s;
  m_TrackingDevice-&gt;Receive(&amp;reply, 2);       // read first 2 characters of reply (error or number of handles returned)</span>
  //printf("%d",reply);
<span style = "background-color:#fdd">  static const std::string error("ERROR");
  if (error.compare(0, 2, reply) == 0)</span>
  {
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;Receive(&amp;s, 3);         // read next characters ("ROR" from ERROR)
    reply += s;                               // to build complete reply string
    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2); // now read 2 bytes error code
    reply += errorcode;                       // build complete reply string</span>
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)               // if the read CRC is correct, return normal error code</span>
    {
<span style = "background-color:#fdd">      returnValue = this-&gt;GetErrorCode(&amp;errorcode);
    }</span>
    else                                      // return error in CRC
    {
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else                                        // transformation data is returned
  {
    /* parse number of handles from first 2 characters */
<span style = "background-color:#fdd">    std::stringstream converter;
    unsigned int numberOfHandles = 0;
    converter &lt;&lt; std::hex &lt;&lt; reply;                       // insert reply into stringstream
    converter &gt;&gt; numberOfHandles;             // extract number of handles as unsigned byte
    converter.clear();                        // converter must be cleared to be reused
    converter.str("");</span>

    /* read and parse transformation data for each handle */
<span style = "background-color:#fdd">    for (unsigned int i = 0; i &lt; numberOfHandles; i++)    // for each handle</span>
    {
      /* Read port handle */
<span style = "background-color:#fdd">      m_TrackingDevice-&gt;Receive(&amp;s, 2);        // read port handle
      reply += s;                              // build complete command string
      NDIPassiveTool::Pointer tool = m_TrackingDevice-&gt;GetInternalTool(s);   // get tool object for that handle
      if (tool.IsNull())</span>
      {
<span style = "background-color:#fdd">        returnValue = UNKNOWNHANDLERETURNED;
        break;  // if we do not know the handle, we can not assume anything about the remaining data, so we better abort (we could read up to the next LF)</span>
      }
      /* Parse reply from tracking device */
<span style = "background-color:#fdd">      static const std::string missing("MISSING");
      static const std::string disabled("DISABLED");
      static const std::string unoccupied("UNOCCUPIED");</span>

<span style = "background-color:#fdd">      m_TrackingDevice-&gt;Receive(&amp;s, 6);        // read next 6 characters: either an error message or part of the transformation data
      reply += s;                              // build complete command string
      if (missing.compare(0, 6, s) == 0)</span>
      {
<span style = "background-color:#fdd">        tool-&gt;SetErrorMessage("Tool is reported as 'missing'.");
        tool-&gt;SetDataValid(false);
        m_TrackingDevice-&gt;Receive(&amp;s, 18);     // after 'missin', 1 character for 'g', 8 characters for port status, 8 characters for frame number  and one for line feed are send
        reply += s;                            // build complete command string
      }
      else if (disabled.compare(0, 6, s) == 0)</span>
      {
<span style = "background-color:#fdd">        tool-&gt;SetErrorMessage("Tool is reported as 'disabled'.");
        tool-&gt;SetDataValid(false);
        m_TrackingDevice-&gt;Receive(&amp;s, 3);     // read last characters of disabled plus 8 characters for port status, 8 characters for frame number  and one for line feed
        reply += s;                            // build complete command string
      }
      else if (unoccupied.compare(0, 6, s) == 0)</span>
      {
<span style = "background-color:#fdd">        tool-&gt;SetErrorMessage("Tool is reported as 'unoccupied'.");
        tool-&gt;SetDataValid(false);
        m_TrackingDevice-&gt;Receive(&amp;s, 21);     // read remaining characters of UNOCCUPIED
        reply += s;                            // build complete command string
      }</span>
      else  // transformation data
      {
        /* define local copies */
<span style = "background-color:#fdd">        signed int number = 0;
        float localPos[3] = {0.0, 0.0, 0.0};
        float localQuat[4] = {0.0, 0.0, 0.0, 0.0};
        float localError = 0.0;
        unsigned long localPortStatus = 0;
        unsigned int localFrameNumber = 0;</span>
        /* read and parse the four 6 character quaternion values */
        //std::cout &lt;&lt; "s =      " &lt;&lt; s &lt;&lt; std::endl;
<span style = "background-color:#fdd">        converter &lt;&lt; std::dec &lt;&lt; s;         // insert string with first number into stringstream
        converter &gt;&gt; number;                // extract first number as integer
        converter.clear();                  // converter must be cleared to be reused
        converter.str("");</span>
        //std::cout &lt;&lt; "number = " &lt;&lt; number &lt;&lt; std::endl;
<span style = "background-color:#fdd">        localQuat[0] = number / 10000.0;    // the value is send with an implied decimal point with 4 digits to the right
        for (unsigned int i = 1; i &lt; 4; i++)// read the next 3 numbers</span>
        {
<span style = "background-color:#fdd">          m_TrackingDevice-&gt;Receive(&amp;s, 6); // read the next number
          reply += s;                       // build complete command string
          converter &lt;&lt; std::dec &lt;&lt; s;                   // insert string with first number into stringstream
          converter &gt;&gt; number;              // extract first number as integer
          converter.clear();                // converter must be cleared to be reused
          converter.str("");
          localQuat[i] = number / 10000.0;  // the value is send with an implied decimal point with 4 digits to the right
        }</span>
        /* read and parse the three 7 character translation values */
<span style = "background-color:#fdd">        for (auto &amp; localPo : localPos)</span>
        {
<span style = "background-color:#fdd">          m_TrackingDevice-&gt;Receive(&amp;s, 7); // read the next position vector number
          reply += s;                       // build complete command string
          converter &lt;&lt; std::dec &lt;&lt; s;                   // insert string with number into stringstream
          converter &gt;&gt; number;              // extract first number as integer
          converter.clear();                // converter must be cleared to be reused
          converter.str("");
          localPo = number / 100.0;     // the value is send with an implied decimal point with 2 digits to the right
        }</span>
        /* read and parse 6 character error value */
<span style = "background-color:#fdd">        m_TrackingDevice-&gt;Receive(&amp;s, 6);   // read the error value
        reply += s;                         // build complete command string
        converter &lt;&lt; std::dec &lt;&lt; s;                     // insert string with number into stringstream
        converter &gt;&gt; number;                // extract the number as integer
        converter.clear();                  // converter must be cleared to be reused
        converter.str("");
        localError = number / 10000.0;      // the error value is send with an implied decimal point with 4 digits to the right</span>
        /* read and parse 8 character port status */
<span style = "background-color:#fdd">        m_TrackingDevice-&gt;Receive(&amp;s, 8);   // read the port status value
        reply += s;                         // build complete command string
        converter &lt;&lt; std::hex &lt;&lt; s;         // insert string into stringstream
        converter &gt;&gt; localPortStatus;       // extract the number as unsigned long
        converter.clear();                  // converter must be cleared to be reused
        converter.str("");</span>
        /* read and parse 8 character frame number as hexadecimal */
<span style = "background-color:#fdd">        m_TrackingDevice-&gt;Receive(&amp;s, 8);   // read the frame number value
        reply += s;                         // build complete command string
        converter &lt;&lt; std::hex &lt;&lt; s;         // insert string with hex value encoded number into stringstream
        converter &gt;&gt; localFrameNumber;      // extract the number as unsigned long
        converter.clear();                  // converter must be cleared to be reused
        converter.str("");</span>

        /* copy local values to the tool */
<span style = "background-color:#fdd">        mitk::Quaternion orientation(localQuat[1], localQuat[2], localQuat[3], localQuat[0]);</span>

        //If the rotation mode is vnlTransposed we have to transpose the quaternion
<span style = "background-color:#fdd">        if (m_TrackingDevice-&gt;GetRotationMode() == mitk::NDITrackingDevice::RotationTransposed)</span>
          {
<span style = "background-color:#fdd">          orientation[0] *= -1; //qx
          orientation[1] *= -1; //qy
          orientation[2] *= -1; //qz</span>
          //qr is not inverted
          }

<span style = "background-color:#fdd">        tool-&gt;SetOrientation(orientation);
        mitk::Point3D position;
        position[0] = localPos[0];
        position[1] = localPos[1];
        position[2] = localPos[2];
        tool-&gt;SetPosition(position);
        tool-&gt;SetTrackingError(localError);
        tool-&gt;SetErrorMessage("");
        tool-&gt;SetDataValid(true);
        m_TrackingDevice-&gt;Receive(&amp;s, 1);   // read the line feed character, that terminates each handle data
        reply += s;                         // build complete command string</span>
      }
<span style = "background-color:#fdd">    } // for</span>


    //Read Reply Option 1000 data
<span style = "background-color:#fdd">    if(trackIndividualMarkers)</span>
    {
      /* parse number of markers from first 2 characters */
<span style = "background-color:#fdd">      m_TrackingDevice-&gt;Receive(&amp;s, 2);
      reply += s;
      unsigned int numberOfMarkers = 0;
      converter &lt;&lt; std::hex &lt;&lt; s;           // insert reply into stringstream
      converter &gt;&gt; numberOfMarkers;             // extract number of markers as unsigned byte
      converter.clear();                        // converter must be cleared to be reused
      converter.str("");</span>

<span style = "background-color:#fdd">      unsigned int oovReplySize = (unsigned int)ceil((double)numberOfMarkers/4.0);
      unsigned int nbMarkersInVolume = 0;</span>
      char c;
      // parse oov data to find out how many marker positions were recorded
<span style = "background-color:#fdd">      for (unsigned int i = 0; i &lt; oovReplySize; i++)</span>
      {
<span style = "background-color:#fdd">        m_TrackingDevice-&gt;ReceiveByte(&amp;c);
        reply += c;
        nbMarkersInVolume += ByteToNbBitsOn(c);
      }</span>

<span style = "background-color:#fdd">      nbMarkersInVolume = numberOfMarkers-nbMarkersInVolume;</span>

      /* read and parse position data for each marker */
<span style = "background-color:#fdd">      for (unsigned int i = 0; i &lt; nbMarkersInVolume; i++)</span>
      {
        /* define local copies */
<span style = "background-color:#fdd">        signed int number = 0;</span>
        MarkerPointType markerPosition;
        /* read and parse the three 7 character translation values */
<span style = "background-color:#fdd">        for (unsigned int i = 0; i &lt; 3; i++)</span>
        {
<span style = "background-color:#fdd">          m_TrackingDevice-&gt;Receive(&amp;s, 7); // read the next position vector number
          reply += s;                       // build complete command string
          converter &lt;&lt; std::dec &lt;&lt; s;       // insert string with number into stringstream
          converter &gt;&gt; number;              // extract first number as integer
          converter.clear();                // converter must be cleared to be reused
          converter.str("");
          markerPosition[i] = number / 100.0;     // the value is send with an implied decimal point with 2 digits to the right
        }
        markerPositions-&gt;push_back(markerPosition);
      } // end for all markers</span>
    }
    //END read Reply Option 1000 data


    /* Read System Status */
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;Receive(&amp;s, 4);       // read system status
    reply += s;                             // build complete command string</span>
    /* now the reply string is complete, perform crc checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                    // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4); // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)             // if the read CRC is correct, return okay</span>
    {
<span style = "background-color:#fdd">      returnValue = NDIOKAY;
    }</span>
    else                                    // return error in CRC
    {
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;</span>
      /* Invalidate all tools because the received data contained an error */
<span style = "background-color:#fdd">      m_TrackingDevice-&gt;InvalidateAll();
      if(trackIndividualMarkers)
        markerPositions-&gt;clear();</span>
    }
<span style = "background-color:#fdd">  } // else</span>

  /* cleanup and return */
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;Receive(&amp;s, 1);         // read the last linde feed (because the tracking system device is sometimes to slow to send it before we clear the buffer. In this case, the LF would remain in the receive buffer and be read as the first character of the next command
  m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::TX1000(MarkerPointContainerType* markerPositions)
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from trackingsystem</span>

<span style = "background-color:#fdd">  markerPositions-&gt;clear();</span>

<span style = "background-color:#fdd">  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

  /* send command */
<span style = "background-color:#fdd">  std::string fullcommand;
  if (m_UseCRC == true)
    fullcommand = "TX:1001";          // command string format 1: with crc</span>
  else
<span style = "background-color:#fdd">    fullcommand = "TX 1001";          // command string format 2: without crc</span>

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;fullcommand, m_UseCRC);</span>

  /* read number of handles returned */
<span style = "background-color:#fdd">  std::string reply;
  std::string s;
  m_TrackingDevice-&gt;Receive(&amp;reply, 2);       // read first 2 characters of reply (error or number of handles returned)</span>

<span style = "background-color:#fdd">  static const std::string error("ERROR");
  if (error.compare(0, 2, reply) == 0)</span>
  {
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;Receive(&amp;s, 3);         // read next characters ("ROR" from ERROR)
    reply += s;                               // to build complete reply string
    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2); // now read 2 bytes error code
    reply += errorcode;                       // build complete reply string</span>
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)               // if the read CRC is correct, return normal error code</span>
    {
<span style = "background-color:#fdd">      returnValue = this-&gt;GetErrorCode(&amp;errorcode);
    }</span>
    else                                      // return error in CRC
    {
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else                                        // transformation data is returned
  {
    /* parse number of handles from first 2 characters */
<span style = "background-color:#fdd">    std::stringstream converter;
    unsigned int numberOfHandles = 0;
    converter &lt;&lt; std::hex &lt;&lt; reply;                       // insert reply into stringstream
    converter &gt;&gt; numberOfHandles;             // extract number of handles as unsigned byte
    converter.clear();                        // converter must be cleared to be reused
    converter.str("");</span>

    /* read and parse transformation data for each handle */
<span style = "background-color:#fdd">    for (unsigned int i = 0; i &lt; numberOfHandles; i++)    // for each handle</span>
    {
      /* Read port handle */
<span style = "background-color:#fdd">      m_TrackingDevice-&gt;Receive(&amp;s, 2);        // read port handle
      reply += s;                              // build complete command string
      NDIPassiveTool::Pointer tool = m_TrackingDevice-&gt;GetInternalTool(s);   // get tool object for that handle
      if (tool.IsNull())</span>
      {
<span style = "background-color:#fdd">        returnValue = UNKNOWNHANDLERETURNED;
        break;  // if we do not know the handle, we can not assume anything about the remaining data, so we better abort (we could read up to the next LF)</span>
      }
      /* Parse reply from tracking device */
<span style = "background-color:#fdd">      static const std::string missing("MISSING");
      static const std::string disabled("DISABLED");
      static const std::string unoccupied("UNOCCUPIED");</span>

<span style = "background-color:#fdd">      m_TrackingDevice-&gt;Receive(&amp;s, 6);        // read next 6 characters: either an error message or part of the transformation data
      reply += s;                              // build complete command string
      if (missing.compare(0, 6, s) == 0)</span>
      {
<span style = "background-color:#fdd">        tool-&gt;SetErrorMessage("Tool is reported as 'missing'.");
        tool-&gt;SetDataValid(false);
        m_TrackingDevice-&gt;Receive(&amp;s, 18);     // after 'missin', 1 character for 'g', 8 characters for port status, 8 characters for frame number  and one for line feed are send
        reply += s;                            // build complete command string
      }
      else if (disabled.compare(0, 6, s) == 0)</span>
      {
<span style = "background-color:#fdd">        tool-&gt;SetErrorMessage("Tool is reported as 'disabled'.");
        tool-&gt;SetDataValid(false);
        m_TrackingDevice-&gt;Receive(&amp;s, 19);     // read last characters of disabled plus 8 characters for port status, 8 characters for frame number  and one for line feed
        reply += s;                            // build complete command string
      }
      else if (unoccupied.compare(0, 6, s) == 0)</span>
      {
<span style = "background-color:#fdd">        tool-&gt;SetErrorMessage("Tool is reported as 'unoccupied'.");
        tool-&gt;SetDataValid(false);
        m_TrackingDevice-&gt;Receive(&amp;s, 21);     // read remaining characters of UNOCCUPIED
        reply += s;                            // build complete command string
      }</span>
      else  // transformation data
      {
        /* define local copies */
<span style = "background-color:#fdd">        signed int number = 0;
        float localPos[3] = {0.0, 0.0, 0.0};
        float localQuat[4] = {0.0, 0.0, 0.0, 0.0};
        float localError = 0.0;
        unsigned long localPortStatus = 0;
        unsigned int localFrameNumber = 0;</span>
        /* read and parse the four 6 character quaternion values */
        //std::cout &lt;&lt; "s =      " &lt;&lt; s &lt;&lt; std::endl;
<span style = "background-color:#fdd">        converter &lt;&lt; std::dec &lt;&lt; s;         // insert string with first number into stringstream
        converter &gt;&gt; number;                // extract first number as integer
        converter.clear();                  // converter must be cleared to be reused
        converter.str("");</span>
        //std::cout &lt;&lt; "number = " &lt;&lt; number &lt;&lt; std::endl;
<span style = "background-color:#fdd">        localQuat[0] = number / 10000.0;    // the value is send with an implied decimal point with 4 digits to the right
        for (unsigned int i = 1; i &lt; 4; i++)// read the next 3 numbers</span>
        {
<span style = "background-color:#fdd">          m_TrackingDevice-&gt;Receive(&amp;s, 6); // read the next number
          reply += s;                       // build complete command string
          converter &lt;&lt; std::dec &lt;&lt; s;                   // insert string with first number into stringstream
          converter &gt;&gt; number;              // extract first number as integer
          converter.clear();                // converter must be cleared to be reused
          converter.str("");
          localQuat[i] = number / 10000.0;  // the value is send with an implied decimal point with 4 digits to the right
        }</span>
        /* read and parse the three 7 character translation values */
<span style = "background-color:#fdd">        for (auto &amp; localPo : localPos)</span>
        {
<span style = "background-color:#fdd">          m_TrackingDevice-&gt;Receive(&amp;s, 7); // read the next position vector number
          reply += s;                       // build complete command string
          converter &lt;&lt; std::dec &lt;&lt; s;                   // insert string with number into stringstream
          converter &gt;&gt; number;              // extract first number as integer
          converter.clear();                // converter must be cleared to be reused
          converter.str("");
          localPo = number / 100.0;     // the value is send with an implied decimal point with 2 digits to the right
        }</span>
        /* read and parse 6 character error value */
<span style = "background-color:#fdd">        m_TrackingDevice-&gt;Receive(&amp;s, 6);   // read the error value
        reply += s;                         // build complete command string
        converter &lt;&lt; std::dec &lt;&lt; s;                     // insert string with number into stringstream
        converter &gt;&gt; number;                // extract the number as integer
        converter.clear();                  // converter must be cleared to be reused
        converter.str("");
        localError = number / 10000.0;      // the error value is send with an implied decimal point with 4 digits to the right</span>
        /* read and parse 8 character port status */
<span style = "background-color:#fdd">        m_TrackingDevice-&gt;Receive(&amp;s, 8);   // read the port status value
        reply += s;                         // build complete command string
        converter &lt;&lt; std::hex &lt;&lt; s;         // insert string into stringstream
        converter &gt;&gt; localPortStatus;       // extract the number as unsigned long
        converter.clear();                  // converter must be cleared to be reused
        converter.str("");</span>
        /* read and parse 8 character frame number as hexadecimal */
<span style = "background-color:#fdd">        m_TrackingDevice-&gt;Receive(&amp;s, 8);   // read the frame number value
        reply += s;                         // build complete command string
        converter &lt;&lt; std::hex &lt;&lt; s;         // insert string with hex value encoded number into stringstream
        converter &gt;&gt; localFrameNumber;      // extract the number as unsigned long
        converter.clear();                  // converter must be cleared to be reused
        converter.str("");</span>

        /* copy local values to the tool */
<span style = "background-color:#fdd">        mitk::Quaternion orientation(localQuat[1], localQuat[2], localQuat[3], localQuat[0]);
        tool-&gt;SetOrientation(orientation);
        mitk::Point3D position;
        position[0] = localPos[0];
        position[1] = localPos[1];
        position[2] = localPos[2];
        tool-&gt;SetPosition(position);
        tool-&gt;SetTrackingError(localError);
        tool-&gt;SetErrorMessage("");
        tool-&gt;SetDataValid(true);
        m_TrackingDevice-&gt;Receive(&amp;s, 1);   // read the line feed character, that terminates each handle data
        reply += s;                         // build complete command string</span>
      }
<span style = "background-color:#fdd">    }</span>
    //Read Reply Option 1000 data

    /* parse number of markers from first 2 characters */
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;Receive(&amp;s, 2);
    reply += s;
    unsigned int numberOfMarkers = 0;
    converter &lt;&lt; std::hex &lt;&lt; s;           // insert reply into stringstream
    converter &gt;&gt; numberOfMarkers;             // extract number of markers as unsigned byte
    converter.clear();                        // converter must be cleared to be reused
    converter.str("");</span>

<span style = "background-color:#fdd">    unsigned int oovReplySize = (unsigned int)ceil((double)numberOfMarkers/4.0);
    unsigned int nbMarkersInVolume = 0;</span>
    char c;
    // parse oov data to find out how many marker positions were recorded
<span style = "background-color:#fdd">    for (unsigned int i = 0; i &lt; oovReplySize; i++)</span>
    {
<span style = "background-color:#fdd">      m_TrackingDevice-&gt;ReceiveByte(&amp;c);
      reply += c;
      nbMarkersInVolume += ByteToNbBitsOn(c);
    }</span>

<span style = "background-color:#fdd">    nbMarkersInVolume = numberOfMarkers-nbMarkersInVolume;</span>

    /* read and parse position data for each marker */
<span style = "background-color:#fdd">    for (unsigned int i = 0; i &lt; nbMarkersInVolume; i++)</span>
    {
      /* define local copies */
<span style = "background-color:#fdd">      signed int number = 0;</span>
      MarkerPointType markerPosition;
      /* read and parse the three 7 character translation values */
<span style = "background-color:#fdd">      for (unsigned int i = 0; i &lt; 3; i++)</span>
      {
<span style = "background-color:#fdd">        m_TrackingDevice-&gt;Receive(&amp;s, 7); // read the next position vector number
        reply += s;                       // build complete command string
        converter &lt;&lt; std::dec &lt;&lt; s;       // insert string with number into stringstream
        converter &gt;&gt; number;              // extract first number as integer
        converter.clear();                // converter must be cleared to be reused
        converter.str("");
        markerPosition[i] = number / 100.0;     // the value is send with an implied decimal point with 2 digits to the right
      }
      markerPositions-&gt;push_back(markerPosition);
    } // end for all markers</span>
    //m_TrackingDevice-&gt;Receive(&amp;s, 1);   // read the line feed character, that terminates each handle data
    //reply += s;                         // build complete command string
    //

    //END read Reply Option 1000 data


<span style = "background-color:#fdd">    m_TrackingDevice-&gt;Receive(&amp;s, 4);       // read system status
    reply += s;                             // build complete command string</span>
    /* now the reply string is complete, perform crc checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                    // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4); // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)             // if the read CRC is correct, return okay</span>
    {
<span style = "background-color:#fdd">      returnValue = NDIOKAY;
    }</span>
    else                                    // return error in CRC
    {
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;</span>
      /* Invalidate all tools because the received data contained an error */
<span style = "background-color:#fdd">      markerPositions-&gt;clear();
      m_TrackingDevice-&gt;InvalidateAll();</span>
    }
<span style = "background-color:#fdd">  } // else</span>

  /* cleanup and return */
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;Receive(&amp;s, 1);         // read the last linde feed (because the tracking system device is sometimes to slow to send it before we clear the buffer. In this case, the LF would remain in the receive buffer and be read as the first character of the next command
  m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::BX()
<span style = "background-color:#fdd">{
  std::cout &lt;&lt; "BX() not implemented yet, using TX() instead." &lt;&lt; std::endl;
  return this-&gt;TX();
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::VER(mitk::TrackingDeviceType&amp; t)
<span style = "background-color:#fdd">{
  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

<span style = "background-color:#fdd">  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from tracking system</span>
  /* send command */
<span style = "background-color:#fdd">  std::string fullcommand;
  if (m_UseCRC == true)
    fullcommand = "VER:4";          // command string format 1: with crc</span>
  else
<span style = "background-color:#fdd">    fullcommand = "VER 4";          // command string format 2: without crc</span>

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;fullcommand, m_UseCRC);
  if (returnValue != NDIOKAY)</span>
  {
    /* cleanup and return */
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
    return returnValue;</span>
  }
  /* read number of handles returned */
<span style = "background-color:#fdd">  std::string reply;
  m_TrackingDevice-&gt;Receive(&amp;reply, 5);       // read first 5 characters of reply (error beginning of version information)
  static const std::string error("ERROR");
  if (error.compare(0, 6, reply) == 0) // ERROR case</span>
  {
<span style = "background-color:#fdd">    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2); // now read 2 bytes error code
    reply += errorcode;                       // build complete reply string</span>
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)               // if the read CRC is correct, return normal error code
      returnValue = this-&gt;GetErrorCode(&amp;errorcode);</span>
    else                                      // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }</span>
  else // no error, valid reply
  {
<span style = "background-color:#fdd">    std::string s;
    m_TrackingDevice-&gt;ReceiveLine(&amp;s);       // read until first LF character
    reply += s;
    std::string upperCaseReply;
    upperCaseReply.resize(reply.size());
    std::transform (reply.begin(), reply.end(), upperCaseReply.begin(), toupper);  // convert reply to uppercase to ease finding
    if (upperCaseReply.find("POLARIS") != std::string::npos)
      t = NDIPolarisTypeInformation::GetTrackingDeviceName();
    else if (upperCaseReply.find("AURORA") != std::string::npos)
      t = NDIAuroraTypeInformation::GetTrackingDeviceName();</span>
    else
<span style = "background-color:#fdd">      t = UnspecifiedTrackingTypeInformation::GetTrackingDeviceName();</span>
    // check for "VICRA", "SPECTRA", "ACCEDO"
    /* do not check for remaining reply, do not check for CRC, just delete remaining reply */
<span style = "background-color:#fdd">    itksys::SystemTools::Delay(500); // wait until reply should be finished
    m_TrackingDevice-&gt;ClearReceiveBuffer();
    returnValue = NDIOKAY;
  }
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::POS3D(MarkerPointContainerType* markerPositions)
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from trackingsystem</span>

<span style = "background-color:#fdd">  if (m_TrackingDevice == nullptr)</span>
  {
<span style = "background-color:#fdd">    return TRACKINGDEVICENOTSET;</span>
  }
<span style = "background-color:#fdd">  if (markerPositions == nullptr)</span>
  {
<span style = "background-color:#fdd">    std::cout &lt;&lt; "ERROR: markerPositions==nullptr" &lt;&lt; std::endl;
    return NDIUNKNOWNERROR;</span>
  }

<span style = "background-color:#fdd">  markerPositions-&gt;clear();   // empty point container</span>
  /* try to obtain a porthandle */
<span style = "background-color:#fdd">  if (m_TrackingDevice-&gt;GetToolCount() == 0)</span>
  {
<span style = "background-color:#fdd">    std::cout &lt;&lt; "ERROR: no tools present" &lt;&lt; std::endl;
    return NDIUNKNOWNERROR;</span>
  }
<span style = "background-color:#fdd">  const TrackingTool* t = m_TrackingDevice-&gt;GetTool(static_cast&lt;unsigned int&gt;(0));
  const NDIPassiveTool* t2 = dynamic_cast&lt;const NDIPassiveTool*&gt;(t);
  if (t2 == nullptr)</span>
  {
<span style = "background-color:#fdd">    std::cout &lt;&lt; "ERROR: no tool present" &lt;&lt; std::endl;
    return NDIUNKNOWNERROR;</span>
  }
<span style = "background-color:#fdd">  std::string portHandle = t2-&gt;GetPortHandle();
  if (portHandle.size() == 0)</span>
  {
<span style = "background-color:#fdd">    std::cout &lt;&lt; "ERROR: no port handle" &lt;&lt; std::endl;
    return NDIUNKNOWNERROR;</span>
  }

  /* send command */
<span style = "background-color:#fdd">  std::string fullcommand;
  if (m_UseCRC == true)
    fullcommand = "3D:" + portHandle + "5";          // command string format 1: with crc</span>
  else
<span style = "background-color:#fdd">    fullcommand = "3D " + portHandle + "5";          // command string format 2: without crc</span>

<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ClearReceiveBuffer();
  returnValue = m_TrackingDevice-&gt;Send(&amp;fullcommand, m_UseCRC);</span>

  /* read number of markers returned */
<span style = "background-color:#fdd">  std::string reply;
  std::string s;</span>

<span style = "background-color:#fdd">  mitk::NDIErrorCode receivevalue = m_TrackingDevice-&gt;Receive(&amp;reply, 3);       // read first 3 characters of reply (error or number of markers returned)
  if(receivevalue != NDIOKAY)</span>
  {
<span style = "background-color:#fdd">    std::cout &lt;&lt; "ERROR: receive_value != NDIOKAY" &lt;&lt; std::endl;
    return receivevalue;</span>
  }

<span style = "background-color:#fdd">  static const std::string error("ERROR");
  if (error.compare(0, 3, reply) == 0)</span>
  {
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;Receive(&amp;s, 2);         // read next characters ("OR" from ERROR)
    reply += s;                               // to build complete reply string
    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2); // now read 2 bytes error code
    reply += errorcode;                       // build complete reply string</span>
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)               // if the read CRC is correct, return normal error code</span>
    {
<span style = "background-color:#fdd">      returnValue = this-&gt;GetErrorCode(&amp;errorcode);
    }</span>
    else                                      // return error in CRC
    {
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else                                        // transformation data is returned
  {
<span style = "background-color:#fdd">    signed int number = 0;</span>
    //float localPos[3] = {0.0, 0.0, 0.0};
    MarkerPointType p;
    //float lineSeparation = 0.0;

    /* parse number of markers from first 3 characters */
<span style = "background-color:#fdd">    std::stringstream converter;
    unsigned int numberOfMarkers = 0;
    converter &lt;&lt; std::dec &lt;&lt; reply;           // insert reply into stringstream
    converter &gt;&gt; numberOfMarkers;             // extract number of handles as unsigned byte
    converter.clear();                        // converter must be cleared to be reused
    converter.str("");</span>
    /* read and parse 3D data for each marker */
<span style = "background-color:#fdd">    for (unsigned int markerID = 0; markerID &lt; numberOfMarkers; markerID++)    // for each marker</span>
    {
<span style = "background-color:#fdd">      m_TrackingDevice-&gt;Receive(&amp;s, 1);       // read line feed
      reply += s;                             // build complete command string</span>
      /* read and parse the three 9 character translation values */
<span style = "background-color:#fdd">      for (unsigned int i = 0; i &lt; 3; i++)</span>
      {
<span style = "background-color:#fdd">        receivevalue = m_TrackingDevice-&gt;Receive(&amp;s, 9); // read the next position vector number
        if(receivevalue != NDIOKAY)</span>
        {
<span style = "background-color:#fdd">          markerPositions-&gt;clear();
          std::cout &lt;&lt; "ERROR: receive_value != NDIOKAY" &lt;&lt; std::endl;
          return receivevalue;</span>
        }
<span style = "background-color:#fdd">        reply += s;                       // build complete command string
        converter &lt;&lt; std::dec &lt;&lt; s;       // insert string with number into stringstream
        converter &gt;&gt; number;              // extract the number as integer
        converter.clear();                // converter must be cleared to be reused
        converter.str("");
        p[i] = number / 10000.0;          // the value is send with an implied decimal point with 4 digits to the right
      }</span>
      /* read and parse 4 character line separation value */
<span style = "background-color:#fdd">      receivevalue = m_TrackingDevice-&gt;Receive(&amp;s, 4);   // read the line separation value
      if(receivevalue != NDIOKAY)</span>
      {
<span style = "background-color:#fdd">        markerPositions-&gt;clear();
        std::cout &lt;&lt; "ERROR: receive_value != NDIOKAY" &lt;&lt; std::endl;
        return receivevalue;</span>
      }
<span style = "background-color:#fdd">      reply += s;                         // build complete command string
      converter &lt;&lt; std::dec &lt;&lt; s;         // insert string with number into stringstream
      converter &gt;&gt; number;                // extract the number as integer
      converter.clear();                  // converter must be cleared to be reused
      converter.str("");</span>
      //lineSeparation = number / 100.0;    // the line separation value is send with an implied decimal point with 2 digits to the right
      /* read and parse 1 character out of volume value */
<span style = "background-color:#fdd">      receivevalue = m_TrackingDevice-&gt;Receive(&amp;s, 1);   // read the port status value
      if(receivevalue != NDIOKAY)</span>
      {
<span style = "background-color:#fdd">        markerPositions-&gt;clear();
        std::cout &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; "ERROR: POS3D != NDIOKAY" &lt;&lt; std::endl;
        return receivevalue;</span>
      }
<span style = "background-color:#fdd">      reply += s;                         // build complete command string</span>
      /* store the marker positions in the point container */
<span style = "background-color:#fdd">      markerPositions-&gt;push_back(p);
    }</span>
    //std::cout &lt;&lt; "INFO: Found " &lt;&lt; markerPositions-&gt;size() &lt;&lt; " markers." &lt;&lt; std::endl;

    /* now the reply string is complete, perform crc checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                    // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4); // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)             // if the read CRC is correct, return okay</span>
    {
<span style = "background-color:#fdd">      returnValue = NDIOKAY;
    }</span>
    else                                    // return error in CRC
    {
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
      std::cout &lt;&lt; "ERROR: receive_value != NDIOKAY" &lt;&lt; std::endl;</span>
      /* delete all marker positions because the received data contained an error */
<span style = "background-color:#fdd">      markerPositions-&gt;clear();</span>
    }
<span style = "background-color:#fdd">  } // else</span>

  /* cleanup and return */
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;Receive(&amp;s, 1);         // read the last linde feed (because the tracking system device is sometimes to slow to send it before we clear the buffer. In this case, the LF would remain in the receive buffer and be read as the first character of the next command
  m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove the remaining carriage return or unknown/unexpected reply</span>

<span style = "background-color:#fdd">  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::GenericCommand(const std::string command, const std::string* parameter)
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from trackingsystem</span>

<span style = "background-color:#fdd">  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

<span style = "background-color:#fdd">  std::string p;
  if (parameter != nullptr)
    p = *parameter;</span>
  else
<span style = "background-color:#fdd">    p = "";</span>

  /* send command */
<span style = "background-color:#fdd">  std::string fullcommand;
  if (m_UseCRC == true)
    fullcommand = command + ":" + p;          // command string format 1: with crc</span>
  else
<span style = "background-color:#fdd">    fullcommand = command + " " + p;          // command string format 2: without crc</span>


<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ClearReceiveBuffer(); // This is a workaround for a linux specific issue:</span>
  // after sending the TSTART command and expecting an "okay" there are some unexpected bytes left in the buffer.
  // this issue is explained in bug 11825

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;fullcommand, m_UseCRC);</span>

<span style = "background-color:#fdd">  if (returnValue != NDIOKAY)                 // check for send error</span>
  {
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove any reply
    return returnValue;</span>
  }
  /* wait for the trackingsystem to process the command */
<span style = "background-color:#fdd">  itksys::SystemTools::Delay(100);</span>

  /* read and parse the reply from tracking device */
  // the reply for a generic command can be OKAY or ERROR##
  // so we can use the generic parse method for these replies
<span style = "background-color:#fdd">  this-&gt;ParseOkayError();
  return returnValue;
}</span>


unsigned int mitk::NDIProtocol::ByteToNbBitsOn(char&amp; c) const
<span style = "background-color:#fdd">{
  if(c == '0')
    return 0;
  else if (c == '1' || c == '2' || c == '4' || c == '8')
    return 1;
  else if (c == '3' || c == '5' || c == '9' || c == '6' || c == 'A' || c == 'C')
    return 2;
  else if (c == '7' || c == 'B' || c == 'D' || c == 'E')
    return 3;
  else if (c == 'F')
    return 4;</span>
  else
<span style = "background-color:#fdd">    return 0;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::ParseOkayError()
<span style = "background-color:#fdd">{
  NDIErrorCode returnValue  = NDIUNKNOWNERROR;</span>
  /* read reply from tracking device */
  // the reply is expected to be OKAY or ERROR##
  // define reply strings
<span style = "background-color:#fdd">  std::string reply;
  m_TrackingDevice-&gt;Receive(&amp;reply, 4);       // read first 4 characters of reply</span>

  /* Parse reply from tracking device */
<span style = "background-color:#fdd">  static const std::string okay("OKAYA896");  // OKAY is static, so we can perform a static crc check
  static const std::string error("ERROR");</span>

<span style = "background-color:#fdd">  if (okay.compare(0, 4, reply) == 0)         // check for "OKAY": compare first 4 characters from okay with reply</span>
  {
    // OKAY was found, now check the CRC16 too
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;Receive(&amp;reply, 4);     // read 4 hexadecimal characters for CRC16
    if (okay.compare(4, 4, reply, 0, 4) == 0) // first 4 from new reply should match last 4 from okay
      returnValue = NDIOKAY;</span>
    else
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }
  else if (error.compare(0, 4, reply) == 0)   // check for "ERRO"</span>
  {
    char b;                                   // The ERROR reply is not static, so we can not use a static crc check.
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ReceiveByte(&amp;b);        // read next character ("R" from ERROR)
    reply += b;                               // to build complete reply string
    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2); // now read 2 bytes error code
    reply += errorcode;                       // build complete reply string</span>
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits
    if (expectedCRC == readCRC)               // if the read CRC is correct, return normal error code
      returnValue = this-&gt;GetErrorCode(&amp;errorcode);</span>
    else                                      // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }</span>
  else                                      // something else, that we do not expect
<span style = "background-color:#fdd">    returnValue = NDIUNEXPECTEDREPLY;</span>

  /* cleanup and return */
  char b;
<span style = "background-color:#fdd">  m_TrackingDevice-&gt;ReceiveByte(&amp;b);          // read CR character
  m_TrackingDevice-&gt;ClearReceiveBuffer();     // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::GetErrorCode(const std::string* input)
<span style = "background-color:#fdd">{
  if (input-&gt;compare("01") == 0)
    return NDIINVALIDCOMMAND;
  else if (input-&gt;compare("02") == 0)
    return NDICOMMANDTOOLONG;
  else if (input-&gt;compare("03") == 0)
    return NDICOMMANDTOOSHORT;
  else if (input-&gt;compare("04") == 0)
    return NDICRCDOESNOTMATCH;
  else if (input-&gt;compare("05") == 0)
    return NDITIMEOUT;
  else if (input-&gt;compare("06") == 0)
    return NDIUNABLETOSETNEWCOMMPARAMETERS;
  else if (input-&gt;compare("07") == 0)
    return NDIINCORRECTNUMBEROFPARAMETERS;
  else if (input-&gt;compare("08") == 0)
    return NDIINVALIDPORTHANDLE;
  else if (input-&gt;compare("09") == 0)
    return NDIINVALIDTRACKINGPRIORITY;
  else if (input-&gt;compare("0A") == 0)
    return NDIINVALIDLED;
  else if (input-&gt;compare("0B") == 0)
    return NDIINVALIDLEDSTATE;
  else if (input-&gt;compare("0C") == 0)
    return NDICOMMANDINVALIDINCURRENTMODE;
  else if (input-&gt;compare("0D") == 0)
    return NDINOTOOLFORPORT;
  else if (input-&gt;compare("0E") == 0)
    return NDIPORTNOTINITIALIZED;</span>

  // ...
<span style = "background-color:#fdd">  else if (input-&gt;compare("10") == 0)
    return NDISYSTEMNOTINITIALIZED;
  else if (input-&gt;compare("11") == 0)
    return NDIUNABLETOSTOPTRACKING;
  else if (input-&gt;compare("12") == 0)
    return NDIUNABLETOSTARTTRACKING;
  else if (input-&gt;compare("13") == 0)
    return NDIINITIALIZATIONFAILED;
  else if (input-&gt;compare("14") == 0)
    return NDIINVALIDVOLUMEPARAMETERS;
  else if (input-&gt;compare("16") == 0)
    return NDICANTSTARTDIAGNOSTICMODE;
  else if (input-&gt;compare("1B") == 0)
    return NDICANTINITIRDIAGNOSTICS;
  else if (input-&gt;compare("1F") == 0)
    return NDIFAILURETOWRITESROM;
  else if (input-&gt;compare("22") == 0)
    return NDIENABLEDTOOLSNOTSUPPORTED;
  else if (input-&gt;compare("23") == 0)
    return NDICOMMANDPARAMETEROUTOFRANGE;
  else if (input-&gt;compare("2A") == 0)
    return NDINOMEMORYAVAILABLE;
  else if (input-&gt;compare("2B") == 0)
    return NDIPORTHANDLENOTALLOCATED;
  else if (input-&gt;compare("2C") == 0)
    return NDIPORTHASBECOMEUNOCCUPIED;
  else if (input-&gt;compare("2D") == 0)
    return NDIOUTOFHANDLES;
  else if (input-&gt;compare("2E") == 0)
    return NDIINCOMPATIBLEFIRMWAREVERSIONS;
  else if (input-&gt;compare("2F") == 0)
    return NDIINVALIDPORTDESCRIPTION;
  else if (input-&gt;compare("32") == 0)
    return NDIINVALIDOPERATIONFORDEVICE;</span>
  // ...
  else
<span style = "background-color:#fdd">    return NDIUNKNOWNERROR;
}</span>

mitk::NDIErrorCode mitk::NDIProtocol::APIREV(std::string* revision)
<span style = "background-color:#fdd">{
  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

<span style = "background-color:#fdd">  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from tracking system</span>

  /* send command */
<span style = "background-color:#fdd">  std::string command;
  if (m_UseCRC)
    command = "APIREV:";</span>
  else
<span style = "background-color:#fdd">    command = "APIREV ";</span>

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;command, m_UseCRC);
  if (returnValue != NDIOKAY)</span>
  {
    /* cleanup and return */
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
    return returnValue;</span>
  }

  //wait for tracking system to compute the output
  //itksys::SystemTools::Delay(100);

  /* read number of handles returned */
<span style = "background-color:#fdd">  std::string reply;
  m_TrackingDevice-&gt;Receive(&amp;reply, 5); //look for ERROR</span>

  // read first 5 characters of reply (error beginning of version information)
<span style = "background-color:#fdd">  static const std::string error("ERROR");
  if (error.compare(0, 6, reply) == 0) // ERROR case</span>
  {
<span style = "background-color:#fdd">    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2); // now read 2 bytes error code
    reply += errorcode;                       // build complete reply string</span>

    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits</span>

<span style = "background-color:#fdd">    if (expectedCRC == readCRC)               // if the read CRC is correct, return normal error code
      returnValue = this-&gt;GetErrorCode(&amp;errorcode);</span>
    else                                      // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }</span>
  else // no error, valid reply: expect something like: D.001.00450D4 (&lt;Family&gt;.&lt;Major revision number&gt;.&lt;Minor revision number&gt;&lt;CRC16&gt;&lt;CR&gt;
  {
<span style = "background-color:#fdd">    std::string s;</span>

<span style = "background-color:#fdd">    m_TrackingDevice-&gt;Receive(&amp;s, 4);       // read further
    reply += s;</span>

    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);  // calculate crc for received reply string
    std::string readCRC;                                          // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);                       // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits</span>

<span style = "background-color:#fdd">    if (expectedCRC == readCRC)                                   // if the read CRC is correct, return normal error code
      returnValue = NDIOKAY;</span>
    else                                      // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }</span>

<span style = "background-color:#fdd">  *revision = reply;
  m_TrackingDevice-&gt;ClearReceiveBuffer();
  return returnValue;
}</span>


mitk::NDIErrorCode mitk::NDIProtocol::SFLIST(std::string* info)
<span style = "background-color:#fdd">{
  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

<span style = "background-color:#fdd">  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from tracking system</span>

  /* send command */
<span style = "background-color:#fdd">  std::string command;
  if (m_UseCRC)
    command = "SFLIST:03";</span>
  else
<span style = "background-color:#fdd">    command = "SFLIST 03";</span>

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;command, m_UseCRC);
  if (returnValue != NDIOKAY)</span>
  {
    /* cleanup and return */
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
    return returnValue;</span>
  }

  /* read number of handles returned */
<span style = "background-color:#fdd">  std::string reply;
  m_TrackingDevice-&gt;Receive(&amp;reply, 5); //look for "ERROR"</span>

<span style = "background-color:#fdd">  static const std::string error("ERROR");
  if (error.compare(0,6,reply) == 0) // ERROR case</span>
  {
<span style = "background-color:#fdd">    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2); // now read 2 bytes error code
    reply += errorcode;                       // build complete reply string</span>

    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits</span>

<span style = "background-color:#fdd">    if (expectedCRC == readCRC)               // if the read CRC is correct, return normal error code
      returnValue = this-&gt;GetErrorCode(&amp;errorcode);</span>
    else                                      // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }</span>

  else // no error, valid reply: expect numbers of devices in hex, and then info of each featured tracking volume &lt;CRC16&gt;&lt;CR&gt;
  {
    /* parse number of volumes from first character in hex */
<span style = "background-color:#fdd">    std::stringstream converter;
    unsigned int numberOfVolumes = 0;
    converter &lt;&lt; std::hex &lt;&lt; reply[0];        // insert reply into stringstream
    converter &gt;&gt; numberOfVolumes;             // extract number of handles as unsigned byte
    converter.clear();                        // converter must be cleared to be reused
    converter.str("");</span>

<span style = "background-color:#fdd">    if ( numberOfVolumes &gt; 9 )</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Number of volumes (" &lt;&lt; numberOfVolumes</span>
        &lt;&lt; ") is not smaller then ten as it was expected. Cannot get supported volumes.";
<span style = "background-color:#fdd">      numberOfVolumes = 0;
      reply[0] = numberOfVolumes;</span>
    }

    //reply currently contains the first 5 elements
<span style = "background-color:#fdd">    if (numberOfVolumes&gt;0)</span>
    {
      //for each featured volume
<span style = "background-color:#fdd">      for (unsigned int i = 0; i&lt;numberOfVolumes; i++)</span>
      {
<span style = "background-color:#fdd">        std::string currentVolume;
        if (i==0)</span>
        {
          //already read the first 4 bytes of the volume info
<span style = "background-color:#fdd">          currentVolume.append(reply,1,4);
          std::string s;
          m_TrackingDevice-&gt;Receive(&amp;s, 69);// 69 characters to get all dimensions plus two characters at the end: one reserved and one for metal resistance.
          reply += s;
          currentVolume += s;
        }</span>
        else
        {
          //read to the end of the line from the last volume
          //(needed here, because if only one volume is supported,
          //then there is no lineending &lt;LF&gt; before CRC checksum
<span style = "background-color:#fdd">          std::string l;
          m_TrackingDevice-&gt;ReceiveLine(&amp;l);
          reply += l;</span>

<span style = "background-color:#fdd">          std::string s;
          m_TrackingDevice-&gt;Receive(&amp;s, 73); //need total of 73 bytes for a volume
          reply += s;
          currentVolume += s;</span>

<span style = "background-color:#fdd">          if ( s.empty() )</span>
          {
<span style = "background-color:#fdd">            MITK_INFO &lt;&lt; "Cannot get information of tracking volume " &lt;&lt; i &lt;&lt; ". Abort getting of tracking volumes.";
            numberOfVolumes = 0;
            reply[0] = numberOfVolumes;
            break;</span>
          }
<span style = "background-color:#fdd">        }</span>
        //analyze volume here

<span style = "background-color:#fdd">        if (currentVolume.compare(0, 1, mitk::NDIPolarisTypeInformation::GetDeviceDataPolarisOldModel().HardwareCode) == 0)
          MITK_INFO&lt;&lt;"Standard volume supported \n";
        else if (currentVolume.compare(0, 3, mitk::NDIPolarisTypeInformation::GetDeviceDataPolarisSpectra().HardwareCode) == 0)
          MITK_INFO&lt;&lt;"Spectra pyramid volume supported \n";
        else if (currentVolume.compare(0, 3, mitk::NDIPolarisTypeInformation::GetDeviceDataSpectraExtendedPyramid().HardwareCode)==0)
          MITK_INFO&lt;&lt;"Spectra extended pyramid volume supported \n";
        else if (currentVolume.compare(0, 1, mitk::NDIPolarisTypeInformation::GetDeviceDataPolarisVicra().HardwareCode) == 0)
          MITK_INFO&lt;&lt;"Vicra volume supported \n";
        else if (currentVolume.compare(0, 1, mitk::NDIAuroraTypeInformation::GetDeviceDataAuroraPlanarCube().HardwareCode) == 0)
          MITK_INFO&lt;&lt;"Cube volume supported \n";
        else if (currentVolume.compare(0, 1, mitk::NDIAuroraTypeInformation::GetDeviceDataAuroraPlanarDome().HardwareCode) == 0)
          MITK_INFO&lt;&lt;"Dome volume supported \n";</span>
        else
<span style = "background-color:#fdd">          MITK_WARN&lt;&lt;"Message not understood!\n";
      }</span>
    }

    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);  // calculate crc for received reply string
    std::string readCRC;                                          // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);                       // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits</span>

    /* CRC check is commented out at the moment, because there is a bug (see bug 16285 for more information)
    if (expectedCRC == readCRC)                                   // if the read CRC is correct, return normal error code
       returnValue = NDIOKAY;
    else                                      // return error in CRC
       returnValue = NDICRCERROR;
    */

<span style = "background-color:#fdd">    returnValue = NDIOKAY;
  }</span>

<span style = "background-color:#fdd">  *info = reply;
  m_TrackingDevice-&gt;ClearReceiveBuffer();
  return returnValue;
}</span>

mitk::NDIErrorCode mitk::NDIProtocol::VSEL(mitk::TrackingDeviceData deviceData)
<span style = "background-color:#fdd">{
  if (m_TrackingDevice == nullptr)
    return TRACKINGDEVICENOTSET;</span>

<span style = "background-color:#fdd">  NDIErrorCode returnValue = NDIUNKNOWNERROR; // return code for this function. Will be set according to reply from tracking system</span>


  //get information about the order of volumes from tracking device. Then choose the number needed for VSEL by the output and parameter "device"
  unsigned int numberOfVolumes;
<span style = "background-color:#fdd">  mitk::NDITrackingDevice::NDITrackingVolumeContainerType volumes;
  mitk::NDITrackingDevice::TrackingVolumeDimensionType volumesDimensions;
  if (!m_TrackingDevice-&gt;GetSupportedVolumes(&amp;numberOfVolumes, &amp;volumes, &amp;volumesDimensions))
    return returnValue;</span>

  //interested in volumes(!)
<span style = "background-color:#fdd">  if (volumes.empty())
    return returnValue;</span>
  //with the order within volumes we can define our needed parameter for VSEL
  //find the index where volumes[n] == device

<span style = "background-color:#fdd">  unsigned int index = 1; //the index for VSEL starts at 1
  auto it = volumes.begin();
  while (it != volumes.end())</span>
  {
<span style = "background-color:#fdd">    if ((*it) == deviceData.Model)</span>
    {
<span style = "background-color:#fdd">      MITK_INFO &lt;&lt; deviceData.Model &lt;&lt; " selected.";
      break;</span>
    }
<span style = "background-color:#fdd">    it++, index++;
  }
  if (it == volumes.end() || index &gt; numberOfVolumes) //not found / volume not supported
    return NDIINVALIDOPERATIONFORDEVICE;</span>

  //index now contains the information on which position the desired volume is situated

  /* send command */
<span style = "background-color:#fdd">  std::string command;
  if (m_UseCRC)
    command = "VSEL:";</span>
  else
<span style = "background-color:#fdd">    command = "VSEL ";</span>

  //add index to command
<span style = "background-color:#fdd">  std::stringstream s;
    s &lt;&lt; index;
  command += s.str();</span>

<span style = "background-color:#fdd">  returnValue = m_TrackingDevice-&gt;Send(&amp;command, m_UseCRC);
  if (returnValue != NDIOKAY)</span>
  {
    /* cleanup and return */
<span style = "background-color:#fdd">    m_TrackingDevice-&gt;ClearReceiveBuffer();   // flush the buffer to remove the remaining carriage return or unknown/unexpected reply
    return returnValue;</span>
  }

  /* read number of handles returned */
<span style = "background-color:#fdd">  std::string reply;
  m_TrackingDevice-&gt;Receive(&amp;reply, 4); //look for "ERROR" or "OKAY"</span>

<span style = "background-color:#fdd">  static const std::string error("ERRO");
  if (error.compare(reply) == 0) // ERROR case</span>
  {
<span style = "background-color:#fdd">    std::string s;
    m_TrackingDevice-&gt;Receive(&amp;s, 1); //get the last "R" in "ERROR"
    reply += s;</span>

<span style = "background-color:#fdd">    std::string errorcode;
    m_TrackingDevice-&gt;Receive(&amp;errorcode, 2); // now read 2 bytes error code
    reply += errorcode;                       // build complete reply string</span>

    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);    // calculate crc for received reply string
    std::string readCRC;                      // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);   // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits</span>

<span style = "background-color:#fdd">    if (expectedCRC == readCRC)               // if the read CRC is correct, return normal error code
      returnValue = this-&gt;GetErrorCode(&amp;errorcode);</span>
    else                                      // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }</span>
  else
  {
    /* perform CRC checking */
<span style = "background-color:#fdd">    std::string expectedCRC = m_TrackingDevice-&gt;CalcCRC(&amp;reply);  // calculate crc for received reply string
    std::string readCRC;                                          // read attached crc value
    m_TrackingDevice-&gt;Receive(&amp;readCRC, 4);                       // CRC16 is 2 bytes long, which is transmitted as 4 hexadecimal digits</span>

<span style = "background-color:#fdd">    if (expectedCRC == readCRC)                                   // if the read CRC is correct, return normal error code
      returnValue = NDIOKAY;</span>
    else                                      // return error in CRC
<span style = "background-color:#fdd">      returnValue = NDICRCERROR;
  }
  m_TrackingDevice-&gt;ClearReceiveBuffer();
  return returnValue;
}</span></pre>
	</body>
</html>