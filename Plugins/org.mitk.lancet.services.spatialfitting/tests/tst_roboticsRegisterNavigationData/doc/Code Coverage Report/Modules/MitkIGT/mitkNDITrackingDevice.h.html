<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNDITrackingDevice.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/


#ifndef MITKNDITRACKINGDEVICE_H_HEADER_INCLUDED_C1C2FCD2
#define MITKNDITRACKINGDEVICE_H_HEADER_INCLUDED_C1C2FCD2

#include "mitkTrackingDevice.h"

#include &lt;MitkIGTExports.h&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

#include "mitkNDIProtocol.h"
#include "mitkNDIPassiveTool.h"
#include "mitkSerialCommunication.h"


namespace mitk
{
  class NDIProtocol;

  /** Documentation
  * \brief superclass for specific NDI tracking Devices that use serial communication.
  *
  * implements the TrackingDevice interface for NDI tracking devices (POLARIS, AURORA)
  *
  * \ingroup IGT
  */
  class MITKIGT_EXPORT NDITrackingDevice : public TrackingDevice
  {
    friend class NDIProtocol;

  public:
    typedef std::vector&lt;NDIPassiveTool::Pointer&gt; Tool6DContainerType;  ///&lt; List of 6D tools of the correct type for this tracking device

    typedef mitk::TrackingDeviceType NDITrackingDeviceType;  ///&lt; This enumeration includes the two types of NDI tracking devices (Polaris, Aurora).
    typedef mitk::SerialCommunication::PortNumber PortNumber; ///&lt; Port number of the serial connection
    typedef mitk::SerialCommunication::BaudRate BaudRate;     ///&lt; Baud rate of the serial connection
    typedef mitk::SerialCommunication::DataBits DataBits;     ///&lt; Number of data bits used in the serial connection
    typedef mitk::SerialCommunication::Parity Parity;         ///&lt; Parity mode used in the serial connection
    typedef mitk::SerialCommunication::StopBits StopBits;     ///&lt; Number of stop bits used in the serial connection
    typedef mitk::SerialCommunication::HardwareHandshake HardwareHandshake; ///&lt; Hardware handshake mode of the serial connection
    typedef mitk::NDIPassiveTool::TrackingPriority TrackingPriority; ///&lt; Tracking priority used for tracking a tool

<span style = "background-color:#fdd">    mitkClassMacro(NDITrackingDevice, TrackingDevice);
    itkFactorylessNewMacro(Self);
    itkCloneMacro(Self);</span>

    /**
    * \brief Set the type of the NDI Tracking Device because it can not jet handle this itself
    */
    //itkSetMacro(Type, TrackingDeviceType);


    /**
    * \brief initialize the connection to the tracking device
    *
    * OpenConnection() establishes the connection to the tracking device by:
    * - initializing the serial port with the given parameters (port number, baud rate, ...)
    * - connection to the tracking device
    * - initializing the device
    * - initializing all manually added passive tools (user supplied srom file)
    * - initializing active tools that are connected to the tracking device
    * @throw mitk::IGTHardwareException Throws an exception if there are errors while connecting to the device.
    * @throw mitk::IGTException Throws a normal IGT exception if an error occures which is not related to the hardware.
    */
    bool OpenConnection() override;

    /**
    * \brief Closes the connection
    *
    * CloseConnection() resets the tracking device, invalidates all tools and then closes the serial port.
    */
    bool CloseConnection() override;

    /** @throw mitk::IGTHardwareException Throws an exception if there are errors while connecting to the device. */
    bool InitializeWiredTools();

    /** Sets the rotation mode of this class. See documentation of enum RotationMode for details
     *  on the different modes.
     */
    void SetRotationMode(RotationMode r) override;

    /**
    * \brief TestConnection() tries to connect to a NDI tracking device on the current port/device and returns which device it has found
    *
    * TestConnection() tries to connect to a NDI tracking device on the current port/device.
    * \return It returns the type of the device that answers at the port/device. Throws an exception if no device is available on that port.
    * @throw mitk::IGTHardwareException Throws an exception if there are errors while connecting to the device.
    */
    virtual mitk::TrackingDeviceType TestConnection();

    /**
    * \brief retrieves all wired tools from the tracking device
    *
    * This method queries the tracking device for all wired tools, initializes them and creates TrackingTool representation objects
    * for them
    * \return True if the method was executed successful.
    * @throw mitk::IGTHardwareException Throws an exception if there are errors while connecting to the device.
    * @throw mitk::IGTException Throws a normal IGT exception if an error occures which is not related to the hardware.
    */
    bool DiscoverWiredTools();

    /**
    * \brief Start the tracking.
    *
    * A new thread is created, which continuously reads the position and orientation information of each tool and stores them inside the tools.
    * Depending on the current operation mode (see SetOperationMode()), either the 6D tools (ToolTracking6D), 5D tools (ToolTracking5D),
    * 3D marker positions (MarkerTracking3D) or both 6D tools and 3D markers (HybridTracking) are updated.
    * Call StopTracking() to stop the tracking thread.
    */
    bool StartTracking() override;

    /**
    * \brief return the tool with index toolNumber
    */
    TrackingTool* GetTool(unsigned int toolNumber) const override;

    mitk::TrackingTool* GetToolByName(std::string name) const override;
    /**
    * \brief return current number of tools
    */
    unsigned int GetToolCount() const override;

    /**
    * \brief Create a passive 6D tool with toolName and fileName and add it to the list of tools
    *
    * This method will create a new NDIPassiveTool object, load the SROM file fileName,
    * set the tool name toolName and the tracking priority p and then add
    * it to the list of tools. It returns a pointer of type mitk::TrackingTool to the tool
    * that can be used to read tracking data from it.
    * This is the only way to add tools to NDITrackingDevice.
    * @throw mitk::IGTHardwareException Throws an exception if there are errors while adding the tool.
    *
    * \warning adding tools is not possible in tracking mode, only in setup and ready.
    */
    mitk::TrackingTool* AddTool(const char* toolName, const char* fileName, TrackingPriority p = NDIPassiveTool::Dynamic);

    /**
    * \brief Remove a passive 6D tool from the list of tracked tools.
    *
    * \warning removing tools is not possible in tracking mode, only in setup and ready modes.
    */
    virtual bool RemoveTool(TrackingTool* tool);

    /**
    * \brief reloads the srom file and reinitializes the tool
    */
    virtual bool UpdateTool(mitk::TrackingTool* tool);

    virtual void SetPortNumber(const PortNumber _arg); ///&lt; set port number for serial communication
<span style = "background-color:#fdd">    itkGetConstMacro(PortNumber, PortNumber);          ///&lt; returns the port number for serial communication</span>
    virtual void SetDeviceName(std::string _arg);      ///&lt; set device name (e.g. COM1, /dev/ttyUSB0). If this is set, PortNumber will be ignored
<span style = "background-color:#fdd">    itkGetStringMacro(DeviceName);                     ///&lt; returns the device name for serial communication</span>
    virtual void SetBaudRate(const BaudRate _arg);     ///&lt; set baud rate for serial communication
<span style = "background-color:#fdd">    itkGetConstMacro(BaudRate, BaudRate);              ///&lt; returns the baud rate for serial communication</span>
    virtual void SetDataBits(const DataBits _arg);     ///&lt; set number of data bits
<span style = "background-color:#fdd">    itkGetConstMacro(DataBits, DataBits);              ///&lt; returns the data bits for serial communication</span>
    virtual void SetParity(const Parity _arg);         ///&lt; set parity mode
<span style = "background-color:#fdd">    itkGetConstMacro(Parity, Parity);                  ///&lt; returns the parity mode</span>
    virtual void SetStopBits(const StopBits _arg);     ///&lt; set number of stop bits
<span style = "background-color:#fdd">    itkGetConstMacro(StopBits, StopBits);              ///&lt; returns the number of stop bits</span>
    virtual void SetHardwareHandshake(const HardwareHandshake _arg);  ///&lt; set use hardware handshake for serial communication
<span style = "background-color:#fdd">    itkGetConstMacro(HardwareHandshake, HardwareHandshake);              ///&lt; returns the hardware handshake setting</span>
    virtual void SetIlluminationActivationRate(const IlluminationActivationRate _arg); ///&lt; set activation rate of IR illumator for polaris
<span style = "background-color:#fdd">    itkGetConstMacro(IlluminationActivationRate, IlluminationActivationRate);          ///&lt; returns the activation rate of IR illumator for polaris</span>
    virtual void SetDataTransferMode(const DataTransferMode _arg);    ///&lt; set data transfer mode to text (TX) or binary (BX). \warning: only TX is supportet at the moment
<span style = "background-color:#fdd">    itkGetConstMacro(DataTransferMode, DataTransferMode);              ///&lt; returns the data transfer mode</span>
    virtual bool Beep(unsigned char count);   ///&lt; Beep the tracking device 1 to 9 times

    NDIErrorCode GetErrorCode(const std::string* input);  ///&lt; returns the error code for a string that contains an error code in hexadecimal format

    virtual bool SetOperationMode(OperationMode mode);  ///&lt; set operation mode to 6D tool tracking, 3D marker tracking or 6D&amp;3D hybrid tracking (see OperationMode)
    virtual OperationMode GetOperationMode();           ///&lt; get current operation mode

    /**
    * \brief Get 3D marker positions (operation mode must be set to MarkerTracking3D or HybridTracking)
    */
    virtual bool GetMarkerPositions(MarkerPointContainerType* markerpositions);

    /**
    * \brief Get major revision number from tracking device
    * should not be called directly after starting to track
    **/
    virtual int GetMajorFirmwareRevisionNumber();

    /**
    * \brief Get revision number from tracking device as string
    * should not be called directly after starting to track
    **/
    virtual const char* GetFirmwareRevisionNumber();

    /** @return Returns true if this device can autodetects its tools. */
    bool AutoDetectToolsAvailable() override;

    /** @return Returns true if it is possible to add a single tool. True for Polaris, false for Aurora.*/
    bool AddSingleToolIsAvailable() override;

    /** Autodetects tools from this device and returns them as a navigation tool storage.
    *  @return Returns the detected tools. Returns an empty storage if no tools are present
    *          or if detection is not possible
    */
    mitk::NavigationToolStorage::Pointer AutoDetectTools() override;



  protected:

    typedef std::vector&lt;std::string&gt; NDITrackingVolumeContainerType;  ///&lt; vector of tracking volumes
    typedef std::vector&lt;int&gt; TrackingVolumeDimensionType;          ///&lt; List of the supported tracking volume dimensions.

        /**
    * \brief Get number of supported tracking volumes, a vector containing the supported volumes and
    * a vector containing the signed dimensions in mm. For each volume 10 boundaries are stored in the order of
    * the supported volumes (see AURORA API GUIDE: SFLIST p.54).
    **/
    virtual bool GetSupportedVolumes(unsigned int* numberOfVolumes, NDITrackingVolumeContainerType* volumes, TrackingVolumeDimensionType* volumesDimensions);

       /**
    * \brief Sets the desired tracking volume. Returns true if the volume type could be set. It is set in the OpenConnection() Method and sets the tracking volume out of m_Data.
    * @throw mitk::IGTHardwareException Throws an IGT hardware exception if the volume could not be set.
    **/
    virtual bool SetVolume(mitk::TrackingDeviceData volume);

    /**
    * \brief Add a passive 6D tool to the list of tracked tools. This method is used by AddTool
    * @throw mitk::IGTHardwareException Throws an exception if there are errors while adding the tool.
    * \warning adding tools is not possible in tracking mode, only in setup and ready.
    */
    virtual bool InternalAddTool(NDIPassiveTool* tool);

    /* Methods for NDIProtocol friend class */
    virtual void InvalidateAll();             ///&lt; invalidate all tools
    NDIPassiveTool* GetInternalTool(std::string portHandle); ///&lt; returns the tool object that has been assigned the port handle or nullptr if no tool can be found

    /**
    * \brief free all port handles that need to be freed
    *
    * This method retrieves a list of all port handles that need to be freed (e.g. tool got disconnected)
    * and frees the handles at the tracking device and it removes the tools from the internal tool list
    * \warning This method can remove TrackingTools from the tool list! After calling this method, GetTool(i) could return
    *          a different tool, because tool indices could have changed.
    * @throw mitk::IGTHardwareException Throws an exception if there are errors while communicating with the device.
    * \return returns NDIOKAY if everything was sucessfull, returns an error code otherwise
    */
    NDIErrorCode FreePortHandles();

    NDIErrorCode Send(const std::string* message, bool addCRC = true);      ///&lt; Send message to tracking device
    NDIErrorCode Receive(std::string* answer, unsigned int numberOfBytes);  ///&lt; receive numberOfBytes bytes from tracking device
    NDIErrorCode ReceiveByte(char* answer);   ///&lt; lightweight receive function, that reads just one byte
    NDIErrorCode ReceiveLine(std::string* answer); ///&lt; receive characters until the first LF (The LF is included in the answer string)
    void ClearSendBuffer();                   ///&lt; empty send buffer of serial communication interface
    void ClearReceiveBuffer();                ///&lt; empty receive buffer of serial communication interface
    const std::string CalcCRC(const std::string* input);  ///&lt; returns the CRC16 for input as a std::string

public:

    /**
    * \brief TrackTools() continuously polls serial interface for new 6d tool positions until StopTracking is called.
    *
    * Continuously tracks the 6D position of all tools until StopTracking() is called.
    * This function is executed by the tracking thread (through StartTracking() and ThreadStartTracking()).
    * It should not be called directly.
    * @throw mitk::IGTHardwareException Throws an exception if there are errors while tracking the tools.
    */
    virtual void TrackTools();

    /**
    * \brief continuously polls serial interface for new 3D marker positions until StopTracking is called.
    *
    * Continuously tracks the 3D position of all markers until StopTracking() is called.
    * This function is executed by the tracking thread (through StartTracking() and ThreadStartTracking()).
    * It should not be called directly.
    */
    virtual void TrackMarkerPositions();

    /**
    * \brief continuously polls serial interface for new 3D marker positions and 6D tool positions until StopTracking is called.
    *
    * Continuously tracks the 3D position of all markers and the 6D position of all tools until StopTracking() is called.
    * This function is executed by the tracking thread (through StartTracking() and ThreadStartTracking()).
    * It should not be called directly.
    */
    virtual void TrackToolsAndMarkers();

    /**
    * \brief start method for the tracking thread.
    */
    void ThreadStartTracking();

  protected:
    NDITrackingDevice();          ///&lt; Constructor
    ~NDITrackingDevice() override; ///&lt; Destructor

    std::string m_DeviceName;///&lt; Device Name
    PortNumber m_PortNumber; ///&lt; COM Port Number
    BaudRate m_BaudRate;     ///&lt; COM Port Baud Rate
    DataBits m_DataBits;     ///&lt; Number of Data Bits per token
    Parity m_Parity;         ///&lt; Parity mode for communication
    StopBits m_StopBits;     ///&lt; number of stop bits per token
    HardwareHandshake m_HardwareHandshake; ///&lt; use hardware handshake for serial port connection
    ///&lt; which tracking volume is currently used (if device supports multiple volumes) (\warning This parameter is not used yet)
    IlluminationActivationRate m_IlluminationActivationRate; ///&lt; update rate of IR illuminator for Polaris
    DataTransferMode m_DataTransferMode;  ///&lt; use TX (text) or BX (binary) (\warning currently, only TX mode is supported)
    Tool6DContainerType m_6DTools;        ///&lt; list of 6D tools

    mutable std::mutex m_ToolsMutex; ///&lt; mutex for coordinated access of tool container
    mitk::SerialCommunication::Pointer m_SerialCommunication;    ///&lt; serial communication interface
    std::mutex m_SerialCommunicationMutex; ///&lt; mutex for coordinated access of serial communication interface
    NDIProtocol::Pointer m_DeviceProtocol;    ///&lt; create and parse NDI protocol strings

    std::thread m_Thread;                 ///&lt; ID of tracking thread
    OperationMode m_OperationMode;  ///&lt; tracking mode (6D tool tracking, 3D marker tracking,...)
    std::mutex m_MarkerPointsMutex;  ///&lt; mutex for marker point data container
    MarkerPointContainerType m_MarkerPoints;          ///&lt; container for markers (3D point tracking mode)
  };
} // namespace mitk
#endif /* MITKNDITRACKINGDEVICE_H_HEADER_INCLUDED_C1C2FCD2 */</pre>
	</body>
</html>