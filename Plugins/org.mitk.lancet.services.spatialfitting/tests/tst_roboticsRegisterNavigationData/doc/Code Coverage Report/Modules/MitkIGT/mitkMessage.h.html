<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkMessage.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef mitkMessageHIncluded
#define mitkMessageHIncluded

#include &lt;functional&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

/**
 * Adds a Message&lt;&gt; variable and methods to add/remove message delegates to/from
 * this variable.
*/
#define mitkNewMessageMacro(msgHandleObject)                                                                           \
private:                                                                                                               \
  ::mitk::Message&lt;&gt; m_##msgHandleObject##Message;                                                                      \
                                                                                                                       \
public:                                                                                                                \
  inline void Add##msgHandleObject##Listener(const ::mitk::MessageAbstractDelegate&lt;&gt; &amp;delegate)                        \
  {                                                                                                                    \
    m_##msgHandleObject##Message += delegate;                                                                          \
  }                                                                                                                    \
  inline void Remove##msgHandleObject##Listener(const ::mitk::MessageAbstractDelegate&lt;&gt; &amp;delegate)                     \
  {                                                                                                                    \
    m_##msgHandleObject##Message -= delegate;                                                                          \
  }

#define mitkNewMessageWithReturnMacro(msgHandleObject, returnType)                                                     \
private:                                                                                                               \
  ::mitk::Message&lt;returnType&gt; m_##msgHandleObject##Message;                                                            \
                                                                                                                       \
public:                                                                                                                \
  inline void Add##msgHandleObject##Listener(const ::mitk::MessageAbstractDelegate&lt;returnType&gt; &amp;delegate)              \
  {                                                                                                                    \
    m_##msgHandleObject##Message += delegate;                                                                          \
  }                                                                                                                    \
  inline void Remove##msgHandleObject##Listener(const ::mitk::MessageAbstractDelegate&lt;returnType&gt; &amp;delegate)           \
  {                                                                                                                    \
    m_##msgHandleObject##Message -= delegate;                                                                          \
  }

#define mitkNewMessage1Macro(msgHandleObject, type1)                                                                   \
private:                                                                                                               \
  ::mitk::Message1&lt;type1&gt; m_##msgHandleObject##Message;                                                                \
                                                                                                                       \
public:                                                                                                                \
  void Add##msgHandleObject##Listener(const ::mitk::MessageAbstractDelegate1&lt;type1&gt; &amp;delegate)                         \
  {                                                                                                                    \
    m_##msgHandleObject##Message += delegate;                                                                          \
  }                                                                                                                    \
  void Remove##msgHandleObject##Listener(const ::mitk::MessageAbstractDelegate1&lt;type1&gt; &amp;delegate)                      \
  {                                                                                                                    \
    m_##msgHandleObject##Message -= delegate;                                                                          \
  }

#define mitkNewMessage2Macro(msgHandleObject, type1, type2)                                                            \
private:                                                                                                               \
  ::mitk::Message2&lt;type1, type2&gt; m_##msgHandleObject##Message;                                                         \
                                                                                                                       \
public:                                                                                                                \
  void Add##msgHandleObject##Listener(const ::mitk::MessageAbstractDelegate2&lt;type1, type2&gt; &amp;delegate)                  \
  {                                                                                                                    \
    m_##msgHandleObject##Message += delegate;                                                                          \
  }                                                                                                                    \
  void Remove##msgHandleObject##Listener(const ::mitk::MessageAbstractDelegate2&lt;type1, type2&gt; &amp;delegate)               \
  {                                                                                                                    \
    m_##msgHandleObject##Message -= delegate;                                                                          \
  }

namespace mitk
{
  template &lt;typename A = void&gt;
  class MessageAbstractDelegate
  {
  public:
    virtual ~MessageAbstractDelegate() {}
    virtual A Execute() const = 0;
    virtual bool operator==(const MessageAbstractDelegate *cmd) const = 0;
    virtual MessageAbstractDelegate *Clone() const = 0;
  };

  template &lt;typename T, typename A = void&gt;
  class MessageAbstractDelegate1
  {
  public:
<span style = "background-color:#fdd">    virtual ~MessageAbstractDelegate1() {}</span>
    virtual A Execute(T t) const = 0;
    virtual bool operator==(const MessageAbstractDelegate1 *cmd) const = 0;
    virtual MessageAbstractDelegate1 *Clone() const = 0;
  };

  template &lt;typename T, typename U, typename A = void&gt;
  class MessageAbstractDelegate2
  {
  public:
<span style = "background-color:#fdd">    virtual ~MessageAbstractDelegate2() {}</span>
    virtual A Execute(T t, U u) const = 0;
    virtual bool operator==(const MessageAbstractDelegate2 *cmd) const = 0;
    virtual MessageAbstractDelegate2 *Clone() const = 0;
  };

  template &lt;typename T, typename U, typename V, typename A = void&gt;
  class MessageAbstractDelegate3
  {
  public:
    virtual ~MessageAbstractDelegate3() {}
    virtual A Execute(T t, U u, V v) const = 0;
    virtual bool operator==(const MessageAbstractDelegate3 *cmd) const = 0;
    virtual MessageAbstractDelegate3 *Clone() const = 0;
  };

  template &lt;typename T, typename U, typename V, typename W, typename A = void&gt;
  class MessageAbstractDelegate4
  {
  public:
    virtual ~MessageAbstractDelegate4() {}
    virtual A Execute(T t, U u, V v, W w) const = 0;
    virtual bool operator==(const MessageAbstractDelegate4 *cmd) const = 0;
    virtual MessageAbstractDelegate4 *Clone() const = 0;
  };

  /**
   * This class essentially wraps a function pointer with signature
   * A(R::*function)(). A is the return type of your callback function
   * and R the type of the class implementing the function.
   *
   * Use this class to add a callback function to
   * messages without parameters.
   */
  template &lt;class R, typename A = void&gt;
  class MessageDelegate : public MessageAbstractDelegate&lt;A&gt;
  {
  public:
    // constructor - takes pointer to an object and pointer to a member and stores
    // them in two private variables
    MessageDelegate(R *object, A (R::*memberFunctionPointer)())
      : m_Object(object), m_MemberFunctionPointer(memberFunctionPointer)
    {
    }

    ~MessageDelegate() override {}
    // override function "Call"
    A Execute() const override
    {
      return (m_Object-&gt;*m_MemberFunctionPointer)(); // execute member function
    }

    bool operator==(const MessageAbstractDelegate&lt;A&gt; *c) const override
    {
      const MessageDelegate&lt;R, A&gt; *cmd = dynamic_cast&lt;const MessageDelegate&lt;R, A&gt; *&gt;(c);
      if (!cmd)
        return false;

      if ((void *)this-&gt;m_Object != (void *)cmd-&gt;m_Object)
        return false;
      if (this-&gt;m_MemberFunctionPointer != cmd-&gt;m_MemberFunctionPointer)
        return false;
      return true;
    }

    MessageAbstractDelegate&lt;A&gt; *Clone() const override { return new MessageDelegate(m_Object, m_MemberFunctionPointer); }
  private:
    R *m_Object;                       // pointer to object
    A (R::*m_MemberFunctionPointer)(); // pointer to member function
  };

  /**
   * This class essentially wraps a function pointer with signature
   * A(R::*function)(T). A is the return type of your callback function,
   * R the type of the class implementing the function and T the type
   * of the argument.
   *
   * Use this class to add a callback function to
   * messages with one parameter.
   *
   * If you need more parameters, use MessageDelegate2 etc.
   */
  template &lt;class R, typename T, typename A = void&gt;
  class MessageDelegate1 : public MessageAbstractDelegate1&lt;T, A&gt;
  {
  public:
    // constructor - takes pointer to an object and pointer to a member and stores
    // them in two private variables
    MessageDelegate1(R *object, A (R::*memberFunctionPointer)(T))
<span style = "background-color:#fdd">      : m_Object(object), m_MemberFunctionPointer(memberFunctionPointer)
    {
    }</span>

<span style = "background-color:#fdd">    ~MessageDelegate1() override {}</span>
    // override function "Call"
    A Execute(T t) const override
<span style = "background-color:#fdd">    {
      return (m_Object-&gt;*m_MemberFunctionPointer)(t); // execute member function
    }</span>

    bool operator==(const MessageAbstractDelegate1&lt;T, A&gt; *c) const override
<span style = "background-color:#fdd">    {
      const MessageDelegate1&lt;R, T, A&gt; *cmd = dynamic_cast&lt;const MessageDelegate1&lt;R, T, A&gt; *&gt;(c);
      if (!cmd)
        return false;</span>

<span style = "background-color:#fdd">      if ((void *)this-&gt;m_Object != (void *)cmd-&gt;m_Object)
        return false;
      if (this-&gt;m_MemberFunctionPointer != cmd-&gt;m_MemberFunctionPointer)
        return false;
      return true;
    }</span>

<span style = "background-color:#fdd">    MessageAbstractDelegate1&lt;T, A&gt; *Clone() const override { return new MessageDelegate1(m_Object, m_MemberFunctionPointer); }</span>
  private:
    R *m_Object;                        // pointer to object
    A (R::*m_MemberFunctionPointer)(T); // pointer to member function
  };

  template &lt;class R, typename T, typename U, typename A = void&gt;
  class MessageDelegate2 : public MessageAbstractDelegate2&lt;T, U, A&gt;
  {
  public:
    // constructor - takes pointer to an object and pointer to a member and stores
    // them in two private variables
    MessageDelegate2(R *object, A (R::*memberFunctionPointer)(T, U))
<span style = "background-color:#fdd">      : m_Object(object), m_MemberFunctionPointer(memberFunctionPointer)
    {
    }</span>

<span style = "background-color:#fdd">    ~MessageDelegate2() override {}</span>
    // override function "Call"
    A Execute(T t, U u) const override
<span style = "background-color:#fdd">    {
      return (m_Object-&gt;*m_MemberFunctionPointer)(t, u); // execute member function
    }</span>

    bool operator==(const MessageAbstractDelegate2&lt;T, U, A&gt; *c) const override
<span style = "background-color:#fdd">    {
      const MessageDelegate2&lt;R, T, U, A&gt; *cmd = dynamic_cast&lt;const MessageDelegate2&lt;R, T, U, A&gt; *&gt;(c);
      if (!cmd)
        return false;</span>

<span style = "background-color:#fdd">      if ((void *)this-&gt;m_Object != (void *)cmd-&gt;m_Object)
        return false;
      if (this-&gt;m_MemberFunctionPointer != cmd-&gt;m_MemberFunctionPointer)
        return false;
      return true;
    }</span>

<span style = "background-color:#fdd">    MessageAbstractDelegate2&lt;T, U, A&gt; *Clone() const override { return new MessageDelegate2(m_Object, m_MemberFunctionPointer); }</span>
  private:
    R *m_Object;                           // pointer to object
    A (R::*m_MemberFunctionPointer)(T, U); // pointer to member function
  };

  template &lt;class R, typename T, typename U, typename V, typename A = void&gt;
  class MessageDelegate3 : public MessageAbstractDelegate3&lt;T, U, V, A&gt;
  {
  public:
    // constructor - takes pointer to an object and pointer to a member and stores
    // them in two private variables
    MessageDelegate3(R *object, A (R::*memberFunctionPointer)(T, U, V))
      : m_Object(object), m_MemberFunctionPointer(memberFunctionPointer)
    {
    }

    ~MessageDelegate3() override {}
    // override function "Call"
    A Execute(T t, U u, V v) const override
    {
      return (m_Object-&gt;*m_MemberFunctionPointer)(t, u, v); // execute member function
    }

    bool operator==(const MessageAbstractDelegate3&lt;T, U, V, A&gt; *c) const override
    {
      const MessageDelegate3&lt;R, T, U, V, A&gt; *cmd = dynamic_cast&lt;const MessageDelegate3&lt;R, T, U, V, A&gt; *&gt;(c);
      if (!cmd)
        return false;

      if ((void *)this-&gt;m_Object != (void *)cmd-&gt;m_Object)
        return false;
      if (this-&gt;m_MemberFunctionPointer != cmd-&gt;m_MemberFunctionPointer)
        return false;
      return true;
    }

    MessageAbstractDelegate3&lt;T, U, V, A&gt; *Clone() const override
    {
      return new MessageDelegate3(m_Object, m_MemberFunctionPointer);
    }

  private:
    R *m_Object;                              // pointer to object
    A (R::*m_MemberFunctionPointer)(T, U, V); // pointer to member function
  };

  template &lt;class R, typename T, typename U, typename V, typename W, typename A = void&gt;
  class MessageDelegate4 : public MessageAbstractDelegate4&lt;T, U, V, W, A&gt;
  {
  public:
    // constructor - takes pointer to an object and pointer to a member and stores
    // them in two private variables
    MessageDelegate4(R *object, A (R::*memberFunctionPointer)(T, U, V, W))
      : m_Object(object), m_MemberFunctionPointer(memberFunctionPointer)
    {
    }

    virtual ~MessageDelegate4() {}
    // override function "Call"
    virtual A Execute(T t, U u, V v, W w) const
    {
      return (m_Object-&gt;*m_MemberFunctionPointer)(t, u, v, w); // execute member function
    }

    bool operator==(const MessageAbstractDelegate4&lt;T, U, V, W, A&gt; *c) const
    {
      const MessageDelegate4&lt;R, T, U, V, W, A&gt; *cmd = dynamic_cast&lt;const MessageDelegate4&lt;R, T, U, V, W, A&gt; *&gt;(c);
      if (!cmd)
        return false;

      if ((void *)this-&gt;m_Object != (void *)cmd-&gt;m_Object)
        return false;
      if (this-&gt;m_MemberFunctionPointer != cmd-&gt;m_MemberFunctionPointer)
        return false;
      return true;
    }

    MessageAbstractDelegate4&lt;T, U, V, W, A&gt; *Clone() const
    {
      return new MessageDelegate4(m_Object, m_MemberFunctionPointer);
    }

  private:
    R *m_Object;                                 // pointer to object
    A (R::*m_MemberFunctionPointer)(T, U, V, W); // pointer to member function
  };

  template &lt;typename AbstractDelegate&gt;
  class MessageBase
  {
  public:
    typedef std::vector&lt;AbstractDelegate *&gt; ListenerList;

    virtual ~MessageBase()
<span style = "background-color:#dfd">    {
      for (auto iter = m_Listeners.begin(); iter != m_Listeners.end(); ++iter)</span>
      {
<span style = "background-color:#fdd">        delete *iter;
      }</span>
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    MessageBase() {}</span>
    MessageBase(const MessageBase &amp;o)
    {
      for (typename ListenerList::iterator iter = o.m_Listeners.begin(); iter != o.m_Listeners.end(); ++iter)
      {
        m_Listeners.push_back((*iter)-&gt;Clone());
      }
    }

    MessageBase &amp;operator=(const MessageBase &amp;o)
    {
      MessageBase tmp(o);
      std::swap(tmp.m_Listeners, this-&gt;m_Listeners);
      return *this;
    }

    void AddListener(const AbstractDelegate &amp;delegate) const
<span style = "background-color:#fdd">    {
      AbstractDelegate *msgCmd = delegate.Clone();</span>

<span style = "background-color:#fdd">      m_Mutex.lock();
      for (auto iter = m_Listeners.begin(); iter != m_Listeners.end(); ++iter)</span>
      {
<span style = "background-color:#fdd">        if ((*iter)-&gt;operator==(msgCmd))</span>
        {
<span style = "background-color:#fdd">          delete msgCmd;
          m_Mutex.unlock();
          return;
        }
      }
      m_Listeners.push_back(msgCmd);
      m_Mutex.unlock();
    }</span>

<span style = "background-color:#fdd">    void operator+=(const AbstractDelegate &amp;delegate) const { this-&gt;AddListener(delegate); }</span>
    void RemoveListener(const AbstractDelegate &amp;delegate) const
<span style = "background-color:#fdd">    {
      m_Mutex.lock();
      for (auto iter = m_Listeners.begin(); iter != m_Listeners.end(); ++iter)</span>
      {
<span style = "background-color:#fdd">        if ((*iter)-&gt;operator==(&amp;delegate))</span>
        {
<span style = "background-color:#fdd">          delete *iter;
          m_Listeners.erase(iter);
          m_Mutex.unlock();
          return;
        }
      }
      m_Mutex.unlock();
    }</span>

<span style = "background-color:#fdd">    void operator-=(const AbstractDelegate &amp;delegate) const { this-&gt;RemoveListener(delegate); }</span>
    const ListenerList &amp;GetListeners() const { return m_Listeners; }
    bool HasListeners() const { return !m_Listeners.empty(); }
    bool IsEmpty() const { return m_Listeners.empty(); }
  protected:
    /**
     * \brief List of listeners.
     *
     * This is declared mutable for a reason: Imagine an object that sends out notifications and
     * someone gets a &lt;tt&gt;const Database&lt;/tt&gt; object, because he/she should not write to the
     * database. He/she should anyway be able to register for notifications about changes in the database
     * -- this is why AddListener and RemoveListener are declared &lt;tt&gt;const&lt;/tt&gt;. m_Listeners must be
     *  mutable so that AddListener and RemoveListener can modify it regardless of the object's constness.
     */
    mutable ListenerList m_Listeners;
    mutable std::mutex m_Mutex;
  };

  /**
   * \brief Event/message/notification class.
   *
   * \sa mitk::BinaryThresholdTool
   * \sa QmitkBinaryThresholdToolGUI
   *
   * This totally ITK, Qt, VTK, whatever toolkit independent class
   * allows one class to send out messages and another class to
   * receive these message. This class is templated over the
   * return type (A) of the callback functions.
   * There are variations of this class
   * (Message1, Message2, etc.) for sending
   * one, two or more parameters along with the messages.
   *
   * This is an implementation of the Observer pattern.
   *
   * \li There is no guarantee about the order of which observer is notified first. At the moment the observers which
   * register first will be notified first.
   * \li Notifications are &lt;b&gt;synchronous&lt;/b&gt;, by direct method calls. There is no support for asynchronous messages.
   *
   * To conveniently add methods for registering/unregistering observers
   * to Message variables of your class, you can use the mitkNewMessageMacro
   * macros.
   */
  template &lt;typename A = void&gt;
  class Message : public MessageBase&lt;MessageAbstractDelegate&lt;A&gt;&gt;
  {
  public:
    typedef MessageBase&lt;MessageAbstractDelegate&lt;A&gt;&gt; Super;
    typedef typename Super::ListenerList ListenerList;

    void Send() const
<span style = "background-color:#fdd">    {
      ListenerList listeners;</span>

      {
<span style = "background-color:#fdd">        this-&gt;m_Mutex.lock();
        listeners.assign(this-&gt;m_Listeners.begin(), this-&gt;m_Listeners.end());
        this-&gt;m_Mutex.unlock();</span>
      }

<span style = "background-color:#fdd">      for (auto iter = listeners.begin(); iter != listeners.end(); ++iter)</span>
      {
        // notify each listener
<span style = "background-color:#fdd">        (*iter)-&gt;Execute();
      }
    }</span>

    void operator()() const { this-&gt;Send(); }
  };

  // message with 1 parameter and return type
  template &lt;typename T, typename A = void&gt;
  class Message1 : public MessageBase&lt;MessageAbstractDelegate1&lt;T, A&gt;&gt;
  {
  public:
    typedef MessageBase&lt;MessageAbstractDelegate1&lt;T, A&gt;&gt; Super;
    typedef typename Super::ListenerList ListenerList;

    void Send(T t) const
<span style = "background-color:#fdd">    {
      ListenerList listeners;</span>

      {
<span style = "background-color:#fdd">        this-&gt;m_Mutex.lock();
        listeners.assign(this-&gt;m_Listeners.begin(), this-&gt;m_Listeners.end());
        this-&gt;m_Mutex.unlock();</span>
      }

<span style = "background-color:#fdd">      for (auto iter = listeners.begin(); iter != listeners.end(); ++iter)</span>
      {
        // notify each listener
<span style = "background-color:#fdd">        (*iter)-&gt;Execute(t);
      }
    }</span>

    void operator() (T t) const { this-&gt;Send(t); }
  };

  // message with 2 parameters and return type
  template &lt;typename T, typename U, typename A = void&gt;
  class Message2 : public MessageBase&lt;MessageAbstractDelegate2&lt;T, U, A&gt;&gt;
  {
  public:
    typedef MessageBase&lt;MessageAbstractDelegate2&lt;T, U, A&gt;&gt; Super;
    typedef typename Super::ListenerList ListenerList;

    void Send(T t, U u) const
<span style = "background-color:#fdd">    {
      ListenerList listeners;</span>

      {
<span style = "background-color:#fdd">        this-&gt;m_Mutex.lock();
        listeners.assign(this-&gt;m_Listeners.begin(), this-&gt;m_Listeners.end());
        this-&gt;m_Mutex.unlock();</span>
      }

<span style = "background-color:#fdd">      for (auto iter = listeners.begin(); iter != listeners.end(); ++iter)</span>
      {
        // notify each listener
<span style = "background-color:#fdd">        (*iter)-&gt;Execute(t, u);
      }
    }</span>

    void operator()(T t, U u) const { this-&gt;Send(t, u); }
  };

  // message with 3 parameters and return type
  template &lt;typename T, typename U, typename V, typename A = void&gt;
  class Message3 : public MessageBase&lt;MessageAbstractDelegate3&lt;T, U, V, A&gt;&gt;
  {
  public:
    typedef MessageBase&lt;MessageAbstractDelegate3&lt;T, U, V, A&gt;&gt; Super;
    typedef typename Super::ListenerList ListenerList;

    void Send(T t, U u, V v) const
    {
      ListenerList listeners;

      {
        this-&gt;m_Mutex.lock();
        listeners.assign(this-&gt;m_Listeners.begin(), this-&gt;m_Listeners.end());
        this-&gt;m_Mutex.unlock();
      }

      for (typename ListenerList::iterator iter = listeners.begin(); iter != listeners.end(); ++iter)
      {
        // notify each listener
        (*iter)-&gt;Execute(t, u, v);
      }
    }

    void operator()(T t, U u, V v) const { this-&gt;Send(t, u, v); }
  };

  // message with 4 parameters and return type
  template &lt;typename T, typename U, typename V, typename W, typename A = void&gt;
  class Message4 : public MessageBase&lt;MessageAbstractDelegate4&lt;T, U, V, W&gt;&gt;
  {
  public:
    typedef MessageBase&lt;MessageAbstractDelegate4&lt;T, U, V, W, A&gt;&gt; Super;
    typedef typename Super::ListenerList ListenerList;

    void Send(T t, U u, V v, W w) const
    {
      ListenerList listeners;

      {
        this-&gt;m_Mutex.lock();
        listeners.assign(this-&gt;m_Listeners.begin(), this-&gt;m_Listeners.end());
        this-&gt;m_Mutex.unlock();
      }

      for (typename ListenerList::iterator iter = listeners.begin(); iter != listeners.end(); ++iter)
      {
        // notify each listener
        (*iter)-&gt;Execute(t, u, v, w);
      }
    }

    void operator()(T t, U u, V v, W w) const { this-&gt;Send(t, u, v, w); }
  };

/* Here is an example how to use the macros and templates:
*
* // An object to be send around
* class Law
* {
*   private:
*     std::string m_Description;
*
*   public:
*
*     Law(const std::string law) : m_Description(law)
*     { }
*
*     std::string GetDescription() const
*     {
*       return m_Description;
*     }
* };
*
* // The NewtonMachine will issue specific events
* class NewtonMachine
* {
*   mitkNewMessageMacro(AnalysisStarted);
*   mitkNewMessage1Macro(AnalysisStopped, bool);
*   mitkNewMessage1Macro(LawDiscovered, const Law&amp;);
*
*   public:
*
*     void StartAnalysis()
*     {
*       // send the "started" signal
*       m_AnalysisStartedMessage();
*
*       // we found a new law of nature by creating one :-)
*       Law massLaw("F=ma");
*       m_LawDiscoveredMessage(massLaw);
*     }
*
*     void StopAnalysis()
*     {
*       // send the "stop" message with false, indicating
*       // that no error occured
*       m_AnalysisStoppedMessage(false);
*     }
* };
*
* class Observer
* {
*   private:
*
*     NewtonMachine* m_Machine;
*
*   public:
*
*     Observer(NewtonMachine* machine) : m_Machine(machine)
*     {
*       // Add "observers", i.e. function pointers to the machine
*       m_Machine-&gt;AddAnalysisStartedListener(
*         ::mitk::MessageDelegate&lt;Observer&gt;(this, &amp;Observer::MachineStarted));
*       m_Machine-&gt;AddAnalysisStoppedListener(
*         ::mitk::MessageDelegate1&lt;Observer, bool&gt;(this, &amp;Observer::MachineStopped));
*       m_Machine-&gt;AddLawDiscoveredListener(
*         ::mitk::MessageDelegate1&lt;Observer, const Law&amp;&gt;(this, &amp;Observer::LawDiscovered));
*      }
*
*     ~Observer()
*     {
*       // Always remove your observers when finished
*       m_Machine-&gt;RemoveAnalysisStartedListener(
*         ::mitk::MessagDelegate&lt;Observer&gt;(this, &amp;Observer::MachineStarted));
*       m_Machine-&gt;RemoveAnalysisStoppedListener(
*         ::mitk::MessageDelegate1&lt;Observer, bool&gt;(this, &amp;Observer::MachineStopped));
*       m_Machine-&gt;RemoveLawDiscoveredListener(
*         ::mitk::MessageDelegate1&lt;Observer, const Law&amp;&gt;(this, &amp;Observer::LawDiscovered));
*      }
*
*      void MachineStarted()
*      {
*        std::cout &lt;&lt; "Observed machine has started" &lt;&lt; std::endl;
*      }
*
*      void MachineStopped(bool error)
*      {
*        std::cout &lt;&lt; "Observed machine stopped " &lt;&lt; (error ? "with an error" : "") &lt;&lt; std::endl;
*      }
*
*      void LawDiscovered(const Law&amp; law)
*      {
*        std::cout &lt;&lt; "New law of nature discovered: " &lt;&lt; law.GetDescription() &lt;&lt; std::endl;
*      }
*  };
*
*  NewtonMachine newtonMachine;
*  Observer observer(&amp;newtonMachine);
*
*  // This will send two events to registered observers
*  newtonMachine.StartAnalysis();
*  // This will send one event to registered observers
*  newtonMachine.StopAnalysis();
*
* Another example of how to use these message classes can be
* found in the directory Testing, file mitkMessageTest.cpp
*
*/

} // namespace

#endif</pre>
	</body>
</html>