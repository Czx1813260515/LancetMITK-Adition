<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkItkNonUniformBSpline.txx</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

/*===================================================================

This file is based heavily on a corresponding ITK filter.

===================================================================*/

/*********************************
  This file was taken from ITK, CVS version 1.13 to circumvent a bug in ITK release 3.18 (see http://public.kitware.com/Bug/view.php?id=10633
 *********************************/

#ifndef __itkNonUniformBSpline_txx
#define __itkNonUniformBSpline_txx

#if defined(_MSC_VER)
#pragma warning ( disable : 4786 )
#endif

#include "mitkItkNonUniformBSpline.h"

#include "vnl/vnl_vector.h"
#include "vnl/vnl_matrix.h"
#include "vnl/algo/vnl_lsqr.h"
#include "vnl/vnl_linear_system.h"


// #define DEBUG_SPLINE

namespace itk
{

/** Constructor */
template&lt; unsigned int TDimension &gt;
NonUniformBSpline&lt; TDimension &gt;
::NonUniformBSpline()
<span style = "background-color:#fdd">{</span>
  // Cubic bspline =&gt; 4th order
<span style = "background-color:#fdd">  m_SplineOrder = 3;
  m_SpatialDimension = TDimension;
}</span>

/** Destructor */
template&lt; unsigned int TDimension &gt;
NonUniformBSpline&lt; TDimension &gt;
::~NonUniformBSpline()
<span style = "background-color:#fdd">{
}</span>

/** Print the object */
template&lt; unsigned int TDimension &gt;
void
NonUniformBSpline&lt; TDimension &gt;
::PrintSelf( std::ostream&amp; os, Indent indent ) const
<span style = "background-color:#fdd">{
  Superclass::PrintSelf( os, indent );
  os &lt;&lt; indent &lt;&lt; "NonUniformBSpline(" &lt;&lt; this &lt;&lt; ")" &lt;&lt; std::endl;</span>

<span style = "background-color:#fdd">  os &lt;&lt; indent &lt;&lt; "Chord lengths : " &lt;&lt; std::endl;
  for (ChordLengthListType::const_iterator iter = m_CumulativeChordLength.begin();
       iter != m_CumulativeChordLength.end();
       iter++)</span>
    {
<span style = "background-color:#fdd">    os &lt;&lt; indent &lt;&lt; indent &lt;&lt; *iter &lt;&lt; std::endl;
    }
  os &lt;&lt; indent &lt;&lt; "Knots : " &lt;&lt; std::endl;
  for (KnotListType::const_iterator kiter = m_Knots.begin();
       kiter != m_Knots.end();
       kiter++)</span>
    {
<span style = "background-color:#fdd">    os &lt;&lt; indent &lt;&lt; indent &lt;&lt; *kiter &lt;&lt; std::endl;
    }
  os &lt;&lt; indent &lt;&lt; "Control Points : " &lt;&lt; std::endl;
  for (typename ControlPointListType::const_iterator cpiter = m_ControlPoints.begin();
       cpiter != m_ControlPoints.end();
       cpiter++)</span>
    {
<span style = "background-color:#fdd">    os &lt;&lt; indent &lt;&lt; indent &lt;&lt; *cpiter &lt;&lt; std::endl;
    }
}</span>


/** Set the list of points composing the tube */
template&lt; unsigned int TDimension &gt;
void
NonUniformBSpline&lt; TDimension &gt;
::SetPoints( PointListType &amp; points )
{
  m_Points.clear();

  typename PointListType::iterator it,end;
  it = points.begin();
  end = points.end();
  while(it != end)
    {
    m_Points.push_back(*it);
    it++;
    }

  this-&gt;Modified();
}

/** Set the list of points composing the tube */
template&lt; unsigned int TDimension &gt;
void
NonUniformBSpline&lt; TDimension &gt;
::SetKnots( KnotListType &amp; knots )
<span style = "background-color:#fdd">{
  m_Knots.clear();</span>

<span style = "background-color:#fdd">  int len = knots.size();
  double max_knot = knots[len - 1];</span>

<span style = "background-color:#fdd">  typename KnotListType::iterator it;
  typename KnotListType::iterator end;</span>

<span style = "background-color:#fdd">  it = knots.begin();
  end = knots.end();</span>

<span style = "background-color:#fdd">  while(it != end)</span>
    {
<span style = "background-color:#fdd">    m_Knots.push_back(*it/max_knot);
    it++;
    }</span>

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span>

template&lt; unsigned int TDimension &gt;
double
NonUniformBSpline&lt; TDimension &gt;
::NonUniformBSplineFunctionRecursive(unsigned int order, unsigned int i, double t) const
<span style = "background-color:#fdd">{
  if (order == 1)</span>
    {
<span style = "background-color:#fdd">    if (m_Knots[i] &lt;= t &amp;&amp; t &lt; m_Knots[i+1])</span>
      {
<span style = "background-color:#fdd">      return 1;
      }</span>
    else
      {
<span style = "background-color:#fdd">      return 0;</span>
      }
    }

  //
  // Be careful, we must use the passed in parameter for the order since this
  // function is recursive.
  //
<span style = "background-color:#fdd">  double numer1 = (t - m_Knots[i]) * NonUniformBSplineFunctionRecursive(order-1, i, t);
  double denom1 = (m_Knots[i+order-1] - m_Knots[i]);
  double val1 = numer1 / denom1;
  if (denom1 == 0 &amp;&amp; numer1 == 0)
    val1 = 0;
  else if (denom1 == 0)
    std::cout &lt;&lt; "Error : " &lt;&lt; denom1 &lt;&lt; ", " &lt;&lt; numer1 &lt;&lt; std::endl;</span>

<span style = "background-color:#fdd">  double numer2 = (m_Knots[i+order] - t) * NonUniformBSplineFunctionRecursive(order-1, i+1, t);
  double denom2 = (m_Knots[i + order] - m_Knots[i+1]);
  double val2 = numer2 / denom2;
  if (denom2 == 0 &amp;&amp; numer2 == 0)
    val2 = 0;
  else if (denom2 == 0)
    std::cout &lt;&lt; "Error : " &lt;&lt; denom2 &lt;&lt; ", " &lt;&lt; numer2 &lt;&lt; std::endl;</span>

<span style = "background-color:#fdd">  return val1 + val2;
}</span>

template&lt; unsigned int TDimension &gt;
void
NonUniformBSpline&lt; TDimension &gt;
::ComputeChordLengths()
{
  m_ChordLength.clear();
  m_CumulativeChordLength.clear();

  m_ChordLength.push_back(0);
  m_CumulativeChordLength.push_back(0);

  double total_chord_length = 0.0;
  ChordLengthListType temp;

  for (::size_t i = 0; i &lt; m_Points.size()-1; i++)
    {
    PointType pt = m_Points[i];
    PointType pt2 = m_Points[i+1];

    double chord = pt.EuclideanDistanceTo(pt2);
    m_ChordLength.push_back(chord);
    total_chord_length = total_chord_length + chord;
    temp.push_back(total_chord_length);
    }

  for (ChordLengthListType::iterator aiter = temp.begin();
       aiter != temp.end();
       aiter++)
    {
    m_CumulativeChordLength.push_back(*aiter/total_chord_length);
    }

  //
  // Debug printouts
  //
#ifdef DEBUG_SPLINE
  std::cout &lt;&lt; "Total chord length : " &lt;&lt; total_chord_length &lt;&lt; std::endl;

  std::cout &lt;&lt; "Chord length : " &lt;&lt; std::endl;
  for (ChordLengthListType::iterator aiter2 = m_ChordLength.begin();
       aiter2 != m_ChordLength.end();
       aiter2++)
    {
    std::cout &lt;&lt; *aiter2 &lt;&lt; std::endl;
    }

  std::cout &lt;&lt; "Cumulative chord length : " &lt;&lt; std::endl;
  for (ChordLengthListType::iterator aiter3 = m_CumulativeChordLength.begin();
       aiter3 != m_CumulativeChordLength.end();
       aiter3++)
    {
    std::cout &lt;&lt; *aiter3 &lt;&lt; std::endl;
    }
  std::cout &lt;&lt; std::endl;
#endif
}

template&lt; unsigned int TDimension &gt;
void
NonUniformBSpline&lt; TDimension &gt;
::SetControlPoints( ControlPointListType&amp; ctrlpts )
<span style = "background-color:#fdd">{
  m_ControlPoints.clear();
  for (typename ControlPointListType::iterator iter = ctrlpts.begin();
       iter != ctrlpts.end();
       iter++)</span>
    {
<span style = "background-color:#fdd">    m_ControlPoints.push_back(*iter);
    }
  this-&gt;Modified();
}</span>


template&lt; unsigned int TDimension &gt;
const typename
NonUniformBSpline&lt; TDimension &gt;::ControlPointListType &amp;
NonUniformBSpline&lt; TDimension &gt;::GetControlPoints() const
{
  return this-&gt;m_ControlPoints;
}


template&lt; unsigned int TDimension &gt;
const typename
NonUniformBSpline&lt; TDimension &gt;::KnotListType &amp;
NonUniformBSpline&lt; TDimension &gt;::GetKnots() const
{
  return this-&gt;m_Knots;
}


template&lt; unsigned int TDimension &gt;
const typename
NonUniformBSpline&lt; TDimension &gt;::PointListType &amp;
NonUniformBSpline&lt; TDimension &gt;::GetPoints() const
{
  return this-&gt;m_Points;
}


template&lt; unsigned int TDimension &gt;
void
NonUniformBSpline&lt; TDimension &gt;::ComputeControlPoints()
{
  unsigned int dim = m_Points[0].GetPointDimension();

#ifdef DEBUG_SPLINE
  std::cout &lt;&lt; "Points have dimension : " &lt;&lt; dim  &lt;&lt; std::endl;
#endif

  //
  // +1 in cols for radius
  //
  vnl_matrix&lt;double&gt; data_matrix(m_Points.size(), dim);

  //
  // Form data point matrix
  //
  int rr = 0;
  for (typename PointListType::iterator iter = m_Points.begin();
       iter != m_Points.end();
       iter++)
    {
    PointType pt = (*iter);
    for (unsigned int i = 0; i &lt; dim; i++)
      {
      data_matrix(rr, i) = pt.GetVnlVector()[i];
      }
    rr++;
    }

#ifdef DEBUG_SPLINE
  std::cout &lt;&lt; std::endl &lt;&lt; "Data matrix" &lt;&lt; std::endl;
  std::cout &lt;&lt; data_matrix &lt;&lt; std::endl;
#endif

  //
  // Form basis function matrix
  //
  //int num_basis_functions = 2 * m_SplineOrder - 1;
  //int num_basis_functions = m_Points.size();
  int num_rows = m_Points.size();

  //
  // Assumes multiplicity k (m_SplineOrder at the ends).
  //
  int num_cols = m_Knots.size() - m_SplineOrder;

  vnl_matrix&lt;double&gt; N_matrix(num_rows, num_cols);

  //N_matrix(0, 0) = 1.0;

  for (int r = 0; r &lt; num_rows; r++)
    {
    for (int c = 0; c &lt; num_cols; c++)
      {
      double t = m_CumulativeChordLength[r];
      N_matrix(r, c) = NonUniformBSplineFunctionRecursive(m_SplineOrder, c, t);
      }
    }

  N_matrix(num_rows-1, num_cols-1) = 1.0;

#ifdef DEBUG_SPLINE
  std::cout &lt;&lt; "Basis function matrix : " &lt;&lt; std::endl;
  std::cout &lt;&lt; N_matrix &lt;&lt; std::endl;
#endif

//FIXME: Use the LSQR linear solver here:
  vnl_matrix&lt;double&gt; B;

// = vnl_matrix_inverse&lt;double&gt;(N_matrix.transpose() * N_matrix) * N_matrix.transpose() * data_matrix;

//  vnl_linear_system ls( N_matrix.rows(), N_matrix.cols() );

//  vnl_lsqr solver( ls );


//#ifdef DEBUG_SPLINE
  std::cout &lt;&lt; "Control point matrix : " &lt;&lt; std::endl;
  std::cout &lt;&lt; B &lt;&lt; std::endl;
//#endif

  m_ControlPoints.clear();

  for ( unsigned int j = 0; j &lt; B.rows(); j++ )
    {
    vnl_vector&lt;double&gt; v = B.get_row(j);
    itk::Vector&lt;double&gt; iv;
    iv.SetVnlVector(v);
    itk::Point&lt;double, TDimension&gt; pt;
    for ( unsigned int d = 0; d &lt; dim; d++ )
      {
      pt[d] = v(d);
      }
    m_ControlPoints.push_back(pt);
    }
  return;
}

template&lt; unsigned int TDimension &gt;
typename NonUniformBSpline&lt;TDimension&gt;::PointType
NonUniformBSpline&lt; TDimension &gt;
::EvaluateSpline(const itk::Array&lt;double&gt; &amp; p) const
{
  double t = p[0];

  return EvaluateSpline(t);
}

template&lt; unsigned int TDimension &gt;
typename NonUniformBSpline&lt;TDimension&gt;::PointType
NonUniformBSpline&lt; TDimension &gt;
::EvaluateSpline(double t) const
<span style = "background-color:#fdd">{
  int i = 0;</span>

<span style = "background-color:#fdd">  vnl_vector&lt;double&gt; result(TDimension);
  result.fill(0);</span>

<span style = "background-color:#fdd">  for (typename ControlPointListType::const_iterator cpiter = m_ControlPoints.begin();
       cpiter != m_ControlPoints.end();
       cpiter++)</span>
    {
<span style = "background-color:#fdd">    ControlPointType pt = *cpiter;
    vnl_vector&lt;double&gt; v = pt.GetVnlVector();</span>

<span style = "background-color:#fdd">    const double N =  this-&gt;NonUniformBSplineFunctionRecursive(m_SplineOrder, i, t);</span>

<span style = "background-color:#fdd">    for( unsigned j = 0; j &lt; TDimension; j++ )</span>
      {
<span style = "background-color:#fdd">      result[j] += N * v[j];
      }</span>

<span style = "background-color:#fdd">    i++;
    }</span>

  double array[TDimension];
<span style = "background-color:#fdd">  for ( unsigned int d = 0; d &lt; TDimension; d++ )</span>
    {
<span style = "background-color:#fdd">    array[d] = result[d];
    }</span>

<span style = "background-color:#fdd">  ControlPointType sum(array);</span>
#ifdef DEBUG_SPLINE
  std::cout &lt;&lt; "Result : " &lt;&lt; result &lt;&lt; std::endl;
  std::cout &lt;&lt; "Sum : " &lt;&lt; sum &lt;&lt; std::endl;
#endif

<span style = "background-color:#fdd">  return sum;
}</span>

} // end namespace itk

#endif</pre>
	</body>
</html>