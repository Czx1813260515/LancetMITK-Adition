<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNavigationTool.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkNavigationTool.h"
#include "mitkIGTException.h"
#include "mitkNavigationData.h"
#include "Poco/File.h"
#include "mitkUnspecifiedTrackingTypeInformation.h"

#include &lt;vtkSphereSource.h&gt;
#include "vtkConeSource.h"
#include "vtkLineSource.h"
#include "vtkCylinderSource.h"
#include "vtkTransformPolyDataFilter.h"
#include &lt;vtkAppendPolyData.h&gt;
#include "mitkTextAnnotation3D.h"
#include "mitkManualPlacementAnnotationRenderer.h"
#include "mitkBaseRenderer.h"

mitk::NavigationTool::NavigationTool()
<span style = "background-color:#fdd">  : m_Identifier("None"),
    m_Type(mitk::NavigationTool::Unknown),
    m_CalibrationFile("none"),
    m_SerialNumber(""),
    m_TrackingDeviceType(mitk::UnspecifiedTrackingTypeInformation::GetTrackingDeviceName()),
    m_ToolLandmarks(mitk::PointSet::New()),
    m_ToolControlPoints(mitk::PointSet::New()),
    m_ToolAxisOrientation(mitk::Quaternion(0, 0, 0, 1)),
    m_ToolRegistrationMatrix(mitk::AffineTransform3D::New())
{
  m_ToolTipPosition[0] = 0;
  m_ToolTipPosition[1] = 0;
  m_ToolTipPosition[2] = 0;</span>
  //MITK_INFO &lt;&lt; "Init Navigation Tool";
  //MITK_INFO &lt;&lt; m_ToolRegistrationMatrix;
<span style = "background-color:#fdd">  SetDefaultSurface();
}</span>

itk::LightObject::Pointer mitk::NavigationTool::InternalClone() const
<span style = "background-color:#fdd">{
  Self::Pointer tool = new Self(*this);
  tool-&gt;UnRegister();
  return tool.GetPointer();
}</span>

mitk::NavigationTool::NavigationTool(const NavigationTool &amp;other)
<span style = "background-color:#fdd">  : Superclass()
{
  this-&gt;m_Identifier = other.m_Identifier;
  this-&gt;m_Type = other.m_Type;
  if (other.m_DataNode.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_DataNode = mitk::DataNode::New();
    this-&gt;m_DataNode-&gt;SetName(other.m_DataNode-&gt;GetName());
    if (other.m_DataNode-&gt;GetData())</span>
    {
<span style = "background-color:#fdd">      this-&gt;m_DataNode-&gt;SetData(dynamic_cast&lt;mitk::BaseData*&gt;(other.m_DataNode-&gt;GetData()-&gt;Clone().GetPointer()));</span>
    }
  }

<span style = "background-color:#fdd">  if (other.m_SpatialObject.IsNotNull())
    this-&gt;m_SpatialObject = other.m_SpatialObject-&gt;Clone();
  this-&gt;m_CalibrationFile = other.m_CalibrationFile;
  this-&gt;m_SerialNumber = other.m_SerialNumber;
  this-&gt;m_TrackingDeviceType = other.m_TrackingDeviceType;
  if (other.m_ToolLandmarks.IsNotNull())
    this-&gt;m_ToolLandmarks = other.m_ToolLandmarks-&gt;Clone();
  if (other.m_ToolControlPoints.IsNotNull())
    this-&gt;m_ToolControlPoints = other.m_ToolControlPoints-&gt;Clone();
  this-&gt;m_ToolTipPosition = other.m_ToolTipPosition;
  this-&gt;m_ToolAxisOrientation = other.m_ToolAxisOrientation;
  if (other.m_ToolRegistrationMatrix.IsNotNull())
    this-&gt;m_ToolRegistrationMatrix = other.m_ToolRegistrationMatrix-&gt;Clone();
}</span>

mitk::NavigationTool::~NavigationTool()
<span style = "background-color:#fdd">{
}</span>

mitk::Point3D mitk::NavigationTool::GetToolAxis()
<span style = "background-color:#fdd">{</span>
  // The tool axis in the sensor coordinate system is defined as the negative z-axis
<span style = "background-color:#fdd">  mitk::Vector3D toolAxisSensorCoordinateSystem;
  mitk::FillVector3D(toolAxisSensorCoordinateSystem, 0.0, 0.0, -1.0);</span>
  // Apply inverse tool axis transform to calculate tool axis
<span style = "background-color:#fdd">  vnl_vector_fixed&lt;mitk::ScalarType,3&gt; toolAxisVector = m_ToolAxisOrientation.inverse().rotate(toolAxisSensorCoordinateSystem.GetVnlVector());</span>
  // Transfer to mitk::Point3D
<span style = "background-color:#fdd">  mitk::Point3D toolAxis;
  toolAxis[0] = toolAxisVector[0];
  toolAxis[1] = toolAxisVector[1];
  toolAxis[2] = toolAxisVector[2];
  return toolAxis;
}</span>

void mitk::NavigationTool::SetToolAxis(mitk::Point3D toolAxis)
<span style = "background-color:#fdd">{</span>
  // The tool axis in the sensor coordinate system is defined as the negative z-axis
<span style = "background-color:#fdd">  mitk::Vector3D toolAxisSensorCoordinateSystem;
  mitk::FillVector3D(toolAxisSensorCoordinateSystem, 0.0, 0.0, -1.0);</span>
  // Normalize the tool axis as obtained by a tool axis calibration
<span style = "background-color:#fdd">  mitk::Vector3D toolAxisFromCalibration;
  mitk::FillVector3D(toolAxisFromCalibration, toolAxis[0], toolAxis[1], toolAxis[2]);
  toolAxisFromCalibration.Normalize();</span>
  // if tool axis to be set is different to the default tool axis (0,0,-1) calculate the tool axis orientation, otherwise set it to identity
<span style = "background-color:#fdd">  if (toolAxisSensorCoordinateSystem == toolAxisFromCalibration)</span>
  {
<span style = "background-color:#fdd">    m_ToolAxisOrientation = mitk::Quaternion(0,0,0,1);
  }</span>
  else
  {
    // Determine rotation angle
<span style = "background-color:#fdd">    mitk::ScalarType rotationAngle = acos(toolAxisSensorCoordinateSystem*toolAxisFromCalibration);</span>
    // Determine rotation axis
<span style = "background-color:#fdd">    mitk::Vector3D rotationAxis = itk::CrossProduct(toolAxisSensorCoordinateSystem, toolAxisFromCalibration);</span>
    // Calculate transform
<span style = "background-color:#fdd">    itk::AffineTransform&lt;mitk::ScalarType&gt;::Pointer sensorToToolAxisOrientation = itk::AffineTransform&lt;mitk::ScalarType&gt;::New();
    sensorToToolAxisOrientation-&gt;Rotate3D(rotationAxis, rotationAngle);</span>
    // transfer to quaternion notation. Note that the vnl_quaternion expects the matrix in row major format, hence the transpose
<span style = "background-color:#fdd">    mitk::Quaternion toolAxisTransform(sensorToToolAxisOrientation-&gt;GetMatrix().GetVnlMatrix().transpose());</span>
    // Update the tool axis orientation
<span style = "background-color:#fdd">    m_ToolAxisOrientation = toolAxisTransform;
  }
}</span>

mitk::AffineTransform3D::Pointer mitk::NavigationTool::GetToolTipTransform()
<span style = "background-color:#fdd">{
  mitk::NavigationData::Pointer returnValue = mitk::NavigationData::New();
  returnValue-&gt;SetPosition(this-&gt;m_ToolTipPosition);
  returnValue-&gt;SetOrientation(this-&gt;m_ToolAxisOrientation);
  return returnValue-&gt;GetAffineTransform3D();
}</span>

void mitk::NavigationTool::Graft(const DataObject *data)
<span style = "background-color:#fdd">{</span>
  // Attempt to cast data to an NavigationData
  const Self* nd;
  try
  {
<span style = "background-color:#fdd">    nd = dynamic_cast&lt;const Self *&gt;(data);</span>
  }
  catch (...)
<span style = "background-color:#fdd">  {
    mitkThrowException(mitk::IGTException) &lt;&lt; "mitk::NavigationData::Graft cannot cast "</span>
      &lt;&lt; typeid(data).name() &lt;&lt; " to "
      &lt;&lt; typeid(const Self *).name();
<span style = "background-color:#fdd">  }
  if (!nd)</span>
  {
    // pointer could not be cast back down
<span style = "background-color:#fdd">    mitkThrowException(mitk::IGTException) &lt;&lt; "mitk::NavigationData::Graft cannot cast "</span>
      &lt;&lt; typeid(data).name() &lt;&lt; " to "
      &lt;&lt; typeid(const Self *).name();
  }
  // Now copy anything that is needed
<span style = "background-color:#fdd">  m_Identifier = nd-&gt;GetIdentifier();
  m_Type = nd-&gt;GetType();
  m_DataNode-&gt;SetName(nd-&gt;GetDataNode()-&gt;GetName());
  m_DataNode-&gt;SetData(nd-&gt;GetDataNode()-&gt;GetData());
  m_SpatialObject = nd-&gt;GetSpatialObject();
  m_CalibrationFile = nd-&gt;GetCalibrationFile();
  m_SerialNumber = nd-&gt;GetSerialNumber();
  m_TrackingDeviceType = nd-&gt;GetTrackingDeviceType();
  m_ToolLandmarks = nd-&gt;GetToolLandmarks();
  m_ToolControlPoints = nd-&gt;GetToolControlPoints();
  m_ToolTipPosition = nd-&gt;GetToolTipPosition();
  m_ToolAxisOrientation = nd-&gt;GetToolAxisOrientation();
}</span>

bool mitk::NavigationTool::IsToolTipSet()
<span style = "background-color:#fdd">{</span>
  if ((m_ToolTipPosition[0] == 0) &amp;&amp;
    (m_ToolTipPosition[1] == 0) &amp;&amp;
    (m_ToolTipPosition[2] == 0) &amp;&amp;
    (m_ToolAxisOrientation.x() == 0) &amp;&amp;
    (m_ToolAxisOrientation.y() == 0) &amp;&amp;
<span style = "background-color:#fdd">    (m_ToolAxisOrientation.z() == 0) &amp;&amp;</span>
    (m_ToolAxisOrientation.r() == 1))
<span style = "background-color:#fdd">    return false;
  else return true;
}</span>

void mitk::NavigationTool::SetCalibrationFile(const std::string filename)
<span style = "background-color:#fdd">{</span>
  //check if file does exist:
<span style = "background-color:#fdd">  if (filename == "")</span>
  {
<span style = "background-color:#fdd">    m_CalibrationFile = "none";
  }</span>
  else
  {
<span style = "background-color:#fdd">    Poco::File myFile(filename);
    if (myFile.exists())
      m_CalibrationFile = filename;</span>
    else
<span style = "background-color:#fdd">      m_CalibrationFile = "none";
  }
}</span>

std::string mitk::NavigationTool::GetToolName()
<span style = "background-color:#fdd">{
  if (this-&gt;m_DataNode.IsNull()) { return ""; }
  else { return m_DataNode-&gt;GetName(); }
}</span>

mitk::Surface::Pointer mitk::NavigationTool::GetToolSurface()
<span style = "background-color:#fdd">{
  if (this-&gt;m_DataNode.IsNull()) { return nullptr; }
  else if (this-&gt;m_DataNode-&gt;GetData() == nullptr) { return nullptr; }
  else { return dynamic_cast&lt;mitk::Surface*&gt;(m_DataNode-&gt;GetData()); }
}</span>

void mitk::NavigationTool::SetDefaultSurface()
<span style = "background-color:#fdd">{
  if (m_DataNode.IsNull())
    m_DataNode = mitk::DataNode::New();</span>

<span style = "background-color:#fdd">  mitk::Surface::Pointer mySphere = mitk::Surface::New();</span>

<span style = "background-color:#fdd">  double axisLength = 5.;</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkSphereSource&gt; vtkSphere = vtkSmartPointer&lt;vtkSphereSource&gt;::New();
  vtkSmartPointer&lt;vtkConeSource&gt; vtkCone = vtkSmartPointer&lt;vtkConeSource&gt;::New();
  vtkSmartPointer&lt;vtkCylinderSource&gt; vtkCylinder = vtkSmartPointer&lt;vtkCylinderSource&gt;::New();
  vtkSmartPointer&lt;vtkPolyData&gt; axis = vtkSmartPointer&lt;vtkPolyData&gt;::New();
  vtkSmartPointer&lt;vtkLineSource&gt; vtkLine = vtkSmartPointer&lt;vtkLineSource&gt;::New();
  vtkSmartPointer&lt;vtkLineSource&gt; vtkLine2 = vtkSmartPointer&lt;vtkLineSource&gt;::New();
  vtkSmartPointer&lt;vtkLineSource&gt; vtkLine3 = vtkSmartPointer&lt;vtkLineSource&gt;::New();</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkAppendPolyData&gt; appendPolyData = vtkSmartPointer&lt;vtkAppendPolyData&gt;::New();
  vtkSmartPointer&lt;vtkPolyData&gt; surface = vtkSmartPointer&lt;vtkPolyData&gt;::New();</span>

  //Y-Axis (start with y, cause cylinder is oriented in y by vtk default...)
<span style = "background-color:#fdd">  vtkCone-&gt;SetDirection(0, 1, 0);
  vtkCone-&gt;SetHeight(1.0);
  vtkCone-&gt;SetRadius(0.4f);
  vtkCone-&gt;SetResolution(16);
  vtkCone-&gt;SetCenter(0.0, axisLength, 0.0);
  vtkCone-&gt;Update();</span>

<span style = "background-color:#fdd">  vtkCylinder-&gt;SetRadius(0.05);
  vtkCylinder-&gt;SetHeight(axisLength);
  vtkCylinder-&gt;SetCenter(0.0, 0.5*axisLength, 0.0);
  vtkCylinder-&gt;Update();</span>

<span style = "background-color:#fdd">  appendPolyData-&gt;AddInputData(vtkCone-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(vtkCylinder-&gt;GetOutput());
  appendPolyData-&gt;Update();
  axis-&gt;DeepCopy(appendPolyData-&gt;GetOutput());</span>

  //y symbol
<span style = "background-color:#fdd">  vtkLine-&gt;SetPoint1(-0.5, axisLength + 2., 0.0);
  vtkLine-&gt;SetPoint2(0.0, axisLength + 1.5, 0.0);
  vtkLine-&gt;Update();</span>

<span style = "background-color:#fdd">  vtkLine2-&gt;SetPoint1(0.5, axisLength + 2., 0.0);
  vtkLine2-&gt;SetPoint2(-0.5, axisLength + 1., 0.0);
  vtkLine2-&gt;Update();</span>

<span style = "background-color:#fdd">  appendPolyData-&gt;AddInputData(vtkLine-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(vtkLine2-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(axis);
  appendPolyData-&gt;Update();
  surface-&gt;DeepCopy(appendPolyData-&gt;GetOutput());</span>

  //X-axis
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkTransform&gt; XTransform = vtkSmartPointer&lt;vtkTransform&gt;::New();
  XTransform-&gt;RotateZ(-90);
  vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt; TrafoFilter = vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt;::New();
  TrafoFilter-&gt;SetTransform(XTransform);
  TrafoFilter-&gt;SetInputData(axis);
  TrafoFilter-&gt;Update();</span>

  //x symbol
<span style = "background-color:#fdd">  vtkLine-&gt;SetPoint1(axisLength + 2., -0.5, 0.0);
  vtkLine-&gt;SetPoint2(axisLength + 1., 0.5, 0.0);
  vtkLine-&gt;Update();</span>

<span style = "background-color:#fdd">  vtkLine2-&gt;SetPoint1(axisLength + 2., 0.5, 0.0);
  vtkLine2-&gt;SetPoint2(axisLength + 1., -0.5, 0.0);
  vtkLine2-&gt;Update();</span>

<span style = "background-color:#fdd">  appendPolyData-&gt;AddInputData(vtkLine-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(vtkLine2-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(TrafoFilter-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(surface);
  appendPolyData-&gt;Update();
  surface-&gt;DeepCopy(appendPolyData-&gt;GetOutput());</span>

  //Z-axis
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkTransform&gt; ZTransform = vtkSmartPointer&lt;vtkTransform&gt;::New();
  ZTransform-&gt;RotateX(90);
  TrafoFilter-&gt;SetTransform(ZTransform);
  TrafoFilter-&gt;SetInputData(axis);
  TrafoFilter-&gt;Update();</span>

  //z symbol
<span style = "background-color:#fdd">  vtkLine-&gt;SetPoint1(-0.5, 0.0, axisLength + 2.);
  vtkLine-&gt;SetPoint2(0.5, 0.0, axisLength + 2.);
  vtkLine-&gt;Update();</span>

<span style = "background-color:#fdd">  vtkLine2-&gt;SetPoint1(-0.5, 0.0, axisLength + 2.);
  vtkLine2-&gt;SetPoint2(0.5, 0.0, axisLength + 1.);
  vtkLine2-&gt;Update();</span>

<span style = "background-color:#fdd">  vtkLine3-&gt;SetPoint1(0.5, 0.0, axisLength + 1.);
  vtkLine3-&gt;SetPoint2(-0.5, 0.0, axisLength + 1.);
  vtkLine3-&gt;Update();</span>

<span style = "background-color:#fdd">  appendPolyData-&gt;AddInputData(vtkLine-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(vtkLine2-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(vtkLine3-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(TrafoFilter-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(surface);
  appendPolyData-&gt;Update();
  surface-&gt;DeepCopy(appendPolyData-&gt;GetOutput());</span>

  //Center
<span style = "background-color:#fdd">  vtkSphere-&gt;SetRadius(0.5f);
  vtkSphere-&gt;SetCenter(0.0, 0.0, 0.0);
  vtkSphere-&gt;Update();</span>

<span style = "background-color:#fdd">  appendPolyData-&gt;AddInputData(vtkSphere-&gt;GetOutput());
  appendPolyData-&gt;AddInputData(surface);
  appendPolyData-&gt;Update();
  surface-&gt;DeepCopy(appendPolyData-&gt;GetOutput());</span>

  //Scale
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkTransform&gt; ScaleTransform = vtkSmartPointer&lt;vtkTransform&gt;::New();
  ScaleTransform-&gt;Scale(20., 20., 20.);</span>

<span style = "background-color:#fdd">  TrafoFilter-&gt;SetTransform(ScaleTransform);
  TrafoFilter-&gt;SetInputData(surface);
  TrafoFilter-&gt;Update();</span>

<span style = "background-color:#fdd">  mySphere-&gt;SetVtkPolyData(TrafoFilter-&gt;GetOutput());</span>

<span style = "background-color:#fdd">  this-&gt;GetDataNode()-&gt;SetData(mySphere);
}</span>

std::string mitk::NavigationTool::GetStringWithAllToolInformation() const
<span style = "background-color:#fdd">{
  std::stringstream _info;
  _info &lt;&lt; "  Identifier: " &lt;&lt; this-&gt;m_Identifier &lt;&lt; "\n"</span>
        &lt;&lt; "  NavigationToolType: " &lt;&lt; m_Type &lt;&lt; "\n"
        &lt;&lt; "  Calibration file: " &lt;&lt; m_CalibrationFile &lt;&lt; "\n"
        &lt;&lt; "  Serial number: " &lt;&lt; m_SerialNumber &lt;&lt; "\n"
        &lt;&lt; "  TrackingDeviceType: " &lt;&lt; m_TrackingDeviceType &lt;&lt; "\n"
        &lt;&lt; "  ToolTip Position: " &lt;&lt; m_ToolTipPosition &lt;&lt; "\n"
        &lt;&lt; "  Tool Axis Orientation: " &lt;&lt; m_ToolAxisOrientation &lt;&lt; "\n"
        &lt;&lt; "  Tool Axis: "
        &lt;&lt; m_ToolAxisOrientation.inverse().rotate(vnl_vector_fixed&lt;mitk::ScalarType, 3&gt;(0.0, 0.0, -1.0)) &lt;&lt; "\n"
        &lt;&lt; "Tool Registration Matrix: "&lt;&lt; "\n"
        &lt;&lt; "R: "&lt;&lt; "\n";


<span style = "background-color:#fdd">  m_ToolRegistrationMatrix-&gt;GetMatrix().GetVnlMatrix().print(_info);</span>

<span style = "background-color:#fdd">  _info &lt;&lt; "V: "</span>
        &lt;&lt; "\n";
<span style = "background-color:#fdd">  auto offset = m_ToolRegistrationMatrix-&gt;GetOffset();
  _info &lt;&lt; offset[0] &lt;&lt; " " &lt;&lt; offset[1] &lt;&lt; " " &lt;&lt; offset[2];
  return _info.str();
}</span></pre>
	</body>
</html>