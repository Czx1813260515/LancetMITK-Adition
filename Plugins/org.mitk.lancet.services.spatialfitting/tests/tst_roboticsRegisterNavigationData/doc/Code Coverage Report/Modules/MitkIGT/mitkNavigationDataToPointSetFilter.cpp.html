<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNavigationDataToPointSetFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkNavigationDataToPointSetFilter.h"

#include &lt;mitkPointOperation.h&gt;
#include &lt;mitkInteractionConst.h&gt;
#include &lt;itksys/SystemTools.hxx&gt;

mitk::NavigationDataToPointSetFilter::NavigationDataToPointSetFilter()
<span style = "background-color:#fdd">{
  mitk::PointSet::Pointer output = mitk::PointSet::New();
  this-&gt;SetNumberOfRequiredOutputs(1);
  this-&gt;SetNthOutput(0, output.GetPointer());</span>

<span style = "background-color:#fdd">  this-&gt;SetNumberOfRequiredInputs(1);</span>

<span style = "background-color:#fdd">  m_OperationMode = Mode3D;
  m_CurrentTimeStep = 0;
  m_RingBufferSize = 50; //the default ring buffer size
  m_NumberForMean = 100;
}</span>

mitk::NavigationDataToPointSetFilter::~NavigationDataToPointSetFilter()
<span style = "background-color:#fdd">{
}</span>

void mitk::NavigationDataToPointSetFilter::GenerateData()
<span style = "background-color:#fdd">{
  switch (m_OperationMode)</span>
  {
  case Mode3D:
<span style = "background-color:#fdd">    GenerateDataMode3D();
    break;</span>
  case Mode3DMean:
<span style = "background-color:#fdd">    GenerateDataMode3DMean();
    break;</span>
  case Mode4D:
<span style = "background-color:#fdd">    GenerateDataMode4D();</span>
    break;
  default:
    break;
  }
<span style = "background-color:#fdd">}</span>


void mitk::NavigationDataToPointSetFilter::SetInput(const NavigationData* nd)
<span style = "background-color:#fdd">{</span>
  // Process object is not const-correct so the const_cast is required here
<span style = "background-color:#fdd">  this-&gt;ProcessObject::SetNthInput(0, const_cast&lt;NavigationData*&gt;(nd));
  this-&gt;CreateOutputsForAllInputs();
}</span>


void mitk::NavigationDataToPointSetFilter::SetInput(unsigned int idx, const NavigationData* nd)
<span style = "background-color:#fdd">{</span>
  // Process object is not const-correct so the const_cast is required here
<span style = "background-color:#fdd">  this-&gt;ProcessObject::SetNthInput(idx, const_cast&lt;NavigationData*&gt;(nd));
  this-&gt;CreateOutputsForAllInputs();
}</span>


const mitk::NavigationData* mitk::NavigationDataToPointSetFilter::GetInput( void )
<span style = "background-color:#fdd">{
  if (this-&gt;GetNumberOfInputs() &lt; 1)
    return nullptr;
  return static_cast&lt;const NavigationData*&gt;(this-&gt;ProcessObject::GetInput(0));
}</span>


const mitk::NavigationData* mitk::NavigationDataToPointSetFilter::GetInput( unsigned int idx )
<span style = "background-color:#fdd">{
  if (this-&gt;GetNumberOfInputs() &lt; 1)
    return nullptr;
  return static_cast&lt;const NavigationData*&gt;(this-&gt;ProcessObject::GetInput(idx));
}</span>


void mitk::NavigationDataToPointSetFilter::CreateOutputsForAllInputs()
<span style = "background-color:#fdd">{
  switch (m_OperationMode)</span>
  {
  case Mode3D:
<span style = "background-color:#fdd">    this-&gt;SetNumberOfIndexedOutputs(this-&gt;GetNumberOfIndexedInputs());  // create one pointset output for each navigation data input
    break;</span>
  case Mode3DMean:
<span style = "background-color:#fdd">    this-&gt;SetNumberOfIndexedOutputs(this-&gt;GetNumberOfIndexedInputs());  // create one pointset output for each navigation data input
    break;</span>
  case Mode4D:
<span style = "background-color:#fdd">    this-&gt;SetNumberOfIndexedOutputs(1); // create just one output pointset that will contain all input navigation data objects</span>
    break;
  default:
    break;
  }

<span style = "background-color:#fdd">  for (unsigned int idx = 0; idx &lt; this-&gt;GetNumberOfIndexedOutputs(); ++idx)</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;GetOutput(idx) == nullptr)</span>
    {
<span style = "background-color:#fdd">      DataObjectPointer newOutput = this-&gt;MakeOutput(idx);
      this-&gt;SetNthOutput(idx, newOutput);
    }
  }</span>

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span>


void mitk::NavigationDataToPointSetFilter::GenerateDataMode3D()
<span style = "background-color:#fdd">{
  for (unsigned int i = 0; i &lt; this-&gt;GetNumberOfIndexedOutputs() ; ++i)  // for each output PointSet</span>
  {
<span style = "background-color:#fdd">    mitk::PointSet* output = this-&gt;GetOutput(i);
    assert(output);
    const mitk::NavigationData* input = this-&gt;GetInput(i);
    assert(input);
    if (input-&gt;IsDataValid() == false)  // don't add point if input is invalid
      continue;
    mitk::PointSet::PointType pos = input-&gt;GetPosition();  // NavigationData::PositionType must be compatible with PointSet::PointType!
    output-&gt;InsertPoint(output-&gt;GetSize(), pos);  // add point with current position of input NavigationData to the output PointSet</span>
    // \TODO: regard ringbuffersize
<span style = "background-color:#fdd">  }
}</span>

/**
* @brief read n times all connected inputs and sum them into outputs. Finish with dividing each output by n.
**/
void mitk::NavigationDataToPointSetFilter::GenerateDataMode3DMean()
<span style = "background-color:#fdd">{</span>
  //make it editable through a Set method if needed

  //check for outputs and inputs
<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; this-&gt;GetNumberOfIndexedOutputs() ; ++i)  // for each output PointSet; change through pointsets to collect all navigation data in order</span>
  {
<span style = "background-color:#fdd">    assert(this-&gt;GetOutput(i));
    assert(this-&gt;GetInput(i));
  }</span>

  //vector of counters for each output
<span style = "background-color:#fdd">  std::vector&lt;unsigned int&gt; counterVec(this-&gt;GetNumberOfIndexedOutputs(),0);</span>

  //vector of old timesteps for each output
<span style = "background-color:#fdd">  std::vector&lt;mitk::NavigationData::TimeStampType&gt; vectorOldTime(this-&gt;GetNumberOfIndexedOutputs());</span>

  //use first Output to get the size of the pointsets. All output pointssets have to have the same size!
<span style = "background-color:#fdd">  mitk::PointSet::PointIdentifier newPointId = this-&gt;GetOutput()-&gt;GetSize();</span>

<span style = "background-color:#fdd">  bool numberForMean_is_reached = false;
  while (!numberForMean_is_reached)</span>
  {
<span style = "background-color:#fdd">    for (unsigned int i = 0; i &lt; this-&gt;GetNumberOfIndexedOutputs() ; ++i)  // for each output PointSet; change through pointsets to collect all navigation data in order</span>
    {
<span style = "background-color:#fdd">        mitk::PointSet* output = this-&gt;GetOutput(i);
        const mitk::NavigationData* input = this-&gt;GetInput(i);
        if (input-&gt;IsDataValid() == false)  // don't add point if input is invalid
          continue;//do not store
        mitk::PointSet::PointType pos;
        if (counterVec[i] == 0) //first Element must be inserted</span>
        {
<span style = "background-color:#fdd">          vectorOldTime[i] = input-&gt;GetIGTTimeStamp();</span>

          //no need to call an update
<span style = "background-color:#fdd">          pos = input-&gt;GetPosition();  // NavigationData::PositionType must be compatible with PointSet::PointType!
          output-&gt;InsertPoint(newPointId, pos);  // add point with current position of input NavigationData to the output PointSet
          counterVec[i]++;
        }</span>
        else
        {
          //manually call an update to track new positions
<span style = "background-color:#fdd">          this-&gt;ProcessObject::GetInput(i)-&gt;Update();
          input = this-&gt;GetInput(i);
          mitk::NavigationData::TimeStampType newTime = input-&gt;GetIGTTimeStamp();
          if (vectorOldTime[i]&lt;newTime)</span>
          {
<span style = "background-color:#fdd">            pos = input-&gt;GetPosition();  // NavigationData::PositionType must be compatible with PointSet::PointType!</span>

            //calculate the summ of the old position and the current coordinate
<span style = "background-color:#fdd">            mitk::Vector3D vec(0.0);
            vec.SetVnlVector(pos.GetVnlVector().as_ref());
            mitk::PointSet::PointType oPoint = output-&gt;GetPoint(newPointId);
            oPoint += vec;//summ up
            output-&gt;SetPoint(newPointId, oPoint);</span>

            //store in counterVec to know how many have been added (and not skipped because of invalid data)
<span style = "background-color:#fdd">            counterVec[i]++;
            vectorOldTime[i] = newTime;</span>
          }
        }
        // \TODO: regard ringbuffersize
<span style = "background-color:#fdd">    }
    numberForMean_is_reached = true;
    for (unsigned int i = 0; i &lt; this-&gt;GetNumberOfIndexedOutputs() ; ++i)</span>
    {
<span style = "background-color:#fdd">      if (counterVec[i]&lt;m_NumberForMean)
        numberForMean_is_reached = false;
    }</span>

<span style = "background-color:#fdd">  }</span>

  //divide with counterVec
<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; this-&gt;GetNumberOfIndexedOutputs() ; ++i)  // for each output PointSet; change through pointsets to collect all navigation data in order</span>
  {
<span style = "background-color:#fdd">    mitk::PointSet* output = this-&gt;GetOutput(i);
    mitk::PointSet::PointType oPoint = output-&gt;GetPoint(newPointId);
    for (unsigned int index = 0; index &lt; oPoint.Size(); index++)
      oPoint[index] = oPoint[index] / counterVec[i];
    output-&gt;SetPoint(newPointId, oPoint);
    MBI_INFO &lt;&lt; "For output # " &lt;&lt; i &lt;&lt; ", " &lt;&lt; counterVec[i] &lt;&lt; " tracked positions used for averaging";
  }
}</span>

void mitk::NavigationDataToPointSetFilter::GenerateDataMode4D()
<span style = "background-color:#fdd">{
  mitk::PointSet* output = this-&gt;GetOutput();
  assert(output);
  for (unsigned int index = 0; index &lt; this-&gt;GetNumberOfIndexedInputs(); index++)</span>
  {
<span style = "background-color:#fdd">    const mitk::NavigationData* nd = GetInput(index);
    assert(nd);
    mitk::NavigationData::PositionType point = nd-&gt;GetPosition();  //get the position
    output-&gt;SetPoint( index, point, m_CurrentTimeStep); //store it in the pointset always at the current time step
  }
  if (m_CurrentTimeStep == m_RingBufferSize - 1) // update ring buffer index
    m_CurrentTimeStep = 0;</span>
  else
<span style = "background-color:#fdd">    m_CurrentTimeStep++;
}</span>


void mitk::NavigationDataToPointSetFilter::SetOperationMode( OperationMode mode )
<span style = "background-color:#fdd">{
  m_OperationMode = mode;</span>
  //Initialize 4D Mode
<span style = "background-color:#fdd">  if (m_OperationMode == Mode4D)
    m_CurrentTimeStep = 0;
  this-&gt;Modified();
  this-&gt;CreateOutputsForAllInputs();
}</span></pre>
	</body>
</html>