<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>jsoncpp.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/// Json-cpp amalgamated source (http://jsoncpp.sourceforge.net/).
/// It is intended to be used with #include "json/json.h"

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////

/*
The JsonCpp library's source code, including accompanying documentation,
tests and demonstration applications, are licensed under the following
conditions...

Baptiste Lepilleur and The JsonCpp Authors explicitly disclaim copyright in all
jurisdictions which recognize such a disclaimer. In such jurisdictions,
this software is released into the Public Domain.

In jurisdictions which do not recognize Public Domain property (e.g. Germany as of
2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur and
The JsonCpp Authors, and is released under the terms of the MIT License (see below).

In jurisdictions which recognize Public Domain property, the user of this
software may choose to accept it either as 1) Public Domain, 2) under the
conditions of the MIT License (see below), or 3) under the terms of dual
Public Domain/MIT License conditions described here, as they choose.

The MIT License is about as close to Public Domain as a license can get, and is
described in clear, concise terms at:

   http://en.wikipedia.org/wiki/MIT_License

The full text of the MIT License follows:

========================================================================
Copyright (c) 2007-2010 Baptiste Lepilleur and The JsonCpp Authors

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
========================================================================
(END LICENSE TEXT)

The MIT license is compatible with both the GPL and commercial
software, affording one all of the rights of Public Domain with the
minor nuisance of being required to keep the above copyright notice
and license text in the source code. Note also that by accepting the
Public Domain "license" you can re-license your copy using whatever
license you like.

*/

// //////////////////////////////////////////////////////////////////////
// End of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////






#include "jsoncpp.h"

#ifndef JSON_IS_AMALGAMATION
#error "Compile with -I PATH_TO_JSON_DIRECTORY"
#endif


// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_tool.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef LIB_JSONCPP_JSON_TOOL_H_INCLUDED
#define LIB_JSONCPP_JSON_TOOL_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include &lt;json/config.h&gt;
#endif

// Also support old flag NO_LOCALE_SUPPORT
#ifdef NO_LOCALE_SUPPORT
#define JSONCPP_NO_LOCALE_SUPPORT
#endif

#ifndef JSONCPP_NO_LOCALE_SUPPORT
#include &lt;clocale&gt;
#endif

/* This header provides common string manipulation support, such as UTF-8,
 * portable conversion from/to string...
 *
 * It is an internal header that must not be exposed.
 */

namespace Json {
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunneeded-internal-declaration"
#endif
static inline char getDecimalPoint() {
#ifdef JSONCPP_NO_LOCALE_SUPPORT
  return '\0';
#else
  struct lconv* lc = localeconv();
  return lc ? *(lc-&gt;decimal_point) : '\0';
#endif
}
#if defined(__clang__)
#pragma clang diagnostic pop
#endif

/// Converts a unicode code-point to UTF-8.
<span style = "background-color:#fdd">static inline String codePointToUTF8(unsigned int cp) {
  String result;</span>

  // based on description from http://en.wikipedia.org/wiki/UTF-8

<span style = "background-color:#fdd">  if (cp &lt;= 0x7f) {
    result.resize(1);
    result[0] = static_cast&lt;char&gt;(cp);
  } else if (cp &lt;= 0x7FF) {
    result.resize(2);
    result[1] = static_cast&lt;char&gt;(0x80 | (0x3f &amp; cp));
    result[0] = static_cast&lt;char&gt;(0xC0 | (0x1f &amp; (cp &gt;&gt; 6)));
  } else if (cp &lt;= 0xFFFF) {
    result.resize(3);
    result[2] = static_cast&lt;char&gt;(0x80 | (0x3f &amp; cp));
    result[1] = static_cast&lt;char&gt;(0x80 | (0x3f &amp; (cp &gt;&gt; 6)));
    result[0] = static_cast&lt;char&gt;(0xE0 | (0xf &amp; (cp &gt;&gt; 12)));
  } else if (cp &lt;= 0x10FFFF) {
    result.resize(4);
    result[3] = static_cast&lt;char&gt;(0x80 | (0x3f &amp; cp));
    result[2] = static_cast&lt;char&gt;(0x80 | (0x3f &amp; (cp &gt;&gt; 6)));
    result[1] = static_cast&lt;char&gt;(0x80 | (0x3f &amp; (cp &gt;&gt; 12)));
    result[0] = static_cast&lt;char&gt;(0xF0 | (0x7 &amp; (cp &gt;&gt; 18)));</span>
  }

<span style = "background-color:#fdd">  return result;
}</span>

enum {
  /// Constant that specify the size of the buffer that must be passed to
  /// uintToString.
  uintToStringBufferSize = 3 * sizeof(LargestUInt) + 1
};

// Defines a char buffer for use with uintToString().
using UIntToStringBuffer = char[uintToStringBufferSize];

/** Converts an unsigned integer to string.
 * @param value Unsigned integer to convert to string
 * @param current Input/Output string buffer.
 *        Must have at least uintToStringBufferSize chars free.
 */
<span style = "background-color:#fdd">static inline void uintToString(LargestUInt value, char*&amp; current) {
  *--current = 0;</span>
  do {
<span style = "background-color:#fdd">    *--current = static_cast&lt;char&gt;(value % 10U + static_cast&lt;unsigned&gt;('0'));
    value /= 10;
  } while (value != 0);
}</span>

/** Change ',' to '.' everywhere in buffer.
 *
 * We had a sophisticated way, but it did not work in WinCE.
 * @see https://github.com/open-source-parsers/jsoncpp/pull/9
 */
<span style = "background-color:#fdd">template &lt;typename Iter&gt; Iter fixNumericLocale(Iter begin, Iter end) {
  for (; begin != end; ++begin) {
    if (*begin == ',') {
      *begin = '.';</span>
    }
<span style = "background-color:#fdd">  }
  return begin;
}</span>

template &lt;typename Iter&gt; void fixNumericLocaleInput(Iter begin, Iter end) {
  char decimalPoint = getDecimalPoint();
  if (decimalPoint == '\0' || decimalPoint == '.') {
    return;
  }
  for (; begin != end; ++begin) {
    if (*begin == '.') {
      *begin = decimalPoint;
    }
  }
}

/**
 * Return iterator that would be the new end of the range [begin,end), if we
 * were to delete zeros in the end of string, but not the last zero before '.'.
 */
template &lt;typename Iter&gt;
<span style = "background-color:#fdd">Iter fixZerosInTheEnd(Iter begin, Iter end, unsigned int precision) {
  for (; begin != end; --end) {
    if (*(end - 1) != '0') {
      return end;</span>
    }
    // Don't delete the last zero before the decimal point.
<span style = "background-color:#fdd">    if (begin != (end - 1) &amp;&amp; begin != (end - 2) &amp;&amp; *(end - 2) == '.') {
      if (precision) {
        return end;</span>
      }
<span style = "background-color:#fdd">      return end - 2;</span>
    }
<span style = "background-color:#fdd">  }
  return end;
}</span>

} // namespace Json

#endif // LIB_JSONCPP_JSON_TOOL_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_tool.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_reader.cpp
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2011 Baptiste Lepilleur and The JsonCpp Authors
// Copyright (C) 2016 InfoTeCS JSC. All rights reserved.
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#if !defined(JSON_IS_AMALGAMATION)
#include "json_tool.h"
#include &lt;json/assertions.h&gt;
#include &lt;json/reader.h&gt;
#include &lt;json/value.h&gt;
#endif // if !defined(JSON_IS_AMALGAMATION)
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;istream&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;utility&gt;

#include &lt;cstdio&gt;
#if __cplusplus &gt;= 201103L

#if !defined(sscanf)
#define sscanf std::sscanf
#endif

#endif //__cplusplus

#if defined(_MSC_VER)
#if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
#endif //_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
#endif //_MSC_VER

#if defined(_MSC_VER)
// Disable warning about strdup being deprecated.
#pragma warning(disable : 4996)
#endif

// Define JSONCPP_DEPRECATED_STACK_LIMIT as an appropriate integer at compile
// time to change the stack limit
#if !defined(JSONCPP_DEPRECATED_STACK_LIMIT)
#define JSONCPP_DEPRECATED_STACK_LIMIT 1000
#endif

static size_t const stackLimit_g =
    JSONCPP_DEPRECATED_STACK_LIMIT; // see readValue()

namespace Json {

#if __cplusplus &gt;= 201103L || (defined(_CPPLIB_VER) &amp;&amp; _CPPLIB_VER &gt;= 520)
using CharReaderPtr = std::unique_ptr&lt;CharReader&gt;;
#else
using CharReaderPtr = std::auto_ptr&lt;CharReader&gt;;
#endif

// Implementation of class Features
// ////////////////////////////////

<span style = "background-color:#dfd">Features::Features() = default;</span>

<span style = "background-color:#fdd">Features Features::all() { return {}; }</span>

<span style = "background-color:#dfd">Features Features::strictMode() {
  Features features;
  features.allowComments_ = false;
  features.strictRoot_ = true;
  features.allowDroppedNullPlaceholders_ = false;
  features.allowNumericKeys_ = false;
  return features;
}</span>

// Implementation of class Reader
// ////////////////////////////////

<span style = "background-color:#fdd">bool Reader::containsNewLine(Reader::Location begin, Reader::Location end) {
  return std::any_of(begin, end, [](char b) { return b == '\n' || b == '\r'; });
}</span>

// Class Reader
// //////////////////////////////////////////////////////////////////

<span style = "background-color:#fdd">Reader::Reader() : features_(Features::all()) {}</span>

<span style = "background-color:#dfd">Reader::Reader(const Features&amp; features) : features_(features) {}</span>

bool Reader::parse(const std::string&amp; document, Value&amp; root,
<span style = "background-color:#fdd">                   bool collectComments) {
  document_.assign(document.begin(), document.end());
  const char* begin = document_.c_str();
  const char* end = begin + document_.length();
  return parse(begin, end, root, collectComments);
}</span>

<span style = "background-color:#dfd">bool Reader::parse(std::istream&amp; is, Value&amp; root, bool collectComments) {</span>
  // std::istream_iterator&lt;char&gt; begin(is);
  // std::istream_iterator&lt;char&gt; end;
  // Those would allow streamed input from a file, if parse() were a
  // template function.

  // Since String is reference-counted, this at least does not
  // create an extra copy.
<span style = "background-color:#dfd">  String doc(std::istreambuf_iterator&lt;char&gt;(is), {});
  return parse(doc.data(), doc.data() + doc.size(), root, collectComments);
}</span>

bool Reader::parse(const char* beginDoc, const char* endDoc, Value&amp; root,
<span style = "background-color:#dfd">                   bool collectComments) {
  if (!features_.allowComments_) {
    collectComments = false;</span>
  }

<span style = "background-color:#dfd">  begin_ = beginDoc;
  end_ = endDoc;
  collectComments_ = collectComments;
  current_ = begin_;
  lastValueEnd_ = nullptr;
  lastValue_ = nullptr;
  commentsBefore_.clear();
  errors_.clear();
  while (!nodes_.empty())</span>
<span style = "background-color:#fdd">    nodes_.pop();</span>
<span style = "background-color:#dfd">  nodes_.push(&amp;root);</span>

<span style = "background-color:#dfd">  bool successful = readValue();</span>
  Token token;
<span style = "background-color:#dfd">  skipCommentTokens(token);
  if (collectComments_ &amp;&amp; !commentsBefore_.empty())</span>
<span style = "background-color:#fdd">    root.setComment(commentsBefore_, commentAfter);</span>
<span style = "background-color:#dfd">  if (features_.strictRoot_) {
    if (!root.isArray() &amp;&amp; !root.isObject()) {</span>
      // Set error location to start of doc, ideally should be first token found
      // in doc
<span style = "background-color:#fdd">      token.type_ = tokenError;
      token.start_ = beginDoc;
      token.end_ = endDoc;
      addError(</span>
          "A valid JSON document must be either an array or an object value.",
          token);
<span style = "background-color:#fdd">      return false;</span>
    }
  }
<span style = "background-color:#dfd">  return successful;
}</span>

<span style = "background-color:#dfd">bool Reader::readValue() {</span>
  // readValue() may call itself only if it calls readObject() or ReadArray().
  // These methods execute nodes_.push() just before and nodes_.pop)() just
  // after calling readValue(). parse() executes one nodes_.push(), so &gt; instead
  // of &gt;=.
<span style = "background-color:#dfd">  if (nodes_.size() &gt; stackLimit_g)</span>
<span style = "background-color:#fdd">    throwRuntimeError("Exceeded stackLimit in readValue().");</span>

  Token token;
<span style = "background-color:#dfd">  skipCommentTokens(token);
  bool successful = true;</span>

<span style = "background-color:#dfd">  if (collectComments_ &amp;&amp; !commentsBefore_.empty()) {</span>
<span style = "background-color:#fdd">    currentValue().setComment(commentsBefore_, commentBefore);
    commentsBefore_.clear();</span>
  }

<span style = "background-color:#dfd">  switch (token.type_) {</span>
  case tokenObjectBegin:
<span style = "background-color:#dfd">    successful = readObject(token);
    currentValue().setOffsetLimit(current_ - begin_);
    break;</span>
  case tokenArrayBegin:
<span style = "background-color:#fdd">    successful = readArray(token);
    currentValue().setOffsetLimit(current_ - begin_);
    break;</span>
  case tokenNumber:
<span style = "background-color:#fdd">    successful = decodeNumber(token);
    break;</span>
  case tokenString:
<span style = "background-color:#dfd">    successful = decodeString(token);
    break;</span>
  case tokenTrue: {
<span style = "background-color:#fdd">    Value v(true);
    currentValue().swapPayload(v);
    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
  } break;</span>
  case tokenFalse: {
<span style = "background-color:#fdd">    Value v(false);
    currentValue().swapPayload(v);
    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
  } break;</span>
  case tokenNull: {
<span style = "background-color:#fdd">    Value v;
    currentValue().swapPayload(v);
    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
  } break;</span>
  case tokenArraySeparator:
  case tokenObjectEnd:
  case tokenArrayEnd:
<span style = "background-color:#fdd">    if (features_.allowDroppedNullPlaceholders_) {</span>
      // "Un-read" the current token and mark the current value as a null
      // token.
<span style = "background-color:#fdd">      current_--;
      Value v;
      currentValue().swapPayload(v);
      currentValue().setOffsetStart(current_ - begin_ - 1);
      currentValue().setOffsetLimit(current_ - begin_);
      break;
    } // Else, fall through...</span>
  default:
<span style = "background-color:#fdd">    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
    return addError("Syntax error: value, object or array expected.", token);</span>
  }

<span style = "background-color:#dfd">  if (collectComments_) {</span>
<span style = "background-color:#fdd">    lastValueEnd_ = current_;
    lastValue_ = &amp;currentValue();</span>
  }

<span style = "background-color:#dfd">  return successful;
}</span>

<span style = "background-color:#dfd">void Reader::skipCommentTokens(Token&amp; token) {
  if (features_.allowComments_) {</span>
    do {
<span style = "background-color:#fdd">      readToken(token);
    } while (token.type_ == tokenComment);
  } else {</span>
<span style = "background-color:#dfd">    readToken(token);</span>
  }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">bool Reader::readToken(Token&amp; token) {
  skipSpaces();
  token.start_ = current_;
  Char c = getNextChar();
  bool ok = true;
  switch (c) {</span>
  case '{':
<span style = "background-color:#dfd">    token.type_ = tokenObjectBegin;
    break;</span>
  case '}':
<span style = "background-color:#dfd">    token.type_ = tokenObjectEnd;
    break;</span>
  case '[':
<span style = "background-color:#fdd">    token.type_ = tokenArrayBegin;
    break;</span>
  case ']':
<span style = "background-color:#fdd">    token.type_ = tokenArrayEnd;
    break;</span>
  case '"':
<span style = "background-color:#dfd">    token.type_ = tokenString;
    ok = readString();
    break;</span>
  case '/':
<span style = "background-color:#fdd">    token.type_ = tokenComment;
    ok = readComment();
    break;</span>
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
  case '-':
<span style = "background-color:#fdd">    token.type_ = tokenNumber;
    readNumber();
    break;</span>
  case 't':
<span style = "background-color:#fdd">    token.type_ = tokenTrue;
    ok = match("rue", 3);
    break;</span>
  case 'f':
<span style = "background-color:#fdd">    token.type_ = tokenFalse;
    ok = match("alse", 4);
    break;</span>
  case 'n':
<span style = "background-color:#fdd">    token.type_ = tokenNull;
    ok = match("ull", 3);
    break;</span>
  case ',':
<span style = "background-color:#fdd">    token.type_ = tokenArraySeparator;
    break;</span>
  case ':':
<span style = "background-color:#dfd">    token.type_ = tokenMemberSeparator;
    break;</span>
  case 0:
<span style = "background-color:#dfd">    token.type_ = tokenEndOfStream;
    break;</span>
  default:
<span style = "background-color:#fdd">    ok = false;</span>
    break;
  }
<span style = "background-color:#dfd">  if (!ok)</span>
<span style = "background-color:#fdd">    token.type_ = tokenError;</span>
<span style = "background-color:#dfd">  token.end_ = current_;
  return ok;
}</span>

<span style = "background-color:#dfd">void Reader::skipSpaces() {
  while (current_ != end_) {
    Char c = *current_;
    if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
      ++current_;</span>
    else
<span style = "background-color:#dfd">      break;
  }
}</span>

<span style = "background-color:#fdd">bool Reader::match(const Char* pattern, int patternLength) {
  if (end_ - current_ &lt; patternLength)
    return false;
  int index = patternLength;
  while (index--)
    if (current_[index] != pattern[index])
      return false;
  current_ += patternLength;
  return true;
}</span>

<span style = "background-color:#fdd">bool Reader::readComment() {
  Location commentBegin = current_ - 1;
  Char c = getNextChar();
  bool successful = false;
  if (c == '*')
    successful = readCStyleComment();
  else if (c == '/')
    successful = readCppStyleComment();
  if (!successful)
    return false;</span>

<span style = "background-color:#fdd">  if (collectComments_) {
    CommentPlacement placement = commentBefore;
    if (lastValueEnd_ &amp;&amp; !containsNewLine(lastValueEnd_, commentBegin)) {
      if (c != '*' || !containsNewLine(commentBegin, current_))
        placement = commentAfterOnSameLine;</span>
    }

<span style = "background-color:#fdd">    addComment(commentBegin, current_, placement);</span>
  }
<span style = "background-color:#fdd">  return true;
}</span>

<span style = "background-color:#fdd">String Reader::normalizeEOL(Reader::Location begin, Reader::Location end) {
  String normalized;
  normalized.reserve(static_cast&lt;size_t&gt;(end - begin));
  Reader::Location current = begin;
  while (current != end) {
    char c = *current++;
    if (c == '\r') {
      if (current != end &amp;&amp; *current == '\n')</span>
        // convert dos EOL
<span style = "background-color:#fdd">        ++current;</span>
      // convert Mac EOL
<span style = "background-color:#fdd">      normalized += '\n';
    } else {
      normalized += c;</span>
    }
<span style = "background-color:#fdd">  }
  return normalized;
}</span>

void Reader::addComment(Location begin, Location end,
<span style = "background-color:#fdd">                        CommentPlacement placement) {
  assert(collectComments_);
  const String&amp; normalized = normalizeEOL(begin, end);
  if (placement == commentAfterOnSameLine) {
    assert(lastValue_ != nullptr);
    lastValue_-&gt;setComment(normalized, placement);
  } else {
    commentsBefore_ += normalized;</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">bool Reader::readCStyleComment() {
  while ((current_ + 1) &lt; end_) {
    Char c = getNextChar();
    if (c == '*' &amp;&amp; *current_ == '/')
      break;
  }
  return getNextChar() == '/';
}</span>

<span style = "background-color:#fdd">bool Reader::readCppStyleComment() {
  while (current_ != end_) {
    Char c = getNextChar();
    if (c == '\n')
      break;
    if (c == '\r') {</span>
      // Consume DOS EOL. It will be normalized in addComment.
<span style = "background-color:#fdd">      if (current_ != end_ &amp;&amp; *current_ == '\n')
        getNextChar();</span>
      // Break on Moc OS 9 EOL.
<span style = "background-color:#fdd">      break;</span>
    }
<span style = "background-color:#fdd">  }
  return true;
}</span>

<span style = "background-color:#fdd">void Reader::readNumber() {
  Location p = current_;
  char c = '0'; // stopgap for already consumed character</span>
  // integral part
<span style = "background-color:#fdd">  while (c &gt;= '0' &amp;&amp; c &lt;= '9')
    c = (current_ = p) &lt; end_ ? *p++ : '\0';</span>
  // fractional part
<span style = "background-color:#fdd">  if (c == '.') {
    c = (current_ = p) &lt; end_ ? *p++ : '\0';
    while (c &gt;= '0' &amp;&amp; c &lt;= '9')
      c = (current_ = p) &lt; end_ ? *p++ : '\0';</span>
  }
  // exponential part
<span style = "background-color:#fdd">  if (c == 'e' || c == 'E') {
    c = (current_ = p) &lt; end_ ? *p++ : '\0';
    if (c == '+' || c == '-')
      c = (current_ = p) &lt; end_ ? *p++ : '\0';
    while (c &gt;= '0' &amp;&amp; c &lt;= '9')
      c = (current_ = p) &lt; end_ ? *p++ : '\0';</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#dfd">bool Reader::readString() {
  Char c = '\0';
  while (current_ != end_) {
    c = getNextChar();
    if (c == '\\')</span>
<span style = "background-color:#fdd">      getNextChar();</span>
<span style = "background-color:#dfd">    else if (c == '"')
      break;
  }
  return c == '"';
}</span>

<span style = "background-color:#dfd">bool Reader::readObject(Token&amp; token) {</span>
  Token tokenName;
<span style = "background-color:#dfd">  String name;
  Value init(objectValue);
  currentValue().swapPayload(init);
  currentValue().setOffsetStart(token.start_ - begin_);
  while (readToken(tokenName)) {
    bool initialTokenOk = true;
    while (tokenName.type_ == tokenComment &amp;&amp; initialTokenOk)</span>
<span style = "background-color:#fdd">      initialTokenOk = readToken(tokenName);</span>
<span style = "background-color:#dfd">    if (!initialTokenOk)</span>
<span style = "background-color:#fdd">      break;</span>
<span style = "background-color:#dfd">    if (tokenName.type_ == tokenObjectEnd &amp;&amp; name.empty()) // empty object</span>
<span style = "background-color:#fdd">      return true;</span>
<span style = "background-color:#dfd">    name.clear();
    if (tokenName.type_ == tokenString) {
      if (!decodeString(tokenName, name))</span>
<span style = "background-color:#fdd">        return recoverFromError(tokenObjectEnd);
    } else if (tokenName.type_ == tokenNumber &amp;&amp; features_.allowNumericKeys_) {
      Value numberName;
      if (!decodeNumber(tokenName, numberName))
        return recoverFromError(tokenObjectEnd);
      name = numberName.asString();
    } else {
      break;</span>
    }

    Token colon;
<span style = "background-color:#dfd">    if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {</span>
<span style = "background-color:#fdd">      return addErrorAndRecover("Missing ':' after object member name", colon,</span>
                                tokenObjectEnd);
    }
<span style = "background-color:#dfd">    Value&amp; value = currentValue()[name];
    nodes_.push(&amp;value);
    bool ok = readValue();
    nodes_.pop();
    if (!ok) // error already set</span>
<span style = "background-color:#fdd">      return recoverFromError(tokenObjectEnd);</span>

    Token comma;
<span style = "background-color:#dfd">    if (!readToken(comma) ||</span>
        (comma.type_ != tokenObjectEnd &amp;&amp; comma.type_ != tokenArraySeparator &amp;&amp;
         comma.type_ != tokenComment)) {
<span style = "background-color:#fdd">      return addErrorAndRecover("Missing ',' or '}' in object declaration",</span>
                                comma, tokenObjectEnd);
    }
<span style = "background-color:#dfd">    bool finalizeTokenOk = true;
    while (comma.type_ == tokenComment &amp;&amp; finalizeTokenOk)</span>
<span style = "background-color:#fdd">      finalizeTokenOk = readToken(comma);</span>
<span style = "background-color:#dfd">    if (comma.type_ == tokenObjectEnd)
      return true;</span>
<span style = "background-color:#fdd">  }
  return addErrorAndRecover("Missing '}' or object member name", tokenName,</span>
                            tokenObjectEnd);
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#fdd">bool Reader::readArray(Token&amp; token) {
  Value init(arrayValue);
  currentValue().swapPayload(init);
  currentValue().setOffsetStart(token.start_ - begin_);
  skipSpaces();
  if (current_ != end_ &amp;&amp; *current_ == ']') // empty array</span>
  {
    Token endArray;
<span style = "background-color:#fdd">    readToken(endArray);
    return true;</span>
  }
<span style = "background-color:#fdd">  int index = 0;</span>
  for (;;) {
<span style = "background-color:#fdd">    Value&amp; value = currentValue()[index++];
    nodes_.push(&amp;value);
    bool ok = readValue();
    nodes_.pop();
    if (!ok) // error already set
      return recoverFromError(tokenArrayEnd);</span>

    Token currentToken;
    // Accept Comment after last item in the array.
<span style = "background-color:#fdd">    ok = readToken(currentToken);
    while (currentToken.type_ == tokenComment &amp;&amp; ok) {
      ok = readToken(currentToken);
    }
    bool badTokenType = (currentToken.type_ != tokenArraySeparator &amp;&amp;</span>
                         currentToken.type_ != tokenArrayEnd);
<span style = "background-color:#fdd">    if (!ok || badTokenType) {
      return addErrorAndRecover("Missing ',' or ']' in array declaration",</span>
                                currentToken, tokenArrayEnd);
    }
<span style = "background-color:#fdd">    if (currentToken.type_ == tokenArrayEnd)
      break;
  }
  return true;
}</span>

<span style = "background-color:#fdd">bool Reader::decodeNumber(Token&amp; token) {
  Value decoded;
  if (!decodeNumber(token, decoded))
    return false;
  currentValue().swapPayload(decoded);
  currentValue().setOffsetStart(token.start_ - begin_);
  currentValue().setOffsetLimit(token.end_ - begin_);
  return true;
}</span>

<span style = "background-color:#fdd">bool Reader::decodeNumber(Token&amp; token, Value&amp; decoded) {</span>
  // Attempts to parse the number as an integer. If the number is
  // larger than the maximum supported value of an integer then
  // we decode the number as a double.
<span style = "background-color:#fdd">  Location current = token.start_;
  bool isNegative = *current == '-';
  if (isNegative)
    ++current;</span>
  // TODO: Help the compiler do the div and mod at compile time or get rid of
  // them.
<span style = "background-color:#fdd">  Value::LargestUInt maxIntegerValue =</span>
      isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
                 : Value::maxLargestUInt;
<span style = "background-color:#fdd">  Value::LargestUInt threshold = maxIntegerValue / 10;
  Value::LargestUInt value = 0;
  while (current &lt; token.end_) {
    Char c = *current++;
    if (c &lt; '0' || c &gt; '9')
      return decodeDouble(token, decoded);
    auto digit(static_cast&lt;Value::UInt&gt;(c - '0'));
    if (value &gt;= threshold) {</span>
      // We've hit or exceeded the max value divided by 10 (rounded down). If
      // a) we've only just touched the limit, b) this is the last digit, and
      // c) it's small enough to fit in that rounding delta, we're okay.
      // Otherwise treat this number as a double to avoid overflow.
<span style = "background-color:#fdd">      if (value &gt; threshold || current != token.end_ ||</span>
          digit &gt; maxIntegerValue % 10) {
<span style = "background-color:#fdd">        return decodeDouble(token, decoded);</span>
      }
    }
<span style = "background-color:#fdd">    value = value * 10 + digit;
  }
  if (isNegative &amp;&amp; value == maxIntegerValue)
    decoded = Value::minLargestInt;
  else if (isNegative)
    decoded = -Value::LargestInt(value);
  else if (value &lt;= Value::LargestUInt(Value::maxInt))
    decoded = Value::LargestInt(value);</span>
  else
<span style = "background-color:#fdd">    decoded = value;
  return true;
}</span>

<span style = "background-color:#fdd">bool Reader::decodeDouble(Token&amp; token) {
  Value decoded;
  if (!decodeDouble(token, decoded))
    return false;
  currentValue().swapPayload(decoded);
  currentValue().setOffsetStart(token.start_ - begin_);
  currentValue().setOffsetLimit(token.end_ - begin_);
  return true;
}</span>

<span style = "background-color:#fdd">bool Reader::decodeDouble(Token&amp; token, Value&amp; decoded) {
  double value = 0;
  String buffer(token.start_, token.end_);
  IStringStream is(buffer);
  if (!(is &gt;&gt; value))
    return addError(</span>
        "'" + String(token.start_, token.end_) + "' is not a number.", token);
<span style = "background-color:#fdd">  decoded = value;
  return true;
}</span>

<span style = "background-color:#dfd">bool Reader::decodeString(Token&amp; token) {
  String decoded_string;
  if (!decodeString(token, decoded_string))</span>
<span style = "background-color:#fdd">    return false;</span>
<span style = "background-color:#dfd">  Value decoded(decoded_string);
  currentValue().swapPayload(decoded);
  currentValue().setOffsetStart(token.start_ - begin_);
  currentValue().setOffsetLimit(token.end_ - begin_);
  return true;
}</span>

<span style = "background-color:#dfd">bool Reader::decodeString(Token&amp; token, String&amp; decoded) {
  decoded.reserve(static_cast&lt;size_t&gt;(token.end_ - token.start_ - 2));
  Location current = token.start_ + 1; // skip '"'
  Location end = token.end_ - 1;       // do not include '"'
  while (current != end) {
    Char c = *current++;
    if (c == '"')</span>
<span style = "background-color:#fdd">      break;</span>
<span style = "background-color:#dfd">    if (c == '\\') {</span>
<span style = "background-color:#fdd">      if (current == end)
        return addError("Empty escape sequence in string", token, current);
      Char escape = *current++;
      switch (escape) {</span>
      case '"':
<span style = "background-color:#fdd">        decoded += '"';
        break;</span>
      case '/':
<span style = "background-color:#fdd">        decoded += '/';
        break;</span>
      case '\\':
<span style = "background-color:#fdd">        decoded += '\\';
        break;</span>
      case 'b':
<span style = "background-color:#fdd">        decoded += '\b';
        break;</span>
      case 'f':
<span style = "background-color:#fdd">        decoded += '\f';
        break;</span>
      case 'n':
<span style = "background-color:#fdd">        decoded += '\n';
        break;</span>
      case 'r':
<span style = "background-color:#fdd">        decoded += '\r';
        break;</span>
      case 't':
<span style = "background-color:#fdd">        decoded += '\t';
        break;</span>
      case 'u': {
        unsigned int unicode;
<span style = "background-color:#fdd">        if (!decodeUnicodeCodePoint(token, current, end, unicode))
          return false;
        decoded += codePointToUTF8(unicode);
      } break;</span>
      default:
<span style = "background-color:#fdd">        return addError("Bad escape sequence in string", token, current);</span>
      }
<span style = "background-color:#fdd">    } else {</span>
<span style = "background-color:#dfd">      decoded += c;</span>
    }
<span style = "background-color:#dfd">  }
  return true;
}</span>

bool Reader::decodeUnicodeCodePoint(Token&amp; token, Location&amp; current,
<span style = "background-color:#fdd">                                    Location end, unsigned int&amp; unicode) {</span>

<span style = "background-color:#fdd">  if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
    return false;
  if (unicode &gt;= 0xD800 &amp;&amp; unicode &lt;= 0xDBFF) {</span>
    // surrogate pairs
<span style = "background-color:#fdd">    if (end - current &lt; 6)
      return addError(</span>
          "additional six characters expected to parse unicode surrogate pair.",
          token, current);
<span style = "background-color:#fdd">    if (*(current++) == '\\' &amp;&amp; *(current++) == 'u') {</span>
      unsigned int surrogatePair;
<span style = "background-color:#fdd">      if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
        unicode = 0x10000 + ((unicode &amp; 0x3FF) &lt;&lt; 10) + (surrogatePair &amp; 0x3FF);
      } else
        return false;
    } else
      return addError("expecting another \\u token to begin the second half of "</span>
                      "a unicode surrogate pair",
                      token, current);
  }
<span style = "background-color:#fdd">  return true;
}</span>

bool Reader::decodeUnicodeEscapeSequence(Token&amp; token, Location&amp; current,
                                         Location end,
<span style = "background-color:#fdd">                                         unsigned int&amp; ret_unicode) {
  if (end - current &lt; 4)
    return addError(</span>
        "Bad unicode escape sequence in string: four digits expected.", token,
        current);
<span style = "background-color:#fdd">  int unicode = 0;
  for (int index = 0; index &lt; 4; ++index) {
    Char c = *current++;
    unicode *= 16;
    if (c &gt;= '0' &amp;&amp; c &lt;= '9')
      unicode += c - '0';
    else if (c &gt;= 'a' &amp;&amp; c &lt;= 'f')
      unicode += c - 'a' + 10;
    else if (c &gt;= 'A' &amp;&amp; c &lt;= 'F')
      unicode += c - 'A' + 10;</span>
    else
<span style = "background-color:#fdd">      return addError(</span>
          "Bad unicode escape sequence in string: hexadecimal digit expected.",
          token, current);
<span style = "background-color:#fdd">  }
  ret_unicode = static_cast&lt;unsigned int&gt;(unicode);
  return true;
}</span>

<span style = "background-color:#fdd">bool Reader::addError(const String&amp; message, Token&amp; token, Location extra) {
  ErrorInfo info;
  info.token_ = token;
  info.message_ = message;
  info.extra_ = extra;
  errors_.push_back(info);
  return false;
}</span>

<span style = "background-color:#fdd">bool Reader::recoverFromError(TokenType skipUntilToken) {
  size_t const errorCount = errors_.size();</span>
  Token skip;
  for (;;) {
<span style = "background-color:#fdd">    if (!readToken(skip))
      errors_.resize(errorCount); // discard errors caused by recovery
    if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
      break;
  }
  errors_.resize(errorCount);
  return false;
}</span>

bool Reader::addErrorAndRecover(const String&amp; message, Token&amp; token,
<span style = "background-color:#fdd">                                TokenType skipUntilToken) {
  addError(message, token);
  return recoverFromError(skipUntilToken);
}</span>

<span style = "background-color:#dfd">Value&amp; Reader::currentValue() { return *(nodes_.top()); }</span>

<span style = "background-color:#dfd">Reader::Char Reader::getNextChar() {
  if (current_ == end_)
    return 0;
  return *current_++;
}</span>

void Reader::getLocationLineAndColumn(Location location, int&amp; line,
<span style = "background-color:#fdd">                                      int&amp; column) const {
  Location current = begin_;
  Location lastLineStart = current;
  line = 0;
  while (current &lt; location &amp;&amp; current != end_) {
    Char c = *current++;
    if (c == '\r') {
      if (*current == '\n')
        ++current;
      lastLineStart = current;
      ++line;
    } else if (c == '\n') {
      lastLineStart = current;
      ++line;</span>
    }
<span style = "background-color:#fdd">  }</span>
  // column &amp; line start at 1
<span style = "background-color:#fdd">  column = int(location - lastLineStart) + 1;
  ++line;
}</span>

<span style = "background-color:#fdd">String Reader::getLocationLineAndColumn(Location location) const {</span>
  int line, column;
<span style = "background-color:#fdd">  getLocationLineAndColumn(location, line, column);</span>
  char buffer[18 + 16 + 16 + 1];
<span style = "background-color:#fdd">  jsoncpp_snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
  return buffer;
}</span>

// Deprecated. Preserved for backward compatibility
<span style = "background-color:#fdd">String Reader::getFormatedErrorMessages() const {
  return getFormattedErrorMessages();
}</span>

<span style = "background-color:#fdd">String Reader::getFormattedErrorMessages() const {
  String formattedMessage;
  for (const auto&amp; error : errors_) {
    formattedMessage +=</span>
        "* " + getLocationLineAndColumn(error.token_.start_) + "\n";
<span style = "background-color:#fdd">    formattedMessage += "  " + error.message_ + "\n";
    if (error.extra_)
      formattedMessage +=</span>
          "See " + getLocationLineAndColumn(error.extra_) + " for detail.\n";
<span style = "background-color:#fdd">  }
  return formattedMessage;
}</span>

<span style = "background-color:#fdd">std::vector&lt;Reader::StructuredError&gt; Reader::getStructuredErrors() const {
  std::vector&lt;Reader::StructuredError&gt; allErrors;
  for (const auto&amp; error : errors_) {
    Reader::StructuredError structured;
    structured.offset_start = error.token_.start_ - begin_;
    structured.offset_limit = error.token_.end_ - begin_;
    structured.message = error.message_;
    allErrors.push_back(structured);
  }
  return allErrors;
}</span>

<span style = "background-color:#fdd">bool Reader::pushError(const Value&amp; value, const String&amp; message) {
  ptrdiff_t const length = end_ - begin_;
  if (value.getOffsetStart() &gt; length || value.getOffsetLimit() &gt; length)
    return false;</span>
  Token token;
<span style = "background-color:#fdd">  token.type_ = tokenError;
  token.start_ = begin_ + value.getOffsetStart();
  token.end_ = begin_ + value.getOffsetLimit();
  ErrorInfo info;
  info.token_ = token;
  info.message_ = message;
  info.extra_ = nullptr;
  errors_.push_back(info);
  return true;
}</span>

bool Reader::pushError(const Value&amp; value, const String&amp; message,
<span style = "background-color:#fdd">                       const Value&amp; extra) {
  ptrdiff_t const length = end_ - begin_;
  if (value.getOffsetStart() &gt; length || value.getOffsetLimit() &gt; length ||</span>
      extra.getOffsetLimit() &gt; length)
<span style = "background-color:#fdd">    return false;</span>
  Token token;
<span style = "background-color:#fdd">  token.type_ = tokenError;
  token.start_ = begin_ + value.getOffsetStart();
  token.end_ = begin_ + value.getOffsetLimit();
  ErrorInfo info;
  info.token_ = token;
  info.message_ = message;
  info.extra_ = begin_ + extra.getOffsetStart();
  errors_.push_back(info);
  return true;
}</span>

<span style = "background-color:#fdd">bool Reader::good() const { return errors_.empty(); }</span>

// Originally copied from the Features class (now deprecated), used internally
// for features implementation.
class OurFeatures {
public:
  static OurFeatures all();
  bool allowComments_;
  bool allowTrailingCommas_;
  bool strictRoot_;
  bool allowDroppedNullPlaceholders_;
  bool allowNumericKeys_;
  bool allowSingleQuotes_;
  bool failIfExtra_;
  bool rejectDupKeys_;
  bool allowSpecialFloats_;
  bool skipBom_;
  size_t stackLimit_;
}; // OurFeatures

<span style = "background-color:#fdd">OurFeatures OurFeatures::all() { return {}; }</span>

// Implementation of class Reader
// ////////////////////////////////

// Originally copied from the Reader class (now deprecated), used internally
// for implementing JSON reading.
class OurReader {
public:
  using Char = char;
  using Location = const Char*;
  struct StructuredError {
    ptrdiff_t offset_start;
    ptrdiff_t offset_limit;
    String message;
  };

  explicit OurReader(OurFeatures const&amp; features);
  bool parse(const char* beginDoc, const char* endDoc, Value&amp; root,
             bool collectComments = true);
  String getFormattedErrorMessages() const;
  std::vector&lt;StructuredError&gt; getStructuredErrors() const;

private:
  OurReader(OurReader const&amp;);      // no impl
  void operator=(OurReader const&amp;); // no impl

  enum TokenType {
    tokenEndOfStream = 0,
    tokenObjectBegin,
    tokenObjectEnd,
    tokenArrayBegin,
    tokenArrayEnd,
    tokenString,
    tokenNumber,
    tokenTrue,
    tokenFalse,
    tokenNull,
    tokenNaN,
    tokenPosInf,
    tokenNegInf,
    tokenArraySeparator,
    tokenMemberSeparator,
    tokenComment,
    tokenError
  };

  class Token {
  public:
    TokenType type_;
    Location start_;
    Location end_;
  };

  class ErrorInfo {
  public:
    Token token_;
    String message_;
    Location extra_;
  };

  using Errors = std::deque&lt;ErrorInfo&gt;;

  bool readToken(Token&amp; token);
  void skipSpaces();
  void skipBom(bool skipBom);
  bool match(const Char* pattern, int patternLength);
  bool readComment();
  bool readCStyleComment(bool* containsNewLineResult);
  bool readCppStyleComment();
  bool readString();
  bool readStringSingleQuote();
  bool readNumber(bool checkInf);
  bool readValue();
  bool readObject(Token&amp; token);
  bool readArray(Token&amp; token);
  bool decodeNumber(Token&amp; token);
  bool decodeNumber(Token&amp; token, Value&amp; decoded);
  bool decodeString(Token&amp; token);
  bool decodeString(Token&amp; token, String&amp; decoded);
  bool decodeDouble(Token&amp; token);
  bool decodeDouble(Token&amp; token, Value&amp; decoded);
  bool decodeUnicodeCodePoint(Token&amp; token, Location&amp; current, Location end,
                              unsigned int&amp; unicode);
  bool decodeUnicodeEscapeSequence(Token&amp; token, Location&amp; current,
                                   Location end, unsigned int&amp; unicode);
  bool addError(const String&amp; message, Token&amp; token, Location extra = nullptr);
  bool recoverFromError(TokenType skipUntilToken);
  bool addErrorAndRecover(const String&amp; message, Token&amp; token,
                          TokenType skipUntilToken);
  void skipUntilSpace();
  Value&amp; currentValue();
  Char getNextChar();
  void getLocationLineAndColumn(Location location, int&amp; line,
                                int&amp; column) const;
  String getLocationLineAndColumn(Location location) const;
  void addComment(Location begin, Location end, CommentPlacement placement);
  void skipCommentTokens(Token&amp; token);

  static String normalizeEOL(Location begin, Location end);
  static bool containsNewLine(Location begin, Location end);

  using Nodes = std::stack&lt;Value*&gt;;

<span style = "background-color:#fdd">  Nodes nodes_{};
  Errors errors_{};
  String document_{};
  Location begin_ = nullptr;
  Location end_ = nullptr;
  Location current_ = nullptr;
  Location lastValueEnd_ = nullptr;
  Value* lastValue_ = nullptr;
  bool lastValueHasAComment_ = false;
  String commentsBefore_{};</span>

  OurFeatures const features_;
<span style = "background-color:#fdd">  bool collectComments_ = false;</span>
}; // OurReader

// complete copy of Read impl, for OurReader

bool OurReader::containsNewLine(OurReader::Location begin,
<span style = "background-color:#fdd">                                OurReader::Location end) {
  return std::any_of(begin, end, [](char b) { return b == '\n' || b == '\r'; });
}</span>

<span style = "background-color:#fdd">OurReader::OurReader(OurFeatures const&amp; features) : features_(features) {}</span>

bool OurReader::parse(const char* beginDoc, const char* endDoc, Value&amp; root,
<span style = "background-color:#fdd">                      bool collectComments) {
  if (!features_.allowComments_) {
    collectComments = false;</span>
  }

<span style = "background-color:#fdd">  begin_ = beginDoc;
  end_ = endDoc;
  collectComments_ = collectComments;
  current_ = begin_;
  lastValueEnd_ = nullptr;
  lastValue_ = nullptr;
  commentsBefore_.clear();
  errors_.clear();
  while (!nodes_.empty())
    nodes_.pop();
  nodes_.push(&amp;root);</span>

  // skip byte order mark if it exists at the beginning of the UTF-8 text.
<span style = "background-color:#fdd">  skipBom(features_.skipBom_);
  bool successful = readValue();
  nodes_.pop();</span>
  Token token;
<span style = "background-color:#fdd">  skipCommentTokens(token);
  if (features_.failIfExtra_ &amp;&amp; (token.type_ != tokenEndOfStream)) {
    addError("Extra non-whitespace after JSON value.", token);
    return false;</span>
  }
<span style = "background-color:#fdd">  if (collectComments_ &amp;&amp; !commentsBefore_.empty())
    root.setComment(commentsBefore_, commentAfter);
  if (features_.strictRoot_) {
    if (!root.isArray() &amp;&amp; !root.isObject()) {</span>
      // Set error location to start of doc, ideally should be first token found
      // in doc
<span style = "background-color:#fdd">      token.type_ = tokenError;
      token.start_ = beginDoc;
      token.end_ = endDoc;
      addError(</span>
          "A valid JSON document must be either an array or an object value.",
          token);
<span style = "background-color:#fdd">      return false;</span>
    }
  }
<span style = "background-color:#fdd">  return successful;
}</span>

<span style = "background-color:#fdd">bool OurReader::readValue() {</span>
  //  To preserve the old behaviour we cast size_t to int.
<span style = "background-color:#fdd">  if (nodes_.size() &gt; features_.stackLimit_)
    throwRuntimeError("Exceeded stackLimit in readValue().");</span>
  Token token;
<span style = "background-color:#fdd">  skipCommentTokens(token);
  bool successful = true;</span>

<span style = "background-color:#fdd">  if (collectComments_ &amp;&amp; !commentsBefore_.empty()) {
    currentValue().setComment(commentsBefore_, commentBefore);
    commentsBefore_.clear();</span>
  }

<span style = "background-color:#fdd">  switch (token.type_) {</span>
  case tokenObjectBegin:
<span style = "background-color:#fdd">    successful = readObject(token);
    currentValue().setOffsetLimit(current_ - begin_);
    break;</span>
  case tokenArrayBegin:
<span style = "background-color:#fdd">    successful = readArray(token);
    currentValue().setOffsetLimit(current_ - begin_);
    break;</span>
  case tokenNumber:
<span style = "background-color:#fdd">    successful = decodeNumber(token);
    break;</span>
  case tokenString:
<span style = "background-color:#fdd">    successful = decodeString(token);
    break;</span>
  case tokenTrue: {
<span style = "background-color:#fdd">    Value v(true);
    currentValue().swapPayload(v);
    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
  } break;</span>
  case tokenFalse: {
<span style = "background-color:#fdd">    Value v(false);
    currentValue().swapPayload(v);
    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
  } break;</span>
  case tokenNull: {
<span style = "background-color:#fdd">    Value v;
    currentValue().swapPayload(v);
    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
  } break;</span>
  case tokenNaN: {
<span style = "background-color:#fdd">    Value v(std::numeric_limits&lt;double&gt;::quiet_NaN());
    currentValue().swapPayload(v);
    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
  } break;</span>
  case tokenPosInf: {
<span style = "background-color:#fdd">    Value v(std::numeric_limits&lt;double&gt;::infinity());
    currentValue().swapPayload(v);
    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
  } break;</span>
  case tokenNegInf: {
<span style = "background-color:#fdd">    Value v(-std::numeric_limits&lt;double&gt;::infinity());
    currentValue().swapPayload(v);
    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
  } break;</span>
  case tokenArraySeparator:
  case tokenObjectEnd:
  case tokenArrayEnd:
<span style = "background-color:#fdd">    if (features_.allowDroppedNullPlaceholders_) {</span>
      // "Un-read" the current token and mark the current value as a null
      // token.
<span style = "background-color:#fdd">      current_--;
      Value v;
      currentValue().swapPayload(v);
      currentValue().setOffsetStart(current_ - begin_ - 1);
      currentValue().setOffsetLimit(current_ - begin_);
      break;
    } // else, fall through ...</span>
  default:
<span style = "background-color:#fdd">    currentValue().setOffsetStart(token.start_ - begin_);
    currentValue().setOffsetLimit(token.end_ - begin_);
    return addError("Syntax error: value, object or array expected.", token);</span>
  }

<span style = "background-color:#fdd">  if (collectComments_) {
    lastValueEnd_ = current_;
    lastValueHasAComment_ = false;
    lastValue_ = &amp;currentValue();</span>
  }

<span style = "background-color:#fdd">  return successful;
}</span>

<span style = "background-color:#fdd">void OurReader::skipCommentTokens(Token&amp; token) {
  if (features_.allowComments_) {</span>
    do {
<span style = "background-color:#fdd">      readToken(token);
    } while (token.type_ == tokenComment);
  } else {
    readToken(token);</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">bool OurReader::readToken(Token&amp; token) {
  skipSpaces();
  token.start_ = current_;
  Char c = getNextChar();
  bool ok = true;
  switch (c) {</span>
  case '{':
<span style = "background-color:#fdd">    token.type_ = tokenObjectBegin;
    break;</span>
  case '}':
<span style = "background-color:#fdd">    token.type_ = tokenObjectEnd;
    break;</span>
  case '[':
<span style = "background-color:#fdd">    token.type_ = tokenArrayBegin;
    break;</span>
  case ']':
<span style = "background-color:#fdd">    token.type_ = tokenArrayEnd;
    break;</span>
  case '"':
<span style = "background-color:#fdd">    token.type_ = tokenString;
    ok = readString();
    break;</span>
  case '\'':
<span style = "background-color:#fdd">    if (features_.allowSingleQuotes_) {
      token.type_ = tokenString;
      ok = readStringSingleQuote();
    } else {</span>
      // If we don't allow single quotes, this is a failure case.
<span style = "background-color:#fdd">      ok = false;</span>
    }
<span style = "background-color:#fdd">    break;</span>
  case '/':
<span style = "background-color:#fdd">    token.type_ = tokenComment;
    ok = readComment();
    break;</span>
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
<span style = "background-color:#fdd">    token.type_ = tokenNumber;
    readNumber(false);
    break;</span>
  case '-':
<span style = "background-color:#fdd">    if (readNumber(true)) {
      token.type_ = tokenNumber;
    } else {
      token.type_ = tokenNegInf;
      ok = features_.allowSpecialFloats_ &amp;&amp; match("nfinity", 7);</span>
    }
<span style = "background-color:#fdd">    break;</span>
  case '+':
<span style = "background-color:#fdd">    if (readNumber(true)) {
      token.type_ = tokenNumber;
    } else {
      token.type_ = tokenPosInf;
      ok = features_.allowSpecialFloats_ &amp;&amp; match("nfinity", 7);</span>
    }
<span style = "background-color:#fdd">    break;</span>
  case 't':
<span style = "background-color:#fdd">    token.type_ = tokenTrue;
    ok = match("rue", 3);
    break;</span>
  case 'f':
<span style = "background-color:#fdd">    token.type_ = tokenFalse;
    ok = match("alse", 4);
    break;</span>
  case 'n':
<span style = "background-color:#fdd">    token.type_ = tokenNull;
    ok = match("ull", 3);
    break;</span>
  case 'N':
<span style = "background-color:#fdd">    if (features_.allowSpecialFloats_) {
      token.type_ = tokenNaN;
      ok = match("aN", 2);
    } else {
      ok = false;</span>
    }
<span style = "background-color:#fdd">    break;</span>
  case 'I':
<span style = "background-color:#fdd">    if (features_.allowSpecialFloats_) {
      token.type_ = tokenPosInf;
      ok = match("nfinity", 7);
    } else {
      ok = false;</span>
    }
<span style = "background-color:#fdd">    break;</span>
  case ',':
<span style = "background-color:#fdd">    token.type_ = tokenArraySeparator;
    break;</span>
  case ':':
<span style = "background-color:#fdd">    token.type_ = tokenMemberSeparator;
    break;</span>
  case 0:
<span style = "background-color:#fdd">    token.type_ = tokenEndOfStream;
    break;</span>
  default:
<span style = "background-color:#fdd">    ok = false;</span>
    break;
  }
<span style = "background-color:#fdd">  if (!ok)
    token.type_ = tokenError;
  token.end_ = current_;
  return ok;
}</span>

<span style = "background-color:#fdd">void OurReader::skipSpaces() {
  while (current_ != end_) {
    Char c = *current_;
    if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
      ++current_;</span>
    else
<span style = "background-color:#fdd">      break;
  }
}</span>

<span style = "background-color:#fdd">void OurReader::skipBom(bool skipBom) {</span>
  // The default behavior is to skip BOM.
<span style = "background-color:#fdd">  if (skipBom) {
    if ((end_ - begin_) &gt;= 3 &amp;&amp; strncmp(begin_, "\xEF\xBB\xBF", 3) == 0) {
      begin_ += 3;
      current_ = begin_;</span>
    }
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">bool OurReader::match(const Char* pattern, int patternLength) {
  if (end_ - current_ &lt; patternLength)
    return false;
  int index = patternLength;
  while (index--)
    if (current_[index] != pattern[index])
      return false;
  current_ += patternLength;
  return true;
}</span>

<span style = "background-color:#fdd">bool OurReader::readComment() {
  const Location commentBegin = current_ - 1;
  const Char c = getNextChar();
  bool successful = false;
  bool cStyleWithEmbeddedNewline = false;</span>

<span style = "background-color:#fdd">  const bool isCStyleComment = (c == '*');
  const bool isCppStyleComment = (c == '/');
  if (isCStyleComment) {
    successful = readCStyleComment(&amp;cStyleWithEmbeddedNewline);
  } else if (isCppStyleComment) {
    successful = readCppStyleComment();</span>
  }

<span style = "background-color:#fdd">  if (!successful)
    return false;</span>

<span style = "background-color:#fdd">  if (collectComments_) {
    CommentPlacement placement = commentBefore;</span>

<span style = "background-color:#fdd">    if (!lastValueHasAComment_) {
      if (lastValueEnd_ &amp;&amp; !containsNewLine(lastValueEnd_, commentBegin)) {
        if (isCppStyleComment || !cStyleWithEmbeddedNewline) {
          placement = commentAfterOnSameLine;
          lastValueHasAComment_ = true;</span>
        }
      }
    }

<span style = "background-color:#fdd">    addComment(commentBegin, current_, placement);</span>
  }
<span style = "background-color:#fdd">  return true;
}</span>

String OurReader::normalizeEOL(OurReader::Location begin,
<span style = "background-color:#fdd">                               OurReader::Location end) {
  String normalized;
  normalized.reserve(static_cast&lt;size_t&gt;(end - begin));
  OurReader::Location current = begin;
  while (current != end) {
    char c = *current++;
    if (c == '\r') {
      if (current != end &amp;&amp; *current == '\n')</span>
        // convert dos EOL
<span style = "background-color:#fdd">        ++current;</span>
      // convert Mac EOL
<span style = "background-color:#fdd">      normalized += '\n';
    } else {
      normalized += c;</span>
    }
<span style = "background-color:#fdd">  }
  return normalized;
}</span>

void OurReader::addComment(Location begin, Location end,
<span style = "background-color:#fdd">                           CommentPlacement placement) {
  assert(collectComments_);
  const String&amp; normalized = normalizeEOL(begin, end);
  if (placement == commentAfterOnSameLine) {
    assert(lastValue_ != nullptr);
    lastValue_-&gt;setComment(normalized, placement);
  } else {
    commentsBefore_ += normalized;</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">bool OurReader::readCStyleComment(bool* containsNewLineResult) {
  *containsNewLineResult = false;</span>

<span style = "background-color:#fdd">  while ((current_ + 1) &lt; end_) {
    Char c = getNextChar();
    if (c == '*' &amp;&amp; *current_ == '/')
      break;
    if (c == '\n')
      *containsNewLineResult = true;
  }</span>

<span style = "background-color:#fdd">  return getNextChar() == '/';
}</span>

<span style = "background-color:#fdd">bool OurReader::readCppStyleComment() {
  while (current_ != end_) {
    Char c = getNextChar();
    if (c == '\n')
      break;
    if (c == '\r') {</span>
      // Consume DOS EOL. It will be normalized in addComment.
<span style = "background-color:#fdd">      if (current_ != end_ &amp;&amp; *current_ == '\n')
        getNextChar();</span>
      // Break on Moc OS 9 EOL.
<span style = "background-color:#fdd">      break;</span>
    }
<span style = "background-color:#fdd">  }
  return true;
}</span>

<span style = "background-color:#fdd">bool OurReader::readNumber(bool checkInf) {
  Location p = current_;
  if (checkInf &amp;&amp; p != end_ &amp;&amp; *p == 'I') {
    current_ = ++p;
    return false;</span>
  }
<span style = "background-color:#fdd">  char c = '0'; // stopgap for already consumed character</span>
  // integral part
<span style = "background-color:#fdd">  while (c &gt;= '0' &amp;&amp; c &lt;= '9')
    c = (current_ = p) &lt; end_ ? *p++ : '\0';</span>
  // fractional part
<span style = "background-color:#fdd">  if (c == '.') {
    c = (current_ = p) &lt; end_ ? *p++ : '\0';
    while (c &gt;= '0' &amp;&amp; c &lt;= '9')
      c = (current_ = p) &lt; end_ ? *p++ : '\0';</span>
  }
  // exponential part
<span style = "background-color:#fdd">  if (c == 'e' || c == 'E') {
    c = (current_ = p) &lt; end_ ? *p++ : '\0';
    if (c == '+' || c == '-')
      c = (current_ = p) &lt; end_ ? *p++ : '\0';
    while (c &gt;= '0' &amp;&amp; c &lt;= '9')
      c = (current_ = p) &lt; end_ ? *p++ : '\0';</span>
  }
<span style = "background-color:#fdd">  return true;
}
bool OurReader::readString() {
  Char c = 0;
  while (current_ != end_) {
    c = getNextChar();
    if (c == '\\')
      getNextChar();
    else if (c == '"')
      break;
  }
  return c == '"';
}</span>

<span style = "background-color:#fdd">bool OurReader::readStringSingleQuote() {
  Char c = 0;
  while (current_ != end_) {
    c = getNextChar();
    if (c == '\\')
      getNextChar();
    else if (c == '\'')
      break;
  }
  return c == '\'';
}</span>

<span style = "background-color:#fdd">bool OurReader::readObject(Token&amp; token) {</span>
  Token tokenName;
<span style = "background-color:#fdd">  String name;
  Value init(objectValue);
  currentValue().swapPayload(init);
  currentValue().setOffsetStart(token.start_ - begin_);
  while (readToken(tokenName)) {
    bool initialTokenOk = true;
    while (tokenName.type_ == tokenComment &amp;&amp; initialTokenOk)
      initialTokenOk = readToken(tokenName);
    if (!initialTokenOk)
      break;
    if (tokenName.type_ == tokenObjectEnd &amp;&amp;</span>
        (name.empty() ||
         features_.allowTrailingCommas_)) // empty object or trailing comma
<span style = "background-color:#fdd">      return true;
    name.clear();
    if (tokenName.type_ == tokenString) {
      if (!decodeString(tokenName, name))
        return recoverFromError(tokenObjectEnd);
    } else if (tokenName.type_ == tokenNumber &amp;&amp; features_.allowNumericKeys_) {
      Value numberName;
      if (!decodeNumber(tokenName, numberName))
        return recoverFromError(tokenObjectEnd);
      name = numberName.asString();
    } else {
      break;</span>
    }
<span style = "background-color:#fdd">    if (name.length() &gt;= (1U &lt;&lt; 30))
      throwRuntimeError("keylength &gt;= 2^30");
    if (features_.rejectDupKeys_ &amp;&amp; currentValue().isMember(name)) {
      String msg = "Duplicate key: '" + name + "'";
      return addErrorAndRecover(msg, tokenName, tokenObjectEnd);</span>
    }

    Token colon;
<span style = "background-color:#fdd">    if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
      return addErrorAndRecover("Missing ':' after object member name", colon,</span>
                                tokenObjectEnd);
    }
<span style = "background-color:#fdd">    Value&amp; value = currentValue()[name];
    nodes_.push(&amp;value);
    bool ok = readValue();
    nodes_.pop();
    if (!ok) // error already set
      return recoverFromError(tokenObjectEnd);</span>

    Token comma;
<span style = "background-color:#fdd">    if (!readToken(comma) ||</span>
        (comma.type_ != tokenObjectEnd &amp;&amp; comma.type_ != tokenArraySeparator &amp;&amp;
         comma.type_ != tokenComment)) {
<span style = "background-color:#fdd">      return addErrorAndRecover("Missing ',' or '}' in object declaration",</span>
                                comma, tokenObjectEnd);
    }
<span style = "background-color:#fdd">    bool finalizeTokenOk = true;
    while (comma.type_ == tokenComment &amp;&amp; finalizeTokenOk)
      finalizeTokenOk = readToken(comma);
    if (comma.type_ == tokenObjectEnd)
      return true;
  }
  return addErrorAndRecover("Missing '}' or object member name", tokenName,</span>
                            tokenObjectEnd);
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">bool OurReader::readArray(Token&amp; token) {
  Value init(arrayValue);
  currentValue().swapPayload(init);
  currentValue().setOffsetStart(token.start_ - begin_);
  int index = 0;</span>
  for (;;) {
<span style = "background-color:#fdd">    skipSpaces();
    if (current_ != end_ &amp;&amp; *current_ == ']' &amp;&amp;</span>
        (index == 0 ||
         (features_.allowTrailingCommas_ &amp;&amp;
          !features_.allowDroppedNullPlaceholders_))) // empty array or trailing
                                                      // comma
    {
      Token endArray;
<span style = "background-color:#fdd">      readToken(endArray);
      return true;</span>
    }
<span style = "background-color:#fdd">    Value&amp; value = currentValue()[index++];
    nodes_.push(&amp;value);
    bool ok = readValue();
    nodes_.pop();
    if (!ok) // error already set
      return recoverFromError(tokenArrayEnd);</span>

    Token currentToken;
    // Accept Comment after last item in the array.
<span style = "background-color:#fdd">    ok = readToken(currentToken);
    while (currentToken.type_ == tokenComment &amp;&amp; ok) {
      ok = readToken(currentToken);
    }
    bool badTokenType = (currentToken.type_ != tokenArraySeparator &amp;&amp;</span>
                         currentToken.type_ != tokenArrayEnd);
<span style = "background-color:#fdd">    if (!ok || badTokenType) {
      return addErrorAndRecover("Missing ',' or ']' in array declaration",</span>
                                currentToken, tokenArrayEnd);
    }
<span style = "background-color:#fdd">    if (currentToken.type_ == tokenArrayEnd)
      break;
  }
  return true;
}</span>

<span style = "background-color:#fdd">bool OurReader::decodeNumber(Token&amp; token) {
  Value decoded;
  if (!decodeNumber(token, decoded))
    return false;
  currentValue().swapPayload(decoded);
  currentValue().setOffsetStart(token.start_ - begin_);
  currentValue().setOffsetLimit(token.end_ - begin_);
  return true;
}</span>

<span style = "background-color:#fdd">bool OurReader::decodeNumber(Token&amp; token, Value&amp; decoded) {</span>
  // Attempts to parse the number as an integer. If the number is
  // larger than the maximum supported value of an integer then
  // we decode the number as a double.
<span style = "background-color:#fdd">  Location current = token.start_;
  const bool isNegative = *current == '-';
  if (isNegative) {
    ++current;</span>
  }

  // We assume we can represent the largest and smallest integer types as
  // unsigned integers with separate sign. This is only true if they can fit
  // into an unsigned integer.
  static_assert(Value::maxLargestInt &lt;= Value::maxLargestUInt,
                "Int must be smaller than UInt");

  // We need to convert minLargestInt into a positive number. The easiest way
  // to do this conversion is to assume our "threshold" value of minLargestInt
  // divided by 10 can fit in maxLargestInt when absolute valued. This should
  // be a safe assumption.
  static_assert(Value::minLargestInt &lt;= -Value::maxLargestInt,
                "The absolute value of minLargestInt must be greater than or "
                "equal to maxLargestInt");
  static_assert(Value::minLargestInt / 10 &gt;= -Value::maxLargestInt,
                "The absolute value of minLargestInt must be only 1 magnitude "
                "larger than maxLargest Int");

  static constexpr Value::LargestUInt positive_threshold =
      Value::maxLargestUInt / 10;
  static constexpr Value::UInt positive_last_digit = Value::maxLargestUInt % 10;

  // For the negative values, we have to be more careful. Since typically
  // -Value::minLargestInt will cause an overflow, we first divide by 10 and
  // then take the inverse. This assumes that minLargestInt is only a single
  // power of 10 different in magnitude, which we check above. For the last
  // digit, we take the modulus before negating for the same reason.
  static constexpr auto negative_threshold =
      Value::LargestUInt(-(Value::minLargestInt / 10));
  static constexpr auto negative_last_digit =
      Value::UInt(-(Value::minLargestInt % 10));

<span style = "background-color:#fdd">  const Value::LargestUInt threshold =</span>
      isNegative ? negative_threshold : positive_threshold;
<span style = "background-color:#fdd">  const Value::UInt max_last_digit =</span>
      isNegative ? negative_last_digit : positive_last_digit;

<span style = "background-color:#fdd">  Value::LargestUInt value = 0;
  while (current &lt; token.end_) {
    Char c = *current++;
    if (c &lt; '0' || c &gt; '9')
      return decodeDouble(token, decoded);</span>

<span style = "background-color:#fdd">    const auto digit(static_cast&lt;Value::UInt&gt;(c - '0'));
    if (value &gt;= threshold) {</span>
      // We've hit or exceeded the max value divided by 10 (rounded down). If
      // a) we've only just touched the limit, meaing value == threshold,
      // b) this is the last digit, or
      // c) it's small enough to fit in that rounding delta, we're okay.
      // Otherwise treat this number as a double to avoid overflow.
<span style = "background-color:#fdd">      if (value &gt; threshold || current != token.end_ ||</span>
          digit &gt; max_last_digit) {
<span style = "background-color:#fdd">        return decodeDouble(token, decoded);</span>
      }
    }
<span style = "background-color:#fdd">    value = value * 10 + digit;
  }</span>

<span style = "background-color:#fdd">  if (isNegative) {</span>
    // We use the same magnitude assumption here, just in case.
<span style = "background-color:#fdd">    const auto last_digit = static_cast&lt;Value::UInt&gt;(value % 10);
    decoded = -Value::LargestInt(value / 10) * 10 - last_digit;
  } else if (value &lt;= Value::LargestUInt(Value::maxLargestInt)) {
    decoded = Value::LargestInt(value);
  } else {
    decoded = value;</span>
  }

<span style = "background-color:#fdd">  return true;
}</span>

<span style = "background-color:#fdd">bool OurReader::decodeDouble(Token&amp; token) {
  Value decoded;
  if (!decodeDouble(token, decoded))
    return false;
  currentValue().swapPayload(decoded);
  currentValue().setOffsetStart(token.start_ - begin_);
  currentValue().setOffsetLimit(token.end_ - begin_);
  return true;
}</span>

<span style = "background-color:#fdd">bool OurReader::decodeDouble(Token&amp; token, Value&amp; decoded) {
  double value = 0;
  const String buffer(token.start_, token.end_);
  IStringStream is(buffer);
  if (!(is &gt;&gt; value)) {
    return addError(</span>
        "'" + String(token.start_, token.end_) + "' is not a number.", token);
  }
<span style = "background-color:#fdd">  decoded = value;
  return true;
}</span>

<span style = "background-color:#fdd">bool OurReader::decodeString(Token&amp; token) {
  String decoded_string;
  if (!decodeString(token, decoded_string))
    return false;
  Value decoded(decoded_string);
  currentValue().swapPayload(decoded);
  currentValue().setOffsetStart(token.start_ - begin_);
  currentValue().setOffsetLimit(token.end_ - begin_);
  return true;
}</span>

<span style = "background-color:#fdd">bool OurReader::decodeString(Token&amp; token, String&amp; decoded) {
  decoded.reserve(static_cast&lt;size_t&gt;(token.end_ - token.start_ - 2));
  Location current = token.start_ + 1; // skip '"'
  Location end = token.end_ - 1;       // do not include '"'
  while (current != end) {
    Char c = *current++;
    if (c == '"')
      break;
    if (c == '\\') {
      if (current == end)
        return addError("Empty escape sequence in string", token, current);
      Char escape = *current++;
      switch (escape) {</span>
      case '"':
<span style = "background-color:#fdd">        decoded += '"';
        break;</span>
      case '/':
<span style = "background-color:#fdd">        decoded += '/';
        break;</span>
      case '\\':
<span style = "background-color:#fdd">        decoded += '\\';
        break;</span>
      case 'b':
<span style = "background-color:#fdd">        decoded += '\b';
        break;</span>
      case 'f':
<span style = "background-color:#fdd">        decoded += '\f';
        break;</span>
      case 'n':
<span style = "background-color:#fdd">        decoded += '\n';
        break;</span>
      case 'r':
<span style = "background-color:#fdd">        decoded += '\r';
        break;</span>
      case 't':
<span style = "background-color:#fdd">        decoded += '\t';
        break;</span>
      case 'u': {
        unsigned int unicode;
<span style = "background-color:#fdd">        if (!decodeUnicodeCodePoint(token, current, end, unicode))
          return false;
        decoded += codePointToUTF8(unicode);
      } break;</span>
      default:
<span style = "background-color:#fdd">        return addError("Bad escape sequence in string", token, current);</span>
      }
<span style = "background-color:#fdd">    } else {
      decoded += c;</span>
    }
<span style = "background-color:#fdd">  }
  return true;
}</span>

bool OurReader::decodeUnicodeCodePoint(Token&amp; token, Location&amp; current,
<span style = "background-color:#fdd">                                       Location end, unsigned int&amp; unicode) {</span>

<span style = "background-color:#fdd">  if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
    return false;
  if (unicode &gt;= 0xD800 &amp;&amp; unicode &lt;= 0xDBFF) {</span>
    // surrogate pairs
<span style = "background-color:#fdd">    if (end - current &lt; 6)
      return addError(</span>
          "additional six characters expected to parse unicode surrogate pair.",
          token, current);
<span style = "background-color:#fdd">    if (*(current++) == '\\' &amp;&amp; *(current++) == 'u') {</span>
      unsigned int surrogatePair;
<span style = "background-color:#fdd">      if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
        unicode = 0x10000 + ((unicode &amp; 0x3FF) &lt;&lt; 10) + (surrogatePair &amp; 0x3FF);
      } else
        return false;
    } else
      return addError("expecting another \\u token to begin the second half of "</span>
                      "a unicode surrogate pair",
                      token, current);
  }
<span style = "background-color:#fdd">  return true;
}</span>

bool OurReader::decodeUnicodeEscapeSequence(Token&amp; token, Location&amp; current,
                                            Location end,
<span style = "background-color:#fdd">                                            unsigned int&amp; ret_unicode) {
  if (end - current &lt; 4)
    return addError(</span>
        "Bad unicode escape sequence in string: four digits expected.", token,
        current);
<span style = "background-color:#fdd">  int unicode = 0;
  for (int index = 0; index &lt; 4; ++index) {
    Char c = *current++;
    unicode *= 16;
    if (c &gt;= '0' &amp;&amp; c &lt;= '9')
      unicode += c - '0';
    else if (c &gt;= 'a' &amp;&amp; c &lt;= 'f')
      unicode += c - 'a' + 10;
    else if (c &gt;= 'A' &amp;&amp; c &lt;= 'F')
      unicode += c - 'A' + 10;</span>
    else
<span style = "background-color:#fdd">      return addError(</span>
          "Bad unicode escape sequence in string: hexadecimal digit expected.",
          token, current);
<span style = "background-color:#fdd">  }
  ret_unicode = static_cast&lt;unsigned int&gt;(unicode);
  return true;
}</span>

<span style = "background-color:#fdd">bool OurReader::addError(const String&amp; message, Token&amp; token, Location extra) {
  ErrorInfo info;
  info.token_ = token;
  info.message_ = message;
  info.extra_ = extra;
  errors_.push_back(info);
  return false;
}</span>

<span style = "background-color:#fdd">bool OurReader::recoverFromError(TokenType skipUntilToken) {
  size_t errorCount = errors_.size();</span>
  Token skip;
  for (;;) {
<span style = "background-color:#fdd">    if (!readToken(skip))
      errors_.resize(errorCount); // discard errors caused by recovery
    if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
      break;
  }
  errors_.resize(errorCount);
  return false;
}</span>

bool OurReader::addErrorAndRecover(const String&amp; message, Token&amp; token,
<span style = "background-color:#fdd">                                   TokenType skipUntilToken) {
  addError(message, token);
  return recoverFromError(skipUntilToken);
}</span>

<span style = "background-color:#fdd">Value&amp; OurReader::currentValue() { return *(nodes_.top()); }</span>

<span style = "background-color:#fdd">OurReader::Char OurReader::getNextChar() {
  if (current_ == end_)
    return 0;
  return *current_++;
}</span>

void OurReader::getLocationLineAndColumn(Location location, int&amp; line,
<span style = "background-color:#fdd">                                         int&amp; column) const {
  Location current = begin_;
  Location lastLineStart = current;
  line = 0;
  while (current &lt; location &amp;&amp; current != end_) {
    Char c = *current++;
    if (c == '\r') {
      if (*current == '\n')
        ++current;
      lastLineStart = current;
      ++line;
    } else if (c == '\n') {
      lastLineStart = current;
      ++line;</span>
    }
<span style = "background-color:#fdd">  }</span>
  // column &amp; line start at 1
<span style = "background-color:#fdd">  column = int(location - lastLineStart) + 1;
  ++line;
}</span>

<span style = "background-color:#fdd">String OurReader::getLocationLineAndColumn(Location location) const {</span>
  int line, column;
<span style = "background-color:#fdd">  getLocationLineAndColumn(location, line, column);</span>
  char buffer[18 + 16 + 16 + 1];
<span style = "background-color:#fdd">  jsoncpp_snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
  return buffer;
}</span>

<span style = "background-color:#fdd">String OurReader::getFormattedErrorMessages() const {
  String formattedMessage;
  for (const auto&amp; error : errors_) {
    formattedMessage +=</span>
        "* " + getLocationLineAndColumn(error.token_.start_) + "\n";
<span style = "background-color:#fdd">    formattedMessage += "  " + error.message_ + "\n";
    if (error.extra_)
      formattedMessage +=</span>
          "See " + getLocationLineAndColumn(error.extra_) + " for detail.\n";
<span style = "background-color:#fdd">  }
  return formattedMessage;
}</span>

<span style = "background-color:#fdd">std::vector&lt;OurReader::StructuredError&gt; OurReader::getStructuredErrors() const {
  std::vector&lt;OurReader::StructuredError&gt; allErrors;
  for (const auto&amp; error : errors_) {
    OurReader::StructuredError structured;
    structured.offset_start = error.token_.start_ - begin_;
    structured.offset_limit = error.token_.end_ - begin_;
    structured.message = error.message_;
    allErrors.push_back(structured);
  }
  return allErrors;
}</span>

class OurCharReader : public CharReader {
  bool const collectComments_;
  OurReader reader_;

public:
<span style = "background-color:#fdd">  OurCharReader(bool collectComments, OurFeatures const&amp; features)
      : collectComments_(collectComments), reader_(features) {}</span>
  bool parse(char const* beginDoc, char const* endDoc, Value* root,
<span style = "background-color:#fdd">             String* errs) override {
    bool ok = reader_.parse(beginDoc, endDoc, *root, collectComments_);
    if (errs) {
      *errs = reader_.getFormattedErrorMessages();</span>
    }
<span style = "background-color:#fdd">    return ok;
  }</span>
};

<span style = "background-color:#fdd">CharReaderBuilder::CharReaderBuilder() { setDefaults(&amp;settings_); }
CharReaderBuilder::~CharReaderBuilder() = default;
CharReader* CharReaderBuilder::newCharReader() const {
  bool collectComments = settings_["collectComments"].asBool();
  OurFeatures features = OurFeatures::all();
  features.allowComments_ = settings_["allowComments"].asBool();
  features.allowTrailingCommas_ = settings_["allowTrailingCommas"].asBool();
  features.strictRoot_ = settings_["strictRoot"].asBool();
  features.allowDroppedNullPlaceholders_ =</span>
      settings_["allowDroppedNullPlaceholders"].asBool();
<span style = "background-color:#fdd">  features.allowNumericKeys_ = settings_["allowNumericKeys"].asBool();
  features.allowSingleQuotes_ = settings_["allowSingleQuotes"].asBool();</span>

  // Stack limit is always a size_t, so we get this as an unsigned int
  // regardless of it we have 64-bit integer support enabled.
<span style = "background-color:#fdd">  features.stackLimit_ = static_cast&lt;size_t&gt;(settings_["stackLimit"].asUInt());
  features.failIfExtra_ = settings_["failIfExtra"].asBool();
  features.rejectDupKeys_ = settings_["rejectDupKeys"].asBool();
  features.allowSpecialFloats_ = settings_["allowSpecialFloats"].asBool();
  features.skipBom_ = settings_["skipBom"].asBool();
  return new OurCharReader(collectComments, features);
}</span>

<span style = "background-color:#fdd">bool CharReaderBuilder::validate(Json::Value* invalid) const {
  static const auto&amp; valid_keys = *new std::set&lt;String&gt;{</span>
      "collectComments",
      "allowComments",
      "allowTrailingCommas",
      "strictRoot",
      "allowDroppedNullPlaceholders",
      "allowNumericKeys",
      "allowSingleQuotes",
      "stackLimit",
      "failIfExtra",
      "rejectDupKeys",
      "allowSpecialFloats",
      "skipBom",
  };
<span style = "background-color:#fdd">  for (auto si = settings_.begin(); si != settings_.end(); ++si) {
    auto key = si.name();
    if (valid_keys.count(key))
      continue;
    if (invalid)
      (*invalid)[key] = *si;</span>
    else
<span style = "background-color:#fdd">      return false;
  }
  return invalid ? invalid-&gt;empty() : true;
}</span>

<span style = "background-color:#fdd">Value&amp; CharReaderBuilder::operator[](const String&amp; key) {
  return settings_[key];
}</span>
// static
<span style = "background-color:#fdd">void CharReaderBuilder::strictMode(Json::Value* settings) {</span>
  //! [CharReaderBuilderStrictMode]
<span style = "background-color:#fdd">  (*settings)["allowComments"] = false;
  (*settings)["allowTrailingCommas"] = false;
  (*settings)["strictRoot"] = true;
  (*settings)["allowDroppedNullPlaceholders"] = false;
  (*settings)["allowNumericKeys"] = false;
  (*settings)["allowSingleQuotes"] = false;
  (*settings)["stackLimit"] = 1000;
  (*settings)["failIfExtra"] = true;
  (*settings)["rejectDupKeys"] = true;
  (*settings)["allowSpecialFloats"] = false;
  (*settings)["skipBom"] = true;</span>
  //! [CharReaderBuilderStrictMode]
<span style = "background-color:#fdd">}</span>
// static
<span style = "background-color:#fdd">void CharReaderBuilder::setDefaults(Json::Value* settings) {</span>
  //! [CharReaderBuilderDefaults]
<span style = "background-color:#fdd">  (*settings)["collectComments"] = true;
  (*settings)["allowComments"] = true;
  (*settings)["allowTrailingCommas"] = true;
  (*settings)["strictRoot"] = false;
  (*settings)["allowDroppedNullPlaceholders"] = false;
  (*settings)["allowNumericKeys"] = false;
  (*settings)["allowSingleQuotes"] = false;
  (*settings)["stackLimit"] = 1000;
  (*settings)["failIfExtra"] = false;
  (*settings)["rejectDupKeys"] = false;
  (*settings)["allowSpecialFloats"] = false;
  (*settings)["skipBom"] = true;</span>
  //! [CharReaderBuilderDefaults]
<span style = "background-color:#fdd">}</span>

//////////////////////////////////
// global functions

bool parseFromStream(CharReader::Factory const&amp; fact, IStream&amp; sin, Value* root,
<span style = "background-color:#fdd">                     String* errs) {
  OStringStream ssin;
  ssin &lt;&lt; sin.rdbuf();
  String doc = ssin.str();
  char const* begin = doc.data();
  char const* end = begin + doc.size();</span>
  // Note that we do not actually need a null-terminator.
<span style = "background-color:#fdd">  CharReaderPtr const reader(fact.newCharReader());
  return reader-&gt;parse(begin, end, root, errs);
}</span>

<span style = "background-color:#fdd">IStream&amp; operator&gt;&gt;(IStream&amp; sin, Value&amp; root) {
  CharReaderBuilder b;
  String errs;
  bool ok = parseFromStream(b, sin, &amp;root, &amp;errs);
  if (!ok) {
    throwRuntimeError(errs);</span>
  }
<span style = "background-color:#fdd">  return sin;
}</span>

} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_reader.cpp
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_valueiterator.inl
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

// included by json_value.cpp

namespace Json {

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class ValueIteratorBase
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

<span style = "background-color:#fdd">ValueIteratorBase::ValueIteratorBase() : current_() {}</span>

ValueIteratorBase::ValueIteratorBase(
    const Value::ObjectValues::iterator&amp; current)
<span style = "background-color:#dfd">    : current_(current), isNull_(false) {}</span>

<span style = "background-color:#fdd">Value&amp; ValueIteratorBase::deref() { return current_-&gt;second; }</span>
<span style = "background-color:#dfd">const Value&amp; ValueIteratorBase::deref() const { return current_-&gt;second; }</span>

<span style = "background-color:#dfd">void ValueIteratorBase::increment() { ++current_; }</span>

<span style = "background-color:#fdd">void ValueIteratorBase::decrement() { --current_; }</span>

ValueIteratorBase::difference_type
<span style = "background-color:#fdd">ValueIteratorBase::computeDistance(const SelfType&amp; other) const {</span>
  // Iterator for null value are initialized using the default
  // constructor, which initialize current_ to the default
  // std::map::iterator. As begin() and end() are two instance
  // of the default std::map::iterator, they can not be compared.
  // To allow this, we handle this comparison specifically.
<span style = "background-color:#fdd">  if (isNull_ &amp;&amp; other.isNull_) {
    return 0;</span>
  }

  // Usage of std::distance is not portable (does not compile with Sun Studio 12
  // RogueWave STL,
  // which is the one used by default).
  // Using a portable hand-made version for non random iterator instead:
  //   return difference_type( std::distance( current_, other.current_ ) );
<span style = "background-color:#fdd">  difference_type myDistance = 0;
  for (Value::ObjectValues::iterator it = current_; it != other.current_;
       ++it) {
    ++myDistance;
  }
  return myDistance;
}</span>

<span style = "background-color:#dfd">bool ValueIteratorBase::isEqual(const SelfType&amp; other) const {
  if (isNull_) {</span>
<span style = "background-color:#fdd">    return other.isNull_;</span>
  }
<span style = "background-color:#dfd">  return current_ == other.current_;
}</span>

<span style = "background-color:#fdd">void ValueIteratorBase::copy(const SelfType&amp; other) {
  current_ = other.current_;
  isNull_ = other.isNull_;
}</span>

<span style = "background-color:#fdd">Value ValueIteratorBase::key() const {
  const Value::CZString czstring = (*current_).first;
  if (czstring.data()) {
    if (czstring.isStaticString())
      return Value(StaticString(czstring.data()));
    return Value(czstring.data(), czstring.data() + czstring.length());</span>
  }
<span style = "background-color:#fdd">  return Value(czstring.index());
}</span>

<span style = "background-color:#fdd">UInt ValueIteratorBase::index() const {
  const Value::CZString czstring = (*current_).first;
  if (!czstring.data())
    return czstring.index();
  return Value::UInt(-1);
}</span>

<span style = "background-color:#dfd">String ValueIteratorBase::name() const {</span>
  char const* keey;
  char const* end;
<span style = "background-color:#dfd">  keey = memberName(&amp;end);
  if (!keey)</span>
<span style = "background-color:#fdd">    return String();</span>
<span style = "background-color:#dfd">  return String(keey, end);
}</span>

<span style = "background-color:#fdd">char const* ValueIteratorBase::memberName() const {
  const char* cname = (*current_).first.data();
  return cname ? cname : "";
}</span>

<span style = "background-color:#dfd">char const* ValueIteratorBase::memberName(char const** end) const {
  const char* cname = (*current_).first.data();
  if (!cname) {</span>
<span style = "background-color:#fdd">    *end = nullptr;
    return nullptr;</span>
  }
<span style = "background-color:#dfd">  *end = cname + (*current_).first.length();
  return cname;
}</span>

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class ValueConstIterator
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

<span style = "background-color:#fdd">ValueConstIterator::ValueConstIterator() = default;</span>

ValueConstIterator::ValueConstIterator(
    const Value::ObjectValues::iterator&amp; current)
<span style = "background-color:#dfd">    : ValueIteratorBase(current) {}</span>

ValueConstIterator::ValueConstIterator(ValueIterator const&amp; other)
<span style = "background-color:#fdd">    : ValueIteratorBase(other) {}</span>

ValueConstIterator&amp; ValueConstIterator::
<span style = "background-color:#fdd">operator=(const ValueIteratorBase&amp; other) {
  copy(other);
  return *this;
}</span>

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class ValueIterator
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

<span style = "background-color:#fdd">ValueIterator::ValueIterator() = default;</span>

ValueIterator::ValueIterator(const Value::ObjectValues::iterator&amp; current)
<span style = "background-color:#fdd">    : ValueIteratorBase(current) {}</span>

ValueIterator::ValueIterator(const ValueConstIterator&amp; other)
<span style = "background-color:#fdd">    : ValueIteratorBase(other) {
  throwRuntimeError("ConstIterator to Iterator should never be allowed.");
}</span>

<span style = "background-color:#fdd">ValueIterator::ValueIterator(const ValueIterator&amp; other) = default;</span>

<span style = "background-color:#fdd">ValueIterator&amp; ValueIterator::operator=(const SelfType&amp; other) {
  copy(other);
  return *this;
}</span>

} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_valueiterator.inl
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_value.cpp
// //////////////////////////////////////////////////////////////////////

// Copyright 2011 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#if !defined(JSON_IS_AMALGAMATION)
#include &lt;json/assertions.h&gt;
#include &lt;json/value.h&gt;
#include &lt;json/writer.h&gt;
#endif // if !defined(JSON_IS_AMALGAMATION)
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;cstddef&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;utility&gt;

// Provide implementation equivalent of std::snprintf for older _MSC compilers
#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900
#include &lt;stdarg.h&gt;
static int msvc_pre1900_c99_vsnprintf(char* outBuf, size_t size,
                                      const char* format, va_list ap) {
  int count = -1;
  if (size != 0)
    count = _vsnprintf_s(outBuf, size, _TRUNCATE, format, ap);
  if (count == -1)
    count = _vscprintf(format, ap);
  return count;
}

int JSON_API msvc_pre1900_c99_snprintf(char* outBuf, size_t size,
                                       const char* format, ...) {
  va_list ap;
  va_start(ap, format);
  const int count = msvc_pre1900_c99_vsnprintf(outBuf, size, format, ap);
  va_end(ap);
  return count;
}
#endif

// Disable warning C4702 : unreachable code
#if defined(_MSC_VER)
#pragma warning(disable : 4702)
#endif

#define JSON_ASSERT_UNREACHABLE assert(false)

namespace Json {
template &lt;typename T&gt;
<span style = "background-color:#dfd">static std::unique_ptr&lt;T&gt; cloneUnique(const std::unique_ptr&lt;T&gt;&amp; p) {
  std::unique_ptr&lt;T&gt; r;
  if (p) {</span>
<span style = "background-color:#fdd">    r = std::unique_ptr&lt;T&gt;(new T(*p));</span>
  }
<span style = "background-color:#dfd">  return r;
}</span>

// This is a walkaround to avoid the static initialization of Value::null.
// kNull must be word-aligned to avoid crashing on ARM.  We use an alignment of
// 8 (instead of 4) as a bit of future-proofing.
#if defined(__ARMEL__)
#define ALIGNAS(byte_alignment) __attribute__((aligned(byte_alignment)))
#else
#define ALIGNAS(byte_alignment)
#endif

// static
<span style = "background-color:#dfd">Value const&amp; Value::nullSingleton() {
  static Value const nullStatic;
  return nullStatic;
}</span>

#if JSON_USE_NULLREF
// for backwards compatibility, we'll leave these global references around, but
// DO NOT use them in JSONCPP library code any more!
// static
<span style = "background-color:#dfd">Value const&amp; Value::null = Value::nullSingleton();</span>

// static
<span style = "background-color:#dfd">Value const&amp; Value::nullRef = Value::nullSingleton();</span>
#endif

#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
template &lt;typename T, typename U&gt;
<span style = "background-color:#fdd">static inline bool InRange(double d, T min, U max) {</span>
  // The casts can lose precision, but we are looking only for
  // an approximate range. Might fail on edge cases though. ~cdunn
<span style = "background-color:#fdd">  return d &gt;= static_cast&lt;double&gt;(min) &amp;&amp; d &lt;= static_cast&lt;double&gt;(max);
}</span>
#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
static inline double integerToDouble(Json::UInt64 value) {
  return static_cast&lt;double&gt;(Int64(value / 2)) * 2.0 +
         static_cast&lt;double&gt;(Int64(value &amp; 1));
}

template &lt;typename T&gt; static inline double integerToDouble(T value) {
  return static_cast&lt;double&gt;(value);
}

template &lt;typename T, typename U&gt;
static inline bool InRange(double d, T min, U max) {
  return d &gt;= integerToDouble(min) &amp;&amp; d &lt;= integerToDouble(max);
}
#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)

/** Duplicates the specified string value.
 * @param value Pointer to the string to duplicate. Must be zero-terminated if
 *              length is "unknown".
 * @param length Length of the value. if equals to unknown, then it will be
 *               computed using strlen(value).
 * @return Pointer on the duplicate instance of string.
 */
<span style = "background-color:#dfd">static inline char* duplicateStringValue(const char* value, size_t length) {</span>
  // Avoid an integer overflow in the call to malloc below by limiting length
  // to a sane value.
<span style = "background-color:#dfd">  if (length &gt;= static_cast&lt;size_t&gt;(Value::maxInt))</span>
<span style = "background-color:#fdd">    length = Value::maxInt - 1;</span>

<span style = "background-color:#dfd">  auto newString = static_cast&lt;char*&gt;(malloc(length + 1));
  if (newString == nullptr) {</span>
<span style = "background-color:#fdd">    throwRuntimeError("in Json::Value::duplicateStringValue(): "</span>
                      "Failed to allocate string value buffer");
  }
<span style = "background-color:#dfd">  memcpy(newString, value, length);
  newString[length] = 0;
  return newString;
}</span>

/* Record the length as a prefix.
 */
static inline char* duplicateAndPrefixStringValue(const char* value,
<span style = "background-color:#dfd">                                                  unsigned int length) {</span>
  // Avoid an integer overflow in the call to malloc below by limiting length
  // to a sane value.
<span style = "background-color:#dfd">  JSON_ASSERT_MESSAGE(length &lt;= static_cast&lt;unsigned&gt;(Value::maxInt) -</span>
                                    sizeof(unsigned) - 1U,
                      "in Json::Value::duplicateAndPrefixStringValue(): "
                      "length too big for prefixing");
<span style = "background-color:#dfd">  size_t actualLength = sizeof(length) + length + 1;
  auto newString = static_cast&lt;char*&gt;(malloc(actualLength));
  if (newString == nullptr) {</span>
<span style = "background-color:#fdd">    throwRuntimeError("in Json::Value::duplicateAndPrefixStringValue(): "</span>
                      "Failed to allocate string value buffer");
  }
<span style = "background-color:#dfd">  *reinterpret_cast&lt;unsigned*&gt;(newString) = length;
  memcpy(newString + sizeof(unsigned), value, length);
  newString[actualLength - 1U] =</span>
      0; // to avoid buffer over-run accidents by users later
<span style = "background-color:#dfd">  return newString;
}</span>
inline static void decodePrefixedString(bool isPrefixed, char const* prefixed,
<span style = "background-color:#dfd">                                        unsigned* length, char const** value) {
  if (!isPrefixed) {</span>
<span style = "background-color:#fdd">    *length = static_cast&lt;unsigned&gt;(strlen(prefixed));
    *value = prefixed;
  } else {</span>
<span style = "background-color:#dfd">    *length = *reinterpret_cast&lt;unsigned const*&gt;(prefixed);
    *value = prefixed + sizeof(unsigned);</span>
  }
<span style = "background-color:#dfd">}</span>
/** Free the string duplicated by
 * duplicateStringValue()/duplicateAndPrefixStringValue().
 */
#if JSONCPP_USING_SECURE_MEMORY
static inline void releasePrefixedStringValue(char* value) {
  unsigned length = 0;
  char const* valueDecoded;
  decodePrefixedString(true, value, &amp;length, &amp;valueDecoded);
  size_t const size = sizeof(unsigned) + length + 1U;
  memset(value, 0, size);
  free(value);
}
static inline void releaseStringValue(char* value, unsigned length) {
  // length==0 =&gt; we allocated the strings memory
  size_t size = (length == 0) ? strlen(value) : length;
  memset(value, 0, size);
  free(value);
}
#else  // !JSONCPP_USING_SECURE_MEMORY
<span style = "background-color:#dfd">static inline void releasePrefixedStringValue(char* value) { free(value); }
static inline void releaseStringValue(char* value, unsigned) { free(value); }</span>
#endif // JSONCPP_USING_SECURE_MEMORY

} // namespace Json

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// ValueInternals...
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
#if !defined(JSON_IS_AMALGAMATION)

#include "json_valueiterator.inl"
#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {

#if JSON_USE_EXCEPTION
<span style = "background-color:#fdd">Exception::Exception(String msg) : msg_(std::move(msg)) {}
Exception::~Exception() noexcept = default;
char const* Exception::what() const noexcept { return msg_.c_str(); }
RuntimeError::RuntimeError(String const&amp; msg) : Exception(msg) {}
LogicError::LogicError(String const&amp; msg) : Exception(msg) {}
JSONCPP_NORETURN void throwRuntimeError(String const&amp; msg) {
  throw RuntimeError(msg);
}
JSONCPP_NORETURN void throwLogicError(String const&amp; msg) {
  throw LogicError(msg);
}</span>
#else // !JSON_USE_EXCEPTION
JSONCPP_NORETURN void throwRuntimeError(String const&amp; msg) {
  std::cerr &lt;&lt; msg &lt;&lt; std::endl;
  abort();
}
JSONCPP_NORETURN void throwLogicError(String const&amp; msg) {
  std::cerr &lt;&lt; msg &lt;&lt; std::endl;
  abort();
}
#endif

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class Value::CZString
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

// Notes: policy_ indicates if the string was allocated when
// a string is stored.

<span style = "background-color:#fdd">Value::CZString::CZString(ArrayIndex index) : cstr_(nullptr), index_(index) {}</span>

Value::CZString::CZString(char const* str, unsigned length,
                          DuplicationPolicy allocate)
<span style = "background-color:#dfd">    : cstr_(str) {</span>
  // allocate != duplicate
<span style = "background-color:#dfd">  storage_.policy_ = allocate &amp; 0x3;
  storage_.length_ = length &amp; 0x3FFFFFFF;
}</span>

<span style = "background-color:#dfd">Value::CZString::CZString(const CZString&amp; other) {
  cstr_ = (other.storage_.policy_ != noDuplication &amp;&amp; other.cstr_ != nullptr</span>
               ? duplicateStringValue(other.cstr_, other.storage_.length_)
               : other.cstr_);
<span style = "background-color:#dfd">  storage_.policy_ =</span>
      static_cast&lt;unsigned&gt;(
          other.cstr_
              ? (static_cast&lt;DuplicationPolicy&gt;(other.storage_.policy_) ==
                         noDuplication
                     ? noDuplication
                     : duplicate)
              : static_cast&lt;DuplicationPolicy&gt;(other.storage_.policy_)) &amp;
      3U;
<span style = "background-color:#dfd">  storage_.length_ = other.storage_.length_;
}</span>

Value::CZString::CZString(CZString&amp;&amp; other) noexcept
<span style = "background-color:#fdd">    : cstr_(other.cstr_), index_(other.index_) {
  other.cstr_ = nullptr;
}</span>

<span style = "background-color:#dfd">Value::CZString::~CZString() {
  if (cstr_ &amp;&amp; storage_.policy_ == duplicate) {
    releaseStringValue(const_cast&lt;char*&gt;(cstr_),</span>
                       storage_.length_ + 1U); // +1 for null terminating
                                               // character for sake of
                                               // completeness but not actually
                                               // necessary
  }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#fdd">void Value::CZString::swap(CZString&amp; other) {
  std::swap(cstr_, other.cstr_);
  std::swap(index_, other.index_);
}</span>

<span style = "background-color:#fdd">Value::CZString&amp; Value::CZString::operator=(const CZString&amp; other) {
  cstr_ = other.cstr_;
  index_ = other.index_;
  return *this;
}</span>

<span style = "background-color:#fdd">Value::CZString&amp; Value::CZString::operator=(CZString&amp;&amp; other) noexcept {
  cstr_ = other.cstr_;
  index_ = other.index_;
  other.cstr_ = nullptr;
  return *this;
}</span>

<span style = "background-color:#fdd">bool Value::CZString::operator&lt;(const CZString&amp; other) const {
  if (!cstr_)
    return index_ &lt; other.index_;</span>
  // return strcmp(cstr_, other.cstr_) &lt; 0;
  // Assume both are strings.
<span style = "background-color:#fdd">  unsigned this_len = this-&gt;storage_.length_;
  unsigned other_len = other.storage_.length_;
  unsigned min_len = std::min&lt;unsigned&gt;(this_len, other_len);
  JSON_ASSERT(this-&gt;cstr_ &amp;&amp; other.cstr_);
  int comp = memcmp(this-&gt;cstr_, other.cstr_, min_len);
  if (comp &lt; 0)
    return true;
  if (comp &gt; 0)
    return false;
  return (this_len &lt; other_len);
}</span>

<span style = "background-color:#fdd">bool Value::CZString::operator==(const CZString&amp; other) const {
  if (!cstr_)
    return index_ == other.index_;</span>
  // return strcmp(cstr_, other.cstr_) == 0;
  // Assume both are strings.
<span style = "background-color:#fdd">  unsigned this_len = this-&gt;storage_.length_;
  unsigned other_len = other.storage_.length_;
  if (this_len != other_len)
    return false;
  JSON_ASSERT(this-&gt;cstr_ &amp;&amp; other.cstr_);
  int comp = memcmp(this-&gt;cstr_, other.cstr_, this_len);
  return comp == 0;
}</span>

<span style = "background-color:#fdd">ArrayIndex Value::CZString::index() const { return index_; }</span>

// const char* Value::CZString::c_str() const { return cstr_; }
<span style = "background-color:#dfd">const char* Value::CZString::data() const { return cstr_; }
unsigned Value::CZString::length() const { return storage_.length_; }</span>
<span style = "background-color:#fdd">bool Value::CZString::isStaticString() const {
  return storage_.policy_ == noDuplication;
}</span>

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class Value::Value
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

/*! \internal Default constructor initialization must be equivalent to:
 * memset( this, 0, sizeof(Value) )
 * This optimization is used in ValueInternalMap fast allocator.
 */
<span style = "background-color:#dfd">Value::Value(ValueType type) {</span>
  static char const emptyString[] = "";
<span style = "background-color:#dfd">  initBasic(type);
  switch (type) {</span>
  case nullValue:
<span style = "background-color:#dfd">    break;</span>
  case intValue:
  case uintValue:
<span style = "background-color:#fdd">    value_.int_ = 0;
    break;</span>
  case realValue:
<span style = "background-color:#fdd">    value_.real_ = 0.0;
    break;</span>
  case stringValue:
    // allocated_ == false, so this is safe.
<span style = "background-color:#fdd">    value_.string_ = const_cast&lt;char*&gt;(static_cast&lt;char const*&gt;(emptyString));
    break;</span>
  case arrayValue:
  case objectValue:
<span style = "background-color:#dfd">    value_.map_ = new ObjectValues();
    break;</span>
  case booleanValue:
<span style = "background-color:#fdd">    value_.bool_ = false;
    break;</span>
  default:
<span style = "background-color:#fdd">    JSON_ASSERT_UNREACHABLE;</span>
  }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#fdd">Value::Value(Int value) {
  initBasic(intValue);
  value_.int_ = value;
}</span>

<span style = "background-color:#fdd">Value::Value(UInt value) {
  initBasic(uintValue);
  value_.uint_ = value;
}</span>
#if defined(JSON_HAS_INT64)
<span style = "background-color:#fdd">Value::Value(Int64 value) {
  initBasic(intValue);
  value_.int_ = value;
}
Value::Value(UInt64 value) {
  initBasic(uintValue);
  value_.uint_ = value;
}</span>
#endif // defined(JSON_HAS_INT64)

<span style = "background-color:#fdd">Value::Value(double value) {
  initBasic(realValue);
  value_.real_ = value;
}</span>

<span style = "background-color:#fdd">Value::Value(const char* value) {
  initBasic(stringValue, true);
  JSON_ASSERT_MESSAGE(value != nullptr,</span>
                      "Null Value Passed to Value Constructor");
<span style = "background-color:#fdd">  value_.string_ = duplicateAndPrefixStringValue(</span>
      value, static_cast&lt;unsigned&gt;(strlen(value)));
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">Value::Value(const char* begin, const char* end) {
  initBasic(stringValue, true);
  value_.string_ =</span>
      duplicateAndPrefixStringValue(begin, static_cast&lt;unsigned&gt;(end - begin));
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#dfd">Value::Value(const String&amp; value) {
  initBasic(stringValue, true);
  value_.string_ = duplicateAndPrefixStringValue(</span>
      value.data(), static_cast&lt;unsigned&gt;(value.length()));
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#fdd">Value::Value(const StaticString&amp; value) {
  initBasic(stringValue);
  value_.string_ = const_cast&lt;char*&gt;(value.c_str());
}</span>

<span style = "background-color:#fdd">Value::Value(bool value) {
  initBasic(booleanValue);
  value_.bool_ = value;
}</span>

<span style = "background-color:#dfd">Value::Value(const Value&amp; other) {
  dupPayload(other);
  dupMeta(other);
}</span>

<span style = "background-color:#fdd">Value::Value(Value&amp;&amp; other) noexcept {
  initBasic(nullValue);
  swap(other);
}</span>

<span style = "background-color:#dfd">Value::~Value() {
  releasePayload();
  value_.uint_ = 0;
}</span>

<span style = "background-color:#fdd">Value&amp; Value::operator=(const Value&amp; other) {
  Value(other).swap(*this);
  return *this;
}</span>

<span style = "background-color:#fdd">Value&amp; Value::operator=(Value&amp;&amp; other) noexcept {
  other.swap(*this);
  return *this;
}</span>

<span style = "background-color:#dfd">void Value::swapPayload(Value&amp; other) {
  std::swap(bits_, other.bits_);
  std::swap(value_, other.value_);
}</span>

<span style = "background-color:#fdd">void Value::copyPayload(const Value&amp; other) {
  releasePayload();
  dupPayload(other);
}</span>

<span style = "background-color:#fdd">void Value::swap(Value&amp; other) {
  swapPayload(other);
  std::swap(comments_, other.comments_);
  std::swap(start_, other.start_);
  std::swap(limit_, other.limit_);
}</span>

<span style = "background-color:#fdd">void Value::copy(const Value&amp; other) {
  copyPayload(other);
  dupMeta(other);
}</span>

<span style = "background-color:#dfd">ValueType Value::type() const {
  return static_cast&lt;ValueType&gt;(bits_.value_type_);
}</span>

<span style = "background-color:#fdd">int Value::compare(const Value&amp; other) const {
  if (*this &lt; other)
    return -1;
  if (*this &gt; other)
    return 1;
  return 0;
}</span>

<span style = "background-color:#fdd">bool Value::operator&lt;(const Value&amp; other) const {
  int typeDelta = type() - other.type();
  if (typeDelta)
    return typeDelta &lt; 0;
  switch (type()) {</span>
  case nullValue:
<span style = "background-color:#fdd">    return false;</span>
  case intValue:
<span style = "background-color:#fdd">    return value_.int_ &lt; other.value_.int_;</span>
  case uintValue:
<span style = "background-color:#fdd">    return value_.uint_ &lt; other.value_.uint_;</span>
  case realValue:
<span style = "background-color:#fdd">    return value_.real_ &lt; other.value_.real_;</span>
  case booleanValue:
<span style = "background-color:#fdd">    return value_.bool_ &lt; other.value_.bool_;</span>
  case stringValue: {
<span style = "background-color:#fdd">    if ((value_.string_ == nullptr) || (other.value_.string_ == nullptr)) {
      return other.value_.string_ != nullptr;</span>
    }
    unsigned this_len;
    unsigned other_len;
    char const* this_str;
    char const* other_str;
<span style = "background-color:#fdd">    decodePrefixedString(this-&gt;isAllocated(), this-&gt;value_.string_, &amp;this_len,</span>
                         &amp;this_str);
<span style = "background-color:#fdd">    decodePrefixedString(other.isAllocated(), other.value_.string_, &amp;other_len,</span>
                         &amp;other_str);
<span style = "background-color:#fdd">    unsigned min_len = std::min&lt;unsigned&gt;(this_len, other_len);
    JSON_ASSERT(this_str &amp;&amp; other_str);
    int comp = memcmp(this_str, other_str, min_len);
    if (comp &lt; 0)
      return true;
    if (comp &gt; 0)
      return false;
    return (this_len &lt; other_len);</span>
  }
  case arrayValue:
  case objectValue: {
<span style = "background-color:#fdd">    auto thisSize = value_.map_-&gt;size();
    auto otherSize = other.value_.map_-&gt;size();
    if (thisSize != otherSize)
      return thisSize &lt; otherSize;
    return (*value_.map_) &lt; (*other.value_.map_);</span>
  }
  default:
<span style = "background-color:#fdd">    JSON_ASSERT_UNREACHABLE;</span>
  }
<span style = "background-color:#fdd">  return false; // unreachable
}</span>

<span style = "background-color:#fdd">bool Value::operator&lt;=(const Value&amp; other) const { return !(other &lt; *this); }</span>

<span style = "background-color:#fdd">bool Value::operator&gt;=(const Value&amp; other) const { return !(*this &lt; other); }</span>

<span style = "background-color:#fdd">bool Value::operator&gt;(const Value&amp; other) const { return other &lt; *this; }</span>

<span style = "background-color:#fdd">bool Value::operator==(const Value&amp; other) const {
  if (type() != other.type())
    return false;
  switch (type()) {</span>
  case nullValue:
<span style = "background-color:#fdd">    return true;</span>
  case intValue:
<span style = "background-color:#fdd">    return value_.int_ == other.value_.int_;</span>
  case uintValue:
<span style = "background-color:#fdd">    return value_.uint_ == other.value_.uint_;</span>
  case realValue:
<span style = "background-color:#fdd">    return value_.real_ == other.value_.real_;</span>
  case booleanValue:
<span style = "background-color:#fdd">    return value_.bool_ == other.value_.bool_;</span>
  case stringValue: {
<span style = "background-color:#fdd">    if ((value_.string_ == nullptr) || (other.value_.string_ == nullptr)) {
      return (value_.string_ == other.value_.string_);</span>
    }
    unsigned this_len;
    unsigned other_len;
    char const* this_str;
    char const* other_str;
<span style = "background-color:#fdd">    decodePrefixedString(this-&gt;isAllocated(), this-&gt;value_.string_, &amp;this_len,</span>
                         &amp;this_str);
<span style = "background-color:#fdd">    decodePrefixedString(other.isAllocated(), other.value_.string_, &amp;other_len,</span>
                         &amp;other_str);
<span style = "background-color:#fdd">    if (this_len != other_len)
      return false;
    JSON_ASSERT(this_str &amp;&amp; other_str);
    int comp = memcmp(this_str, other_str, this_len);
    return comp == 0;</span>
  }
  case arrayValue:
  case objectValue:
<span style = "background-color:#fdd">    return value_.map_-&gt;size() == other.value_.map_-&gt;size() &amp;&amp;</span>
           (*value_.map_) == (*other.value_.map_);
  default:
<span style = "background-color:#fdd">    JSON_ASSERT_UNREACHABLE;</span>
  }
<span style = "background-color:#fdd">  return false; // unreachable
}</span>

<span style = "background-color:#fdd">bool Value::operator!=(const Value&amp; other) const { return !(*this == other); }</span>

<span style = "background-color:#fdd">const char* Value::asCString() const {
  JSON_ASSERT_MESSAGE(type() == stringValue,</span>
                      "in Json::Value::asCString(): requires stringValue");
<span style = "background-color:#fdd">  if (value_.string_ == nullptr)
    return nullptr;</span>
  unsigned this_len;
  char const* this_str;
<span style = "background-color:#fdd">  decodePrefixedString(this-&gt;isAllocated(), this-&gt;value_.string_, &amp;this_len,</span>
                       &amp;this_str);
<span style = "background-color:#fdd">  return this_str;
}</span>

#if JSONCPP_USING_SECURE_MEMORY
unsigned Value::getCStringLength() const {
  JSON_ASSERT_MESSAGE(type() == stringValue,
                      "in Json::Value::asCString(): requires stringValue");
  if (value_.string_ == 0)
    return 0;
  unsigned this_len;
  char const* this_str;
  decodePrefixedString(this-&gt;isAllocated(), this-&gt;value_.string_, &amp;this_len,
                       &amp;this_str);
  return this_len;
}
#endif

<span style = "background-color:#fdd">bool Value::getString(char const** begin, char const** end) const {
  if (type() != stringValue)
    return false;
  if (value_.string_ == nullptr)
    return false;</span>
  unsigned length;
<span style = "background-color:#fdd">  decodePrefixedString(this-&gt;isAllocated(), this-&gt;value_.string_, &amp;length,</span>
                       begin);
<span style = "background-color:#fdd">  *end = *begin + length;
  return true;
}</span>

<span style = "background-color:#dfd">String Value::asString() const {
  switch (type()) {</span>
  case nullValue:
<span style = "background-color:#fdd">    return "";</span>
  case stringValue: {
<span style = "background-color:#dfd">    if (value_.string_ == nullptr)</span>
<span style = "background-color:#fdd">      return "";</span>
    unsigned this_len;
    char const* this_str;
<span style = "background-color:#dfd">    decodePrefixedString(this-&gt;isAllocated(), this-&gt;value_.string_, &amp;this_len,</span>
                         &amp;this_str);
<span style = "background-color:#dfd">    return String(this_str, this_len);</span>
  }
  case booleanValue:
<span style = "background-color:#fdd">    return value_.bool_ ? "true" : "false";</span>
  case intValue:
<span style = "background-color:#fdd">    return valueToString(value_.int_);</span>
  case uintValue:
<span style = "background-color:#fdd">    return valueToString(value_.uint_);</span>
  case realValue:
<span style = "background-color:#fdd">    return valueToString(value_.real_);</span>
  default:
<span style = "background-color:#fdd">    JSON_FAIL_MESSAGE("Type is not convertible to string");</span>
  }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#fdd">Value::Int Value::asInt() const {
  switch (type()) {</span>
  case intValue:
<span style = "background-color:#fdd">    JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
    return Int(value_.int_);</span>
  case uintValue:
<span style = "background-color:#fdd">    JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
    return Int(value_.uint_);</span>
  case realValue:
<span style = "background-color:#fdd">    JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),</span>
                        "double out of Int range");
<span style = "background-color:#fdd">    return Int(value_.real_);</span>
  case nullValue:
<span style = "background-color:#fdd">    return 0;</span>
  case booleanValue:
<span style = "background-color:#fdd">    return value_.bool_ ? 1 : 0;</span>
  default:
    break;
  }
<span style = "background-color:#fdd">  JSON_FAIL_MESSAGE("Value is not convertible to Int.");
}</span>

<span style = "background-color:#fdd">Value::UInt Value::asUInt() const {
  switch (type()) {</span>
  case intValue:
<span style = "background-color:#fdd">    JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
    return UInt(value_.int_);</span>
  case uintValue:
<span style = "background-color:#fdd">    JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
    return UInt(value_.uint_);</span>
  case realValue:
<span style = "background-color:#fdd">    JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),</span>
                        "double out of UInt range");
<span style = "background-color:#fdd">    return UInt(value_.real_);</span>
  case nullValue:
<span style = "background-color:#fdd">    return 0;</span>
  case booleanValue:
<span style = "background-color:#fdd">    return value_.bool_ ? 1 : 0;</span>
  default:
    break;
  }
<span style = "background-color:#fdd">  JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
}</span>

#if defined(JSON_HAS_INT64)

<span style = "background-color:#fdd">Value::Int64 Value::asInt64() const {
  switch (type()) {</span>
  case intValue:
<span style = "background-color:#fdd">    return Int64(value_.int_);</span>
  case uintValue:
<span style = "background-color:#fdd">    JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
    return Int64(value_.uint_);</span>
  case realValue:
<span style = "background-color:#fdd">    JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),</span>
                        "double out of Int64 range");
<span style = "background-color:#fdd">    return Int64(value_.real_);</span>
  case nullValue:
<span style = "background-color:#fdd">    return 0;</span>
  case booleanValue:
<span style = "background-color:#fdd">    return value_.bool_ ? 1 : 0;</span>
  default:
    break;
  }
<span style = "background-color:#fdd">  JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
}</span>

<span style = "background-color:#fdd">Value::UInt64 Value::asUInt64() const {
  switch (type()) {</span>
  case intValue:
<span style = "background-color:#fdd">    JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
    return UInt64(value_.int_);</span>
  case uintValue:
<span style = "background-color:#fdd">    return UInt64(value_.uint_);</span>
  case realValue:
<span style = "background-color:#fdd">    JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),</span>
                        "double out of UInt64 range");
<span style = "background-color:#fdd">    return UInt64(value_.real_);</span>
  case nullValue:
<span style = "background-color:#fdd">    return 0;</span>
  case booleanValue:
<span style = "background-color:#fdd">    return value_.bool_ ? 1 : 0;</span>
  default:
    break;
  }
<span style = "background-color:#fdd">  JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
}</span>
#endif // if defined(JSON_HAS_INT64)

<span style = "background-color:#fdd">LargestInt Value::asLargestInt() const {</span>
#if defined(JSON_NO_INT64)
  return asInt();
#else
<span style = "background-color:#fdd">  return asInt64();</span>
#endif
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">LargestUInt Value::asLargestUInt() const {</span>
#if defined(JSON_NO_INT64)
  return asUInt();
#else
<span style = "background-color:#fdd">  return asUInt64();</span>
#endif
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">double Value::asDouble() const {
  switch (type()) {</span>
  case intValue:
<span style = "background-color:#fdd">    return static_cast&lt;double&gt;(value_.int_);</span>
  case uintValue:
#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
<span style = "background-color:#fdd">    return static_cast&lt;double&gt;(value_.uint_);</span>
#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
    return integerToDouble(value_.uint_);
#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
  case realValue:
<span style = "background-color:#fdd">    return value_.real_;</span>
  case nullValue:
<span style = "background-color:#fdd">    return 0.0;</span>
  case booleanValue:
<span style = "background-color:#fdd">    return value_.bool_ ? 1.0 : 0.0;</span>
  default:
    break;
  }
<span style = "background-color:#fdd">  JSON_FAIL_MESSAGE("Value is not convertible to double.");
}</span>

<span style = "background-color:#fdd">float Value::asFloat() const {
  switch (type()) {</span>
  case intValue:
<span style = "background-color:#fdd">    return static_cast&lt;float&gt;(value_.int_);</span>
  case uintValue:
#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
<span style = "background-color:#fdd">    return static_cast&lt;float&gt;(value_.uint_);</span>
#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
    // This can fail (silently?) if the value is bigger than MAX_FLOAT.
    return static_cast&lt;float&gt;(integerToDouble(value_.uint_));
#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
  case realValue:
<span style = "background-color:#fdd">    return static_cast&lt;float&gt;(value_.real_);</span>
  case nullValue:
<span style = "background-color:#fdd">    return 0.0;</span>
  case booleanValue:
<span style = "background-color:#fdd">    return value_.bool_ ? 1.0F : 0.0F;</span>
  default:
    break;
  }
<span style = "background-color:#fdd">  JSON_FAIL_MESSAGE("Value is not convertible to float.");
}</span>

<span style = "background-color:#fdd">bool Value::asBool() const {
  switch (type()) {</span>
  case booleanValue:
<span style = "background-color:#fdd">    return value_.bool_;</span>
  case nullValue:
<span style = "background-color:#fdd">    return false;</span>
  case intValue:
<span style = "background-color:#fdd">    return value_.int_ != 0;</span>
  case uintValue:
<span style = "background-color:#fdd">    return value_.uint_ != 0;</span>
  case realValue: {
    // According to JavaScript language zero or NaN is regarded as false
<span style = "background-color:#fdd">    const auto value_classification = std::fpclassify(value_.real_);
    return value_classification != FP_ZERO &amp;&amp; value_classification != FP_NAN;</span>
  }
  default:
    break;
  }
<span style = "background-color:#fdd">  JSON_FAIL_MESSAGE("Value is not convertible to bool.");
}</span>

<span style = "background-color:#fdd">bool Value::isConvertibleTo(ValueType other) const {
  switch (other) {</span>
  case nullValue:
<span style = "background-color:#fdd">    return (isNumeric() &amp;&amp; asDouble() == 0.0) ||</span>
           (type() == booleanValue &amp;&amp; !value_.bool_) ||
           (type() == stringValue &amp;&amp; asString().empty()) ||
           (type() == arrayValue &amp;&amp; value_.map_-&gt;empty()) ||
           (type() == objectValue &amp;&amp; value_.map_-&gt;empty()) ||
           type() == nullValue;
  case intValue:
<span style = "background-color:#fdd">    return isInt() ||</span>
           (type() == realValue &amp;&amp; InRange(value_.real_, minInt, maxInt)) ||
           type() == booleanValue || type() == nullValue;
  case uintValue:
<span style = "background-color:#fdd">    return isUInt() ||</span>
           (type() == realValue &amp;&amp; InRange(value_.real_, 0, maxUInt)) ||
           type() == booleanValue || type() == nullValue;
  case realValue:
<span style = "background-color:#fdd">    return isNumeric() || type() == booleanValue || type() == nullValue;</span>
  case booleanValue:
<span style = "background-color:#fdd">    return isNumeric() || type() == booleanValue || type() == nullValue;</span>
  case stringValue:
<span style = "background-color:#fdd">    return isNumeric() || type() == booleanValue || type() == stringValue ||</span>
           type() == nullValue;
  case arrayValue:
<span style = "background-color:#fdd">    return type() == arrayValue || type() == nullValue;</span>
  case objectValue:
<span style = "background-color:#fdd">    return type() == objectValue || type() == nullValue;</span>
  }
<span style = "background-color:#fdd">  JSON_ASSERT_UNREACHABLE;
  return false;
}</span>

/// Number of values in array or object
<span style = "background-color:#fdd">ArrayIndex Value::size() const {
  switch (type()) {</span>
  case nullValue:
  case intValue:
  case uintValue:
  case realValue:
  case booleanValue:
  case stringValue:
<span style = "background-color:#fdd">    return 0;</span>
  case arrayValue: // size of the array is highest index + 1
<span style = "background-color:#fdd">    if (!value_.map_-&gt;empty()) {
      ObjectValues::const_iterator itLast = value_.map_-&gt;end();
      --itLast;
      return (*itLast).first.index() + 1;</span>
    }
<span style = "background-color:#fdd">    return 0;</span>
  case objectValue:
<span style = "background-color:#fdd">    return ArrayIndex(value_.map_-&gt;size());</span>
  }
<span style = "background-color:#fdd">  JSON_ASSERT_UNREACHABLE;
  return 0; // unreachable;
}</span>

<span style = "background-color:#fdd">bool Value::empty() const {
  if (isNull() || isArray() || isObject())
    return size() == 0U;
  return false;
}</span>

<span style = "background-color:#fdd">Value::operator bool() const { return !isNull(); }</span>

<span style = "background-color:#fdd">void Value::clear() {
  JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue ||</span>
                          type() == objectValue,
                      "in Json::Value::clear(): requires complex value");
<span style = "background-color:#fdd">  start_ = 0;
  limit_ = 0;
  switch (type()) {</span>
  case arrayValue:
  case objectValue:
<span style = "background-color:#fdd">    value_.map_-&gt;clear();</span>
    break;
  default:
    break;
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">void Value::resize(ArrayIndex newSize) {
  JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue,</span>
                      "in Json::Value::resize(): requires arrayValue");
<span style = "background-color:#fdd">  if (type() == nullValue)
    *this = Value(arrayValue);
  ArrayIndex oldSize = size();
  if (newSize == 0)
    clear();
  else if (newSize &gt; oldSize)
    for (ArrayIndex i = oldSize; i &lt; newSize; ++i)
      (*this)[i];</span>
  else {
<span style = "background-color:#fdd">    for (ArrayIndex index = newSize; index &lt; oldSize; ++index) {
      value_.map_-&gt;erase(index);
    }
    JSON_ASSERT(size() == newSize);</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">Value&amp; Value::operator[](ArrayIndex index) {
  JSON_ASSERT_MESSAGE(</span>
      type() == nullValue || type() == arrayValue,
      "in Json::Value::operator[](ArrayIndex): requires arrayValue");
<span style = "background-color:#fdd">  if (type() == nullValue)
    *this = Value(arrayValue);
  CZString key(index);
  auto it = value_.map_-&gt;lower_bound(key);
  if (it != value_.map_-&gt;end() &amp;&amp; (*it).first == key)
    return (*it).second;</span>

<span style = "background-color:#fdd">  ObjectValues::value_type defaultValue(key, nullSingleton());
  it = value_.map_-&gt;insert(it, defaultValue);
  return (*it).second;
}</span>

<span style = "background-color:#fdd">Value&amp; Value::operator[](int index) {
  JSON_ASSERT_MESSAGE(</span>
      index &gt;= 0,
      "in Json::Value::operator[](int index): index cannot be negative");
<span style = "background-color:#fdd">  return (*this)[ArrayIndex(index)];
}</span>

<span style = "background-color:#fdd">const Value&amp; Value::operator[](ArrayIndex index) const {
  JSON_ASSERT_MESSAGE(</span>
      type() == nullValue || type() == arrayValue,
      "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
<span style = "background-color:#fdd">  if (type() == nullValue)
    return nullSingleton();
  CZString key(index);
  ObjectValues::const_iterator it = value_.map_-&gt;find(key);
  if (it == value_.map_-&gt;end())
    return nullSingleton();
  return (*it).second;
}</span>

<span style = "background-color:#fdd">const Value&amp; Value::operator[](int index) const {
  JSON_ASSERT_MESSAGE(</span>
      index &gt;= 0,
      "in Json::Value::operator[](int index) const: index cannot be negative");
<span style = "background-color:#fdd">  return (*this)[ArrayIndex(index)];
}</span>

<span style = "background-color:#dfd">void Value::initBasic(ValueType type, bool allocated) {
  setType(type);
  setIsAllocated(allocated);
  comments_ = Comments{};
  start_ = 0;
  limit_ = 0;
}</span>

<span style = "background-color:#dfd">void Value::dupPayload(const Value&amp; other) {
  setType(other.type());
  setIsAllocated(false);
  switch (type()) {</span>
  case nullValue:
  case intValue:
  case uintValue:
  case realValue:
  case booleanValue:
<span style = "background-color:#dfd">    value_ = other.value_;
    break;</span>
  case stringValue:
<span style = "background-color:#fdd">    if (other.value_.string_ &amp;&amp; other.isAllocated()) {</span>
      unsigned len;
      char const* str;
<span style = "background-color:#fdd">      decodePrefixedString(other.isAllocated(), other.value_.string_, &amp;len,</span>
                           &amp;str);
<span style = "background-color:#fdd">      value_.string_ = duplicateAndPrefixStringValue(str, len);
      setIsAllocated(true);
    } else {
      value_.string_ = other.value_.string_;</span>
    }
<span style = "background-color:#fdd">    break;</span>
  case arrayValue:
  case objectValue:
<span style = "background-color:#fdd">    value_.map_ = new ObjectValues(*other.value_.map_);
    break;</span>
  default:
<span style = "background-color:#fdd">    JSON_ASSERT_UNREACHABLE;</span>
  }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">void Value::releasePayload() {
  switch (type()) {</span>
  case nullValue:
  case intValue:
  case uintValue:
  case realValue:
  case booleanValue:
<span style = "background-color:#dfd">    break;</span>
  case stringValue:
<span style = "background-color:#dfd">    if (isAllocated())
      releasePrefixedStringValue(value_.string_);
    break;</span>
  case arrayValue:
  case objectValue:
<span style = "background-color:#dfd">    delete value_.map_;
    break;</span>
  default:
<span style = "background-color:#fdd">    JSON_ASSERT_UNREACHABLE;</span>
  }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">void Value::dupMeta(const Value&amp; other) {
  comments_ = other.comments_;
  start_ = other.start_;
  limit_ = other.limit_;
}</span>

// Access an object value by name, create a null member if it does not exist.
// @pre Type of '*this' is object or null.
// @param key is null-terminated.
<span style = "background-color:#fdd">Value&amp; Value::resolveReference(const char* key) {
  JSON_ASSERT_MESSAGE(</span>
      type() == nullValue || type() == objectValue,
      "in Json::Value::resolveReference(): requires objectValue");
<span style = "background-color:#fdd">  if (type() == nullValue)
    *this = Value(objectValue);
  CZString actualKey(key, static_cast&lt;unsigned&gt;(strlen(key)),</span>
                     CZString::noDuplication); // NOTE!
<span style = "background-color:#fdd">  auto it = value_.map_-&gt;lower_bound(actualKey);
  if (it != value_.map_-&gt;end() &amp;&amp; (*it).first == actualKey)
    return (*it).second;</span>

<span style = "background-color:#fdd">  ObjectValues::value_type defaultValue(actualKey, nullSingleton());
  it = value_.map_-&gt;insert(it, defaultValue);
  Value&amp; value = (*it).second;
  return value;
}</span>

// @param key is not null-terminated.
<span style = "background-color:#dfd">Value&amp; Value::resolveReference(char const* key, char const* end) {
  JSON_ASSERT_MESSAGE(</span>
      type() == nullValue || type() == objectValue,
      "in Json::Value::resolveReference(key, end): requires objectValue");
<span style = "background-color:#dfd">  if (type() == nullValue)</span>
<span style = "background-color:#fdd">    *this = Value(objectValue);</span>
<span style = "background-color:#dfd">  CZString actualKey(key, static_cast&lt;unsigned&gt;(end - key),</span>
                     CZString::duplicateOnCopy);
<span style = "background-color:#dfd">  auto it = value_.map_-&gt;lower_bound(actualKey);
  if (it != value_.map_-&gt;end() &amp;&amp; (*it).first == actualKey)</span>
<span style = "background-color:#fdd">    return (*it).second;</span>

<span style = "background-color:#dfd">  ObjectValues::value_type defaultValue(actualKey, nullSingleton());
  it = value_.map_-&gt;insert(it, defaultValue);
  Value&amp; value = (*it).second;
  return value;
}</span>

<span style = "background-color:#fdd">Value Value::get(ArrayIndex index, const Value&amp; defaultValue) const {
  const Value* value = &amp;((*this)[index]);
  return value == &amp;nullSingleton() ? defaultValue : *value;
}</span>

<span style = "background-color:#fdd">bool Value::isValidIndex(ArrayIndex index) const { return index &lt; size(); }</span>

<span style = "background-color:#fdd">Value const* Value::find(char const* begin, char const* end) const {
  JSON_ASSERT_MESSAGE(type() == nullValue || type() == objectValue,</span>
                      "in Json::Value::find(begin, end): requires "
                      "objectValue or nullValue");
<span style = "background-color:#fdd">  if (type() == nullValue)
    return nullptr;
  CZString actualKey(begin, static_cast&lt;unsigned&gt;(end - begin),</span>
                     CZString::noDuplication);
<span style = "background-color:#fdd">  ObjectValues::const_iterator it = value_.map_-&gt;find(actualKey);
  if (it == value_.map_-&gt;end())
    return nullptr;
  return &amp;(*it).second;
}
Value* Value::demand(char const* begin, char const* end) {
  JSON_ASSERT_MESSAGE(type() == nullValue || type() == objectValue,</span>
                      "in Json::Value::demand(begin, end): requires "
                      "objectValue or nullValue");
<span style = "background-color:#fdd">  return &amp;resolveReference(begin, end);
}
const Value&amp; Value::operator[](const char* key) const {
  Value const* found = find(key, key + strlen(key));
  if (!found)
    return nullSingleton();
  return *found;
}
Value const&amp; Value::operator[](const String&amp; key) const {
  Value const* found = find(key.data(), key.data() + key.length());
  if (!found)
    return nullSingleton();
  return *found;
}</span>

<span style = "background-color:#fdd">Value&amp; Value::operator[](const char* key) {
  return resolveReference(key, key + strlen(key));
}</span>

<span style = "background-color:#dfd">Value&amp; Value::operator[](const String&amp; key) {
  return resolveReference(key.data(), key.data() + key.length());
}</span>

<span style = "background-color:#fdd">Value&amp; Value::operator[](const StaticString&amp; key) {
  return resolveReference(key.c_str());
}</span>

<span style = "background-color:#fdd">Value&amp; Value::append(const Value&amp; value) { return append(Value(value)); }</span>

<span style = "background-color:#fdd">Value&amp; Value::append(Value&amp;&amp; value) {
  JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue,</span>
                      "in Json::Value::append: requires arrayValue");
<span style = "background-color:#fdd">  if (type() == nullValue) {
    *this = Value(arrayValue);</span>
  }
<span style = "background-color:#fdd">  return this-&gt;value_.map_-&gt;emplace(size(), std::move(value)).first-&gt;second;
}</span>

<span style = "background-color:#fdd">bool Value::insert(ArrayIndex index, const Value&amp; newValue) {
  return insert(index, Value(newValue));
}</span>

<span style = "background-color:#fdd">bool Value::insert(ArrayIndex index, Value&amp;&amp; newValue) {
  JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue,</span>
                      "in Json::Value::insert: requires arrayValue");
<span style = "background-color:#fdd">  ArrayIndex length = size();
  if (index &gt; length) {
    return false;</span>
  }
<span style = "background-color:#fdd">  for (ArrayIndex i = length; i &gt; index; i--) {
    (*this)[i] = std::move((*this)[i - 1]);
  }
  (*this)[index] = std::move(newValue);
  return true;
}</span>

Value Value::get(char const* begin, char const* end,
<span style = "background-color:#fdd">                 Value const&amp; defaultValue) const {
  Value const* found = find(begin, end);
  return !found ? defaultValue : *found;
}
Value Value::get(char const* key, Value const&amp; defaultValue) const {
  return get(key, key + strlen(key), defaultValue);
}
Value Value::get(String const&amp; key, Value const&amp; defaultValue) const {
  return get(key.data(), key.data() + key.length(), defaultValue);
}</span>

<span style = "background-color:#fdd">bool Value::removeMember(const char* begin, const char* end, Value* removed) {
  if (type() != objectValue) {
    return false;</span>
  }
<span style = "background-color:#fdd">  CZString actualKey(begin, static_cast&lt;unsigned&gt;(end - begin),</span>
                     CZString::noDuplication);
<span style = "background-color:#fdd">  auto it = value_.map_-&gt;find(actualKey);
  if (it == value_.map_-&gt;end())
    return false;
  if (removed)
    *removed = std::move(it-&gt;second);
  value_.map_-&gt;erase(it);
  return true;
}
bool Value::removeMember(const char* key, Value* removed) {
  return removeMember(key, key + strlen(key), removed);
}
bool Value::removeMember(String const&amp; key, Value* removed) {
  return removeMember(key.data(), key.data() + key.length(), removed);
}
void Value::removeMember(const char* key) {
  JSON_ASSERT_MESSAGE(type() == nullValue || type() == objectValue,</span>
                      "in Json::Value::removeMember(): requires objectValue");
<span style = "background-color:#fdd">  if (type() == nullValue)
    return;</span>

<span style = "background-color:#fdd">  CZString actualKey(key, unsigned(strlen(key)), CZString::noDuplication);
  value_.map_-&gt;erase(actualKey);
}
void Value::removeMember(const String&amp; key) { removeMember(key.c_str()); }</span>

<span style = "background-color:#fdd">bool Value::removeIndex(ArrayIndex index, Value* removed) {
  if (type() != arrayValue) {
    return false;</span>
  }
<span style = "background-color:#fdd">  CZString key(index);
  auto it = value_.map_-&gt;find(key);
  if (it == value_.map_-&gt;end()) {
    return false;</span>
  }
<span style = "background-color:#fdd">  if (removed)
    *removed = it-&gt;second;
  ArrayIndex oldSize = size();</span>
  // shift left all items left, into the place of the "removed"
<span style = "background-color:#fdd">  for (ArrayIndex i = index; i &lt; (oldSize - 1); ++i) {
    CZString keey(i);
    (*value_.map_)[keey] = (*this)[i + 1];
  }</span>
  // erase the last one ("leftover")
<span style = "background-color:#fdd">  CZString keyLast(oldSize - 1);
  auto itLast = value_.map_-&gt;find(keyLast);
  value_.map_-&gt;erase(itLast);
  return true;
}</span>

<span style = "background-color:#fdd">bool Value::isMember(char const* begin, char const* end) const {
  Value const* value = find(begin, end);
  return nullptr != value;
}
bool Value::isMember(char const* key) const {
  return isMember(key, key + strlen(key));
}
bool Value::isMember(String const&amp; key) const {
  return isMember(key.data(), key.data() + key.length());
}</span>

<span style = "background-color:#fdd">Value::Members Value::getMemberNames() const {
  JSON_ASSERT_MESSAGE(</span>
      type() == nullValue || type() == objectValue,
      "in Json::Value::getMemberNames(), value must be objectValue");
<span style = "background-color:#fdd">  if (type() == nullValue)
    return Value::Members();
  Members members;
  members.reserve(value_.map_-&gt;size());
  ObjectValues::const_iterator it = value_.map_-&gt;begin();
  ObjectValues::const_iterator itEnd = value_.map_-&gt;end();
  for (; it != itEnd; ++it) {
    members.push_back(String((*it).first.data(), (*it).first.length()));
  }
  return members;
}</span>

<span style = "background-color:#fdd">static bool IsIntegral(double d) {</span>
  double integral_part;
<span style = "background-color:#fdd">  return modf(d, &amp;integral_part) == 0.0;
}</span>

<span style = "background-color:#fdd">bool Value::isNull() const { return type() == nullValue; }</span>

<span style = "background-color:#fdd">bool Value::isBool() const { return type() == booleanValue; }</span>

<span style = "background-color:#fdd">bool Value::isInt() const {
  switch (type()) {</span>
  case intValue:
#if defined(JSON_HAS_INT64)
<span style = "background-color:#fdd">    return value_.int_ &gt;= minInt &amp;&amp; value_.int_ &lt;= maxInt;</span>
#else
    return true;
#endif
  case uintValue:
<span style = "background-color:#fdd">    return value_.uint_ &lt;= UInt(maxInt);</span>
  case realValue:
<span style = "background-color:#fdd">    return value_.real_ &gt;= minInt &amp;&amp; value_.real_ &lt;= maxInt &amp;&amp;</span>
           IsIntegral(value_.real_);
  default:
    break;
  }
<span style = "background-color:#fdd">  return false;
}</span>

<span style = "background-color:#fdd">bool Value::isUInt() const {
  switch (type()) {</span>
  case intValue:
#if defined(JSON_HAS_INT64)
<span style = "background-color:#fdd">    return value_.int_ &gt;= 0 &amp;&amp; LargestUInt(value_.int_) &lt;= LargestUInt(maxUInt);</span>
#else
    return value_.int_ &gt;= 0;
#endif
  case uintValue:
#if defined(JSON_HAS_INT64)
<span style = "background-color:#fdd">    return value_.uint_ &lt;= maxUInt;</span>
#else
    return true;
#endif
  case realValue:
<span style = "background-color:#fdd">    return value_.real_ &gt;= 0 &amp;&amp; value_.real_ &lt;= maxUInt &amp;&amp;</span>
           IsIntegral(value_.real_);
  default:
    break;
  }
<span style = "background-color:#fdd">  return false;
}</span>

<span style = "background-color:#fdd">bool Value::isInt64() const {</span>
#if defined(JSON_HAS_INT64)
<span style = "background-color:#fdd">  switch (type()) {</span>
  case intValue:
<span style = "background-color:#fdd">    return true;</span>
  case uintValue:
<span style = "background-color:#fdd">    return value_.uint_ &lt;= UInt64(maxInt64);</span>
  case realValue:
    // Note that maxInt64 (= 2^63 - 1) is not exactly representable as a
    // double, so double(maxInt64) will be rounded up to 2^63. Therefore we
    // require the value to be strictly less than the limit.
<span style = "background-color:#fdd">    return value_.real_ &gt;= double(minInt64) &amp;&amp;</span>
           value_.real_ &lt; double(maxInt64) &amp;&amp; IsIntegral(value_.real_);
  default:
    break;
  }
#endif // JSON_HAS_INT64
<span style = "background-color:#fdd">  return false;
}</span>

<span style = "background-color:#fdd">bool Value::isUInt64() const {</span>
#if defined(JSON_HAS_INT64)
<span style = "background-color:#fdd">  switch (type()) {</span>
  case intValue:
<span style = "background-color:#fdd">    return value_.int_ &gt;= 0;</span>
  case uintValue:
<span style = "background-color:#fdd">    return true;</span>
  case realValue:
    // Note that maxUInt64 (= 2^64 - 1) is not exactly representable as a
    // double, so double(maxUInt64) will be rounded up to 2^64. Therefore we
    // require the value to be strictly less than the limit.
<span style = "background-color:#fdd">    return value_.real_ &gt;= 0 &amp;&amp; value_.real_ &lt; maxUInt64AsDouble &amp;&amp;</span>
           IsIntegral(value_.real_);
  default:
    break;
  }
#endif // JSON_HAS_INT64
<span style = "background-color:#fdd">  return false;
}</span>

<span style = "background-color:#fdd">bool Value::isIntegral() const {
  switch (type()) {</span>
  case intValue:
  case uintValue:
<span style = "background-color:#fdd">    return true;</span>
  case realValue:
#if defined(JSON_HAS_INT64)
    // Note that maxUInt64 (= 2^64 - 1) is not exactly representable as a
    // double, so double(maxUInt64) will be rounded up to 2^64. Therefore we
    // require the value to be strictly less than the limit.
<span style = "background-color:#fdd">    return value_.real_ &gt;= double(minInt64) &amp;&amp;</span>
           value_.real_ &lt; maxUInt64AsDouble &amp;&amp; IsIntegral(value_.real_);
#else
    return value_.real_ &gt;= minInt &amp;&amp; value_.real_ &lt;= maxUInt &amp;&amp;
           IsIntegral(value_.real_);
#endif // JSON_HAS_INT64
  default:
    break;
  }
<span style = "background-color:#fdd">  return false;
}</span>

<span style = "background-color:#fdd">bool Value::isDouble() const {
  return type() == intValue || type() == uintValue || type() == realValue;
}</span>

<span style = "background-color:#fdd">bool Value::isNumeric() const { return isDouble(); }</span>

<span style = "background-color:#dfd">bool Value::isString() const { return type() == stringValue; }</span>

<span style = "background-color:#dfd">bool Value::isArray() const { return type() == arrayValue; }</span>

<span style = "background-color:#dfd">bool Value::isObject() const { return type() == objectValue; }</span>

Value::Comments::Comments(const Comments&amp; that)
<span style = "background-color:#fdd">    : ptr_{cloneUnique(that.ptr_)} {}</span>

Value::Comments::Comments(Comments&amp;&amp; that) noexcept
<span style = "background-color:#fdd">    : ptr_{std::move(that.ptr_)} {}</span>

<span style = "background-color:#dfd">Value::Comments&amp; Value::Comments::operator=(const Comments&amp; that) {
  ptr_ = cloneUnique(that.ptr_);
  return *this;
}</span>

<span style = "background-color:#dfd">Value::Comments&amp; Value::Comments::operator=(Comments&amp;&amp; that) noexcept {
  ptr_ = std::move(that.ptr_);
  return *this;
}</span>

<span style = "background-color:#fdd">bool Value::Comments::has(CommentPlacement slot) const {
  return ptr_ &amp;&amp; !(*ptr_)[slot].empty();
}</span>

<span style = "background-color:#fdd">String Value::Comments::get(CommentPlacement slot) const {
  if (!ptr_)
    return {};
  return (*ptr_)[slot];
}</span>

<span style = "background-color:#fdd">void Value::Comments::set(CommentPlacement slot, String comment) {
  if (slot &gt;= CommentPlacement::numberOfCommentPlacement)
    return;
  if (!ptr_)
    ptr_ = std::unique_ptr&lt;Array&gt;(new Array());
  (*ptr_)[slot] = std::move(comment);
}</span>

<span style = "background-color:#fdd">void Value::setComment(String comment, CommentPlacement placement) {
  if (!comment.empty() &amp;&amp; (comment.back() == '\n')) {</span>
    // Always discard trailing newline, to aid indentation.
<span style = "background-color:#fdd">    comment.pop_back();</span>
  }
<span style = "background-color:#fdd">  JSON_ASSERT(!comment.empty());
  JSON_ASSERT_MESSAGE(</span>
      comment[0] == '\0' || comment[0] == '/',
      "in Json::Value::setComment(): Comments must start with /");
<span style = "background-color:#fdd">  comments_.set(placement, std::move(comment));
}</span>

<span style = "background-color:#fdd">bool Value::hasComment(CommentPlacement placement) const {
  return comments_.has(placement);
}</span>

<span style = "background-color:#fdd">String Value::getComment(CommentPlacement placement) const {
  return comments_.get(placement);
}</span>

<span style = "background-color:#dfd">void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }</span>

<span style = "background-color:#dfd">void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }</span>

<span style = "background-color:#fdd">ptrdiff_t Value::getOffsetStart() const { return start_; }</span>

<span style = "background-color:#fdd">ptrdiff_t Value::getOffsetLimit() const { return limit_; }</span>

<span style = "background-color:#fdd">String Value::toStyledString() const {
  StreamWriterBuilder builder;</span>

<span style = "background-color:#fdd">  String out = this-&gt;hasComment(commentBefore) ? "\n" : "";
  out += Json::writeString(builder, *this);
  out += '\n';</span>

<span style = "background-color:#fdd">  return out;
}</span>

<span style = "background-color:#dfd">Value::const_iterator Value::begin() const {
  switch (type()) {</span>
  case arrayValue:
  case objectValue:
<span style = "background-color:#dfd">    if (value_.map_)
      return const_iterator(value_.map_-&gt;begin());</span>
    break;
  default:
    break;
  }
<span style = "background-color:#fdd">  return {};</span>
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">Value::const_iterator Value::end() const {
  switch (type()) {</span>
  case arrayValue:
  case objectValue:
<span style = "background-color:#dfd">    if (value_.map_)
      return const_iterator(value_.map_-&gt;end());</span>
    break;
  default:
    break;
  }
<span style = "background-color:#fdd">  return {};</span>
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#fdd">Value::iterator Value::begin() {
  switch (type()) {</span>
  case arrayValue:
  case objectValue:
<span style = "background-color:#fdd">    if (value_.map_)
      return iterator(value_.map_-&gt;begin());</span>
    break;
  default:
    break;
  }
<span style = "background-color:#fdd">  return iterator();
}</span>

<span style = "background-color:#fdd">Value::iterator Value::end() {
  switch (type()) {</span>
  case arrayValue:
  case objectValue:
<span style = "background-color:#fdd">    if (value_.map_)
      return iterator(value_.map_-&gt;end());</span>
    break;
  default:
    break;
  }
<span style = "background-color:#fdd">  return iterator();
}</span>

// class PathArgument
// //////////////////////////////////////////////////////////////////

<span style = "background-color:#fdd">PathArgument::PathArgument() = default;</span>

PathArgument::PathArgument(ArrayIndex index)
<span style = "background-color:#fdd">    : index_(index), kind_(kindIndex) {}</span>

<span style = "background-color:#fdd">PathArgument::PathArgument(const char* key) : key_(key), kind_(kindKey) {}</span>

<span style = "background-color:#fdd">PathArgument::PathArgument(String key) : key_(std::move(key)), kind_(kindKey) {}</span>

// class Path
// //////////////////////////////////////////////////////////////////

Path::Path(const String&amp; path, const PathArgument&amp; a1, const PathArgument&amp; a2,
           const PathArgument&amp; a3, const PathArgument&amp; a4,
<span style = "background-color:#fdd">           const PathArgument&amp; a5) {
  InArgs in;
  in.reserve(5);
  in.push_back(&amp;a1);
  in.push_back(&amp;a2);
  in.push_back(&amp;a3);
  in.push_back(&amp;a4);
  in.push_back(&amp;a5);
  makePath(path, in);
}</span>

<span style = "background-color:#fdd">void Path::makePath(const String&amp; path, const InArgs&amp; in) {
  const char* current = path.c_str();
  const char* end = current + path.length();
  auto itInArg = in.begin();
  while (current != end) {
    if (*current == '[') {
      ++current;
      if (*current == '%')
        addPathInArg(path, in, itInArg, PathArgument::kindIndex);</span>
      else {
<span style = "background-color:#fdd">        ArrayIndex index = 0;
        for (; current != end &amp;&amp; *current &gt;= '0' &amp;&amp; *current &lt;= '9'; ++current)
          index = index * 10 + ArrayIndex(*current - '0');
        args_.push_back(index);</span>
      }
<span style = "background-color:#fdd">      if (current == end || *++current != ']')
        invalidPath(path, int(current - path.c_str()));
    } else if (*current == '%') {
      addPathInArg(path, in, itInArg, PathArgument::kindKey);
      ++current;
    } else if (*current == '.' || *current == ']') {
      ++current;
    } else {
      const char* beginName = current;
      while (current != end &amp;&amp; !strchr("[.", *current))
        ++current;
      args_.push_back(String(beginName, current));</span>
    }
<span style = "background-color:#fdd">  }
}</span>

void Path::addPathInArg(const String&amp; /*path*/, const InArgs&amp; in,
                        InArgs::const_iterator&amp; itInArg,
<span style = "background-color:#fdd">                        PathArgument::Kind kind) {
  if (itInArg == in.end()) {</span>
    // Error: missing argument %d
<span style = "background-color:#fdd">  } else if ((*itInArg)-&gt;kind_ != kind) {</span>
    // Error: bad argument type
<span style = "background-color:#fdd">  } else {
    args_.push_back(**itInArg++);</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">void Path::invalidPath(const String&amp; /*path*/, int /*location*/) {</span>
  // Error: invalid path.
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">const Value&amp; Path::resolve(const Value&amp; root) const {
  const Value* node = &amp;root;
  for (const auto&amp; arg : args_) {
    if (arg.kind_ == PathArgument::kindIndex) {
      if (!node-&gt;isArray() || !node-&gt;isValidIndex(arg.index_)) {</span>
        // Error: unable to resolve path (array value expected at position... )
<span style = "background-color:#fdd">        return Value::nullSingleton();</span>
      }
<span style = "background-color:#fdd">      node = &amp;((*node)[arg.index_]);
    } else if (arg.kind_ == PathArgument::kindKey) {
      if (!node-&gt;isObject()) {</span>
        // Error: unable to resolve path (object value expected at position...)
<span style = "background-color:#fdd">        return Value::nullSingleton();</span>
      }
<span style = "background-color:#fdd">      node = &amp;((*node)[arg.key_]);
      if (node == &amp;Value::nullSingleton()) {</span>
        // Error: unable to resolve path (object has no member named '' at
        // position...)
<span style = "background-color:#fdd">        return Value::nullSingleton();</span>
      }
    }
<span style = "background-color:#fdd">  }
  return *node;
}</span>

<span style = "background-color:#fdd">Value Path::resolve(const Value&amp; root, const Value&amp; defaultValue) const {
  const Value* node = &amp;root;
  for (const auto&amp; arg : args_) {
    if (arg.kind_ == PathArgument::kindIndex) {
      if (!node-&gt;isArray() || !node-&gt;isValidIndex(arg.index_))
        return defaultValue;
      node = &amp;((*node)[arg.index_]);
    } else if (arg.kind_ == PathArgument::kindKey) {
      if (!node-&gt;isObject())
        return defaultValue;
      node = &amp;((*node)[arg.key_]);
      if (node == &amp;Value::nullSingleton())
        return defaultValue;</span>
    }
<span style = "background-color:#fdd">  }
  return *node;
}</span>

<span style = "background-color:#fdd">Value&amp; Path::make(Value&amp; root) const {
  Value* node = &amp;root;
  for (const auto&amp; arg : args_) {
    if (arg.kind_ == PathArgument::kindIndex) {
      if (!node-&gt;isArray()) {</span>
        // Error: node is not an array at position ...
      }
<span style = "background-color:#fdd">      node = &amp;((*node)[arg.index_]);
    } else if (arg.kind_ == PathArgument::kindKey) {
      if (!node-&gt;isObject()) {</span>
        // Error: node is not an object at position...
      }
<span style = "background-color:#fdd">      node = &amp;((*node)[arg.key_]);</span>
    }
<span style = "background-color:#fdd">  }
  return *node;
}</span>

} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_value.cpp
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_writer.cpp
// //////////////////////////////////////////////////////////////////////

// Copyright 2011 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#if !defined(JSON_IS_AMALGAMATION)
#include "json_tool.h"
#include &lt;json/writer.h&gt;
#endif // if !defined(JSON_IS_AMALGAMATION)
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstring&gt;
#include &lt;iomanip&gt;
#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;utility&gt;

#if __cplusplus &gt;= 201103L
#include &lt;cmath&gt;
#include &lt;cstdio&gt;

#if !defined(isnan)
#define isnan std::isnan
#endif

#if !defined(isfinite)
#define isfinite std::isfinite
#endif

#else
#include &lt;cmath&gt;
#include &lt;cstdio&gt;

#if defined(_MSC_VER)
#if !defined(isnan)
#include &lt;float.h&gt;
#define isnan _isnan
#endif

#if !defined(isfinite)
#include &lt;float.h&gt;
#define isfinite _finite
#endif

#if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
#endif //_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES

#endif //_MSC_VER

#if defined(__sun) &amp;&amp; defined(__SVR4) // Solaris
#if !defined(isfinite)
#include &lt;ieeefp.h&gt;
#define isfinite finite
#endif
#endif

#if defined(__hpux)
#if !defined(isfinite)
#if defined(__ia64) &amp;&amp; !defined(finite)
#define isfinite(x)                                                            \
  ((sizeof(x) == sizeof(float) ? _Isfinitef(x) : _IsFinite(x)))
#endif
#endif
#endif

#if !defined(isnan)
// IEEE standard states that NaN values will not compare to themselves
#define isnan(x) ((x) != (x))
#endif

#if !defined(__APPLE__)
#if !defined(isfinite)
#define isfinite finite
#endif
#endif
#endif

#if defined(_MSC_VER)
// Disable warning about strdup being deprecated.
#pragma warning(disable : 4996)
#endif

namespace Json {

#if __cplusplus &gt;= 201103L || (defined(_CPPLIB_VER) &amp;&amp; _CPPLIB_VER &gt;= 520)
using StreamWriterPtr = std::unique_ptr&lt;StreamWriter&gt;;
#else
using StreamWriterPtr = std::auto_ptr&lt;StreamWriter&gt;;
#endif

<span style = "background-color:#fdd">String valueToString(LargestInt value) {</span>
  UIntToStringBuffer buffer;
<span style = "background-color:#fdd">  char* current = buffer + sizeof(buffer);
  if (value == Value::minLargestInt) {
    uintToString(LargestUInt(Value::maxLargestInt) + 1, current);
    *--current = '-';
  } else if (value &lt; 0) {
    uintToString(LargestUInt(-value), current);
    *--current = '-';
  } else {
    uintToString(LargestUInt(value), current);</span>
  }
<span style = "background-color:#fdd">  assert(current &gt;= buffer);
  return current;
}</span>

<span style = "background-color:#fdd">String valueToString(LargestUInt value) {</span>
  UIntToStringBuffer buffer;
<span style = "background-color:#fdd">  char* current = buffer + sizeof(buffer);
  uintToString(value, current);
  assert(current &gt;= buffer);
  return current;
}</span>

#if defined(JSON_HAS_INT64)

<span style = "background-color:#fdd">String valueToString(Int value) { return valueToString(LargestInt(value)); }</span>

<span style = "background-color:#fdd">String valueToString(UInt value) { return valueToString(LargestUInt(value)); }</span>

#endif // # if defined(JSON_HAS_INT64)

namespace {
String valueToString(double value, bool useSpecialFloats,
<span style = "background-color:#fdd">                     unsigned int precision, PrecisionType precisionType) {</span>
  // Print into the buffer. We need not request the alternative representation
  // that always has a decimal point because JSON doesn't distinguish the
  // concepts of reals and integers.
<span style = "background-color:#fdd">  if (!isfinite(value)) {</span>
    static const char* const reps[2][3] = {{"NaN", "-Infinity", "Infinity"},
                                           {"null", "-1e+9999", "1e+9999"}};
<span style = "background-color:#fdd">    return reps[useSpecialFloats ? 0 : 1]</span>
               [isnan(value) ? 0 : (value &lt; 0) ? 1 : 2];
  }

<span style = "background-color:#fdd">  String buffer(size_t(36), '\0');
  while (true) {
    int len = jsoncpp_snprintf(</span>
        &amp;*buffer.begin(), buffer.size(),
        (precisionType == PrecisionType::significantDigits) ? "%.*g" : "%.*f",
        precision, value);
<span style = "background-color:#fdd">    assert(len &gt;= 0);
    auto wouldPrint = static_cast&lt;size_t&gt;(len);
    if (wouldPrint &gt;= buffer.size()) {
      buffer.resize(wouldPrint + 1);
      continue;</span>
    }
<span style = "background-color:#fdd">    buffer.resize(wouldPrint);
    break;
  }</span>

<span style = "background-color:#fdd">  buffer.erase(fixNumericLocale(buffer.begin(), buffer.end()), buffer.end());</span>

  // try to ensure we preserve the fact that this was given to us as a double on
  // input
<span style = "background-color:#fdd">  if (buffer.find('.') == buffer.npos &amp;&amp; buffer.find('e') == buffer.npos) {
    buffer += ".0";</span>
  }

  // strip the zero padding from the right
<span style = "background-color:#fdd">  if (precisionType == PrecisionType::decimalPlaces) {
    buffer.erase(fixZerosInTheEnd(buffer.begin(), buffer.end(), precision),</span>
                 buffer.end());
  }

<span style = "background-color:#fdd">  return buffer;
}</span>
} // namespace

String valueToString(double value, unsigned int precision,
<span style = "background-color:#fdd">                     PrecisionType precisionType) {
  return valueToString(value, false, precision, precisionType);
}</span>

<span style = "background-color:#fdd">String valueToString(bool value) { return value ? "true" : "false"; }</span>

<span style = "background-color:#fdd">static bool doesAnyCharRequireEscaping(char const* s, size_t n) {
  assert(s || !n);</span>

<span style = "background-color:#fdd">  return std::any_of(s, s + n, [](unsigned char c) {
    return c == '\\' || c == '"' || c &lt; 0x20 || c &gt; 0x7F;
  });
}</span>

<span style = "background-color:#fdd">static unsigned int utf8ToCodepoint(const char*&amp; s, const char* e) {
  const unsigned int REPLACEMENT_CHARACTER = 0xFFFD;</span>

<span style = "background-color:#fdd">  unsigned int firstByte = static_cast&lt;unsigned char&gt;(*s);</span>

<span style = "background-color:#fdd">  if (firstByte &lt; 0x80)
    return firstByte;</span>

<span style = "background-color:#fdd">  if (firstByte &lt; 0xE0) {
    if (e - s &lt; 2)
      return REPLACEMENT_CHARACTER;</span>

<span style = "background-color:#fdd">    unsigned int calculated =</span>
        ((firstByte &amp; 0x1F) &lt;&lt; 6) | (static_cast&lt;unsigned int&gt;(s[1]) &amp; 0x3F);
<span style = "background-color:#fdd">    s += 1;</span>
    // oversized encoded characters are invalid
<span style = "background-color:#fdd">    return calculated &lt; 0x80 ? REPLACEMENT_CHARACTER : calculated;</span>
  }

<span style = "background-color:#fdd">  if (firstByte &lt; 0xF0) {
    if (e - s &lt; 3)
      return REPLACEMENT_CHARACTER;</span>

<span style = "background-color:#fdd">    unsigned int calculated = ((firstByte &amp; 0x0F) &lt;&lt; 12) |</span>
                              ((static_cast&lt;unsigned int&gt;(s[1]) &amp; 0x3F) &lt;&lt; 6) |
                              (static_cast&lt;unsigned int&gt;(s[2]) &amp; 0x3F);
<span style = "background-color:#fdd">    s += 2;</span>
    // surrogates aren't valid codepoints itself
    // shouldn't be UTF-8 encoded
<span style = "background-color:#fdd">    if (calculated &gt;= 0xD800 &amp;&amp; calculated &lt;= 0xDFFF)
      return REPLACEMENT_CHARACTER;</span>
    // oversized encoded characters are invalid
<span style = "background-color:#fdd">    return calculated &lt; 0x800 ? REPLACEMENT_CHARACTER : calculated;</span>
  }

<span style = "background-color:#fdd">  if (firstByte &lt; 0xF8) {
    if (e - s &lt; 4)
      return REPLACEMENT_CHARACTER;</span>

<span style = "background-color:#fdd">    unsigned int calculated = ((firstByte &amp; 0x07) &lt;&lt; 18) |</span>
                              ((static_cast&lt;unsigned int&gt;(s[1]) &amp; 0x3F) &lt;&lt; 12) |
                              ((static_cast&lt;unsigned int&gt;(s[2]) &amp; 0x3F) &lt;&lt; 6) |
                              (static_cast&lt;unsigned int&gt;(s[3]) &amp; 0x3F);
<span style = "background-color:#fdd">    s += 3;</span>
    // oversized encoded characters are invalid
<span style = "background-color:#fdd">    return calculated &lt; 0x10000 ? REPLACEMENT_CHARACTER : calculated;</span>
  }

<span style = "background-color:#fdd">  return REPLACEMENT_CHARACTER;
}</span>

static const char hex2[] = "000102030405060708090a0b0c0d0e0f"
                           "101112131415161718191a1b1c1d1e1f"
                           "202122232425262728292a2b2c2d2e2f"
                           "303132333435363738393a3b3c3d3e3f"
                           "404142434445464748494a4b4c4d4e4f"
                           "505152535455565758595a5b5c5d5e5f"
                           "606162636465666768696a6b6c6d6e6f"
                           "707172737475767778797a7b7c7d7e7f"
                           "808182838485868788898a8b8c8d8e8f"
                           "909192939495969798999a9b9c9d9e9f"
                           "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
                           "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
                           "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
                           "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
                           "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
                           "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";

<span style = "background-color:#fdd">static String toHex16Bit(unsigned int x) {
  const unsigned int hi = (x &gt;&gt; 8) &amp; 0xff;
  const unsigned int lo = x &amp; 0xff;
  String result(4, ' ');
  result[0] = hex2[2 * hi];
  result[1] = hex2[2 * hi + 1];
  result[2] = hex2[2 * lo];
  result[3] = hex2[2 * lo + 1];
  return result;
}</span>

<span style = "background-color:#fdd">static void appendRaw(String&amp; result, unsigned ch) {
  result += static_cast&lt;char&gt;(ch);
}</span>

<span style = "background-color:#fdd">static void appendHex(String&amp; result, unsigned ch) {
  result.append("\\u").append(toHex16Bit(ch));
}</span>

static String valueToQuotedStringN(const char* value, size_t length,
<span style = "background-color:#fdd">                                   bool emitUTF8 = false) {
  if (value == nullptr)
    return "";</span>

<span style = "background-color:#fdd">  if (!doesAnyCharRequireEscaping(value, length))
    return String("\"") + value + "\"";</span>
  // We have to walk value and escape any special characters.
  // Appending to String is not efficient, but this should be rare.
  // (Note: forward slashes are *not* rare, but I am not escaping them.)
<span style = "background-color:#fdd">  String::size_type maxsize = length * 2 + 3; // allescaped+quotes+NULL
  String result;
  result.reserve(maxsize); // to avoid lots of mallocs
  result += "\"";
  char const* end = value + length;
  for (const char* c = value; c != end; ++c) {
    switch (*c) {</span>
    case '\"':
<span style = "background-color:#fdd">      result += "\\\"";
      break;</span>
    case '\\':
<span style = "background-color:#fdd">      result += "\\\\";
      break;</span>
    case '\b':
<span style = "background-color:#fdd">      result += "\\b";
      break;</span>
    case '\f':
<span style = "background-color:#fdd">      result += "\\f";
      break;</span>
    case '\n':
<span style = "background-color:#fdd">      result += "\\n";
      break;</span>
    case '\r':
<span style = "background-color:#fdd">      result += "\\r";
      break;</span>
    case '\t':
<span style = "background-color:#fdd">      result += "\\t";
      break;</span>
    // case '/':
    // Even though \/ is considered a legal escape in JSON, a bare
    // slash is also legal, so I see no reason to escape it.
    // (I hope I am not misunderstanding something.)
    // blep notes: actually escaping \/ may be useful in javascript to avoid &lt;/
    // sequence.
    // Should add a flag to allow this compatibility mode and prevent this
    // sequence from occurring.
    default: {
<span style = "background-color:#fdd">      if (emitUTF8) {
        unsigned codepoint = static_cast&lt;unsigned char&gt;(*c);
        if (codepoint &lt; 0x20) {
          appendHex(result, codepoint);
        } else {
          appendRaw(result, codepoint);</span>
        }
<span style = "background-color:#fdd">      } else {
        unsigned codepoint = utf8ToCodepoint(c, end); // modifies `c`
        if (codepoint &lt; 0x20) {
          appendHex(result, codepoint);
        } else if (codepoint &lt; 0x80) {
          appendRaw(result, codepoint);
        } else if (codepoint &lt; 0x10000) {</span>
          // Basic Multilingual Plane
<span style = "background-color:#fdd">          appendHex(result, codepoint);
        } else {</span>
          // Extended Unicode. Encode 20 bits as a surrogate pair.
<span style = "background-color:#fdd">          codepoint -= 0x10000;
          appendHex(result, 0xd800 + ((codepoint &gt;&gt; 10) &amp; 0x3ff));
          appendHex(result, 0xdc00 + (codepoint &amp; 0x3ff));</span>
        }
      }
    } break;
    }
<span style = "background-color:#fdd">  }
  result += "\"";
  return result;
}</span>

<span style = "background-color:#fdd">String valueToQuotedString(const char* value) {
  return valueToQuotedStringN(value, strlen(value));
}</span>

// Class Writer
// //////////////////////////////////////////////////////////////////
<span style = "background-color:#fdd">Writer::~Writer() = default;</span>

// Class FastWriter
// //////////////////////////////////////////////////////////////////

<span style = "background-color:#fdd">FastWriter::FastWriter()</span>

    = default;

<span style = "background-color:#fdd">void FastWriter::enableYAMLCompatibility() { yamlCompatibilityEnabled_ = true; }</span>

<span style = "background-color:#fdd">void FastWriter::dropNullPlaceholders() { dropNullPlaceholders_ = true; }</span>

<span style = "background-color:#fdd">void FastWriter::omitEndingLineFeed() { omitEndingLineFeed_ = true; }</span>

<span style = "background-color:#fdd">String FastWriter::write(const Value&amp; root) {
  document_.clear();
  writeValue(root);
  if (!omitEndingLineFeed_)
    document_ += '\n';
  return document_;
}</span>

<span style = "background-color:#fdd">void FastWriter::writeValue(const Value&amp; value) {
  switch (value.type()) {</span>
  case nullValue:
<span style = "background-color:#fdd">    if (!dropNullPlaceholders_)
      document_ += "null";
    break;</span>
  case intValue:
<span style = "background-color:#fdd">    document_ += valueToString(value.asLargestInt());
    break;</span>
  case uintValue:
<span style = "background-color:#fdd">    document_ += valueToString(value.asLargestUInt());
    break;</span>
  case realValue:
<span style = "background-color:#fdd">    document_ += valueToString(value.asDouble());
    break;</span>
  case stringValue: {
    // Is NULL possible for value.string_? No.
    char const* str;
    char const* end;
<span style = "background-color:#fdd">    bool ok = value.getString(&amp;str, &amp;end);
    if (ok)
      document_ += valueToQuotedStringN(str, static_cast&lt;size_t&gt;(end - str));
    break;</span>
  }
  case booleanValue:
<span style = "background-color:#fdd">    document_ += valueToString(value.asBool());
    break;</span>
  case arrayValue: {
<span style = "background-color:#fdd">    document_ += '[';
    ArrayIndex size = value.size();
    for (ArrayIndex index = 0; index &lt; size; ++index) {
      if (index &gt; 0)
        document_ += ',';
      writeValue(value[index]);
    }
    document_ += ']';
  } break;</span>
  case objectValue: {
<span style = "background-color:#fdd">    Value::Members members(value.getMemberNames());
    document_ += '{';
    for (auto it = members.begin(); it != members.end(); ++it) {
      const String&amp; name = *it;
      if (it != members.begin())
        document_ += ',';
      document_ += valueToQuotedStringN(name.data(), name.length());
      document_ += yamlCompatibilityEnabled_ ? ": " : ":";
      writeValue(value[name]);
    }
    document_ += '}';
  } break;</span>
  }
<span style = "background-color:#fdd">}</span>

// Class StyledWriter
// //////////////////////////////////////////////////////////////////

<span style = "background-color:#fdd">StyledWriter::StyledWriter() = default;</span>

<span style = "background-color:#fdd">String StyledWriter::write(const Value&amp; root) {
  document_.clear();
  addChildValues_ = false;
  indentString_.clear();
  writeCommentBeforeValue(root);
  writeValue(root);
  writeCommentAfterValueOnSameLine(root);
  document_ += '\n';
  return document_;
}</span>

<span style = "background-color:#fdd">void StyledWriter::writeValue(const Value&amp; value) {
  switch (value.type()) {</span>
  case nullValue:
<span style = "background-color:#fdd">    pushValue("null");
    break;</span>
  case intValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asLargestInt()));
    break;</span>
  case uintValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asLargestUInt()));
    break;</span>
  case realValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asDouble()));
    break;</span>
  case stringValue: {
    // Is NULL possible for value.string_? No.
    char const* str;
    char const* end;
<span style = "background-color:#fdd">    bool ok = value.getString(&amp;str, &amp;end);
    if (ok)
      pushValue(valueToQuotedStringN(str, static_cast&lt;size_t&gt;(end - str)));</span>
    else
<span style = "background-color:#fdd">      pushValue("");
    break;</span>
  }
  case booleanValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asBool()));
    break;</span>
  case arrayValue:
<span style = "background-color:#fdd">    writeArrayValue(value);
    break;</span>
  case objectValue: {
<span style = "background-color:#fdd">    Value::Members members(value.getMemberNames());
    if (members.empty())
      pushValue("{}");</span>
    else {
<span style = "background-color:#fdd">      writeWithIndent("{");
      indent();
      auto it = members.begin();</span>
      for (;;) {
<span style = "background-color:#fdd">        const String&amp; name = *it;
        const Value&amp; childValue = value[name];
        writeCommentBeforeValue(childValue);
        writeWithIndent(valueToQuotedString(name.c_str()));
        document_ += " : ";
        writeValue(childValue);
        if (++it == members.end()) {
          writeCommentAfterValueOnSameLine(childValue);
          break;</span>
        }
<span style = "background-color:#fdd">        document_ += ',';
        writeCommentAfterValueOnSameLine(childValue);
      }
      unindent();
      writeWithIndent("}");
    }
  } break;</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">void StyledWriter::writeArrayValue(const Value&amp; value) {
  size_t size = value.size();
  if (size == 0)
    pushValue("[]");</span>
  else {
<span style = "background-color:#fdd">    bool isArrayMultiLine = isMultilineArray(value);
    if (isArrayMultiLine) {
      writeWithIndent("[");
      indent();
      bool hasChildValue = !childValues_.empty();
      ArrayIndex index = 0;</span>
      for (;;) {
<span style = "background-color:#fdd">        const Value&amp; childValue = value[index];
        writeCommentBeforeValue(childValue);
        if (hasChildValue)
          writeWithIndent(childValues_[index]);</span>
        else {
<span style = "background-color:#fdd">          writeIndent();
          writeValue(childValue);</span>
        }
<span style = "background-color:#fdd">        if (++index == size) {
          writeCommentAfterValueOnSameLine(childValue);
          break;</span>
        }
<span style = "background-color:#fdd">        document_ += ',';
        writeCommentAfterValueOnSameLine(childValue);
      }
      unindent();
      writeWithIndent("]");
    } else // output on a single line</span>
    {
<span style = "background-color:#fdd">      assert(childValues_.size() == size);
      document_ += "[ ";
      for (size_t index = 0; index &lt; size; ++index) {
        if (index &gt; 0)
          document_ += ", ";
        document_ += childValues_[index];
      }
      document_ += " ]";</span>
    }
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">bool StyledWriter::isMultilineArray(const Value&amp; value) {
  ArrayIndex const size = value.size();
  bool isMultiLine = size * 3 &gt;= rightMargin_;
  childValues_.clear();
  for (ArrayIndex index = 0; index &lt; size &amp;&amp; !isMultiLine; ++index) {
    const Value&amp; childValue = value[index];
    isMultiLine = ((childValue.isArray() || childValue.isObject()) &amp;&amp;</span>
                   !childValue.empty());
<span style = "background-color:#fdd">  }
  if (!isMultiLine) // check if line length &gt; max line length</span>
  {
<span style = "background-color:#fdd">    childValues_.reserve(size);
    addChildValues_ = true;
    ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
    for (ArrayIndex index = 0; index &lt; size; ++index) {
      if (hasCommentForValue(value[index])) {
        isMultiLine = true;</span>
      }
<span style = "background-color:#fdd">      writeValue(value[index]);
      lineLength += static_cast&lt;ArrayIndex&gt;(childValues_[index].length());
    }
    addChildValues_ = false;
    isMultiLine = isMultiLine || lineLength &gt;= rightMargin_;</span>
  }
<span style = "background-color:#fdd">  return isMultiLine;
}</span>

<span style = "background-color:#fdd">void StyledWriter::pushValue(const String&amp; value) {
  if (addChildValues_)
    childValues_.push_back(value);</span>
  else
<span style = "background-color:#fdd">    document_ += value;
}</span>

<span style = "background-color:#fdd">void StyledWriter::writeIndent() {
  if (!document_.empty()) {
    char last = document_[document_.length() - 1];
    if (last == ' ') // already indented
      return;
    if (last != '\n') // Comments may add new-line
      document_ += '\n';</span>
  }
<span style = "background-color:#fdd">  document_ += indentString_;
}</span>

<span style = "background-color:#fdd">void StyledWriter::writeWithIndent(const String&amp; value) {
  writeIndent();
  document_ += value;
}</span>

<span style = "background-color:#fdd">void StyledWriter::indent() { indentString_ += String(indentSize_, ' '); }</span>

<span style = "background-color:#fdd">void StyledWriter::unindent() {
  assert(indentString_.size() &gt;= indentSize_);
  indentString_.resize(indentString_.size() - indentSize_);
}</span>

<span style = "background-color:#fdd">void StyledWriter::writeCommentBeforeValue(const Value&amp; root) {
  if (!root.hasComment(commentBefore))
    return;</span>

<span style = "background-color:#fdd">  document_ += '\n';
  writeIndent();
  const String&amp; comment = root.getComment(commentBefore);
  String::const_iterator iter = comment.begin();
  while (iter != comment.end()) {
    document_ += *iter;
    if (*iter == '\n' &amp;&amp; ((iter + 1) != comment.end() &amp;&amp; *(iter + 1) == '/'))
      writeIndent();
    ++iter;
  }</span>

  // Comments are stripped of trailing newlines, so add one here
<span style = "background-color:#fdd">  document_ += '\n';
}</span>

<span style = "background-color:#fdd">void StyledWriter::writeCommentAfterValueOnSameLine(const Value&amp; root) {
  if (root.hasComment(commentAfterOnSameLine))
    document_ += " " + root.getComment(commentAfterOnSameLine);</span>

<span style = "background-color:#fdd">  if (root.hasComment(commentAfter)) {
    document_ += '\n';
    document_ += root.getComment(commentAfter);
    document_ += '\n';</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">bool StyledWriter::hasCommentForValue(const Value&amp; value) {
  return value.hasComment(commentBefore) ||</span>
         value.hasComment(commentAfterOnSameLine) ||
         value.hasComment(commentAfter);
<span style = "background-color:#fdd">}</span>

// Class StyledStreamWriter
// //////////////////////////////////////////////////////////////////

StyledStreamWriter::StyledStreamWriter(String indentation)
<span style = "background-color:#fdd">    : document_(nullptr), indentation_(std::move(indentation)),
      addChildValues_(), indented_(false) {}</span>

<span style = "background-color:#fdd">void StyledStreamWriter::write(OStream&amp; out, const Value&amp; root) {
  document_ = &amp;out;
  addChildValues_ = false;
  indentString_.clear();
  indented_ = true;
  writeCommentBeforeValue(root);
  if (!indented_)
    writeIndent();
  indented_ = true;
  writeValue(root);
  writeCommentAfterValueOnSameLine(root);
  *document_ &lt;&lt; "\n";
  document_ = nullptr; // Forget the stream, for safety.
}</span>

<span style = "background-color:#fdd">void StyledStreamWriter::writeValue(const Value&amp; value) {
  switch (value.type()) {</span>
  case nullValue:
<span style = "background-color:#fdd">    pushValue("null");
    break;</span>
  case intValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asLargestInt()));
    break;</span>
  case uintValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asLargestUInt()));
    break;</span>
  case realValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asDouble()));
    break;</span>
  case stringValue: {
    // Is NULL possible for value.string_? No.
    char const* str;
    char const* end;
<span style = "background-color:#fdd">    bool ok = value.getString(&amp;str, &amp;end);
    if (ok)
      pushValue(valueToQuotedStringN(str, static_cast&lt;size_t&gt;(end - str)));</span>
    else
<span style = "background-color:#fdd">      pushValue("");
    break;</span>
  }
  case booleanValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asBool()));
    break;</span>
  case arrayValue:
<span style = "background-color:#fdd">    writeArrayValue(value);
    break;</span>
  case objectValue: {
<span style = "background-color:#fdd">    Value::Members members(value.getMemberNames());
    if (members.empty())
      pushValue("{}");</span>
    else {
<span style = "background-color:#fdd">      writeWithIndent("{");
      indent();
      auto it = members.begin();</span>
      for (;;) {
<span style = "background-color:#fdd">        const String&amp; name = *it;
        const Value&amp; childValue = value[name];
        writeCommentBeforeValue(childValue);
        writeWithIndent(valueToQuotedString(name.c_str()));
        *document_ &lt;&lt; " : ";
        writeValue(childValue);
        if (++it == members.end()) {
          writeCommentAfterValueOnSameLine(childValue);
          break;</span>
        }
<span style = "background-color:#fdd">        *document_ &lt;&lt; ",";
        writeCommentAfterValueOnSameLine(childValue);
      }
      unindent();
      writeWithIndent("}");
    }
  } break;</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">void StyledStreamWriter::writeArrayValue(const Value&amp; value) {
  unsigned size = value.size();
  if (size == 0)
    pushValue("[]");</span>
  else {
<span style = "background-color:#fdd">    bool isArrayMultiLine = isMultilineArray(value);
    if (isArrayMultiLine) {
      writeWithIndent("[");
      indent();
      bool hasChildValue = !childValues_.empty();
      unsigned index = 0;</span>
      for (;;) {
<span style = "background-color:#fdd">        const Value&amp; childValue = value[index];
        writeCommentBeforeValue(childValue);
        if (hasChildValue)
          writeWithIndent(childValues_[index]);</span>
        else {
<span style = "background-color:#fdd">          if (!indented_)
            writeIndent();
          indented_ = true;
          writeValue(childValue);
          indented_ = false;</span>
        }
<span style = "background-color:#fdd">        if (++index == size) {
          writeCommentAfterValueOnSameLine(childValue);
          break;</span>
        }
<span style = "background-color:#fdd">        *document_ &lt;&lt; ",";
        writeCommentAfterValueOnSameLine(childValue);
      }
      unindent();
      writeWithIndent("]");
    } else // output on a single line</span>
    {
<span style = "background-color:#fdd">      assert(childValues_.size() == size);
      *document_ &lt;&lt; "[ ";
      for (unsigned index = 0; index &lt; size; ++index) {
        if (index &gt; 0)
          *document_ &lt;&lt; ", ";
        *document_ &lt;&lt; childValues_[index];
      }
      *document_ &lt;&lt; " ]";</span>
    }
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">bool StyledStreamWriter::isMultilineArray(const Value&amp; value) {
  ArrayIndex const size = value.size();
  bool isMultiLine = size * 3 &gt;= rightMargin_;
  childValues_.clear();
  for (ArrayIndex index = 0; index &lt; size &amp;&amp; !isMultiLine; ++index) {
    const Value&amp; childValue = value[index];
    isMultiLine = ((childValue.isArray() || childValue.isObject()) &amp;&amp;</span>
                   !childValue.empty());
<span style = "background-color:#fdd">  }
  if (!isMultiLine) // check if line length &gt; max line length</span>
  {
<span style = "background-color:#fdd">    childValues_.reserve(size);
    addChildValues_ = true;
    ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
    for (ArrayIndex index = 0; index &lt; size; ++index) {
      if (hasCommentForValue(value[index])) {
        isMultiLine = true;</span>
      }
<span style = "background-color:#fdd">      writeValue(value[index]);
      lineLength += static_cast&lt;ArrayIndex&gt;(childValues_[index].length());
    }
    addChildValues_ = false;
    isMultiLine = isMultiLine || lineLength &gt;= rightMargin_;</span>
  }
<span style = "background-color:#fdd">  return isMultiLine;
}</span>

<span style = "background-color:#fdd">void StyledStreamWriter::pushValue(const String&amp; value) {
  if (addChildValues_)
    childValues_.push_back(value);</span>
  else
<span style = "background-color:#fdd">    *document_ &lt;&lt; value;
}</span>

<span style = "background-color:#fdd">void StyledStreamWriter::writeIndent() {</span>
  // blep intended this to look at the so-far-written string
  // to determine whether we are already indented, but
  // with a stream we cannot do that. So we rely on some saved state.
  // The caller checks indented_.
<span style = "background-color:#fdd">  *document_ &lt;&lt; '\n' &lt;&lt; indentString_;
}</span>

<span style = "background-color:#fdd">void StyledStreamWriter::writeWithIndent(const String&amp; value) {
  if (!indented_)
    writeIndent();
  *document_ &lt;&lt; value;
  indented_ = false;
}</span>

<span style = "background-color:#fdd">void StyledStreamWriter::indent() { indentString_ += indentation_; }</span>

<span style = "background-color:#fdd">void StyledStreamWriter::unindent() {
  assert(indentString_.size() &gt;= indentation_.size());
  indentString_.resize(indentString_.size() - indentation_.size());
}</span>

<span style = "background-color:#fdd">void StyledStreamWriter::writeCommentBeforeValue(const Value&amp; root) {
  if (!root.hasComment(commentBefore))
    return;</span>

<span style = "background-color:#fdd">  if (!indented_)
    writeIndent();
  const String&amp; comment = root.getComment(commentBefore);
  String::const_iterator iter = comment.begin();
  while (iter != comment.end()) {
    *document_ &lt;&lt; *iter;
    if (*iter == '\n' &amp;&amp; ((iter + 1) != comment.end() &amp;&amp; *(iter + 1) == '/'))</span>
      // writeIndent();  // would include newline
<span style = "background-color:#fdd">      *document_ &lt;&lt; indentString_;
    ++iter;
  }
  indented_ = false;
}</span>

<span style = "background-color:#fdd">void StyledStreamWriter::writeCommentAfterValueOnSameLine(const Value&amp; root) {
  if (root.hasComment(commentAfterOnSameLine))
    *document_ &lt;&lt; ' ' &lt;&lt; root.getComment(commentAfterOnSameLine);</span>

<span style = "background-color:#fdd">  if (root.hasComment(commentAfter)) {
    writeIndent();
    *document_ &lt;&lt; root.getComment(commentAfter);</span>
  }
<span style = "background-color:#fdd">  indented_ = false;
}</span>

<span style = "background-color:#fdd">bool StyledStreamWriter::hasCommentForValue(const Value&amp; value) {
  return value.hasComment(commentBefore) ||</span>
         value.hasComment(commentAfterOnSameLine) ||
         value.hasComment(commentAfter);
<span style = "background-color:#fdd">}</span>

//////////////////////////
// BuiltStyledStreamWriter

/// Scoped enums are not available until C++11.
struct CommentStyle {
  /// Decide whether to write comments.
  enum Enum {
    None, ///&lt; Drop all comments.
    Most, ///&lt; Recover odd behavior of previous versions (not implemented yet).
    All   ///&lt; Keep all comments.
  };
};

struct BuiltStyledStreamWriter : public StreamWriter {
  BuiltStyledStreamWriter(String indentation, CommentStyle::Enum cs,
                          String colonSymbol, String nullSymbol,
                          String endingLineFeedSymbol, bool useSpecialFloats,
                          bool emitUTF8, unsigned int precision,
                          PrecisionType precisionType);
  int write(Value const&amp; root, OStream* sout) override;

private:
  void writeValue(Value const&amp; value);
  void writeArrayValue(Value const&amp; value);
  bool isMultilineArray(Value const&amp; value);
  void pushValue(String const&amp; value);
  void writeIndent();
  void writeWithIndent(String const&amp; value);
  void indent();
  void unindent();
  void writeCommentBeforeValue(Value const&amp; root);
  void writeCommentAfterValueOnSameLine(Value const&amp; root);
  static bool hasCommentForValue(const Value&amp; value);

  using ChildValues = std::vector&lt;String&gt;;

  ChildValues childValues_;
  String indentString_;
  unsigned int rightMargin_;
  String indentation_;
  CommentStyle::Enum cs_;
  String colonSymbol_;
  String nullSymbol_;
  String endingLineFeedSymbol_;
  bool addChildValues_ : 1;
  bool indented_ : 1;
  bool useSpecialFloats_ : 1;
  bool emitUTF8_ : 1;
  unsigned int precision_;
  PrecisionType precisionType_;
};
BuiltStyledStreamWriter::BuiltStyledStreamWriter(
    String indentation, CommentStyle::Enum cs, String colonSymbol,
    String nullSymbol, String endingLineFeedSymbol, bool useSpecialFloats,
    bool emitUTF8, unsigned int precision, PrecisionType precisionType)
<span style = "background-color:#fdd">    : rightMargin_(74), indentation_(std::move(indentation)), cs_(cs),
      colonSymbol_(std::move(colonSymbol)), nullSymbol_(std::move(nullSymbol)),
      endingLineFeedSymbol_(std::move(endingLineFeedSymbol)),
      addChildValues_(false), indented_(false),
      useSpecialFloats_(useSpecialFloats), emitUTF8_(emitUTF8),
      precision_(precision), precisionType_(precisionType) {}
int BuiltStyledStreamWriter::write(Value const&amp; root, OStream* sout) {
  sout_ = sout;
  addChildValues_ = false;
  indented_ = true;
  indentString_.clear();
  writeCommentBeforeValue(root);
  if (!indented_)
    writeIndent();
  indented_ = true;
  writeValue(root);
  writeCommentAfterValueOnSameLine(root);
  *sout_ &lt;&lt; endingLineFeedSymbol_;
  sout_ = nullptr;
  return 0;
}
void BuiltStyledStreamWriter::writeValue(Value const&amp; value) {
  switch (value.type()) {</span>
  case nullValue:
<span style = "background-color:#fdd">    pushValue(nullSymbol_);
    break;</span>
  case intValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asLargestInt()));
    break;</span>
  case uintValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asLargestUInt()));
    break;</span>
  case realValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,</span>
                            precisionType_));
<span style = "background-color:#fdd">    break;</span>
  case stringValue: {
    // Is NULL is possible for value.string_? No.
    char const* str;
    char const* end;
<span style = "background-color:#fdd">    bool ok = value.getString(&amp;str, &amp;end);
    if (ok)
      pushValue(</span>
          valueToQuotedStringN(str, static_cast&lt;size_t&gt;(end - str), emitUTF8_));
    else
<span style = "background-color:#fdd">      pushValue("");
    break;</span>
  }
  case booleanValue:
<span style = "background-color:#fdd">    pushValue(valueToString(value.asBool()));
    break;</span>
  case arrayValue:
<span style = "background-color:#fdd">    writeArrayValue(value);
    break;</span>
  case objectValue: {
<span style = "background-color:#fdd">    Value::Members members(value.getMemberNames());
    if (members.empty())
      pushValue("{}");</span>
    else {
<span style = "background-color:#fdd">      writeWithIndent("{");
      indent();
      auto it = members.begin();</span>
      for (;;) {
<span style = "background-color:#fdd">        String const&amp; name = *it;
        Value const&amp; childValue = value[name];
        writeCommentBeforeValue(childValue);
        writeWithIndent(</span>
            valueToQuotedStringN(name.data(), name.length(), emitUTF8_));
<span style = "background-color:#fdd">        *sout_ &lt;&lt; colonSymbol_;
        writeValue(childValue);
        if (++it == members.end()) {
          writeCommentAfterValueOnSameLine(childValue);
          break;</span>
        }
<span style = "background-color:#fdd">        *sout_ &lt;&lt; ",";
        writeCommentAfterValueOnSameLine(childValue);
      }
      unindent();
      writeWithIndent("}");
    }
  } break;</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">void BuiltStyledStreamWriter::writeArrayValue(Value const&amp; value) {
  unsigned size = value.size();
  if (size == 0)
    pushValue("[]");</span>
  else {
<span style = "background-color:#fdd">    bool isMultiLine = (cs_ == CommentStyle::All) || isMultilineArray(value);
    if (isMultiLine) {
      writeWithIndent("[");
      indent();
      bool hasChildValue = !childValues_.empty();
      unsigned index = 0;</span>
      for (;;) {
<span style = "background-color:#fdd">        Value const&amp; childValue = value[index];
        writeCommentBeforeValue(childValue);
        if (hasChildValue)
          writeWithIndent(childValues_[index]);</span>
        else {
<span style = "background-color:#fdd">          if (!indented_)
            writeIndent();
          indented_ = true;
          writeValue(childValue);
          indented_ = false;</span>
        }
<span style = "background-color:#fdd">        if (++index == size) {
          writeCommentAfterValueOnSameLine(childValue);
          break;</span>
        }
<span style = "background-color:#fdd">        *sout_ &lt;&lt; ",";
        writeCommentAfterValueOnSameLine(childValue);
      }
      unindent();
      writeWithIndent("]");
    } else // output on a single line</span>
    {
<span style = "background-color:#fdd">      assert(childValues_.size() == size);
      *sout_ &lt;&lt; "[";
      if (!indentation_.empty())
        *sout_ &lt;&lt; " ";
      for (unsigned index = 0; index &lt; size; ++index) {
        if (index &gt; 0)
          *sout_ &lt;&lt; ((!indentation_.empty()) ? ", " : ",");
        *sout_ &lt;&lt; childValues_[index];
      }
      if (!indentation_.empty())
        *sout_ &lt;&lt; " ";
      *sout_ &lt;&lt; "]";</span>
    }
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">bool BuiltStyledStreamWriter::isMultilineArray(Value const&amp; value) {
  ArrayIndex const size = value.size();
  bool isMultiLine = size * 3 &gt;= rightMargin_;
  childValues_.clear();
  for (ArrayIndex index = 0; index &lt; size &amp;&amp; !isMultiLine; ++index) {
    Value const&amp; childValue = value[index];
    isMultiLine = ((childValue.isArray() || childValue.isObject()) &amp;&amp;</span>
                   !childValue.empty());
<span style = "background-color:#fdd">  }
  if (!isMultiLine) // check if line length &gt; max line length</span>
  {
<span style = "background-color:#fdd">    childValues_.reserve(size);
    addChildValues_ = true;
    ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
    for (ArrayIndex index = 0; index &lt; size; ++index) {
      if (hasCommentForValue(value[index])) {
        isMultiLine = true;</span>
      }
<span style = "background-color:#fdd">      writeValue(value[index]);
      lineLength += static_cast&lt;ArrayIndex&gt;(childValues_[index].length());
    }
    addChildValues_ = false;
    isMultiLine = isMultiLine || lineLength &gt;= rightMargin_;</span>
  }
<span style = "background-color:#fdd">  return isMultiLine;
}</span>

<span style = "background-color:#fdd">void BuiltStyledStreamWriter::pushValue(String const&amp; value) {
  if (addChildValues_)
    childValues_.push_back(value);</span>
  else
<span style = "background-color:#fdd">    *sout_ &lt;&lt; value;
}</span>

<span style = "background-color:#fdd">void BuiltStyledStreamWriter::writeIndent() {</span>
  // blep intended this to look at the so-far-written string
  // to determine whether we are already indented, but
  // with a stream we cannot do that. So we rely on some saved state.
  // The caller checks indented_.

<span style = "background-color:#fdd">  if (!indentation_.empty()) {</span>
    // In this case, drop newlines too.
<span style = "background-color:#fdd">    *sout_ &lt;&lt; '\n' &lt;&lt; indentString_;</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">void BuiltStyledStreamWriter::writeWithIndent(String const&amp; value) {
  if (!indented_)
    writeIndent();
  *sout_ &lt;&lt; value;
  indented_ = false;
}</span>

<span style = "background-color:#fdd">void BuiltStyledStreamWriter::indent() { indentString_ += indentation_; }</span>

<span style = "background-color:#fdd">void BuiltStyledStreamWriter::unindent() {
  assert(indentString_.size() &gt;= indentation_.size());
  indentString_.resize(indentString_.size() - indentation_.size());
}</span>

<span style = "background-color:#fdd">void BuiltStyledStreamWriter::writeCommentBeforeValue(Value const&amp; root) {
  if (cs_ == CommentStyle::None)
    return;
  if (!root.hasComment(commentBefore))
    return;</span>

<span style = "background-color:#fdd">  if (!indented_)
    writeIndent();
  const String&amp; comment = root.getComment(commentBefore);
  String::const_iterator iter = comment.begin();
  while (iter != comment.end()) {
    *sout_ &lt;&lt; *iter;
    if (*iter == '\n' &amp;&amp; ((iter + 1) != comment.end() &amp;&amp; *(iter + 1) == '/'))</span>
      // writeIndent();  // would write extra newline
<span style = "background-color:#fdd">      *sout_ &lt;&lt; indentString_;
    ++iter;
  }
  indented_ = false;
}</span>

void BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine(
<span style = "background-color:#fdd">    Value const&amp; root) {
  if (cs_ == CommentStyle::None)
    return;
  if (root.hasComment(commentAfterOnSameLine))
    *sout_ &lt;&lt; " " + root.getComment(commentAfterOnSameLine);</span>

<span style = "background-color:#fdd">  if (root.hasComment(commentAfter)) {
    writeIndent();
    *sout_ &lt;&lt; root.getComment(commentAfter);</span>
  }
<span style = "background-color:#fdd">}</span>

// static
<span style = "background-color:#fdd">bool BuiltStyledStreamWriter::hasCommentForValue(const Value&amp; value) {
  return value.hasComment(commentBefore) ||</span>
         value.hasComment(commentAfterOnSameLine) ||
         value.hasComment(commentAfter);
<span style = "background-color:#fdd">}</span>

///////////////
// StreamWriter

<span style = "background-color:#fdd">StreamWriter::StreamWriter() : sout_(nullptr) {}
StreamWriter::~StreamWriter() = default;
StreamWriter::Factory::~Factory() = default;
StreamWriterBuilder::StreamWriterBuilder() { setDefaults(&amp;settings_); }
StreamWriterBuilder::~StreamWriterBuilder() = default;
StreamWriter* StreamWriterBuilder::newStreamWriter() const {
  const String indentation = settings_["indentation"].asString();
  const String cs_str = settings_["commentStyle"].asString();
  const String pt_str = settings_["precisionType"].asString();
  const bool eyc = settings_["enableYAMLCompatibility"].asBool();
  const bool dnp = settings_["dropNullPlaceholders"].asBool();
  const bool usf = settings_["useSpecialFloats"].asBool();
  const bool emitUTF8 = settings_["emitUTF8"].asBool();
  unsigned int pre = settings_["precision"].asUInt();
  CommentStyle::Enum cs = CommentStyle::All;
  if (cs_str == "All") {
    cs = CommentStyle::All;
  } else if (cs_str == "None") {
    cs = CommentStyle::None;
  } else {
    throwRuntimeError("commentStyle must be 'All' or 'None'");</span>
  }
<span style = "background-color:#fdd">  PrecisionType precisionType(significantDigits);
  if (pt_str == "significant") {
    precisionType = PrecisionType::significantDigits;
  } else if (pt_str == "decimal") {
    precisionType = PrecisionType::decimalPlaces;
  } else {
    throwRuntimeError("precisionType must be 'significant' or 'decimal'");</span>
  }
<span style = "background-color:#fdd">  String colonSymbol = " : ";
  if (eyc) {
    colonSymbol = ": ";
  } else if (indentation.empty()) {
    colonSymbol = ":";</span>
  }
<span style = "background-color:#fdd">  String nullSymbol = "null";
  if (dnp) {
    nullSymbol.clear();</span>
  }
<span style = "background-color:#fdd">  if (pre &gt; 17)
    pre = 17;
  String endingLineFeedSymbol;
  return new BuiltStyledStreamWriter(indentation, cs, colonSymbol, nullSymbol,</span>
                                     endingLineFeedSymbol, usf, emitUTF8, pre,
                                     precisionType);
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">bool StreamWriterBuilder::validate(Json::Value* invalid) const {
  static const auto&amp; valid_keys = *new std::set&lt;String&gt;{</span>
      "indentation",
      "commentStyle",
      "enableYAMLCompatibility",
      "dropNullPlaceholders",
      "useSpecialFloats",
      "emitUTF8",
      "precision",
      "precisionType",
  };
<span style = "background-color:#fdd">  for (auto si = settings_.begin(); si != settings_.end(); ++si) {
    auto key = si.name();
    if (valid_keys.count(key))
      continue;
    if (invalid)
      (*invalid)[key] = *si;</span>
    else
<span style = "background-color:#fdd">      return false;
  }
  return invalid ? invalid-&gt;empty() : true;
}</span>

<span style = "background-color:#fdd">Value&amp; StreamWriterBuilder::operator[](const String&amp; key) {
  return settings_[key];
}</span>
// static
<span style = "background-color:#fdd">void StreamWriterBuilder::setDefaults(Json::Value* settings) {</span>
  //! [StreamWriterBuilderDefaults]
<span style = "background-color:#fdd">  (*settings)["commentStyle"] = "All";
  (*settings)["indentation"] = "\t";
  (*settings)["enableYAMLCompatibility"] = false;
  (*settings)["dropNullPlaceholders"] = false;
  (*settings)["useSpecialFloats"] = false;
  (*settings)["emitUTF8"] = false;
  (*settings)["precision"] = 17;
  (*settings)["precisionType"] = "significant";</span>
  //! [StreamWriterBuilderDefaults]
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">String writeString(StreamWriter::Factory const&amp; factory, Value const&amp; root) {
  OStringStream sout;
  StreamWriterPtr const writer(factory.newStreamWriter());
  writer-&gt;write(root, &amp;sout);
  return sout.str();
}</span>

<span style = "background-color:#fdd">OStream&amp; operator&lt;&lt;(OStream&amp; sout, Value const&amp; root) {
  StreamWriterBuilder builder;
  StreamWriterPtr const writer(builder.newStreamWriter());
  writer-&gt;write(root, &amp;sout);
  return sout;
}</span>

} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_writer.cpp
// //////////////////////////////////////////////////////////////////////




</pre>
	</body>
</html>