<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>usModuleResourceBuffer.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

  Library: CppMicroServices

  Copyright (c) German Cancer Research Center (DKFZ)
  All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

============================================================================*/

#include "usModuleResourceBuffer_p.h"

#include "us_stdint.h"

#include &lt;limits&gt;
#include &lt;cassert&gt;
#include &lt;cstdlib&gt;

#ifdef US_PLATFORM_WINDOWS
#define DATA_NEEDS_NEWLINE_CONVERSION 1
#undef REMOVE_LAST_NEWLINE_IN_TEXT_MODE
#else
#undef DATA_NEEDS_NEWLINE_CONVERSION
#define REMOVE_LAST_NEWLINE_IN_TEXT_MODE 1
#endif

US_BEGIN_NAMESPACE

class ModuleResourceBufferPrivate
{
public:

  ModuleResourceBufferPrivate(void* data, std::size_t size, const char* begin, std::ios_base::openmode mode)
<span style = "background-color:#dfd">    : begin(begin)
    , end(begin + size)
    , current(begin)
    , mode(mode)
    , uncompressedData(reinterpret_cast&lt;unsigned char*&gt;(data))</span>
  #ifdef DATA_NEEDS_NEWLINE_CONVERSION
<span style = "background-color:#dfd">    , pos(0)</span>
  #endif
<span style = "background-color:#dfd">  {
  }</span>

  ~ModuleResourceBufferPrivate()
<span style = "background-color:#dfd">  {
    free(uncompressedData);
  }</span>

  const char* const begin;
  const char* const end;
  const char* current;

  const std::ios_base::openmode mode;

  unsigned char* uncompressedData;

#ifdef DATA_NEEDS_NEWLINE_CONVERSION
  // records the stream position ignoring CR characters
  std::streambuf::pos_type pos;
#endif

};

ModuleResourceBuffer::ModuleResourceBuffer(void* data, std::size_t _size,
                                           std::ios_base::openmode mode)
<span style = "background-color:#dfd">  : d(nullptr)
{
  assert(_size &lt; static_cast&lt;std::size_t&gt;(std::numeric_limits&lt;uint32_t&gt;::max()));</span>
  // assert(data != nullptr);

<span style = "background-color:#dfd">  char* begin = reinterpret_cast&lt;char*&gt;(data);
  std::size_t size = _size;</span>

#ifdef DATA_NEEDS_NEWLINE_CONVERSION
<span style = "background-color:#dfd">  if (data != nullptr &amp;&amp; !(mode &amp; std::ios_base::binary) &amp;&amp; begin[0] == '\r')</span>
  {
<span style = "background-color:#fdd">    ++begin;
    --size;</span>
  }
#endif

#ifdef REMOVE_LAST_NEWLINE_IN_TEXT_MODE
  if (data != nullptr &amp;&amp; !(mode &amp; std::ios_base::binary) &amp;&amp; begin[size-1] == '\n')
  {
    --size;
  }
#endif

<span style = "background-color:#dfd">  d = new ModuleResourceBufferPrivate(data, size, begin, mode);
}</span>

ModuleResourceBuffer::~ModuleResourceBuffer()
<span style = "background-color:#dfd">{
  delete d;
}</span>

ModuleResourceBuffer::int_type ModuleResourceBuffer::underflow()
<span style = "background-color:#dfd">{
  if (d-&gt;current == d-&gt;end)
    return traits_type::eof();</span>

#ifdef DATA_NEEDS_NEWLINE_CONVERSION
<span style = "background-color:#dfd">  char c = *d-&gt;current;
  if (!(d-&gt;mode &amp; std::ios_base::binary))</span>
  {
<span style = "background-color:#dfd">    if (c == '\r')</span>
    {
<span style = "background-color:#dfd">      if (d-&gt;current + 1 == d-&gt;end)</span>
      {
<span style = "background-color:#fdd">        return traits_type::eof();</span>
      }
<span style = "background-color:#dfd">      c = d-&gt;current[1];</span>
    }
  }
<span style = "background-color:#dfd">  return traits_type::to_int_type(c);</span>
#else
  return traits_type::to_int_type(*d-&gt;current);
#endif
<span style = "background-color:#dfd">}</span>

ModuleResourceBuffer::int_type ModuleResourceBuffer::uflow()
<span style = "background-color:#dfd">{
  if (d-&gt;current == d-&gt;end)</span>
<span style = "background-color:#fdd">    return traits_type::eof();</span>

#ifdef DATA_NEEDS_NEWLINE_CONVERSION
<span style = "background-color:#dfd">  char c = *d-&gt;current++;
  if (!(d-&gt;mode &amp; std::ios_base::binary))</span>
  {
<span style = "background-color:#dfd">    if (c == '\r')</span>
    {
<span style = "background-color:#dfd">      if (d-&gt;current == d-&gt;end)</span>
      {
<span style = "background-color:#fdd">        return traits_type::eof();</span>
      }
<span style = "background-color:#dfd">      c = *d-&gt;current++;</span>
    }
  }
<span style = "background-color:#dfd">  return traits_type::to_int_type(c);</span>
#else
  return traits_type::to_int_type(*d-&gt;current++);
#endif
<span style = "background-color:#dfd">}</span>

ModuleResourceBuffer::int_type ModuleResourceBuffer::pbackfail(int_type ch)
<span style = "background-color:#fdd">{
  int backOffset = -1;</span>
#ifdef DATA_NEEDS_NEWLINE_CONVERSION
<span style = "background-color:#fdd">  if (!(d-&gt;mode &amp; std::ios_base::binary))</span>
  {
<span style = "background-color:#fdd">    while ((d-&gt;current - backOffset) &gt;= d-&gt;begin &amp;&amp; d-&gt;current[backOffset] == '\r')</span>
    {
<span style = "background-color:#fdd">      --backOffset;
    }</span>
    // d-&gt;begin always points to a character != '\r'
  }
#endif
<span style = "background-color:#fdd">  if (d-&gt;current == d-&gt;begin || (ch != traits_type::eof() &amp;&amp; ch != d-&gt;current[backOffset]))</span>
  {
<span style = "background-color:#fdd">    return traits_type::eof();</span>
  }

<span style = "background-color:#fdd">  d-&gt;current += backOffset;
  return traits_type::to_int_type(*d-&gt;current);
}</span>

std::streamsize ModuleResourceBuffer::showmanyc()
<span style = "background-color:#fdd">{
  assert(d-&gt;current &lt;= d-&gt;end);</span>

#ifdef DATA_NEEDS_NEWLINE_CONVERSION
<span style = "background-color:#fdd">  std::streamsize ssize = 0;
  std::size_t chunkSize = d-&gt;end - d-&gt;current;
  for (std::size_t i = 0; i &lt; chunkSize; ++i)</span>
  {
<span style = "background-color:#fdd">    if (d-&gt;current[i] != '\r')</span>
    {
<span style = "background-color:#fdd">      ++ssize;</span>
    }
<span style = "background-color:#fdd">  }
  return ssize;</span>
#else
  return d-&gt;end - d-&gt;current;
#endif
<span style = "background-color:#fdd">}</span>

std::streambuf::pos_type ModuleResourceBuffer::seekoff(std::streambuf::off_type off,
                                                       std::ios_base::seekdir way,
                                                       std::ios_base::openmode /*which*/)
<span style = "background-color:#dfd">{</span>
#ifdef DATA_NEEDS_NEWLINE_CONVERSION
<span style = "background-color:#dfd">  std::streambuf::off_type step = 1;
  if (way == std::ios_base::beg)</span>
  {
<span style = "background-color:#dfd">    d-&gt;current = d-&gt;begin;
  }
  else if (way == std::ios_base::end)</span>
  {
<span style = "background-color:#dfd">    d-&gt;current = d-&gt;end;
    step = -1;</span>
  }

<span style = "background-color:#dfd">  if (!(d-&gt;mode &amp; std::ios_base::binary))</span>
  {
<span style = "background-color:#dfd">    if (way == std::ios_base::beg)</span>
    {
<span style = "background-color:#dfd">      d-&gt;pos = 0;
    }
    else if (way == std::ios_base::end)</span>
    {
<span style = "background-color:#dfd">      d-&gt;current -= 1;</span>
    }

<span style = "background-color:#dfd">    std::streambuf::off_type i = 0;</span>
    // scan through off amount of characters excluding '\r'
<span style = "background-color:#dfd">    while (i != off)</span>
    {
<span style = "background-color:#fdd">      if (*d-&gt;current != '\r')</span>
      {
<span style = "background-color:#fdd">        i += step;
        d-&gt;pos += step;</span>
      }
<span style = "background-color:#fdd">      d-&gt;current += step;
    }</span>

    // adjust the position in case of a "backwards" seek
<span style = "background-color:#dfd">    if (way == std::ios_base::end)</span>
    {
      // fix pointer from previous while loop
<span style = "background-color:#dfd">      d-&gt;current += 1;
      d-&gt;pos = 0;
      i = 0;
      const std::streampos currInternalPos = d-&gt;current - d-&gt;begin;
      while (i != currInternalPos)</span>
      {
<span style = "background-color:#dfd">        if (d-&gt;begin[i] != '\r')</span>
        {
<span style = "background-color:#dfd">          d-&gt;pos += 1;</span>
        }
<span style = "background-color:#dfd">        ++i;
      }</span>
    }
<span style = "background-color:#dfd">  }</span>
  else
  {
<span style = "background-color:#fdd">    d-&gt;current += off;
    d-&gt;pos = d-&gt;current - d-&gt;begin;</span>
  }
<span style = "background-color:#dfd">  return d-&gt;pos;</span>
#else
  if (way == std::ios_base::beg)
  {
    d-&gt;current = d-&gt;begin + off;
    return off;
  }
  else if (way == std::ios_base::cur)
  {
    d-&gt;current += off;
    return d-&gt;current - d-&gt;begin;
  }
  else
  {
    d-&gt;current = d-&gt;end + off;
    return d-&gt;current - d-&gt;begin;
  }
#endif
<span style = "background-color:#dfd">}</span>

std::streambuf::pos_type ModuleResourceBuffer::seekpos(std::streambuf::pos_type sp,
                                                       std::ios_base::openmode /*which*/)
<span style = "background-color:#fdd">{
  return this-&gt;seekoff(sp, std::ios_base::beg);
}</span>

US_END_NAMESPACE</pre>
	</body>
</html>