<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkLabelSet.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef __mitkLabelSet_H_
#define __mitkLabelSet_H_

#include "MitkMultilabelExports.h"
#include &lt;mitkLookupTable.h&gt;
#include &lt;mitkMessage.h&gt;

#include &lt;itkObject.h&gt;
#include &lt;itkObjectFactory.h&gt;

#include &lt;mitkLabel.h&gt;

namespace mitk
{
  //
  // Documentation
  // @brief LabelSet containing the labels corresponding to a segmentation session.
  // @ingroup Data
  //

  class MITKMULTILABEL_EXPORT LabelSet : public itk::Object
  {
  public:
<span style = "background-color:#fdd">    mitkClassMacroItkParent(LabelSet, itk::Object);
    itkNewMacro(Self);</span>

    typedef mitk::Label::PixelType PixelType;

    typedef std::map&lt;PixelType, Label::Pointer&gt; LabelContainerType;
    typedef LabelContainerType::const_iterator LabelContainerConstIteratorType;
    typedef LabelContainerType::iterator LabelContainerIteratorType;

    /**
    * \brief AddLabelEvent is emitted whenever a new label has been added to the LabelSet.
    *
    * Observers should register to this event by calling myLabelSet-&gt;AddLabelEvent.AddListener(myObject,
    * MyObject::MyMethod).
    * After registering, myObject-&gt;MyMethod() will be called every time a new label has been added to the LabelSet.
    * Observers should unregister by calling myLabelSet-&gt;AddLabelEvent.RemoveListener(myObject, MyObject::MyMethod).
    *
    * member variable is not needed to be locked in multi-threaded scenarios since the LabelSetEvent is a typedef for
    * a Message1 object which is thread safe
    */
    Message&lt;&gt; AddLabelEvent;

    /**
    * \brief RemoveLabelEvent is emitted whenever a new label has been removed from the LabelSet.
    *
    * Observers should register to this event by calling myLabelSet-&gt;RemoveLabelEvent.AddListener(myObject,
    * MyObject::MyMethod).
    * After registering, myObject-&gt;MyMethod() will be called every time a new label has been removed from the LabelSet.
    * Observers should unregister by calling myLabelSet-&gt;RemoveLabelEvent.RemoveListener(myObject, MyObject::MyMethod).
    *
    * member variable is not needed to be locked in multi-threaded scenarios since the LabelSetEvent is a typedef for
    * a Message object which is thread safe
    */
    Message&lt;&gt; RemoveLabelEvent;

    /**
    * \brief ModifyLabelEvent is emitted whenever a label has been modified from the LabelSet.
    *
    * Observers should register to this event by calling myLabelSet-&gt;ModifyLabelEvent.AddListener(myObject,
    * MyObject::MyMethod).
    * After registering, myObject-&gt;MyMethod() will be called every time a new label has been removed from the LabelSet.
    * Observers should unregister by calling myLabelSet-&gt;ModifyLabelEvent.RemoveListener(myObject, MyObject::MyMethod).
    *
    * member variable is not needed to be locked in multi-threaded scenarios since the LabelSetEvent is a typedef for
    * a Message object which is thread safe
    */
    Message&lt;&gt; ModifyLabelEvent;

    /**
    * \brief ActiveLabelEvent is emitted whenever a label has been set as active in the LabelSet.
    */
    Message1&lt;PixelType&gt; ActiveLabelEvent;

    /**
    * \brief AllLabelsModifiedEvent is emitted whenever a new label has been removed from the LabelSet.
    *
    * Observers should register to this event by calling myLabelSet-&gt;AllLabelsModifiedEvent.AddListener(myObject,
    * MyObject::MyMethod).
    * After registering, myObject-&gt;MyMethod() will be called every time a new label has been removed from the LabelSet.
    * Observers should unregister by calling myLabelSet-&gt;AllLabelsModifiedEvent.RemoveListener(myObject,
    * MyObject::MyMethod).
    *
    * member variable is not needed to be locked in multi-threaded scenarios since the LabelSetEvent is a typedef for
    * a Message object which is thread safe
    */
    Message&lt;&gt; AllLabelsModifiedEvent;

    /** \brief Returns a const iterator poiting to the begining of the container.
    */
    LabelContainerConstIteratorType IteratorConstBegin() const;

    /** \brief Returns a const iterator pointing to the end of the container.
    */
    LabelContainerConstIteratorType IteratorConstEnd() const;

    /** \brief Returns a iterator poiting to the begining of the container.
    */
    LabelContainerIteratorType IteratorBegin();

    /** \brief Returns a iterator pointing to the end of the container.
    */
    LabelContainerIteratorType IteratorEnd();

    /** \brief
     * Recall itk::Object::Modified event from a label and send a ModifyLabelEvent
    */
    void OnLabelModified();

    /** \brief
    */
    void SetLayer(unsigned int);

    /** \brief
    */
    void SetActiveLabel(PixelType);

    /** \brief
    */
    void RemoveLabel(PixelType);

    /** \brief
    */
    bool ExistLabel(PixelType);

    /** \brief
    */
    void AddLabel(mitk::Label *label);

    /** \brief
    */
    void AddLabel(const std::string &amp;name, const Color &amp;color);

    /** \brief
    */
    void RenameLabel(PixelType, const std::string &amp;, const Color &amp;);

    /** \brief
    */
    unsigned int GetNumberOfLabels() const;

    /** \brief
    */
    void SetAllLabelsVisible(bool);

    /** \brief
    */
    void SetAllLabelsLocked(bool);

    /** \brief
    */
    void RemoveAllLabels();

    void SetNextActiveLabel();

    /** \brief
    */
<span style = "background-color:#fdd">    Label *GetActiveLabel() { return GetLabel(m_ActiveLabelValue); }</span>
    /** \brief
    */
<span style = "background-color:#fdd">    const Label *GetActiveLabel() const { return GetLabel(m_ActiveLabelValue); }</span>
    /** \brief
    */
    Label *GetLabel(PixelType pixelValue);

    /** \brief
    */
    const Label *GetLabel(PixelType pixelValue) const;

<span style = "background-color:#fdd">    itkGetMacro(Layer, int);</span>

<span style = "background-color:#fdd">    itkGetConstMacro(Layer, int);</span>

<span style = "background-color:#fdd">    itkGetModifiableObjectMacro(LookupTable, mitk::LookupTable);</span>

      /** \brief
      */
      void SetLookupTable(LookupTable *lut);

    /** \brief
    */
    void UpdateLookupTable(PixelType pixelValue);

  protected:
    LabelSet();
    LabelSet(const LabelSet &amp;);

<span style = "background-color:#fdd">    mitkCloneMacro(Self);</span>

      ~LabelSet() override;

    void PrintSelf(std::ostream &amp;os, itk::Indent indent) const override;

    LabelContainerType m_LabelContainer;

    LookupTable::Pointer m_LookupTable;

    PixelType m_ActiveLabelValue;

    unsigned int m_Layer;
  };

  /**
  * @brief Equal A function comparing two label sets  for beeing equal in data
  *
  * @ingroup MITKTestingAPI
  *
  * Following aspects are tested for equality:
  *  - LabelSetmembers
  *  - Label container (map)
  *
  * @param rightHandSide An image to be compared
  * @param leftHandSide An image to be compared
  * @param eps Tolarence for comparison. You can use mitk::eps in most cases.
  * @param verbose Flag indicating if the user wants detailed console output or not.
  * @return true, if all subsequent comparisons are true, false otherwise
  */
  MITKMULTILABEL_EXPORT bool Equal(const mitk::LabelSet &amp;leftHandSide,
                                   const mitk::LabelSet &amp;rightHandSide,
                                   ScalarType eps,
                                   bool verbose);

} // namespace mitk

#endif // __mitkLabelSet_H_</pre>
	</body>
</html>