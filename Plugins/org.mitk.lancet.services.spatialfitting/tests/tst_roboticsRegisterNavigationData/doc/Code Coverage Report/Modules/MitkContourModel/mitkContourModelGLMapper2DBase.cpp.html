<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkContourModelGLMapper2DBase.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkContourModelSetGLMapper2D.h"

#include "mitkColorProperty.h"
#include "mitkContourModelSet.h"
#include "mitkPlaneGeometry.h"
#include "mitkProperties.h"
#include &lt;vtkContext2D.h&gt;
#include &lt;vtkLinearTransform.h&gt;
#include &lt;vtkOpenGLContextDevice2D.h&gt;
#include &lt;vtkPen.h&gt;

#include "mitkManualPlacementAnnotationRenderer.h"
#include "mitkBaseRenderer.h"
#include "mitkContourModel.h"
#include "mitkTextAnnotation2D.h"

mitk::ContourModelGLMapper2DBase::ContourModelGLMapper2DBase()
<span style = "background-color:#fdd">{
  m_PointNumbersAnnotation = mitk::TextAnnotation2D::New();
  m_ControlPointNumbersAnnotation = mitk::TextAnnotation2D::New();
}</span>

mitk::ContourModelGLMapper2DBase::~ContourModelGLMapper2DBase()
<span style = "background-color:#fdd">{
}</span>

void mitk::ContourModelGLMapper2DBase::ApplyColorAndOpacityProperties(mitk::BaseRenderer *renderer, vtkActor * /*actor*/)
<span style = "background-color:#fdd">{
  auto* localStorage = m_LocalStorageHandler.GetLocalStorage(renderer);</span>

<span style = "background-color:#fdd">  float rgba[4] = { 1.0f, 1.0f, 1.0f, 1.0f };</span>
  // check for color prop and use it for rendering if it exists
<span style = "background-color:#fdd">  GetDataNode()-&gt;GetColor(rgba, renderer, "color");</span>
  // check for opacity prop and use it for rendering if it exists
<span style = "background-color:#fdd">  GetDataNode()-&gt;GetOpacity(rgba[3], renderer, "opacity");</span>

<span style = "background-color:#fdd">  if (localStorage-&gt;Context-&gt;GetPen() == nullptr)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }
<span style = "background-color:#fdd">  localStorage-&gt;Context-&gt;GetPen()-&gt;SetColorF((double)rgba[0], (double)rgba[1], (double)rgba[2], (double)rgba[3]);
}</span>

void mitk::ContourModelGLMapper2DBase::DrawContour(mitk::ContourModel *renderingContour, mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  if (std::find(m_RendererList.begin(), m_RendererList.end(), renderer) == m_RendererList.end())</span>
  {
<span style = "background-color:#fdd">    m_RendererList.push_back(renderer);</span>
  }

<span style = "background-color:#fdd">  mitk::ManualPlacementAnnotationRenderer::AddAnnotation(m_PointNumbersAnnotation.GetPointer(), renderer);
  m_PointNumbersAnnotation-&gt;SetVisibility(false);</span>

<span style = "background-color:#fdd">  mitk::ManualPlacementAnnotationRenderer::AddAnnotation(m_ControlPointNumbersAnnotation.GetPointer(), renderer);
  m_ControlPointNumbersAnnotation-&gt;SetVisibility(false);</span>

<span style = "background-color:#fdd">  InternalDrawContour(renderingContour, renderer);
}</span>

void mitk::ContourModelGLMapper2DBase::InternalDrawContour(mitk::ContourModel *renderingContour,
                                                           mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  if (!renderingContour)
    return;</span>

<span style = "background-color:#fdd">  auto* localStorage = m_LocalStorageHandler.GetLocalStorage(renderer);</span>

<span style = "background-color:#fdd">  localStorage-&gt;Device = vtkSmartPointer&lt;vtkOpenGLContextDevice2D&gt;::New();
  localStorage-&gt;Context = vtkSmartPointer&lt;vtkContext2D&gt;::New();</span>

<span style = "background-color:#fdd">  localStorage-&gt;Device-&gt;Begin(renderer-&gt;GetVtkRenderer());
  localStorage-&gt;Context-&gt;Begin(localStorage-&gt;Device);</span>

<span style = "background-color:#fdd">  mitk::DataNode *dataNode = this-&gt;GetDataNode();</span>

<span style = "background-color:#fdd">  renderingContour-&gt;UpdateOutputInformation();</span>

<span style = "background-color:#fdd">  const auto timestep = this-&gt;GetTimestep();</span>

<span style = "background-color:#fdd">  if (!renderingContour-&gt;IsEmptyTimeStep(timestep))</span>
  {
    // apply color and opacity read from the PropertyList
<span style = "background-color:#fdd">    ApplyColorAndOpacityProperties(renderer);</span>

<span style = "background-color:#fdd">    mitk::ColorProperty::Pointer colorprop =</span>
      dynamic_cast&lt;mitk::ColorProperty *&gt;(dataNode-&gt;GetProperty("contour.color", renderer));
<span style = "background-color:#fdd">    float opacity = 0.5;
    dataNode-&gt;GetFloatProperty("opacity", opacity, renderer);</span>

<span style = "background-color:#fdd">    if (colorprop)</span>
    {
      // set the color of the contour
<span style = "background-color:#fdd">      double red = colorprop-&gt;GetColor().GetRed();
      double green = colorprop-&gt;GetColor().GetGreen();
      double blue = colorprop-&gt;GetColor().GetBlue();
      localStorage-&gt;Context-&gt;GetPen()-&gt;SetColorF(red, green, blue, opacity);</span>
    }

<span style = "background-color:#fdd">    mitk::ColorProperty::Pointer selectedcolor =</span>
      dynamic_cast&lt;mitk::ColorProperty *&gt;(dataNode-&gt;GetProperty("contour.points.color", renderer));
<span style = "background-color:#fdd">    if (!selectedcolor)</span>
    {
<span style = "background-color:#fdd">      selectedcolor = mitk::ColorProperty::New(1.0, 0.0, 0.1);</span>
    }

<span style = "background-color:#fdd">    vtkLinearTransform *transform = dataNode-&gt;GetVtkTransform();</span>

    //    ContourModel::OutputType point;
<span style = "background-color:#fdd">    mitk::Point3D point;</span>

<span style = "background-color:#fdd">    mitk::Point3D p;</span>
    float vtkp[3];
<span style = "background-color:#fdd">    float lineWidth = 3.0;</span>

<span style = "background-color:#fdd">    bool drawit = false;</span>

<span style = "background-color:#fdd">    bool isHovering = false;
    dataNode-&gt;GetBoolProperty("contour.hovering", isHovering);</span>

<span style = "background-color:#fdd">    if (isHovering)
      dataNode-&gt;GetFloatProperty("contour.hovering.width", lineWidth);</span>
    else
<span style = "background-color:#fdd">      dataNode-&gt;GetFloatProperty("contour.width", lineWidth);</span>

<span style = "background-color:#fdd">    bool showSegments = false;
    dataNode-&gt;GetBoolProperty("contour.segments.show", showSegments);</span>

<span style = "background-color:#fdd">    bool showControlPoints = false;
    dataNode-&gt;GetBoolProperty("contour.controlpoints.show", showControlPoints);</span>

<span style = "background-color:#fdd">    bool showPoints = false;
    dataNode-&gt;GetBoolProperty("contour.points.show", showPoints);</span>

<span style = "background-color:#fdd">    bool showPointsNumbers = false;
    dataNode-&gt;GetBoolProperty("contour.points.text", showPointsNumbers);</span>

<span style = "background-color:#fdd">    bool showControlPointsNumbers = false;
    dataNode-&gt;GetBoolProperty("contour.controlpoints.text", showControlPointsNumbers);</span>

<span style = "background-color:#fdd">    bool projectmode = false;
    dataNode-&gt;GetVisibility(projectmode, renderer, "contour.project-onto-plane");</span>

<span style = "background-color:#fdd">    auto pointsIt = renderingContour-&gt;IteratorBegin(timestep);</span>

<span style = "background-color:#fdd">    Point2D pt2d; // projected_p in display coordinates
    Point2D lastPt2d;</span>

<span style = "background-color:#fdd">    int index = 0;</span>

<span style = "background-color:#fdd">    mitk::ScalarType maxDiff = 0.25;</span>

<span style = "background-color:#fdd">    while (pointsIt != renderingContour-&gt;IteratorEnd(timestep))</span>
    {
<span style = "background-color:#fdd">      lastPt2d = pt2d;</span>

<span style = "background-color:#fdd">      point = (*pointsIt)-&gt;Coordinates;</span>

<span style = "background-color:#fdd">      itk2vtk(point, vtkp);
      transform-&gt;TransformPoint(vtkp, vtkp);
      vtk2itk(vtkp, p);</span>

<span style = "background-color:#fdd">      renderer-&gt;WorldToView(p, pt2d);</span>

<span style = "background-color:#fdd">      ScalarType scalardiff = fabs(renderer-&gt;GetCurrentWorldPlaneGeometry()-&gt;SignedDistance(p));</span>

      // project to plane
<span style = "background-color:#fdd">      if (projectmode)</span>
      {
<span style = "background-color:#fdd">        drawit = true;
      }
      else if (scalardiff &lt; maxDiff) // point is close enough to be drawn</span>
      {
<span style = "background-color:#fdd">        drawit = true;
      }</span>
      else
      {
<span style = "background-color:#fdd">        drawit = false;</span>
      }

      // draw line
<span style = "background-color:#fdd">      if (drawit)</span>
      {
<span style = "background-color:#fdd">        if (showSegments)</span>
        {
          // lastPt2d is not valid in first step
<span style = "background-color:#fdd">          if (!(pointsIt == renderingContour-&gt;IteratorBegin(timestep)))</span>
          {
<span style = "background-color:#fdd">            localStorage-&gt;Context-&gt;GetPen()-&gt;SetWidth(lineWidth);
            localStorage-&gt;Context-&gt;DrawLine(pt2d[0], pt2d[1], lastPt2d[0], lastPt2d[1]);
            localStorage-&gt;Context-&gt;GetPen()-&gt;SetWidth(1);</span>
          }
        }

<span style = "background-color:#fdd">        if (showControlPoints)</span>
        {
          // draw ontrol points
<span style = "background-color:#fdd">          if ((*pointsIt)-&gt;IsControlPoint)</span>
          {
<span style = "background-color:#fdd">            float pointsize = 4;
            Point2D tmp;</span>

<span style = "background-color:#fdd">            Vector2D horz, vert;
            horz[1] = 0;
            vert[0] = 0;
            horz[0] = pointsize;
            vert[1] = pointsize;
            localStorage-&gt;Context-&gt;GetPen()-&gt;SetColorF(selectedcolor-&gt;GetColor().GetRed(),</span>
                                                 selectedcolor-&gt;GetColor().GetBlue(),
                                                 selectedcolor-&gt;GetColor().GetGreen());
<span style = "background-color:#fdd">            localStorage-&gt;Context-&gt;GetPen()-&gt;SetWidth(1);</span>
            // a rectangle around the point with the selected color
<span style = "background-color:#fdd">            auto* rectPts = new float[8];
            tmp = pt2d - horz;
            rectPts[0] = tmp[0];
            rectPts[1] = tmp[1];
            tmp = pt2d + vert;
            rectPts[2] = tmp[0];
            rectPts[3] = tmp[1];
            tmp = pt2d + horz;
            rectPts[4] = tmp[0];
            rectPts[5] = tmp[1];
            tmp = pt2d - vert;
            rectPts[6] = tmp[0];
            rectPts[7] = tmp[1];
            localStorage-&gt;Context-&gt;DrawPolygon(rectPts,4);</span>
            // the actual point in the specified color to see the usual color of the point
<span style = "background-color:#fdd">            localStorage-&gt;Context-&gt;GetPen()-&gt;SetColorF(</span>
              colorprop-&gt;GetColor().GetRed(), colorprop-&gt;GetColor().GetGreen(), colorprop-&gt;GetColor().GetBlue());
<span style = "background-color:#fdd">            localStorage-&gt;Context-&gt;DrawPoint(pt2d[0], pt2d[1]);</span>
          }
        }

<span style = "background-color:#fdd">        if (showPoints)</span>
        {
<span style = "background-color:#fdd">          float pointsize = 3;
          Point2D tmp;</span>

<span style = "background-color:#fdd">          Vector2D horz, vert;
          horz[1] = 0;
          vert[0] = 0;
          horz[0] = pointsize;
          vert[1] = pointsize;
          localStorage-&gt;Context-&gt;GetPen()-&gt;SetColorF(0.0, 0.0, 0.0);
          localStorage-&gt;Context-&gt;GetPen()-&gt;SetWidth(1);</span>
          // a rectangle around the point with the selected color
<span style = "background-color:#fdd">          auto* rectPts = new float[8];
          tmp = pt2d - horz;
          rectPts[0] = tmp[0];
          rectPts[1] = tmp[1];
          tmp = pt2d + vert;
          rectPts[2] = tmp[0];
          rectPts[3] = tmp[1];
          tmp = pt2d + horz;
          rectPts[4] = tmp[0];
          rectPts[5] = tmp[1];
          tmp = pt2d - vert;
          rectPts[6] = tmp[0];
          rectPts[7] = tmp[1];
          localStorage-&gt;Context-&gt;DrawPolygon(rectPts, 4);</span>
          // the actual point in the specified color to see the usual color of the point
<span style = "background-color:#fdd">          localStorage-&gt;Context-&gt;GetPen()-&gt;SetColorF(</span>
            colorprop-&gt;GetColor().GetRed(), colorprop-&gt;GetColor().GetGreen(), colorprop-&gt;GetColor().GetBlue());
<span style = "background-color:#fdd">          localStorage-&gt;Context-&gt;DrawPoint(pt2d[0], pt2d[1]);</span>
        }

<span style = "background-color:#fdd">        if (showPointsNumbers)</span>
        {
<span style = "background-color:#fdd">          std::string l;
          std::stringstream ss;
          ss &lt;&lt; index;
          l.append(ss.str());</span>

          float rgb[3];
<span style = "background-color:#fdd">          rgb[0] = 0.0;
          rgb[1] = 0.0;
          rgb[2] = 0.0;</span>

<span style = "background-color:#fdd">          WriteTextWithAnnotation(m_PointNumbersAnnotation, l.c_str(), rgb, pt2d, renderer);
        }</span>

<span style = "background-color:#fdd">        if (showControlPointsNumbers &amp;&amp; (*pointsIt)-&gt;IsControlPoint)</span>
        {
<span style = "background-color:#fdd">          std::string l;
          std::stringstream ss;
          ss &lt;&lt; index;
          l.append(ss.str());</span>

          float rgb[3];
<span style = "background-color:#fdd">          rgb[0] = 1.0;
          rgb[1] = 1.0;
          rgb[2] = 0.0;</span>

<span style = "background-color:#fdd">          WriteTextWithAnnotation(m_ControlPointNumbersAnnotation, l.c_str(), rgb, pt2d, renderer);
        }</span>

<span style = "background-color:#fdd">        index++;</span>
      }

<span style = "background-color:#fdd">      pointsIt++;
    } // end while iterate over controlpoints</span>

    // close contour if necessary
<span style = "background-color:#fdd">    if (renderingContour-&gt;IsClosed(timestep) &amp;&amp; drawit &amp;&amp; showSegments)</span>
    {
<span style = "background-color:#fdd">      lastPt2d = pt2d;
      point = renderingContour-&gt;GetVertexAt(0, timestep)-&gt;Coordinates;
      itk2vtk(point, vtkp);
      transform-&gt;TransformPoint(vtkp, vtkp);
      vtk2itk(vtkp, p);
      renderer-&gt;WorldToDisplay(p, pt2d);</span>

<span style = "background-color:#fdd">      localStorage-&gt;Context-&gt;GetPen()-&gt;SetWidth(lineWidth);
      localStorage-&gt;Context-&gt;DrawLine(lastPt2d[0], lastPt2d[1], pt2d[0], pt2d[1]);
      localStorage-&gt;Context-&gt;GetPen()-&gt;SetWidth(1);</span>
    }

    // draw selected vertex if exists
<span style = "background-color:#fdd">    if (renderingContour-&gt;GetSelectedVertex())</span>
    {
      // transform selected vertex
<span style = "background-color:#fdd">      point = renderingContour-&gt;GetSelectedVertex()-&gt;Coordinates;</span>

<span style = "background-color:#fdd">      itk2vtk(point, vtkp);
      transform-&gt;TransformPoint(vtkp, vtkp);
      vtk2itk(vtkp, p);</span>

<span style = "background-color:#fdd">      renderer-&gt;WorldToDisplay(p, pt2d);</span>

<span style = "background-color:#fdd">      ScalarType scalardiff = fabs(renderer-&gt;GetCurrentWorldPlaneGeometry()-&gt;SignedDistance(p));</span>
      //----------------------------------

      // draw point if close to plane
<span style = "background-color:#fdd">      if (scalardiff &lt; maxDiff)</span>
      {
<span style = "background-color:#fdd">        float pointsize = 5;
        Point2D tmp;</span>

<span style = "background-color:#fdd">        localStorage-&gt;Context-&gt;GetPen()-&gt;SetColorF(0.0, 1.0, 0.0);
        localStorage-&gt;Context-&gt;GetPen()-&gt;SetWidth(1);</span>
        // a rectangle around the point with the selected color
<span style = "background-color:#fdd">        auto* rectPts = new float[8];</span>
        // a diamond around the point
        // begin from upper left corner and paint clockwise
<span style = "background-color:#fdd">        rectPts[0] = pt2d[0] - pointsize;
        rectPts[1] = pt2d[1] + pointsize;
        rectPts[2] = pt2d[0] + pointsize;
        rectPts[3] = pt2d[1] + pointsize;
        rectPts[4] = pt2d[0] + pointsize;
        rectPts[5] = pt2d[1] - pointsize;
        rectPts[6] = pt2d[0] - pointsize;
        rectPts[7] = pt2d[1] - pointsize;
        localStorage-&gt;Context-&gt;DrawPolygon(rectPts, 4);</span>
      }
      //------------------------------------
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  localStorage-&gt;Context = nullptr;
  localStorage-&gt;Device = nullptr;
}</span>

void mitk::ContourModelGLMapper2DBase::WriteTextWithAnnotation(TextAnnotationPointerType textAnnotation,
                                                            const char *text,
                                                            float rgb[3],
                                                            Point2D /*pt2d*/,
                                                            mitk::BaseRenderer * /*renderer*/)
<span style = "background-color:#fdd">{
  textAnnotation-&gt;SetText(text);
  textAnnotation-&gt;SetColor(rgb);
  textAnnotation-&gt;SetOpacity(1);
  textAnnotation-&gt;SetFontSize(16);
  textAnnotation-&gt;SetBoolProperty("drawShadow", false);
  textAnnotation-&gt;SetVisibility(true);
}</span></pre>
	</body>
</html>