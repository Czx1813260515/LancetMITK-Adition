<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkRegVisHelper.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/


//VTK
#include &lt;vtkPolyLine.h&gt;
#include &lt;vtkIdList.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkFloatArray.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkWarpVector.h&gt;
#include &lt;vtkCleanPolyData.h&gt;
#include &lt;vtkVectorNorm.h&gt;
#include &lt;vtkGlyph3D.h&gt;
#include &lt;vtkArrowSource.h&gt;

//MITK
#include &lt;mitkProperties.h&gt;

//MITK
#include "mitkRegVisHelper.h"
#include "mitkRegVisPropertyTags.h"
#include "mitkRegVisDirectionProperty.h"
#include "mitkMAPRegistrationWrapper.h"

//MAP
#include "mapRegistration.h"

namespace mitk
{

  void GetGridGeometryFromNode(const mitk::DataNode* regNode, mitk::Geometry3D::Pointer&amp; gridDesc, unsigned int&amp; gridFrequ)
<span style = "background-color:#fdd">  {</span>

<span style = "background-color:#fdd">    int internalFrequ = 1;</span>

<span style = "background-color:#fdd">    if(!regNode-&gt;GetIntProperty(mitk::nodeProp_RegVisGridFrequence,internalFrequ))</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot configure node correctly. Node property "&lt;&lt;mitk::nodeProp_RegVisGridFrequence&lt;&lt;" is not correctly defined.";</span>
    }

<span style = "background-color:#fdd">    mitk::Vector3DProperty* valueProp = nullptr;
    mitk::Vector3D size;
    mitk::Vector3D spacing;</span>

<span style = "background-color:#fdd">    if (regNode-&gt;GetProperty(valueProp, mitk::nodeProp_RegVisFOVSize))</span>
    {
<span style = "background-color:#fdd">      size = valueProp-&gt;GetValue();
    }</span>
    else
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot configure node correctly. Node property "&lt;&lt;mitk::nodeProp_RegVisFOVSize&lt;&lt;" is not correctly defined.";</span>
    }

<span style = "background-color:#fdd">    if (regNode-&gt;GetProperty(valueProp, mitk::nodeProp_RegVisFOVSpacing))</span>
    {
<span style = "background-color:#fdd">      spacing = valueProp-&gt;GetValue();
    }</span>
    else
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot configure node correctly. Node property "&lt;&lt;mitk::nodeProp_RegVisFOVSpacing&lt;&lt;" is not correctly defined.";</span>
    }

<span style = "background-color:#fdd">    mitk::Point3dProperty* originProp = nullptr;
    mitk::Point3D origin;
    if (regNode-&gt;GetProperty(originProp, mitk::nodeProp_RegVisFOVOrigin))</span>
    {
<span style = "background-color:#fdd">      origin = originProp-&gt;GetValue();
    }</span>
    else
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot configure node correctly. Node property "&lt;&lt;mitk::nodeProp_RegVisFOVOrigin&lt;&lt;" is not correctly defined.";</span>
    }

<span style = "background-color:#fdd">    gridDesc = mitk::Geometry3D::New();
    mitk::Geometry3D::BoundsArrayType bounds = gridDesc-&gt;GetBounds();
    bounds[0] = 0;
    bounds[1] = size[0]/spacing[0];
    bounds[2] = 0;
    bounds[3] = size[1]/spacing[1];
    bounds[4] = 0;
    bounds[5] = size[2]/spacing[2];
    gridDesc-&gt;SetBounds(bounds);
    gridDesc-&gt;SetSpacing(spacing);
    gridDesc-&gt;SetOrigin(origin);</span>

<span style = "background-color:#fdd">    gridFrequ = internalFrequ;
  }</span>


  vtkSmartPointer&lt;vtkPolyData&gt; Generate3DDeformationGlyph(const mitk::BaseGeometry* gridDesc, const map::core::RegistrationKernelBase&lt;3,3&gt;* regKernel)
<span style = "background-color:#fdd">  {
    assert(gridDesc);</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPoints&gt;  points = vtkSmartPointer&lt;vtkPoints&gt;::New();
    vtkSmartPointer&lt;vtkFloatArray&gt; vectors = vtkSmartPointer&lt;vtkFloatArray&gt;::New();
    vectors-&gt;SetNumberOfComponents(3);
    vectors-&gt;SetName("DeformationVectors");</span>

<span style = "background-color:#fdd">    long xExtend = itk::Math::Ceil&lt;long,mitk::ScalarType&gt;(gridDesc-&gt;GetExtent(0));
    long yExtend = itk::Math::Ceil&lt;long,mitk::ScalarType&gt;(gridDesc-&gt;GetExtent(1));
    long zExtend = itk::Math::Ceil&lt;long,mitk::ScalarType&gt;(gridDesc-&gt;GetExtent(2));</span>

<span style = "background-color:#fdd">    mitk::Geometry3D::BoundsArrayType bounds = gridDesc-&gt;GetBounds();</span>

    //Generate Points
<span style = "background-color:#fdd">    mitk::Point3D pos;
    for (pos[2] = bounds[4] ; pos[2]&lt; bounds[4]+zExtend; ++(pos[2]))</span>
    {
<span style = "background-color:#fdd">      for (pos[1] = bounds[2]; pos[1]&lt; bounds[2]+yExtend; ++(pos[1]))</span>
      {
<span style = "background-color:#fdd">        for (pos[0] = bounds[0]; pos[0]&lt; bounds[0]+xExtend; ++(pos[0]))</span>
        {
<span style = "background-color:#fdd">          mitk::Point3D worldPos;
          gridDesc-&gt;IndexToWorld(pos,worldPos);
          points-&gt;InsertNextPoint(worldPos[0],worldPos[1],worldPos[2]);</span>

<span style = "background-color:#fdd">          if(regKernel)</span>
          {
<span style = "background-color:#fdd">            map::core::RegistrationKernelBase&lt;3,3&gt;::InputPointType regInput(worldPos);</span>
            map::core::RegistrationKernelBase&lt;3,3&gt;::OutputPointType regOutput;

<span style = "background-color:#fdd">            bool mapped = regKernel-&gt;mapPoint(regInput,regOutput);
            mitk::Vector3D vector(regOutput-regInput);
            if (!mapped)</span>
            {
<span style = "background-color:#fdd">              vector.Fill(0.0);</span>
            }

<span style = "background-color:#fdd">            vectors-&gt;InsertNextTuple(vector.GetDataPointer());</span>
          }
<span style = "background-color:#fdd">        }
      }
    }</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPolyData&gt; input = vtkSmartPointer&lt;vtkPolyData&gt;::New();
    vtkSmartPointer&lt;vtkFloatArray&gt; vectorMagnitude;</span>

<span style = "background-color:#fdd">    input-&gt;SetPoints(points);</span>

<span style = "background-color:#fdd">    if(regKernel)</span>
    {
<span style = "background-color:#fdd">      input-&gt;GetPointData()-&gt;SetVectors(vectors);
      input-&gt;GetPointData()-&gt;SetActiveVectors(vectors-&gt;GetName());</span>

<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkVectorNorm&gt; norm = vtkSmartPointer&lt;vtkVectorNorm&gt;::New();
      norm-&gt;SetInputData(input);
      norm-&gt;SetAttributeModeToUsePointData();
      norm-&gt;Update();</span>

<span style = "background-color:#fdd">      vectorMagnitude = vtkFloatArray::SafeDownCast(norm-&gt;GetOutput()-&gt;GetPointData()-&gt;GetScalars());
      vectorMagnitude-&gt;SetName("VectorMagnitude");
      input-&gt;GetPointData()-&gt;SetScalars(vectorMagnitude);
      input-&gt;GetPointData()-&gt;SetActiveScalars(vectorMagnitude-&gt;GetName());
    }</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkGlyph3D&gt; glyphFilter = vtkSmartPointer&lt;vtkGlyph3D&gt;::New();
    glyphFilter-&gt;ScalingOn();
    glyphFilter-&gt;OrientOn();
    glyphFilter-&gt;SetVectorModeToUseVector();
    glyphFilter-&gt;SetScaleModeToScaleByVector();
    glyphFilter-&gt;SetInputData(input);</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkArrowSource&gt; arrowSource = vtkSmartPointer&lt;vtkArrowSource&gt;::New();
    arrowSource-&gt;SetTipLength(0.2);</span>

<span style = "background-color:#fdd">    glyphFilter-&gt;SetSourceConnection(arrowSource-&gt;GetOutputPort());</span>

<span style = "background-color:#fdd">    glyphFilter-&gt;Update();</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPolyData&gt; output = glyphFilter-&gt;GetOutput();</span>

<span style = "background-color:#fdd">    return output;
  }</span>

  vtkSmartPointer&lt;vtkPolyData&gt; MITKMATCHPOINTREGISTRATION_EXPORT Generate3DDeformationGrid( const mitk::BaseGeometry* gridDesc, unsigned int gridFrequence, const map::core::RegistrationKernelBase&lt;3,3&gt;* regKernel /*= nullptr*/ )
<span style = "background-color:#fdd">  {
    assert(gridDesc);</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPoints&gt;  points = vtkSmartPointer&lt;vtkPoints&gt;::New();
    vtkSmartPointer&lt;vtkFloatArray&gt; vectors = vtkSmartPointer&lt;vtkFloatArray&gt;::New();
    vectors-&gt;SetNumberOfComponents(3);
    vectors-&gt;SetName("DeformationVectors");</span>

<span style = "background-color:#fdd">    long xExtend = itk::Math::Ceil&lt;long,mitk::ScalarType&gt;(gridDesc-&gt;GetExtent(0))+1;
    long yExtend = itk::Math::Ceil&lt;long,mitk::ScalarType&gt;(gridDesc-&gt;GetExtent(1))+1;
    long zExtend = itk::Math::Ceil&lt;long,mitk::ScalarType&gt;(gridDesc-&gt;GetExtent(2))+1;
    long zOffset = xExtend*yExtend;</span>

<span style = "background-color:#fdd">    mitk::Geometry3D::BoundsArrayType bounds = gridDesc-&gt;GetBounds();</span>

    //Generate Points
<span style = "background-color:#fdd">    mitk::Point3D pos;
    for (pos[2] = bounds[4] ; pos[2]&lt; bounds[4]+zExtend; ++(pos[2]))</span>
    {
<span style = "background-color:#fdd">      for (pos[1] = bounds[2]; pos[1]&lt; bounds[2]+yExtend; ++(pos[1]))</span>
      {
<span style = "background-color:#fdd">        for (pos[0] = bounds[0]; pos[0]&lt; bounds[0]+xExtend; ++(pos[0]))</span>
        {
<span style = "background-color:#fdd">          mitk::Point3D worldPos;
          gridDesc-&gt;IndexToWorld(pos,worldPos);
          points-&gt;InsertNextPoint(worldPos[0],worldPos[1],worldPos[2]);</span>

<span style = "background-color:#fdd">          if(regKernel)</span>
          {
<span style = "background-color:#fdd">            map::core::RegistrationKernelBase&lt;3,3&gt;::InputPointType regInput(worldPos);</span>
            map::core::RegistrationKernelBase&lt;3,3&gt;::OutputPointType regOutput;

<span style = "background-color:#fdd">            bool mapped = regKernel-&gt;mapPoint(regInput,regOutput);
            mitk::Vector3D vector(regOutput-regInput);
            if (!mapped)</span>
            {
<span style = "background-color:#fdd">              vector.Fill(0.0);</span>
            }

<span style = "background-color:#fdd">            vectors-&gt;InsertNextTuple(vector.GetDataPointer());</span>
          }
<span style = "background-color:#fdd">        }
      }
    }</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkCellArray&gt; gridLinesCell = vtkSmartPointer&lt;vtkCellArray&gt;::New();
    vtkSmartPointer&lt;vtkPolyLine&gt; gridLine = vtkSmartPointer&lt;vtkPolyLine&gt;::New();
    gridLine-&gt;GetPointIds()-&gt;SetNumberOfIds(2);</span>

    //generate the gridlines between the points
<span style = "background-color:#fdd">    for (long zPos = 0; zPos&lt; zExtend-1; ++zPos)</span>
    {
<span style = "background-color:#fdd">      for (long yPos = 0; yPos&lt; yExtend-1; ++yPos)</span>
      {
<span style = "background-color:#fdd">        for (long xPos = 0; xPos&lt; xExtend-1; ++xPos)</span>
        {
<span style = "background-color:#fdd">          gridLine-&gt;GetPointIds()-&gt;SetId(0, xPos+yPos*xExtend+zPos*zOffset);</span>

<span style = "background-color:#fdd">          if ((yPos%gridFrequence == 0) &amp;&amp; (zPos%gridFrequence == 0))</span>
          {
<span style = "background-color:#fdd">            gridLine-&gt;GetPointIds()-&gt;SetId(1, (xPos+1)+yPos*xExtend+zPos*zOffset);
            gridLinesCell-&gt;InsertNextCell(gridLine);</span>
          }

<span style = "background-color:#fdd">          if ((xPos%gridFrequence == 0) &amp;&amp; (zPos%gridFrequence == 0))</span>
          {
<span style = "background-color:#fdd">            gridLine-&gt;GetPointIds()-&gt;SetId(1, xPos+(yPos+1)*xExtend+zPos*zOffset);
            gridLinesCell-&gt;InsertNextCell(gridLine);</span>
          }

<span style = "background-color:#fdd">          if ((xPos%gridFrequence == 0) &amp;&amp; (yPos%gridFrequence == 0))</span>
          {
<span style = "background-color:#fdd">            gridLine-&gt;GetPointIds()-&gt;SetId(1, xPos+yPos*xExtend+(zPos+1)*zOffset);
            gridLinesCell-&gt;InsertNextCell(gridLine);</span>
          }
<span style = "background-color:#fdd">        }
      }
    }</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPolyData&gt; grid = vtkSmartPointer&lt;vtkPolyData&gt;::New();
    vtkSmartPointer&lt;vtkFloatArray&gt; vectorMagnitude;</span>

<span style = "background-color:#fdd">    grid-&gt;SetPoints(points);
    grid-&gt;SetLines(gridLinesCell);</span>

<span style = "background-color:#fdd">    if(regKernel)</span>
    {
<span style = "background-color:#fdd">      grid-&gt;GetPointData()-&gt;SetVectors(vectors);
      grid-&gt;GetPointData()-&gt;SetActiveVectors(vectors-&gt;GetName());</span>

<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkVectorNorm&gt; norm = vtkSmartPointer&lt;vtkVectorNorm&gt;::New();
      norm-&gt;SetInputData(grid);
      norm-&gt;SetAttributeModeToUsePointData();
      norm-&gt;Update();</span>

<span style = "background-color:#fdd">      vectorMagnitude = vtkFloatArray::SafeDownCast(norm-&gt;GetOutput()-&gt;GetPointData()-&gt;GetScalars());
      vectorMagnitude-&gt;SetName("VectorMagnitude");
    }</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPolyData&gt; input = grid;</span>

<span style = "background-color:#fdd">    if(regKernel)</span>
    {
<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkWarpVector&gt; warp = vtkSmartPointer&lt;vtkWarpVector&gt;::New();</span>

<span style = "background-color:#fdd">      warp-&gt;SetInputData(input);
      warp-&gt;SetScaleFactor(1);
      warp-&gt;Update();</span>

<span style = "background-color:#fdd">      input = warp-&gt;GetPolyDataOutput();</span>

<span style = "background-color:#fdd">      input-&gt;GetPointData()-&gt;SetScalars(vectorMagnitude);
      input-&gt;GetPointData()-&gt;SetActiveScalars(vectorMagnitude-&gt;GetName());
    }</span>

<span style = "background-color:#fdd">    return input;
  }</span>


  bool GridIsOutdated(const mitk::DataNode* regNode, const itk::TimeStamp&amp; reference)
<span style = "background-color:#fdd">  {</span>

<span style = "background-color:#fdd">    if (PropertyIsOutdated(regNode,mitk::nodeProp_RegVisGridFrequence,reference))</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }

<span style = "background-color:#fdd">    if (PropertyIsOutdated(regNode,mitk::nodeProp_RegVisFOVSize,reference))</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }

<span style = "background-color:#fdd">    if (PropertyIsOutdated(regNode,mitk::nodeProp_RegVisFOVSpacing,reference))</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }

<span style = "background-color:#fdd">    if (PropertyIsOutdated(regNode,mitk::nodeProp_RegVisFOVOrigin,reference))</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }

<span style = "background-color:#fdd">    if (PropertyIsOutdated(regNode,mitk::nodeProp_RegVisDirection,reference))</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }

<span style = "background-color:#fdd">    return false;
  }</span>

  bool PropertyIsOutdated(const mitk::DataNode* regNode, const std::string&amp; propName, const itk::TimeStamp&amp; reference)
<span style = "background-color:#fdd">  {
    if (!regNode)</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot check for outdated property. Passed regNode is null.";</span>
    }

<span style = "background-color:#fdd">    bool result = false;</span>

<span style = "background-color:#fdd">    mitk::BaseProperty* prop = regNode-&gt;GetProperty(propName.c_str());
    if (prop)</span>
    {
<span style = "background-color:#fdd">      result = reference &lt; prop-&gt;GetMTime();
    }</span>
    else
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot check for outdated property. Property not defined in passed regNode. Property name: "&lt;&lt;propName;</span>
    }

<span style = "background-color:#fdd">    return result;
  }</span>

  const map::core::RegistrationKernelBase&lt;3,3&gt;* GetRelevantRegKernelOfNode(const mitk::DataNode* regNode)
<span style = "background-color:#fdd">  {
    const map::core::RegistrationKernelBase&lt;3,3&gt;* regKernel = nullptr;</span>

<span style = "background-color:#fdd">    if (!regNode) return regKernel;</span>

<span style = "background-color:#fdd">    const mitk::MAPRegistrationWrapper* regWrapper = dynamic_cast&lt;const mitk::MAPRegistrationWrapper*&gt;(regNode-&gt;GetData());</span>

<span style = "background-color:#fdd">    if (!regWrapper) return regKernel;</span>

<span style = "background-color:#fdd">    const map::core::Registration&lt;3,3&gt;* reg = dynamic_cast&lt;const map::core::Registration&lt;3,3&gt;*&gt;(regWrapper-&gt;GetRegistration());</span>

<span style = "background-color:#fdd">    if (reg)</span>
    {
<span style = "background-color:#fdd">      mitk::RegVisDirectionProperty* directionProp = nullptr;
      if (regNode-&gt;GetProperty(directionProp, mitk::nodeProp_RegVisDirection))</span>
      {
<span style = "background-color:#fdd">        if (directionProp-&gt;GetValueAsId()==0)</span>
        {
<span style = "background-color:#fdd">          regKernel = &amp;(reg-&gt;getDirectMapping());
        }</span>
        else
        {
<span style = "background-color:#fdd">          regKernel = &amp;(reg-&gt;getInverseMapping());</span>
        }
      }
    }
<span style = "background-color:#fdd">    return regKernel;
  }</span>

}</pre>
	</body>
</html>