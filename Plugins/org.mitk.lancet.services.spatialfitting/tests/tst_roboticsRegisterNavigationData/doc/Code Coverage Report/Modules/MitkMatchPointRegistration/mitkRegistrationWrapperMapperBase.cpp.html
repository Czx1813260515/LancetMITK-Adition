<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkRegistrationWrapperMapperBase.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/


#include &lt;vtkPropAssembly.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkColorTransferFunction.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkActor.h&gt;

#include &lt;mitkProperties.h&gt;
#include &lt;mitkExceptionMacro.h&gt;
#include &lt;mitkException.h&gt;

#include "mitkMAPRegistrationWrapper.h"
#include "mitkRegistrationWrapperMapperBase.h"
#include "mitkRegVisColorStyleProperty.h"
#include "mitkRegVisHelper.h"
#include "mitkRegVisPropertyTags.h"

mitk::MITKRegistrationWrapperMapperBase::MITKRegistrationWrapperMapperBase()
<span style = "background-color:#fdd">{</span>

<span style = "background-color:#fdd">}</span>


mitk::MITKRegistrationWrapperMapperBase::~MITKRegistrationWrapperMapperBase()
<span style = "background-color:#fdd">{</span>

<span style = "background-color:#fdd">}</span>

void mitk::MITKRegistrationWrapperMapperBase::GenerateDataForRenderer( mitk::BaseRenderer *renderer )
<span style = "background-color:#fdd">{
    mitk::DataNode::Pointer node = this-&gt;GetDataNode();</span>

<span style = "background-color:#fdd">    if (node.IsNull())
      return;</span>

<span style = "background-color:#fdd">    bool isVisible = true;
    node-&gt;GetVisibility(isVisible, renderer);</span>

<span style = "background-color:#fdd">    if (!isVisible)
        return;</span>

<span style = "background-color:#fdd">    RegWrapperLocalStorage *localStorage = m_LSH.GetLocalStorage(renderer);</span>

    //check if updates occured in the node or on the display
<span style = "background-color:#fdd">    bool outdatedRendererGeometry = RendererGeometryIsOutdated(renderer,localStorage-&gt;m_LastUpdateTime);</span>

    if ( (localStorage-&gt;m_LastUpdateTime &lt; node-&gt;GetMTime())
         || (localStorage-&gt;m_LastUpdateTime &lt; node-&gt;GetPropertyList()-&gt;GetMTime()) //was a property modified?
         || (localStorage-&gt;m_LastUpdateTime &lt; node-&gt;GetPropertyList(renderer)-&gt;GetMTime())
<span style = "background-color:#fdd">         || outdatedRendererGeometry)</span>
    {
<span style = "background-color:#fdd">        MITK_DEBUG &lt;&lt; "UPDATE NEEDED FOR _ " &lt;&lt; renderer-&gt;GetName();</span>

<span style = "background-color:#fdd">        bool isGridActive = false;
        node-&gt;GetBoolProperty(mitk::nodeProp_RegVisGrid,isGridActive);</span>

<span style = "background-color:#fdd">        bool isGlyphActive = false;
        node-&gt;GetBoolProperty(mitk::nodeProp_RegVisGlyph,isGlyphActive);</span>

<span style = "background-color:#fdd">        bool isPointsActive = false;
        node-&gt;GetBoolProperty(mitk::nodeProp_RegVisPoints,isPointsActive);</span>

<span style = "background-color:#fdd">        bool showStartGrid = false;
        node-&gt;GetBoolProperty(mitk::nodeProp_RegVisGridShowStart,showStartGrid);</span>

<span style = "background-color:#fdd">        bool isGridActiveOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisGrid,localStorage-&gt;m_LastUpdateTime);
        bool isGlyphActiveOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisGlyph,localStorage-&gt;m_LastUpdateTime);
        bool isPointsActiveOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisPoints,localStorage-&gt;m_LastUpdateTime);
        bool showStartGridOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisGridShowStart,localStorage-&gt;m_LastUpdateTime);</span>

<span style = "background-color:#fdd">        mitk::BaseData::Pointer baseData = node-&gt;GetData();</span>

<span style = "background-color:#fdd">        if (baseData.IsNull())
            return;</span>

<span style = "background-color:#fdd">        const mitk::MAPRegistrationWrapper* regWrapper = dynamic_cast&lt;const mitk::MAPRegistrationWrapper*&gt;(baseData.GetPointer());
        if (regWrapper == nullptr)
            return;</span>

        //////////////////////////////////////////////////////////////////////////
        //1. Check the FOV and presentation styles
<span style = "background-color:#fdd">        bool outdatedFOV = mitk::GridIsOutdated(node,localStorage-&gt;m_LastUpdateTime);
        if (outdatedFOV ||isGridActiveOutdated || isGlyphActiveOutdated || isPointsActiveOutdated ||  outdatedRendererGeometry)</span>
          {  // we need to generate the grids/presentation again
<span style = "background-color:#fdd">            const map::core::RegistrationKernelBase&lt;3,3&gt;* regKernel= mitk::GetRelevantRegKernelOfNode(node);</span>

<span style = "background-color:#fdd">            if(!regKernel)</span>
              {
<span style = "background-color:#fdd">                mitkThrow() &lt;&lt; "No reg kernel for visualization";</span>
              }

<span style = "background-color:#fdd">            mitk::BaseGeometry::ConstPointer gridDesc;
            unsigned int gridFrequ =5;</span>

<span style = "background-color:#fdd">            if (!GetGeometryDescription(renderer,gridDesc, gridFrequ))</span>
            {
<span style = "background-color:#fdd">              return;</span>
            };

<span style = "background-color:#fdd">            if(isGridActive)</span>
            {
<span style = "background-color:#fdd">              localStorage-&gt;m_DeformedGridData = mitk::Generate3DDeformationGrid(gridDesc, gridFrequ, regKernel);
              localStorage-&gt;m_StartGridData = mitk::Generate3DDeformationGrid(gridDesc,gridFrequ);
              localStorage-&gt;m_DeformedGridMapper-&gt;SetInputData(localStorage-&gt;m_DeformedGridData);
              localStorage-&gt;m_StartGridMapper-&gt;SetInputData(localStorage-&gt;m_StartGridData);
            }
            else if (isGlyphActive)</span>
            {
<span style = "background-color:#fdd">              localStorage-&gt;m_DeformedGridData = mitk::Generate3DDeformationGlyph(gridDesc, regKernel);
              localStorage-&gt;m_StartGridData = nullptr;
              localStorage-&gt;m_DeformedGridMapper-&gt;SetInputData(localStorage-&gt;m_DeformedGridData);
            }</span>
            else
            {
<span style = "background-color:#fdd">              mitkThrow() &lt;&lt; "No reg kernel visualization style activated.";</span>
            }
<span style = "background-color:#fdd">          }</span>

        //////////////////////////////////////////////////////////////////////////
        //2.Check if the mappers or actors must be modified
<span style = "background-color:#fdd">        bool isColorStyleOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisColorStyle,localStorage-&gt;m_LastUpdateTime);
        bool isColorUniOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisColorUni,localStorage-&gt;m_LastUpdateTime);
        bool isColor1Outdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisColor1Value,localStorage-&gt;m_LastUpdateTime);
        bool isColor2Outdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisColor2Value,localStorage-&gt;m_LastUpdateTime);
        bool isColor3Outdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisColor3Value,localStorage-&gt;m_LastUpdateTime);
        bool isColor4Outdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisColor4Value,localStorage-&gt;m_LastUpdateTime);
        bool isColor2MagOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisColor2Magnitude,localStorage-&gt;m_LastUpdateTime);
        bool isColor3MagOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisColor3Magnitude,localStorage-&gt;m_LastUpdateTime);
        bool isColor4MagOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisColor4Magnitude,localStorage-&gt;m_LastUpdateTime);
        bool isColorInterpolateOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisColorInterpolate,localStorage-&gt;m_LastUpdateTime);</span>

        if(isColorStyleOutdated || isColorUniOutdated || isColor1Outdated ||
           isColor2Outdated || isColor2MagOutdated || isColor3Outdated || isColor3MagOutdated ||
<span style = "background-color:#fdd">           isColor4Outdated || isColor4MagOutdated || isColorInterpolateOutdated)</span>
          {
<span style = "background-color:#fdd">            localStorage-&gt;m_DeformedGridMapper-&gt;ScalarVisibilityOn();
            localStorage-&gt;m_DeformedGridMapper-&gt;SetScalarModeToUsePointData();
            localStorage-&gt;m_DeformedGridMapper-&gt;SelectColorArray( "VectorMagnitude" );</span>

<span style = "background-color:#fdd">            mitk::RegVisColorStyleProperty* colorStyleProp = nullptr;
            node-&gt;GetProperty(colorStyleProp, mitk::nodeProp_RegVisColorStyle);</span>

<span style = "background-color:#fdd">            float color1[3] = {0.0,0.0,0.0};
            node-&gt;GetColor( color1, nullptr, mitk::nodeProp_RegVisColor1Value );
            float color2[3] = {0.25,0.25,0.25};
            node-&gt;GetColor( color2, nullptr, mitk::nodeProp_RegVisColor2Value );
            float color3[3] = {0.5,0.5,0.5};
            node-&gt;GetColor( color3, nullptr, mitk::nodeProp_RegVisColor3Value );
            float color4[3] = {1.0,1.0,1.0};
            node-&gt;GetColor( color4, nullptr, mitk::nodeProp_RegVisColor4Value );</span>

<span style = "background-color:#fdd">            double mag2 = 0;
            node-&gt;GetPropertyValue(mitk::nodeProp_RegVisColor2Magnitude, mag2);
            double mag3 = 0;
            node-&gt;GetPropertyValue(mitk::nodeProp_RegVisColor3Magnitude, mag3);
            double mag4 = 0;
            node-&gt;GetPropertyValue(mitk::nodeProp_RegVisColor4Magnitude, mag4);</span>

<span style = "background-color:#fdd">            bool interpolate = true;
            node-&gt;GetBoolProperty(mitk::nodeProp_RegVisColorInterpolate,interpolate);</span>

            //default :color by vector magnitude
<span style = "background-color:#fdd">            localStorage-&gt;m_DeformedGridMapper-&gt;SelectColorArray( "VectorMagnitude" );
            localStorage-&gt;m_DeformedGridMapper-&gt;SetUseLookupTableScalarRange(true);</span>

<span style = "background-color:#fdd">            localStorage-&gt;m_LUT = vtkSmartPointer&lt;vtkColorTransferFunction&gt;::New();</span>

<span style = "background-color:#fdd">            if (!colorStyleProp || colorStyleProp-&gt;GetValueAsId()==0)</span>
            { //uni color mode
<span style = "background-color:#fdd">                float temprgb[3] = {1.0,1.0,1.0};
                node-&gt;GetColor( temprgb, nullptr, mitk::nodeProp_RegVisColorUni );
                localStorage-&gt;m_LUT-&gt;AddRGBSegment(0.0,temprgb[0],temprgb[1],temprgb[2],1.0,temprgb[0],temprgb[1],temprgb[2]);
                localStorage-&gt;m_LUT-&gt;Build();
                localStorage-&gt;m_DeformedGridMapper-&gt;SetLookupTable(localStorage-&gt;m_LUT);
            }</span>
            else
            {
<span style = "background-color:#fdd">              localStorage-&gt;m_LUT-&gt;AddRGBPoint(0.0,color1[0],color1[1],color1[2]);
              localStorage-&gt;m_LUT-&gt;AddRGBPoint(mag2,color2[0],color2[1],color2[2]);
              localStorage-&gt;m_LUT-&gt;AddRGBPoint(mag3,color3[0],color3[1],color3[2]);
              localStorage-&gt;m_LUT-&gt;AddRGBPoint(mag4,color4[0],color4[1],color4[2]);
              if (!interpolate)</span>
              {
<span style = "background-color:#fdd">                localStorage-&gt;m_LUT-&gt;AddRGBPoint(0.99*mag2,color1[0],color1[1],color1[2]);
                localStorage-&gt;m_LUT-&gt;AddRGBPoint(0.99*mag3,color2[0],color2[1],color2[2]);
                localStorage-&gt;m_LUT-&gt;AddRGBPoint(0.99*mag4,color3[0],color3[1],color3[2]);</span>
              };
            }

<span style = "background-color:#fdd">            localStorage-&gt;m_LUT-&gt;Build();
            localStorage-&gt;m_DeformedGridMapper-&gt;SetLookupTable(localStorage-&gt;m_LUT);
            localStorage-&gt;m_DeformedGridMapper-&gt;Update();</span>
        }

<span style = "background-color:#fdd">        bool isGridStartColorOutdated = mitk::PropertyIsOutdated(node,mitk::nodeProp_RegVisGridStartColor,localStorage-&gt;m_LastUpdateTime);</span>

<span style = "background-color:#fdd">        if(isGridStartColorOutdated)</span>
          {
<span style = "background-color:#fdd">            localStorage-&gt;m_StartGridMapper-&gt;ScalarVisibilityOn();
            localStorage-&gt;m_StartGridMapper-&gt;SetScalarModeToUsePointFieldData();</span>

            float temprgb[3];
<span style = "background-color:#fdd">            if (node-&gt;GetColor( temprgb, nullptr, mitk::nodeProp_RegVisGridStartColor ))</span>
              {
<span style = "background-color:#fdd">                      double trgb[3] = { (double) temprgb[0], (double) temprgb[1], (double) temprgb[2] };
                      localStorage-&gt;m_StartGridActor-&gt;GetProperty()-&gt;SetColor(trgb);</span>
              }
          }

        //////////////////////////////////////////////////////////////////////////
        //3. Check if Assembly must be updated
<span style = "background-color:#fdd">        if(isGridActiveOutdated||isGlyphActiveOutdated||isPointsActiveOutdated||showStartGridOutdated)</span>
          {
<span style = "background-color:#fdd">            localStorage-&gt;m_RegAssembly = vtkSmartPointer&lt;vtkPropAssembly&gt;::New();</span>

<span style = "background-color:#fdd">            if (isGridActive)</span>
              {
<span style = "background-color:#fdd">                localStorage-&gt;m_RegAssembly-&gt;AddPart(localStorage-&gt;m_DeformedGridActor);
                if (showStartGrid)</span>
                  {
<span style = "background-color:#fdd">                    localStorage-&gt;m_RegAssembly-&gt;AddPart(localStorage-&gt;m_StartGridActor);</span>
                  }
<span style = "background-color:#fdd">              }
            else if (isGlyphActive)</span>
            {
<span style = "background-color:#fdd">              localStorage-&gt;m_RegAssembly-&gt;AddPart(localStorage-&gt;m_DeformedGridActor);</span>
            }
          }

<span style = "background-color:#fdd">        localStorage-&gt;m_LastUpdateTime.Modified();</span>

<span style = "background-color:#fdd">    }
}</span>


void mitk::MITKRegistrationWrapperMapperBase::SetDefaultProperties(mitk::DataNode* node, mitk::BaseRenderer* renderer, bool overwrite)
<span style = "background-color:#fdd">{
    Superclass::SetDefaultProperties(node, renderer, overwrite);
}</span>

vtkProp* mitk::MITKRegistrationWrapperMapperBase::GetVtkProp(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
    return m_LSH.GetLocalStorage(renderer)-&gt;m_RegAssembly;
}</span>

mitk::MITKRegistrationWrapperMapperBase::RegWrapperLocalStorage::RegWrapperLocalStorage()
<span style = "background-color:#fdd">{
    m_DeformedGridActor = vtkSmartPointer&lt;vtkActor&gt;::New();
    m_DeformedGridMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
    m_DeformedGridActor-&gt;SetMapper(m_DeformedGridMapper);</span>

<span style = "background-color:#fdd">    m_StartGridActor = vtkSmartPointer&lt;vtkActor&gt;::New();
    m_StartGridMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
    m_StartGridActor-&gt;SetMapper(m_StartGridMapper);</span>

<span style = "background-color:#fdd">    m_RegAssembly = vtkSmartPointer&lt;vtkPropAssembly&gt;::New();</span>

<span style = "background-color:#fdd">    m_LUT = vtkSmartPointer&lt;vtkColorTransferFunction&gt;::New();</span>

<span style = "background-color:#fdd">    m_DeformedGridData = nullptr;
    m_StartGridData = nullptr;
}</span>
</pre>
	</body>
</html>