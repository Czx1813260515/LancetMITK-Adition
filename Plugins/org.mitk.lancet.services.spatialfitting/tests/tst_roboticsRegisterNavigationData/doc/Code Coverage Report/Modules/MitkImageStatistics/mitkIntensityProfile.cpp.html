<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkIntensityProfile.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;itkLinearInterpolateImageFunction.h&gt;
#include &lt;itkNearestNeighborInterpolateImageFunction.h&gt;
#include &lt;itkPolyLineParametricPath.h&gt;
#include &lt;itkWindowedSincInterpolateImageFunction.h&gt;
#include &lt;mitkImageAccessByItk.h&gt;
#include &lt;mitkImagePixelReadAccessor.h&gt;
#include &lt;mitkPixelTypeMultiplex.h&gt;
#include &lt;mitkImageStatisticsContainer.h&gt;
#include "mitkIntensityProfile.h"

using namespace mitk;

template &lt;class T&gt;
static void ReadPixel(const PixelType&amp;, Image::Pointer image, const itk::Index&lt;3&gt;&amp; index, ScalarType* returnValue)
<span style = "background-color:#fdd">{
  switch (image-&gt;GetDimension())</span>
  {
  case 2:
    {
<span style = "background-color:#fdd">      ImagePixelReadAccessor&lt;T, 2&gt; readAccess(image, image-&gt;GetSliceData(0));
      *returnValue = readAccess.GetPixelByIndex(reinterpret_cast&lt;const itk::Index&lt;2&gt;&amp;&gt;(index));
      break;
    }</span>

  case 3:
    {
<span style = "background-color:#fdd">      ImagePixelReadAccessor&lt;T, 3&gt; readAccess(image, image-&gt;GetVolumeData(0));
      *returnValue = readAccess.GetPixelByIndex(index);
      break;
    }</span>

  default:
<span style = "background-color:#fdd">    *returnValue = 0;</span>
    break;
  }
<span style = "background-color:#fdd">}</span>

static IntensityProfile::Pointer ComputeIntensityProfile(Image::Pointer image, itk::PolyLineParametricPath&lt;3&gt;::Pointer path)
<span style = "background-color:#fdd">{
  if (image-&gt;GetDimension() == 4)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "computation of intensity profiles not supported for 4D images";</span>
  }

<span style = "background-color:#fdd">  IntensityProfile::Pointer intensityProfile = IntensityProfile::New();
  itk::PolyLineParametricPath&lt;3&gt;::InputType input = path-&gt;StartOfInput();
  BaseGeometry* imageGeometry = image-&gt;GetGeometry();
  const PixelType pixelType = image-&gt;GetPixelType();</span>

  IntensityProfile::MeasurementVectorType measurementVector;
  itk::PolyLineParametricPath&lt;3&gt;::OffsetType offset;
<span style = "background-color:#fdd">  Point3D worldPoint;</span>
  itk::Index&lt;3&gt; index;

  do
  {
<span style = "background-color:#fdd">    imageGeometry-&gt;IndexToWorld(path-&gt;Evaluate(input), worldPoint);
    imageGeometry-&gt;WorldToIndex(worldPoint, index);</span>

<span style = "background-color:#fdd">    mitkPixelTypeMultiplex3(ReadPixel, pixelType, image, index, measurementVector.GetDataPointer());
    intensityProfile-&gt;PushBack(measurementVector);</span>

<span style = "background-color:#fdd">    offset = path-&gt;IncrementInput(input);
  } while ((offset[0] | offset[1] | offset[2]) != 0);</span>

<span style = "background-color:#fdd">  return intensityProfile;
}</span>

template &lt;class TInputImage&gt;
static typename itk::InterpolateImageFunction&lt;TInputImage&gt;::Pointer CreateInterpolateImageFunction(InterpolateImageFunction::Enum interpolator)
<span style = "background-color:#fdd">{
  switch (interpolator)</span>
  {
  case InterpolateImageFunction::NearestNeighbor:
<span style = "background-color:#fdd">    return itk::NearestNeighborInterpolateImageFunction&lt;TInputImage&gt;::New().GetPointer();</span>

  case InterpolateImageFunction::Linear:
<span style = "background-color:#fdd">    return itk::LinearInterpolateImageFunction&lt;TInputImage&gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Blackman_3:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 3, itk::Function::BlackmanWindowFunction&lt;3&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Blackman_4:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 4, itk::Function::BlackmanWindowFunction&lt;4&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Blackman_5:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 5, itk::Function::BlackmanWindowFunction&lt;5&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Cosine_3:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 3, itk::Function::CosineWindowFunction&lt;3&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Cosine_4:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 4, itk::Function::CosineWindowFunction&lt;4&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Cosine_5:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 5, itk::Function::CosineWindowFunction&lt;5&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Hamming_3:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 3, itk::Function::HammingWindowFunction&lt;3&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Hamming_4:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 4, itk::Function::HammingWindowFunction&lt;4&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Hamming_5:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 5, itk::Function::HammingWindowFunction&lt;5&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Lanczos_3:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 3, itk::Function::LanczosWindowFunction&lt;3&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Lanczos_4:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 4, itk::Function::LanczosWindowFunction&lt;4&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Lanczos_5:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 5, itk::Function::LanczosWindowFunction&lt;5&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Welch_3:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 3, itk::Function::WelchWindowFunction&lt;3&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Welch_4:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 4, itk::Function::WelchWindowFunction&lt;4&gt; &gt;::New().GetPointer();</span>

  case InterpolateImageFunction::WindowedSinc_Welch_5:
<span style = "background-color:#fdd">    return itk::WindowedSincInterpolateImageFunction&lt;TInputImage, 5, itk::Function::WelchWindowFunction&lt;5&gt; &gt;::New().GetPointer();</span>

  default:
<span style = "background-color:#fdd">    return itk::NearestNeighborInterpolateImageFunction&lt;TInputImage&gt;::New().GetPointer();</span>
  }
<span style = "background-color:#fdd">}</span>

template &lt;class TPixel, unsigned int VImageDimension&gt;
static void ComputeIntensityProfile(itk::Image&lt;TPixel, VImageDimension&gt;* image, itk::PolyLineParametricPath&lt;3&gt;::Pointer path, unsigned int numSamples, InterpolateImageFunction::Enum interpolator, IntensityProfile::Pointer intensityProfile)
<span style = "background-color:#fdd">{
  typename itk::InterpolateImageFunction&lt;itk::Image&lt;TPixel, VImageDimension&gt; &gt;::Pointer interpolateImageFunction = CreateInterpolateImageFunction&lt;itk::Image&lt;TPixel, VImageDimension&gt; &gt;(interpolator);
  interpolateImageFunction-&gt;SetInputImage(image);</span>

<span style = "background-color:#fdd">  const itk::PolyLineParametricPath&lt;3&gt;::InputType startOfInput = path-&gt;StartOfInput();
  const itk::PolyLineParametricPath&lt;3&gt;::InputType delta = 1.0 / (numSamples - 1);</span>

  IntensityProfile::MeasurementVectorType measurementVector;

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; numSamples; ++i)</span>
  {
<span style = "background-color:#fdd">    measurementVector[0] = interpolateImageFunction-&gt;EvaluateAtContinuousIndex(path-&gt;Evaluate(startOfInput + i * delta));
    intensityProfile-&gt;PushBack(measurementVector);
  }
}</span>

static IntensityProfile::Pointer ComputeIntensityProfile(Image::Pointer image, itk::PolyLineParametricPath&lt;3&gt;::Pointer path, unsigned int numSamples, InterpolateImageFunction::Enum interpolator)
<span style = "background-color:#fdd">{
  IntensityProfile::Pointer intensityProfile = IntensityProfile::New();
  AccessFixedDimensionByItk_n(image, ComputeIntensityProfile, 3, (path, numSamples, interpolator, intensityProfile));
  return intensityProfile;
}</span>

class AddPolyLineElementToPath
{
public:
  AddPolyLineElementToPath(const PlaneGeometry* planarFigureGeometry, const BaseGeometry* imageGeometry, itk::PolyLineParametricPath&lt;3&gt;::Pointer path)
<span style = "background-color:#fdd">    : m_PlanarFigureGeometry(planarFigureGeometry),
      m_ImageGeometry(imageGeometry),
      m_Path(path)
  {
  }</span>

  void operator()(const PlanarFigure::PolyLineElement&amp; polyLineElement)
<span style = "background-color:#fdd">  {
    m_PlanarFigureGeometry-&gt;Map(polyLineElement, m_WorldPoint);
    m_ImageGeometry-&gt;WorldToIndex(m_WorldPoint, m_ContinuousIndexPoint);
    m_Vertex.CastFrom(m_ContinuousIndexPoint);
    m_Path-&gt;AddVertex(m_Vertex);
  }</span>

private:
  const PlaneGeometry* m_PlanarFigureGeometry;
  const BaseGeometry* m_ImageGeometry;
  itk::PolyLineParametricPath&lt;3&gt;::Pointer m_Path;

  Point3D m_WorldPoint;
  Point3D m_ContinuousIndexPoint;
  itk::PolyLineParametricPath&lt;3&gt;::ContinuousIndexType m_Vertex;
};

static itk::PolyLineParametricPath&lt;3&gt;::Pointer CreatePathFromPlanarFigure(BaseGeometry* imageGeometry, PlanarFigure* planarFigure)
<span style = "background-color:#fdd">{
  itk::PolyLineParametricPath&lt;3&gt;::Pointer path = itk::PolyLineParametricPath&lt;3&gt;::New();
  const PlanarFigure::PolyLineType polyLine = planarFigure-&gt;GetPolyLine(0);</span>

<span style = "background-color:#fdd">  std::for_each(polyLine.begin(), polyLine.end(),</span>
    AddPolyLineElementToPath(planarFigure-&gt;GetPlaneGeometry(), imageGeometry, path));

<span style = "background-color:#fdd">  return path;
}</span>

static void AddPointToPath(const BaseGeometry* imageGeometry, const Point3D&amp; point, itk::PolyLineParametricPath&lt;3&gt;::Pointer path)
<span style = "background-color:#fdd">{
  Point3D continuousIndexPoint;
  imageGeometry-&gt;WorldToIndex(point, continuousIndexPoint);</span>

  itk::PolyLineParametricPath&lt;3&gt;::ContinuousIndexType vertex;
<span style = "background-color:#fdd">  vertex.CastFrom(continuousIndexPoint);</span>

<span style = "background-color:#fdd">  path-&gt;AddVertex(vertex);
}</span>

static itk::PolyLineParametricPath&lt;3&gt;::Pointer CreatePathFromPoints(BaseGeometry* imageGeometry, const Point3D&amp; startPoint, const Point3D&amp; endPoint)
<span style = "background-color:#fdd">{
  itk::PolyLineParametricPath&lt;3&gt;::Pointer path = itk::PolyLineParametricPath&lt;3&gt;::New();</span>

<span style = "background-color:#fdd">  AddPointToPath(imageGeometry, startPoint, path);
  AddPointToPath(imageGeometry, endPoint, path);</span>

<span style = "background-color:#fdd">  return path;
}</span>

IntensityProfile::Pointer mitk::ComputeIntensityProfile(Image::Pointer image, PlanarFigure::Pointer planarFigure)
<span style = "background-color:#fdd">{
  return ::ComputeIntensityProfile(image, CreatePathFromPlanarFigure(image-&gt;GetGeometry(), planarFigure));
}</span>

IntensityProfile::Pointer mitk::ComputeIntensityProfile(Image::Pointer image, PlanarLine::Pointer planarLine, unsigned int numSamples, InterpolateImageFunction::Enum interpolator)
<span style = "background-color:#fdd">{
  return ::ComputeIntensityProfile(image, CreatePathFromPlanarFigure(image-&gt;GetGeometry(), planarLine.GetPointer()), numSamples, interpolator);
}</span>

IntensityProfile::Pointer mitk::ComputeIntensityProfile(Image::Pointer image, const Point3D&amp; startPoint, const Point3D&amp; endPoint, unsigned int numSamples, InterpolateImageFunction::Enum interpolator)
<span style = "background-color:#fdd">{
  return ::ComputeIntensityProfile(image, CreatePathFromPoints(image-&gt;GetGeometry(), startPoint, endPoint), numSamples, interpolator);
}</span>

IntensityProfile::InstanceIdentifier mitk::ComputeGlobalMaximum(IntensityProfile::ConstPointer intensityProfile, IntensityProfile::MeasurementType &amp;max)
<span style = "background-color:#fdd">{
  max = -vcl_numeric_limits&lt;IntensityProfile::MeasurementType&gt;::min();
  IntensityProfile::InstanceIdentifier maxIndex = 0;</span>

<span style = "background-color:#fdd">  IntensityProfile::ConstIterator end = intensityProfile-&gt;End();</span>
  IntensityProfile::MeasurementType measurement;

<span style = "background-color:#fdd">  for (IntensityProfile::ConstIterator it = intensityProfile-&gt;Begin(); it != end; ++it)</span>
  {
<span style = "background-color:#fdd">    measurement = it.GetMeasurementVector()[0];</span>

<span style = "background-color:#fdd">    if (measurement &gt; max)</span>
    {
<span style = "background-color:#fdd">      max = measurement;
      maxIndex = it.GetInstanceIdentifier();
    }
  }</span>

<span style = "background-color:#fdd">  return maxIndex;
}</span>

IntensityProfile::InstanceIdentifier mitk::ComputeGlobalMinimum(IntensityProfile::ConstPointer intensityProfile, IntensityProfile::MeasurementType &amp;min)
<span style = "background-color:#fdd">{
  min = vcl_numeric_limits&lt;IntensityProfile::MeasurementType&gt;::max();
  IntensityProfile::InstanceIdentifier minIndex = 0;</span>

<span style = "background-color:#fdd">  IntensityProfile::ConstIterator end = intensityProfile-&gt;End();</span>
  IntensityProfile::MeasurementType measurement;

<span style = "background-color:#fdd">  for (IntensityProfile::ConstIterator it = intensityProfile-&gt;Begin(); it != end; ++it)</span>
  {
<span style = "background-color:#fdd">    measurement = it.GetMeasurementVector()[0];</span>

<span style = "background-color:#fdd">    if (measurement &lt; min)</span>
    {
<span style = "background-color:#fdd">      min = measurement;
      minIndex = it.GetInstanceIdentifier();
    }
  }</span>

<span style = "background-color:#fdd">  return minIndex;
}</span>

IntensityProfile::InstanceIdentifier mitk::ComputeCenterOfMaximumArea(IntensityProfile::ConstPointer intensityProfile, IntensityProfile::InstanceIdentifier radius)
<span style = "background-color:#fdd">{</span>
  //const IntensityProfile::MeasurementType min = intensityProfile-&gt;GetMeasurementVector(ComputeGlobalMinimum(intensityProfile))[0];
  IntensityProfile::MeasurementType min;
<span style = "background-color:#fdd">  ComputeGlobalMinimum(intensityProfile, min);
  const IntensityProfile::InstanceIdentifier areaWidth = 1 + 2 * radius;</span>

<span style = "background-color:#fdd">  IntensityProfile::MeasurementType maxArea = 0;</span>

<span style = "background-color:#fdd">  for (IntensityProfile::InstanceIdentifier i = 0; i &lt; areaWidth; ++i)
    maxArea += intensityProfile-&gt;GetMeasurementVector(i)[0] - min;</span>

<span style = "background-color:#fdd">  const IntensityProfile::InstanceIdentifier lastIndex = intensityProfile-&gt;Size() - areaWidth;
  IntensityProfile::InstanceIdentifier centerOfMaxArea = radius;
  IntensityProfile::MeasurementType area = maxArea;</span>

<span style = "background-color:#fdd">  for (IntensityProfile::InstanceIdentifier i = 1; i &lt;= lastIndex; ++i)</span>
  {
<span style = "background-color:#fdd">    area += intensityProfile-&gt;GetMeasurementVector(i + areaWidth - 1)[0] - min;
    area -= intensityProfile-&gt;GetMeasurementVector(i - 1)[0] - min;</span>

<span style = "background-color:#fdd">    if (area &gt; maxArea)</span>
    {
<span style = "background-color:#fdd">      maxArea = area;
      centerOfMaxArea = i + radius; // TODO: If multiple areas in the neighborhood have the same intensity chose the middle one instead of the first one.</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return centerOfMaxArea;
}</span>

std::vector&lt;IntensityProfile::MeasurementType&gt; mitk::CreateVectorFromIntensityProfile(IntensityProfile::ConstPointer intensityProfile)
<span style = "background-color:#fdd">{
  std::vector&lt;IntensityProfile::MeasurementType&gt; result;
  result.reserve(intensityProfile-&gt;Size());</span>

<span style = "background-color:#fdd">  IntensityProfile::ConstIterator end = intensityProfile-&gt;End();</span>

<span style = "background-color:#fdd">  for (IntensityProfile::ConstIterator it = intensityProfile-&gt;Begin(); it != end; ++it)
    result.push_back(it.GetMeasurementVector()[0]);</span>

<span style = "background-color:#fdd">  return result;
}</span>

IntensityProfile::Pointer mitk::CreateIntensityProfileFromVector(const std::vector&lt;IntensityProfile::MeasurementType&gt;&amp; vector)
<span style = "background-color:#fdd">{
  const IntensityProfile::InstanceIdentifier size = vector.size();</span>

<span style = "background-color:#fdd">  IntensityProfile::Pointer result = IntensityProfile::New();
  result-&gt;Resize(size);</span>

<span style = "background-color:#fdd">  for (IntensityProfile::InstanceIdentifier i = 0; i &lt; size; ++i)
    result-&gt;SetMeasurement(i, 0, vector[i]);</span>

<span style = "background-color:#fdd">  return result;
}</span>

void mitk::ComputeIntensityProfileStatistics(IntensityProfile::ConstPointer intensityProfile, ImageStatisticsContainer::ImageStatisticsObject&amp; stats)
<span style = "background-color:#fdd">{</span>
  typedef std::vector&lt;IntensityProfile::MeasurementType&gt; StatsVecType;

<span style = "background-color:#fdd">  StatsVecType statsVec = mitk::CreateVectorFromIntensityProfile( intensityProfile );</span>

  IntensityProfile::MeasurementType min;
  IntensityProfile::MeasurementType max;
<span style = "background-color:#fdd">  mitk::ComputeGlobalMinimum( intensityProfile, min );
  mitk::ComputeGlobalMaximum( intensityProfile, max );
  auto numSamples = static_cast&lt;mitk::ImageStatisticsContainer::VoxelCountType&gt;(statsVec.size());</span>

<span style = "background-color:#fdd">  double mean = 0.0;
  double rms = 0.0;
  for ( StatsVecType::const_iterator it = statsVec.begin(); it != statsVec.end(); ++it )</span>
  {
<span style = "background-color:#fdd">    double val = *it;
    mean += val;
    rms += val*val;
  }
  mean /= static_cast&lt;double&gt;(numSamples);
  rms /= static_cast&lt;double&gt;(numSamples);</span>

<span style = "background-color:#fdd">  double var = 0.0;
  for ( StatsVecType::const_iterator it = statsVec.begin(); it != statsVec.end(); ++it )</span>
  {
<span style = "background-color:#fdd">    double diff = *it - mean;
    var += diff*diff;
  }
  var /= (static_cast&lt;double&gt;(numSamples) - 1 );</span>

<span style = "background-color:#fdd">  rms = sqrt( rms );</span>

<span style = "background-color:#fdd">  stats.AddStatistic(mitk::ImageStatisticsConstants::MINIMUM(), min);
  stats.AddStatistic(mitk::ImageStatisticsConstants::MAXIMUM(), max);
  stats.AddStatistic(mitk::ImageStatisticsConstants::NUMBEROFVOXELS(), numSamples);
  stats.AddStatistic(mitk::ImageStatisticsConstants::MEAN(), mean);
  stats.AddStatistic(mitk::ImageStatisticsConstants::STANDARDDEVIATION(), sqrt(var));
  stats.AddStatistic(mitk::ImageStatisticsConstants::VARIANCE(), var);
  stats.AddStatistic(mitk::ImageStatisticsConstants::RMS(), rms);
}</span></pre>
	</body>
</html>