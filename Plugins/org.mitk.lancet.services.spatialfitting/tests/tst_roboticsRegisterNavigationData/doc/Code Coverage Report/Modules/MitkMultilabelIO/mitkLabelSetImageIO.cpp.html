<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkLabelSetImageIO.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef __mitkLabelSetImageWriter__cpp
#define __mitkLabelSetImageWriter__cpp

#include "mitkLabelSetImageIO.h"
#include "mitkBasePropertySerializer.h"
#include "mitkIOMimeTypes.h"
#include "mitkImageAccessByItk.h"
#include "mitkLabelSetIOHelper.h"
#include "mitkLabelSetImageConverter.h"
#include &lt;mitkLocaleSwitch.h&gt;
#include &lt;mitkArbitraryTimeGeometry.h&gt;
#include &lt;mitkIPropertyPersistence.h&gt;
#include &lt;mitkCoreServices.h&gt;
#include &lt;mitkItkImageIO.h&gt;
#include &lt;mitkUIDManipulator.h&gt;

// itk
#include "itkImageFileReader.h"
#include "itkImageFileWriter.h"
#include "itkMetaDataDictionary.h"
#include "itkMetaDataObject.h"
#include "itkNrrdImageIO.h"

#include &lt;tinyxml2.h&gt;

namespace mitk
{

  const char* const PROPERTY_NAME_TIMEGEOMETRY_TYPE = "org.mitk.timegeometry.type";
  const char* const PROPERTY_NAME_TIMEGEOMETRY_TIMEPOINTS = "org.mitk.timegeometry.timepoints";
  const char* const PROPERTY_KEY_TIMEGEOMETRY_TYPE = "org_mitk_timegeometry_type";
  const char* const PROPERTY_KEY_TIMEGEOMETRY_TIMEPOINTS = "org_mitk_timegeometry_timepoints";
  const char* const PROPERTY_KEY_UID = "org_mitk_uid";

  LabelSetImageIO::LabelSetImageIO()
<span style = "background-color:#dfd">    : AbstractFileIO(LabelSetImage::GetStaticNameOfClass(), IOMimeTypes::NRRD_MIMETYPE(), "MITK Multilabel Image")
  {
    AbstractFileWriter::SetRanking(10);
    AbstractFileReader::SetRanking(10);
    this-&gt;RegisterService();
  }</span>

  IFileIO::ConfidenceLevel LabelSetImageIO::GetWriterConfidenceLevel() const
<span style = "background-color:#fdd">  {
    if (AbstractFileIO::GetWriterConfidenceLevel() == Unsupported)
      return Unsupported;
    const auto *input = static_cast&lt;const LabelSetImage *&gt;(this-&gt;GetInput());
    if (input)
      return Supported;</span>
    else
<span style = "background-color:#fdd">      return Unsupported;
  }</span>

  void LabelSetImageIO::Write()
<span style = "background-color:#fdd">  {
    ValidateOutputLocation();</span>

<span style = "background-color:#fdd">    auto input = dynamic_cast&lt;const LabelSetImage *&gt;(this-&gt;GetInput());</span>

<span style = "background-color:#fdd">    mitk::LocaleSwitch localeSwitch("C");</span>

<span style = "background-color:#fdd">    mitk::Image::Pointer inputVector = mitk::ConvertLabelSetImageToImage(input);</span>

    // image write
<span style = "background-color:#fdd">    if (inputVector.IsNull())</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot write non-image data";</span>
    }

<span style = "background-color:#fdd">    itk::NrrdImageIO::Pointer nrrdImageIo = itk::NrrdImageIO::New();</span>

    // Clone the image geometry, because we might have to change it
    // for writing purposes
<span style = "background-color:#fdd">    BaseGeometry::Pointer geometry = inputVector-&gt;GetGeometry()-&gt;Clone();</span>

    // Check if geometry information will be lost
<span style = "background-color:#fdd">    if (inputVector-&gt;GetDimension() == 2 &amp;&amp; !geometry-&gt;Is2DConvertable())</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Saving a 2D image with 3D geometry information. Geometry information will be lost! You might "</span>
                   "consider using Convert2Dto3DImageFilter before saving.";

      // set matrix to identity
<span style = "background-color:#fdd">      mitk::AffineTransform3D::Pointer affTrans = mitk::AffineTransform3D::New();
      affTrans-&gt;SetIdentity();
      mitk::Vector3D spacing = geometry-&gt;GetSpacing();
      mitk::Point3D origin = geometry-&gt;GetOrigin();
      geometry-&gt;SetIndexToWorldTransform(affTrans);
      geometry-&gt;SetSpacing(spacing);
      geometry-&gt;SetOrigin(origin);
    }</span>

<span style = "background-color:#fdd">    LocalFile localFile(this);
    const std::string path = localFile.GetFileName();</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "Writing image: " &lt;&lt; path &lt;&lt; std::endl;</span>

    try
    {
      // Implementation of writer using itkImageIO directly. This skips the use
      // of templated itkImageFileWriter, which saves the multiplexing on MITK side.

<span style = "background-color:#fdd">      const unsigned int dimension = inputVector-&gt;GetDimension();
      const unsigned int *const dimensions = inputVector-&gt;GetDimensions();
      const mitk::PixelType pixelType = inputVector-&gt;GetPixelType();
      const mitk::Vector3D mitkSpacing = geometry-&gt;GetSpacing();
      const mitk::Point3D mitkOrigin = geometry-&gt;GetOrigin();</span>

      // Due to templating in itk, we are forced to save a 4D spacing and 4D Origin,
      // though they are not supported in MITK
      itk::Vector&lt;double, 4u&gt; spacing4D;
<span style = "background-color:#fdd">      spacing4D[0] = mitkSpacing[0];
      spacing4D[1] = mitkSpacing[1];
      spacing4D[2] = mitkSpacing[2];
      spacing4D[3] = 1; // There is no support for a 4D spacing. However, we should have a valid value here</span>

      itk::Vector&lt;double, 4u&gt; origin4D;
<span style = "background-color:#fdd">      origin4D[0] = mitkOrigin[0];
      origin4D[1] = mitkOrigin[1];
      origin4D[2] = mitkOrigin[2];
      origin4D[3] = 0; // There is no support for a 4D origin. However, we should have a valid value here</span>

      // Set the necessary information for imageIO
<span style = "background-color:#fdd">      nrrdImageIo-&gt;SetNumberOfDimensions(dimension);
      nrrdImageIo-&gt;SetPixelType(pixelType.GetPixelType());
      nrrdImageIo-&gt;SetComponentType(static_cast&lt;int&gt;(pixelType.GetComponentType()) &lt; PixelComponentUserType</span>
                                      ? pixelType.GetComponentType()
                                      : itk::IOComponentEnum::UNKNOWNCOMPONENTTYPE);
<span style = "background-color:#fdd">      nrrdImageIo-&gt;SetNumberOfComponents(pixelType.GetNumberOfComponents());</span>

<span style = "background-color:#fdd">      itk::ImageIORegion ioRegion(dimension);</span>

<span style = "background-color:#fdd">      for (unsigned int i = 0; i &lt; dimension; i++)</span>
      {
<span style = "background-color:#fdd">        nrrdImageIo-&gt;SetDimensions(i, dimensions[i]);
        nrrdImageIo-&gt;SetSpacing(i, spacing4D[i]);
        nrrdImageIo-&gt;SetOrigin(i, origin4D[i]);</span>

<span style = "background-color:#fdd">        mitk::Vector3D mitkDirection(0.0);
        mitkDirection.SetVnlVector(geometry-&gt;GetIndexToWorldTransform()-&gt;GetMatrix().GetVnlMatrix().get_column(i).as_ref());</span>
        itk::Vector&lt;double, 4u&gt; direction4D;
<span style = "background-color:#fdd">        direction4D[0] = mitkDirection[0];
        direction4D[1] = mitkDirection[1];
        direction4D[2] = mitkDirection[2];</span>

        // MITK only supports a 3x3 direction matrix. Due to templating in itk, however, we must
        // save a 4x4 matrix for 4D images. in this case, add an homogneous component to the matrix.
<span style = "background-color:#fdd">        if (i == 3)</span>
        {
<span style = "background-color:#fdd">          direction4D[3] = 1; // homogenous component
        }</span>
        else
        {
<span style = "background-color:#fdd">          direction4D[3] = 0;</span>
        }
<span style = "background-color:#fdd">        vnl_vector&lt;double&gt; axisDirection(dimension);
        for (unsigned int j = 0; j &lt; dimension; j++)</span>
        {
<span style = "background-color:#fdd">          axisDirection[j] = direction4D[j] / spacing4D[i];
        }
        nrrdImageIo-&gt;SetDirection(i, axisDirection);</span>

<span style = "background-color:#fdd">        ioRegion.SetSize(i, inputVector-&gt;GetLargestPossibleRegion().GetSize(i));
        ioRegion.SetIndex(i, inputVector-&gt;GetLargestPossibleRegion().GetIndex(i));
      }</span>

      // use compression if available
<span style = "background-color:#fdd">      nrrdImageIo-&gt;UseCompressionOn();</span>

<span style = "background-color:#fdd">      nrrdImageIo-&gt;SetIORegion(ioRegion);
      nrrdImageIo-&gt;SetFileName(path);</span>

      // label set specific meta data
      char keybuffer[512];
      char valbuffer[512];

<span style = "background-color:#fdd">      sprintf(keybuffer, "modality");
      sprintf(valbuffer, "org.mitk.image.multilabel");
      itk::EncapsulateMetaData&lt;std::string&gt;(</span>
        nrrdImageIo-&gt;GetMetaDataDictionary(), std::string(keybuffer), std::string(valbuffer));

<span style = "background-color:#fdd">      sprintf(keybuffer, "layers");
      sprintf(valbuffer, "%1d", input-&gt;GetNumberOfLayers());
      itk::EncapsulateMetaData&lt;std::string&gt;(</span>
        nrrdImageIo-&gt;GetMetaDataDictionary(), std::string(keybuffer), std::string(valbuffer));

<span style = "background-color:#fdd">      for (unsigned int layerIdx = 0; layerIdx &lt; input-&gt;GetNumberOfLayers(); layerIdx++)</span>
      {
<span style = "background-color:#fdd">        sprintf(keybuffer, "layer_%03u", layerIdx);                    // layer idx
        sprintf(valbuffer, "%1u", input-&gt;GetNumberOfLabels(layerIdx)); // number of labels for the layer
        itk::EncapsulateMetaData&lt;std::string&gt;(</span>
          nrrdImageIo-&gt;GetMetaDataDictionary(), std::string(keybuffer), std::string(valbuffer));

<span style = "background-color:#fdd">        auto iter = input-&gt;GetLabelSet(layerIdx)-&gt;IteratorConstBegin();
        unsigned int count(0);
        while (iter != input-&gt;GetLabelSet(layerIdx)-&gt;IteratorConstEnd())</span>
        {
<span style = "background-color:#fdd">          tinyxml2::XMLDocument document;
          document.InsertEndChild(document.NewDeclaration());
          auto *labelElem = mitk::LabelSetIOHelper::GetLabelAsXMLElement(document, iter-&gt;second);
          document.InsertEndChild(labelElem);
          tinyxml2::XMLPrinter printer;
          document.Print(&amp;printer);</span>

<span style = "background-color:#fdd">          sprintf(keybuffer, "org.mitk.label_%03u_%05u", layerIdx, count);
          itk::EncapsulateMetaData&lt;std::string&gt;(</span>
            nrrdImageIo-&gt;GetMetaDataDictionary(), std::string(keybuffer), printer.CStr());
<span style = "background-color:#fdd">          ++iter;
          ++count;
        }
      }</span>
      // end label set specific meta data

      // Handle time geometry
<span style = "background-color:#fdd">      const auto* arbitraryTG = dynamic_cast&lt;const ArbitraryTimeGeometry*&gt;(input-&gt;GetTimeGeometry());
      if (arbitraryTG)</span>
      {
<span style = "background-color:#fdd">        itk::EncapsulateMetaData&lt;std::string&gt;(nrrdImageIo-&gt;GetMetaDataDictionary(),</span>
          PROPERTY_KEY_TIMEGEOMETRY_TYPE,
          ArbitraryTimeGeometry::GetStaticNameOfClass());


<span style = "background-color:#fdd">        auto metaTimePoints = ConvertTimePointListToMetaDataObject(arbitraryTG);
        nrrdImageIo-&gt;GetMetaDataDictionary().Set(PROPERTY_KEY_TIMEGEOMETRY_TIMEPOINTS, metaTimePoints);
      }</span>

      // Handle properties
<span style = "background-color:#fdd">      mitk::PropertyList::Pointer imagePropertyList = input-&gt;GetPropertyList();
      for (const auto&amp; property : *imagePropertyList-&gt;GetMap())</span>
      {
<span style = "background-color:#fdd">        mitk::CoreServicePointer&lt;IPropertyPersistence&gt; propPersistenceService(mitk::CoreServices::GetPropertyPersistence());
        IPropertyPersistence::InfoResultType infoList = propPersistenceService-&gt;GetInfo(property.first, GetMimeType()-&gt;GetName(), true);</span>

<span style = "background-color:#fdd">        if (infoList.empty())</span>
        {
<span style = "background-color:#fdd">          continue;</span>
        }

<span style = "background-color:#fdd">        std::string value = infoList.front()-&gt;GetSerializationFunction()(property.second);</span>

<span style = "background-color:#fdd">        if (value == mitk::BaseProperty::VALUE_CANNOT_BE_CONVERTED_TO_STRING)</span>
        {
<span style = "background-color:#fdd">          continue;</span>
        }

<span style = "background-color:#fdd">        std::string key = infoList.front()-&gt;GetKey();</span>

<span style = "background-color:#fdd">        itk::EncapsulateMetaData&lt;std::string&gt;(nrrdImageIo-&gt;GetMetaDataDictionary(), key, value);
      }</span>

      // Handle UID
<span style = "background-color:#fdd">      itk::EncapsulateMetaData&lt;std::string&gt;(nrrdImageIo-&gt;GetMetaDataDictionary(), PROPERTY_KEY_UID, input-&gt;GetUID());</span>

<span style = "background-color:#fdd">      ImageReadAccessor imageAccess(inputVector);
      nrrdImageIo-&gt;Write(imageAccess.GetData());
    }</span>
    catch (const std::exception &amp;e)
<span style = "background-color:#fdd">    {
      mitkThrow() &lt;&lt; e.what();
    }</span>
    // end image write
<span style = "background-color:#fdd">  }</span>

  IFileIO::ConfidenceLevel LabelSetImageIO::GetReaderConfidenceLevel() const
<span style = "background-color:#fdd">  {
    if (AbstractFileIO::GetReaderConfidenceLevel() == Unsupported)
      return Unsupported;
    const std::string fileName = this-&gt;GetLocalFileName();
    itk::NrrdImageIO::Pointer io = itk::NrrdImageIO::New();
    io-&gt;SetFileName(fileName);
    io-&gt;ReadImageInformation();</span>

<span style = "background-color:#fdd">    itk::MetaDataDictionary imgMetaDataDictionary = io-&gt;GetMetaDataDictionary();
    std::string value("");
    itk::ExposeMetaData&lt;std::string&gt;(imgMetaDataDictionary, "modality", value);
    if (value.compare("org.mitk.image.multilabel") == 0)</span>
    {
<span style = "background-color:#fdd">      return Supported;
    }</span>
    else
<span style = "background-color:#fdd">      return Unsupported;
  }</span>

  std::vector&lt;BaseData::Pointer&gt; LabelSetImageIO::DoRead()
<span style = "background-color:#fdd">  {
    mitk::LocaleSwitch localeSwitch("C");</span>

    // begin regular image loading, adapted from mitkItkImageIO
<span style = "background-color:#fdd">    itk::NrrdImageIO::Pointer nrrdImageIO = itk::NrrdImageIO::New();
    Image::Pointer image = Image::New();</span>

<span style = "background-color:#fdd">    const unsigned int MINDIM = 2;
    const unsigned int MAXDIM = 4;</span>

<span style = "background-color:#fdd">    const std::string path = this-&gt;GetLocalFileName();</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "loading " &lt;&lt; path &lt;&lt; " via itk::ImageIOFactory... " &lt;&lt; std::endl;</span>

    // Check to see if we can read the file given the name or prefix
<span style = "background-color:#fdd">    if (path.empty())</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Empty filename in mitk::ItkImageIO ";</span>
    }

    // Got to allocate space for the image. Determine the characteristics of
    // the image.
<span style = "background-color:#fdd">    nrrdImageIO-&gt;SetFileName(path);
    nrrdImageIO-&gt;ReadImageInformation();</span>

<span style = "background-color:#fdd">    unsigned int ndim = nrrdImageIO-&gt;GetNumberOfDimensions();
    if (ndim &lt; MINDIM || ndim &gt; MAXDIM)</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Sorry, only dimensions 2, 3 and 4 are supported. The given file has " &lt;&lt; ndim</span>
                &lt;&lt; " dimensions! Reading as 4D.";
<span style = "background-color:#fdd">      ndim = MAXDIM;</span>
    }

<span style = "background-color:#fdd">    itk::ImageIORegion ioRegion(ndim);
    itk::ImageIORegion::SizeType ioSize = ioRegion.GetSize();
    itk::ImageIORegion::IndexType ioStart = ioRegion.GetIndex();</span>

    unsigned int dimensions[MAXDIM];
<span style = "background-color:#fdd">    dimensions[0] = 0;
    dimensions[1] = 0;
    dimensions[2] = 0;
    dimensions[3] = 0;</span>

    ScalarType spacing[MAXDIM];
<span style = "background-color:#fdd">    spacing[0] = 1.0f;
    spacing[1] = 1.0f;
    spacing[2] = 1.0f;
    spacing[3] = 1.0f;</span>

<span style = "background-color:#fdd">    Point3D origin;
    origin.Fill(0);</span>

    unsigned int i;
<span style = "background-color:#fdd">    for (i = 0; i &lt; ndim; ++i)</span>
    {
<span style = "background-color:#fdd">      ioStart[i] = 0;
      ioSize[i] = nrrdImageIO-&gt;GetDimensions(i);
      if (i &lt; MAXDIM)</span>
      {
<span style = "background-color:#fdd">        dimensions[i] = nrrdImageIO-&gt;GetDimensions(i);
        spacing[i] = nrrdImageIO-&gt;GetSpacing(i);
        if (spacing[i] &lt;= 0)
          spacing[i] = 1.0f;</span>
      }
<span style = "background-color:#fdd">      if (i &lt; 3)</span>
      {
<span style = "background-color:#fdd">        origin[i] = nrrdImageIO-&gt;GetOrigin(i);</span>
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    ioRegion.SetSize(ioSize);
    ioRegion.SetIndex(ioStart);</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "ioRegion: " &lt;&lt; ioRegion &lt;&lt; std::endl;
    nrrdImageIO-&gt;SetIORegion(ioRegion);
    void *buffer = new unsigned char[nrrdImageIO-&gt;GetImageSizeInBytes()];
    nrrdImageIO-&gt;Read(buffer);</span>

<span style = "background-color:#fdd">    image-&gt;Initialize(MakePixelType(nrrdImageIO), ndim, dimensions);
    image-&gt;SetImportChannel(buffer, 0, Image::ManageMemory);</span>

    // access direction of itk::Image and include spacing
<span style = "background-color:#fdd">    mitk::Matrix3D matrix;
    matrix.SetIdentity();
    unsigned int j, itkDimMax3 = (ndim &gt;= 3 ? 3 : ndim);
    for (i = 0; i &lt; itkDimMax3; ++i)
      for (j = 0; j &lt; itkDimMax3; ++j)
        matrix[i][j] = nrrdImageIO-&gt;GetDirection(j)[i];</span>

    // re-initialize PlaneGeometry with origin and direction
<span style = "background-color:#fdd">    PlaneGeometry *planeGeometry = image-&gt;GetSlicedGeometry(0)-&gt;GetPlaneGeometry(0);
    planeGeometry-&gt;SetOrigin(origin);
    planeGeometry-&gt;GetIndexToWorldTransform()-&gt;SetMatrix(matrix);</span>

    // re-initialize SlicedGeometry3D
<span style = "background-color:#fdd">    SlicedGeometry3D *slicedGeometry = image-&gt;GetSlicedGeometry(0);
    slicedGeometry-&gt;InitializeEvenlySpaced(planeGeometry, image-&gt;GetDimension(2));
    slicedGeometry-&gt;SetSpacing(spacing);</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; slicedGeometry-&gt;GetCornerPoint(false, false, false);
    MITK_INFO &lt;&lt; slicedGeometry-&gt;GetCornerPoint(true, true, true);</span>

    // re-initialize TimeGeometry
<span style = "background-color:#fdd">    const itk::MetaDataDictionary&amp; dictionary = nrrdImageIO-&gt;GetMetaDataDictionary();
    TimeGeometry::Pointer timeGeometry;</span>

<span style = "background-color:#fdd">    if (dictionary.HasKey(PROPERTY_NAME_TIMEGEOMETRY_TYPE) || dictionary.HasKey(PROPERTY_KEY_TIMEGEOMETRY_TYPE))</span>
    { // also check for the name because of backwards compatibility. Past code version stored with the name and not with
      // the key
<span style = "background-color:#fdd">      itk::MetaDataObject&lt;std::string&gt;::ConstPointer timeGeometryTypeData;
      if (dictionary.HasKey(PROPERTY_NAME_TIMEGEOMETRY_TYPE))</span>
      {
<span style = "background-color:#fdd">        timeGeometryTypeData =</span>
          dynamic_cast&lt;const itk::MetaDataObject&lt;std::string&gt;*&gt;(dictionary.Get(PROPERTY_NAME_TIMEGEOMETRY_TYPE));
<span style = "background-color:#fdd">      }</span>
      else
      {
<span style = "background-color:#fdd">        timeGeometryTypeData =</span>
          dynamic_cast&lt;const itk::MetaDataObject&lt;std::string&gt;*&gt;(dictionary.Get(PROPERTY_KEY_TIMEGEOMETRY_TYPE));
      }

<span style = "background-color:#fdd">      if (timeGeometryTypeData-&gt;GetMetaDataObjectValue() == ArbitraryTimeGeometry::GetStaticNameOfClass())</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "used time geometry: " &lt;&lt; ArbitraryTimeGeometry::GetStaticNameOfClass();</span>
        typedef std::vector&lt;TimePointType&gt; TimePointVector;
<span style = "background-color:#fdd">        TimePointVector timePoints;</span>

<span style = "background-color:#fdd">        if (dictionary.HasKey(PROPERTY_NAME_TIMEGEOMETRY_TIMEPOINTS))</span>
        {
<span style = "background-color:#fdd">          timePoints = ConvertMetaDataObjectToTimePointList(dictionary.Get(PROPERTY_NAME_TIMEGEOMETRY_TIMEPOINTS));
        }
        else if (dictionary.HasKey(PROPERTY_KEY_TIMEGEOMETRY_TIMEPOINTS))</span>
        {
<span style = "background-color:#fdd">          timePoints = ConvertMetaDataObjectToTimePointList(dictionary.Get(PROPERTY_KEY_TIMEGEOMETRY_TIMEPOINTS));</span>
        }

<span style = "background-color:#fdd">        if (timePoints.empty())</span>
        {
<span style = "background-color:#fdd">          MITK_ERROR &lt;&lt; "Stored timepoints are empty. Meta information seems to bee invalid. Switch to ProportionalTimeGeometry fallback";
        }
        else if (timePoints.size() - 1 != image-&gt;GetDimension(3))</span>
        {
<span style = "background-color:#fdd">          MITK_ERROR &lt;&lt; "Stored timepoints (" &lt;&lt; timePoints.size() - 1 &lt;&lt; ") and size of image time dimension ("</span>
            &lt;&lt; image-&gt;GetDimension(3) &lt;&lt; ") do not match. Switch to ProportionalTimeGeometry fallback";
<span style = "background-color:#fdd">        }</span>
        else
        {
<span style = "background-color:#fdd">          ArbitraryTimeGeometry::Pointer arbitraryTimeGeometry = ArbitraryTimeGeometry::New();
          TimePointVector::const_iterator pos = timePoints.begin();
          auto prePos = pos++;</span>

<span style = "background-color:#fdd">          for (; pos != timePoints.end(); ++prePos, ++pos)</span>
          {
<span style = "background-color:#fdd">            arbitraryTimeGeometry-&gt;AppendNewTimeStepClone(slicedGeometry, *prePos, *pos);
          }</span>

<span style = "background-color:#fdd">          timeGeometry = arbitraryTimeGeometry;
        }
      }
    }</span>

<span style = "background-color:#fdd">    if (timeGeometry.IsNull())</span>
    { // Fallback. If no other valid time geometry has been created, create a ProportionalTimeGeometry
<span style = "background-color:#fdd">      MITK_INFO &lt;&lt; "used time geometry: " &lt;&lt; ProportionalTimeGeometry::GetStaticNameOfClass();
      ProportionalTimeGeometry::Pointer propTimeGeometry = ProportionalTimeGeometry::New();
      propTimeGeometry-&gt;Initialize(slicedGeometry, image-&gt;GetDimension(3));
      timeGeometry = propTimeGeometry;
    }</span>

<span style = "background-color:#fdd">    image-&gt;SetTimeGeometry(timeGeometry);</span>

<span style = "background-color:#fdd">    buffer = nullptr;
    MITK_INFO &lt;&lt; "number of image components: " &lt;&lt; image-&gt;GetPixelType().GetNumberOfComponents();</span>

    // end regular image loading

<span style = "background-color:#fdd">    LabelSetImage::Pointer output = ConvertImageToLabelSetImage(image);</span>

    // get labels and add them as properties to the image
    char keybuffer[256];

<span style = "background-color:#fdd">    unsigned int numberOfLayers = GetIntByKey(dictionary, "layers");
    std::string _xmlStr;
    mitk::Label::Pointer label;</span>

<span style = "background-color:#fdd">    for (unsigned int layerIdx = 0; layerIdx &lt; numberOfLayers; layerIdx++)</span>
    {
<span style = "background-color:#fdd">      sprintf(keybuffer, "layer_%03u", layerIdx);
      int numberOfLabels = GetIntByKey(dictionary, keybuffer);</span>

<span style = "background-color:#fdd">      mitk::LabelSet::Pointer labelSet = mitk::LabelSet::New();</span>

<span style = "background-color:#fdd">      for (int labelIdx = 0; labelIdx &lt; numberOfLabels; labelIdx++)</span>
      {
<span style = "background-color:#fdd">        tinyxml2::XMLDocument doc;
        sprintf(keybuffer, "label_%03u_%05d", layerIdx, labelIdx);
        _xmlStr = GetStringByKey(dictionary, keybuffer);
        doc.Parse(_xmlStr.c_str(), _xmlStr.size());</span>

<span style = "background-color:#fdd">        auto *labelElem = doc.FirstChildElement("Label");
        if (labelElem == nullptr)
          mitkThrow() &lt;&lt; "Error parsing NRRD header for mitk::LabelSetImage IO";</span>

<span style = "background-color:#fdd">        label = mitk::LabelSetIOHelper::LoadLabelFromXMLDocument(labelElem);</span>

<span style = "background-color:#fdd">        if (label-&gt;GetValue() == 0) // set exterior label is needed to hold exterior information
          output-&gt;SetExteriorLabel(label);
        labelSet-&gt;AddLabel(label);
        labelSet-&gt;SetLayer(layerIdx);
      }
      output-&gt;AddLabelSetToLayer(layerIdx, labelSet);
    }</span>

<span style = "background-color:#fdd">    for (auto iter = dictionary.Begin(), iterEnd = dictionary.End(); iter != iterEnd;
      ++iter)</span>
    {
<span style = "background-color:#fdd">      if (iter-&gt;second-&gt;GetMetaDataObjectTypeInfo() == typeid(std::string))</span>
      {
<span style = "background-color:#fdd">        const std::string&amp; key = iter-&gt;first;
        std::string assumedPropertyName = key;
        std::replace(assumedPropertyName.begin(), assumedPropertyName.end(), '_', '.');</span>

<span style = "background-color:#fdd">        std::string mimeTypeName = GetMimeType()-&gt;GetName();</span>

        // Check if there is already a info for the key and our mime type.
<span style = "background-color:#fdd">        mitk::CoreServicePointer&lt;IPropertyPersistence&gt; propPersistenceService(mitk::CoreServices::GetPropertyPersistence());
        IPropertyPersistence::InfoResultType infoList = propPersistenceService-&gt;GetInfoByKey(key);</span>

<span style = "background-color:#fdd">        auto predicate = [&amp;mimeTypeName](const PropertyPersistenceInfo::ConstPointer&amp; x) {
          return x.IsNotNull() &amp;&amp; x-&gt;GetMimeTypeName() == mimeTypeName;
        };
        auto finding = std::find_if(infoList.begin(), infoList.end(), predicate);</span>

<span style = "background-color:#fdd">        if (finding == infoList.end())</span>
        {
<span style = "background-color:#fdd">          auto predicateWild = [](const PropertyPersistenceInfo::ConstPointer&amp; x) {
            return x.IsNotNull() &amp;&amp; x-&gt;GetMimeTypeName() == PropertyPersistenceInfo::ANY_MIMETYPE_NAME();
          };
          finding = std::find_if(infoList.begin(), infoList.end(), predicateWild);</span>
        }

<span style = "background-color:#fdd">        PropertyPersistenceInfo::ConstPointer info;</span>

<span style = "background-color:#fdd">        if (finding != infoList.end())</span>
        {
<span style = "background-color:#fdd">          assumedPropertyName = (*finding)-&gt;GetName();
          info = *finding;
        }</span>
        else
        { // we have not found anything suitable so we generate our own info
<span style = "background-color:#fdd">          auto newInfo = PropertyPersistenceInfo::New();
          newInfo-&gt;SetNameAndKey(assumedPropertyName, key);
          newInfo-&gt;SetMimeTypeName(PropertyPersistenceInfo::ANY_MIMETYPE_NAME());
          info = newInfo;
        }</span>

<span style = "background-color:#fdd">        std::string value =</span>
          dynamic_cast&lt;itk::MetaDataObject&lt;std::string&gt;*&gt;(iter-&gt;second.GetPointer())-&gt;GetMetaDataObjectValue();

<span style = "background-color:#fdd">        mitk::BaseProperty::Pointer loadedProp = info-&gt;GetDeserializationFunction()(value);</span>

<span style = "background-color:#fdd">        if (loadedProp.IsNull())</span>
        {
<span style = "background-color:#fdd">          MITK_ERROR &lt;&lt; "Property cannot be correctly deserialized and is skipped. Check if data format is valid. Problematic property value string: \"" &lt;&lt; value &lt;&lt; "\"; Property info used to deserialized: " &lt;&lt; info;
          break;</span>
        }

<span style = "background-color:#fdd">        output-&gt;SetProperty(assumedPropertyName.c_str(), loadedProp);</span>

        // Read properties should be persisted unless they are default properties
        // which are written anyway
<span style = "background-color:#fdd">        bool isDefaultKey = false;</span>

<span style = "background-color:#fdd">        for (const auto&amp; defaultKey : m_DefaultMetaDataKeys)</span>
        {
<span style = "background-color:#fdd">          if (defaultKey.length() &lt;= assumedPropertyName.length())</span>
          {
            // does the start match the default key
<span style = "background-color:#fdd">            if (assumedPropertyName.substr(0, defaultKey.length()).find(defaultKey) != std::string::npos)</span>
            {
<span style = "background-color:#fdd">              isDefaultKey = true;
              break;</span>
            }
          }
<span style = "background-color:#fdd">        }</span>

<span style = "background-color:#fdd">        if (!isDefaultKey)</span>
        {
<span style = "background-color:#fdd">          propPersistenceService-&gt;AddInfo(info);</span>
        }
<span style = "background-color:#fdd">      }
    }</span>

    // Handle UID
<span style = "background-color:#fdd">    if (dictionary.HasKey(PROPERTY_KEY_UID))</span>
    {
<span style = "background-color:#fdd">      itk::MetaDataObject&lt;std::string&gt;::ConstPointer uidData = dynamic_cast&lt;const itk::MetaDataObject&lt;std::string&gt;*&gt;(dictionary.Get(PROPERTY_KEY_UID));
      if (uidData.IsNotNull())</span>
      {
<span style = "background-color:#fdd">        mitk::UIDManipulator uidManipulator(output);
        uidManipulator.SetUID(uidData-&gt;GetMetaDataObjectValue());
      }
    }</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "...finished!";</span>

<span style = "background-color:#fdd">    std::vector&lt;BaseData::Pointer&gt; result;
    result.push_back(output.GetPointer());
    return result;
  }</span>

  int LabelSetImageIO::GetIntByKey(const itk::MetaDataDictionary &amp;dic, const std::string &amp;str)
<span style = "background-color:#fdd">  {
    std::vector&lt;std::string&gt; imgMetaKeys = dic.GetKeys();
    std::vector&lt;std::string&gt;::const_iterator itKey = imgMetaKeys.begin();
    std::string metaString("");
    for (; itKey != imgMetaKeys.end(); itKey++)</span>
    {
<span style = "background-color:#fdd">      itk::ExposeMetaData&lt;std::string&gt;(dic, *itKey, metaString);
      if (itKey-&gt;find(str.c_str()) != std::string::npos)</span>
      {
<span style = "background-color:#fdd">        return atoi(metaString.c_str());</span>
      }
<span style = "background-color:#fdd">    }
    return 0;
  }</span>

  std::string LabelSetImageIO::GetStringByKey(const itk::MetaDataDictionary &amp;dic, const std::string &amp;str)
<span style = "background-color:#fdd">  {
    std::vector&lt;std::string&gt; imgMetaKeys = dic.GetKeys();
    std::vector&lt;std::string&gt;::const_iterator itKey = imgMetaKeys.begin();
    std::string metaString("");
    for (; itKey != imgMetaKeys.end(); itKey++)</span>
    {
<span style = "background-color:#fdd">      itk::ExposeMetaData&lt;std::string&gt;(dic, *itKey, metaString);
      if (itKey-&gt;find(str.c_str()) != std::string::npos)</span>
      {
<span style = "background-color:#fdd">        return metaString;</span>
      }
<span style = "background-color:#fdd">    }
    return metaString;
  }</span>

<span style = "background-color:#fdd">  LabelSetImageIO *LabelSetImageIO::IOClone() const { return new LabelSetImageIO(*this); }</span>

  void LabelSetImageIO::InitializeDefaultMetaDataKeys()
<span style = "background-color:#fdd">  {
    this-&gt;m_DefaultMetaDataKeys.push_back("NRRD.space");
    this-&gt;m_DefaultMetaDataKeys.push_back("NRRD.kinds");
    this-&gt;m_DefaultMetaDataKeys.push_back(PROPERTY_NAME_TIMEGEOMETRY_TYPE);
    this-&gt;m_DefaultMetaDataKeys.push_back(PROPERTY_NAME_TIMEGEOMETRY_TIMEPOINTS);
    this-&gt;m_DefaultMetaDataKeys.push_back("ITK.InputFilterName");
    this-&gt;m_DefaultMetaDataKeys.push_back("label_");
    this-&gt;m_DefaultMetaDataKeys.push_back("layer_");
  }</span>

} // namespace

#endif //__mitkLabelSetImageWriter__cpp</pre>
	</body>
</html>