<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDICOMTag.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkDICOMTag.h"

#include &lt;gdcmGlobal.h&gt;
#include &lt;gdcmDicts.h&gt;

#include &lt;boost/algorithm/string.hpp&gt;

#include "mitkLogMacros.h"
#include "dcmtk/ofstd/ofstd.h"

mitk::DICOMTag
::DICOMTag(unsigned int group, unsigned int element)
<span style = "background-color:#dfd">:m_Group(group)
,m_Element(element)
{
}</span>

mitk::DICOMTag
::DICOMTag(const DICOMTag&amp; other)
<span style = "background-color:#dfd">:m_Group(other.m_Group)
,m_Element(other.m_Element)
{
}</span>

bool
mitk::DICOMTag
::operator==(const DICOMTag&amp; other) const
<span style = "background-color:#fdd">{
  return</span>
    m_Group == other.m_Group &amp;&amp;
    m_Element == other.m_Element
    ;
<span style = "background-color:#fdd">}</span>


mitk::DICOMTag&amp;
mitk::DICOMTag
::operator=(const DICOMTag&amp; other)
<span style = "background-color:#fdd">{
 if (this != &amp;other)</span>
  {
<span style = "background-color:#fdd">    m_Group = other.m_Group;
    m_Element = other.m_Element;</span>
  }
<span style = "background-color:#fdd">  return *this;
}</span>

unsigned int
mitk::DICOMTag
::GetGroup() const
<span style = "background-color:#dfd">{
  return m_Group;
}</span>

unsigned int
mitk::DICOMTag
::GetElement() const
<span style = "background-color:#dfd">{
  return m_Element;
}</span>

bool
mitk::DICOMTag
::operator&lt;(const DICOMTag&amp; other) const
<span style = "background-color:#dfd">{
  return</span>
    ( this-&gt;m_Group &lt; other.m_Group )
    ||
    ( ( this-&gt;m_Group == other.m_Group )
      &amp;&amp;
      ( this-&gt;m_Element &lt; other.m_Element )
    );
<span style = "background-color:#dfd">}</span>

std::string
mitk::DICOMTag
::GetName() const
<span style = "background-color:#dfd">{
  gdcm::Tag t(m_Group, m_Element);</span>

<span style = "background-color:#dfd">  const gdcm::Global&amp; g = gdcm::Global::GetInstance(); // sum of all knowledge !
  const gdcm::Dicts&amp; dicts = g.GetDicts();
  const gdcm::Dict&amp; pub = dicts.GetPublicDict(); // Part 6</span>

<span style = "background-color:#dfd">  const gdcm::DictEntry&amp; entry = pub.GetDictEntry(t);
  std::string name = entry.GetName();
  if (name.empty())</span>
  {
<span style = "background-color:#fdd">    name = "Unknown Tag";</span>
  }

<span style = "background-color:#dfd">  return name;
}</span>

std::string
mitk::DICOMTag
::toHexString(unsigned int i) const
<span style = "background-color:#fdd">{
  std::stringstream ss;
  ss &lt;&lt; std::setfill ('0') &lt;&lt; std::setw(4) &lt;&lt; std::hex &lt;&lt; i;
  return ss.str();
}</span>

void
mitk::DICOMTag
::Print(std::ostream&amp; os) const
<span style = "background-color:#fdd">{
  os &lt;&lt; "(" &lt;&lt; toHexString(m_Group) &lt;&lt; "," &lt;&lt; toHexString(m_Element) &lt;&lt; ") " &lt;&lt; this-&gt;GetName();
}</span>

void mitk::DICOMStringToOrientationVectors( const std::string&amp; s,
                                            Vector3D&amp; right,
                                            Vector3D&amp; up,
                                            bool&amp; successful )
<span style = "background-color:#fdd">{
  successful = false;</span>

  try
  {
<span style = "background-color:#fdd">    std::vector&lt;std::string&gt; strs;
    boost::split( strs, s, boost::is_any_of( "\\" ) );
    if ( strs.size() == 6 )</span>
    {
<span style = "background-color:#fdd">      int i = 0;
      for ( ; i &lt; 3; ++i )</span>
      {
<span style = "background-color:#fdd">        right[i] = OFStandard::atof( strs[i].c_str() );
      }
      for ( ; i &lt; 6; ++i )</span>
      {
<span style = "background-color:#fdd">        up[i - 3] = OFStandard::atof( strs[i].c_str() );
      }
      successful = true;</span>
    }
<span style = "background-color:#fdd">  }</span>
  catch ( const std::exception&amp; /*e*/ )
<span style = "background-color:#fdd">  {
    right.Fill( 0.0 );
    right[0] = 1.0;</span>

<span style = "background-color:#fdd">    up.Fill( 0.0 );
    up[1] = 1.0;</span>

<span style = "background-color:#fdd">    successful = false;
  }
}</span>


bool
mitk::DICOMStringToSpacing(const std::string&amp; s, ScalarType&amp; spacingX, ScalarType&amp; spacingY)
<span style = "background-color:#fdd">{
  bool successful = false;</span>

  try
  {
<span style = "background-color:#fdd">    std::vector&lt;std::string&gt; strs;
    boost::split( strs, s, boost::is_any_of( "\\" ) );
    if ( strs.size() &gt; 1 )</span>
    {
<span style = "background-color:#fdd">      spacingY = OFStandard::atof( strs[0].c_str() );
      spacingX = OFStandard::atof( strs[1].c_str() );
      successful = true;</span>
    }
<span style = "background-color:#fdd">  }</span>
  catch ( const std::exception&amp; /*e*/ )
<span style = "background-color:#fdd">  {
  }</span>

<span style = "background-color:#fdd">  return successful;
}</span>


mitk::Point3D mitk::DICOMStringToPoint3D( const std::string&amp; s, bool&amp; successful )
<span style = "background-color:#fdd">{
  Point3D p;
  successful = true;</span>

  try
  {
<span style = "background-color:#fdd">    std::vector&lt;std::string&gt; strs;
    boost::split( strs, s, boost::is_any_of( "\\" ) );
    if ( strs.size() == 3 )</span>
    {
<span style = "background-color:#fdd">      for ( int i = 0; i &lt; 3; ++i )</span>
      {
<span style = "background-color:#fdd">        p[i] = OFStandard::atof( strs[i].c_str() );
      }</span>
    }
<span style = "background-color:#fdd">  }</span>
  catch ( const std::exception&amp; /*e*/ )
<span style = "background-color:#fdd">  {
    p.Fill( 0.0 );
  }</span>


<span style = "background-color:#fdd">  return p;
}</span></pre>
	</body>
</html>