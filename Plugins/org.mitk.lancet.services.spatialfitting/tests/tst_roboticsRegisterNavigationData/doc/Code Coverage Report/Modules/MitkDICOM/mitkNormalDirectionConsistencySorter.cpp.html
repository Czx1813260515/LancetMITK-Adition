<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNormalDirectionConsistencySorter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

//#define MBILOG_ENABLE_DEBUG

#include "mitkNormalDirectionConsistencySorter.h"

#include &lt;algorithm&gt;

mitk::NormalDirectionConsistencySorter
::NormalDirectionConsistencySorter()
<span style = "background-color:#dfd">:DICOMDatasetSorter()
{
}</span>

mitk::NormalDirectionConsistencySorter
::NormalDirectionConsistencySorter(const NormalDirectionConsistencySorter&amp; other )
<span style = "background-color:#fdd">:DICOMDatasetSorter(other)
{
}</span>

mitk::NormalDirectionConsistencySorter
::~NormalDirectionConsistencySorter()
<span style = "background-color:#dfd">{
}</span>

void
mitk::NormalDirectionConsistencySorter
::PrintConfiguration(std::ostream&amp; os, const std::string&amp; indent) const
<span style = "background-color:#fdd">{
  os &lt;&lt; indent &lt;&lt; "NormalDirectionConsistencySorter" &lt;&lt; std::endl;
}</span>


mitk::NormalDirectionConsistencySorter&amp;
mitk::NormalDirectionConsistencySorter
::operator=(const NormalDirectionConsistencySorter&amp; other)
<span style = "background-color:#fdd">{
  if (this != &amp;other)</span>
  {
<span style = "background-color:#fdd">    DICOMDatasetSorter::operator=(other);</span>
  }
<span style = "background-color:#fdd">  return *this;
}</span>

bool
mitk::NormalDirectionConsistencySorter
::operator==(const DICOMDatasetSorter&amp; other) const
<span style = "background-color:#fdd">{
  return dynamic_cast&lt;const NormalDirectionConsistencySorter*&gt;(&amp;other) != nullptr;
}</span>


mitk::DICOMTagList
mitk::NormalDirectionConsistencySorter
::GetTagsOfInterest()
<span style = "background-color:#fdd">{
  DICOMTagList tags;
  tags.push_back( DICOMTag(0x0020, 0x0032) ); // ImagePositionPatient
  tags.push_back( DICOMTag(0x0020, 0x0037) ); // ImageOrientationPatient</span>

<span style = "background-color:#fdd">  return tags;
}</span>

void
mitk::NormalDirectionConsistencySorter
::Sort()
<span style = "background-color:#fdd">{
  DICOMDatasetList datasets = GetInput();</span>

<span style = "background-color:#fdd">  if (datasets.size() &gt; 1)</span>
  {
    // at some point in the code, there is the expectation that
    // the direction of the slice normals is the same as the direction between
    // first and last slice origin. We need to make this sure here, because
    // we want to feed the files into itk::ImageSeriesReader with the consistent
    // setting of ReverseOrderOff.

<span style = "background-color:#fdd">    static const DICOMTag tagImagePositionPatient = DICOMTag(0x0020,0x0032); // Image Position (Patient)
    static const DICOMTag    tagImageOrientation = DICOMTag(0x0020, 0x0037); // Image Orientation</span>

<span style = "background-color:#fdd">    DICOMDatasetAccess* firstDS = datasets.front();
    DICOMDatasetAccess*  lastDS = datasets.back();</span>

    // make sure here that the direction from slice to slice is the direction of
    // image normals...
<span style = "background-color:#fdd">    const std::string imageOrientationString = firstDS-&gt;GetTagValueAsString( tagImageOrientation ).value;
    const std::string imagePositionPatientFirst = firstDS-&gt;GetTagValueAsString(tagImagePositionPatient).value;
    const std::string imagePositionPatientLast = lastDS-&gt;GetTagValueAsString(tagImagePositionPatient).value;</span>

<span style = "background-color:#fdd">    Vector3D right; right.Fill(0.0);
    Vector3D up; up.Fill(0.0);
    bool hasOrientation(false);
    DICOMStringToOrientationVectors( imageOrientationString,</span>
        right, up, hasOrientation );

<span style = "background-color:#fdd">    Point3D firstOrigin; firstOrigin.Fill(0.0f);
    bool firstHasOrigin(false);
    firstOrigin = DICOMStringToPoint3D( imagePositionPatientFirst, firstHasOrigin );</span>

<span style = "background-color:#fdd">    Point3D lastOrigin; lastOrigin.Fill(0.0f);
    bool lastHasOrigin(false);
    lastOrigin = DICOMStringToPoint3D( imagePositionPatientLast, lastHasOrigin );</span>

<span style = "background-color:#fdd">    Vector3D normal;
    normal[0] = right[1] * up[2] - right[2] * up[1];
    normal[1] = right[2] * up[0] - right[0] * up[2];
    normal[2] = right[0] * up[1] - right[1] * up[0];
    normal.Normalize();</span>

<span style = "background-color:#fdd">    Vector3D directionOfSlices;
    directionOfSlices = lastOrigin - firstOrigin;
    directionOfSlices.Normalize();</span>

<span style = "background-color:#fdd">    double projection = normal * directionOfSlices;</span>

<span style = "background-color:#fdd">    MITK_DEBUG &lt;&lt; "Making sense of \norientation '" &lt;&lt; imageOrientationString</span>
               &lt;&lt; "'\nfirst position '" &lt;&lt; imagePositionPatientFirst
               &lt;&lt; "'\nlast position '" &lt;&lt; imagePositionPatientLast &lt;&lt; "'";
<span style = "background-color:#fdd">    MITK_DEBUG &lt;&lt; "Normal: " &lt;&lt; normal;
    MITK_DEBUG &lt;&lt; "Direction of slices: " &lt;&lt; directionOfSlices;
    MITK_DEBUG &lt;&lt; "Projection of direction onto slice normal: " &lt;&lt; projection;</span>

<span style = "background-color:#fdd">    if ( projection &lt; 0.0 )</span>
    {
<span style = "background-color:#fdd">      MITK_DEBUG &lt;&lt; "Need to reverse filenames";
      std::reverse( datasets.begin(), datasets.end() );</span>

<span style = "background-color:#fdd">      m_TiltInfo = GantryTiltInformation::MakeFromTagValues(</span>
          imagePositionPatientLast,
          imagePositionPatientFirst,
          imageOrientationString,
          datasets.size() - 1
          );
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">      m_TiltInfo = GantryTiltInformation::MakeFromTagValues(</span>
          imagePositionPatientFirst,
          imagePositionPatientLast,
          imageOrientationString,
          datasets.size() - 1
          );
    }
<span style = "background-color:#fdd">  }</span>
  else // just ONE dataset, do not forget to reset tilt information
  {
<span style = "background-color:#fdd">    m_TiltInfo = GantryTiltInformation(); // empty info</span>
  }

<span style = "background-color:#fdd">  this-&gt;SetNumberOfOutputs(1);
  this-&gt;SetOutput(0, datasets);
}</span>

mitk::GantryTiltInformation
mitk::NormalDirectionConsistencySorter
::GetTiltInformation() const
<span style = "background-color:#fdd">{
  return m_TiltInfo;
}</span></pre>
	</body>
</html>