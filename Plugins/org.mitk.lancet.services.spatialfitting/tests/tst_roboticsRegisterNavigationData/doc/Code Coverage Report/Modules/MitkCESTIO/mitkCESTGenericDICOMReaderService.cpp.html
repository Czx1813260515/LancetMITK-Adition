<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkCESTGenericDICOMReaderService.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkCESTGenericDICOMReaderService.h"

#include "mitkIOMimeTypes.h"
#include &lt;mitkExtractCESTOffset.h&gt;
#include &lt;mitkCustomTagParser.h&gt;
#include &lt;mitkCESTPropertyHelper.h&gt;
#include &lt;mitkDICOMDCMTKTagScanner.h&gt;
#include &lt;mitkDICOMFileReaderSelector.h&gt;
#include &lt;mitkDICOMProperty.h&gt;

#include "mitkCESTImageNormalizationFilter.h"

#include "itksys/SystemTools.hxx"

#include &lt;usGetModuleContext.h&gt;
#include &lt;usModuleContext.h&gt;
#include &lt;usModuleResource.h&gt;

#include &lt;boost/property_tree/json_parser.hpp&gt;
#include &lt;boost/property_tree/ptree.hpp&gt;

namespace
{
  std::string OPTION_NAME_B1()
<span style = "background-color:#dfd">  {
    return "B1 amplitude";
  }</span>

  std::string OPTION_NAME_PULSE()
<span style = "background-color:#dfd">  {
    return "Pulse duration [us]";
  }</span>

  std::string OPTION_NAME_DC()
<span style = "background-color:#dfd">  {
    return "Duty cycle [%]";
  }</span>

  std::string OPTION_NAME_NORMALIZE()
<span style = "background-color:#dfd">  {
    return "Normalize data";
  }</span>

  std::string OPTION_NAME_NORMALIZE_AUTOMATIC()
<span style = "background-color:#dfd">  {
    return "Automatic";
  }</span>

  std::string OPTION_NAME_NORMALIZE_NO()
<span style = "background-color:#dfd">  {
    return "No";
  }</span>

  std::string OPTION_NAME_MERGE()
<span style = "background-color:#dfd">  {
    return "Merge all series";
  }</span>

  std::string OPTION_NAME_MERGE_YES()
<span style = "background-color:#dfd">  {
    return "Yes";
  }</span>

  std::string OPTION_NAME_MERGE_NO()
<span style = "background-color:#dfd">  {
    return "No";
  }</span>

  std::string META_FILE_OPTION_NAME_MERGE()
<span style = "background-color:#fdd">  {
    return "CEST.MergeAllSeries";
  }</span>

}

namespace mitk
{
  DICOMTagPath DICOM_IMAGING_FREQUENCY_PATH()
<span style = "background-color:#dfd">  {
    return mitk::DICOMTagPath(0x0018, 0x0084);
  }</span>

  CESTDICOMManualReaderService::CESTDICOMManualReaderService(const CustomMimeType&amp; mimeType, const std::string&amp; description)
<span style = "background-color:#dfd">    : BaseDICOMReaderService(mimeType, description)
  {
    IFileIO::Options options;
    options[OPTION_NAME_B1()] = 0.0;
    options[OPTION_NAME_PULSE()] = 0.0;
    options[OPTION_NAME_DC()] = 0.0;
    std::vector&lt;std::string&gt; normalizationStrategy;
    normalizationStrategy.push_back(OPTION_NAME_NORMALIZE_AUTOMATIC());
    normalizationStrategy.push_back(OPTION_NAME_NORMALIZE_NO());
    options[OPTION_NAME_NORMALIZE()] = normalizationStrategy;
    std::vector&lt;std::string&gt; mergeStrategy;
    mergeStrategy.push_back(OPTION_NAME_MERGE_NO());
    mergeStrategy.push_back(OPTION_NAME_MERGE_YES());
    options[OPTION_NAME_MERGE()] = mergeStrategy;
    this-&gt;SetDefaultOptions(options);</span>

<span style = "background-color:#dfd">    this-&gt;RegisterService();
  }</span>

  namespace
  {
    void ExtractOptionFromPropertyTree(const std::string&amp; key, boost::property_tree::ptree&amp; root, std::map&lt;std::string, us::Any&gt;&amp; options)
<span style = "background-color:#fdd">    {
      auto finding = root.find(key);
      if (finding != root.not_found())</span>
      {
        try
        {
<span style = "background-color:#fdd">          options[key] = finding-&gt;second.get_value&lt;double&gt;();</span>
        }
        catch (const boost::property_tree::ptree_bad_data&amp; /*e*/)
<span style = "background-color:#fdd">        {
          options[key] = finding-&gt;second.get_value&lt;std::string&gt;();
        }</span>
      }
<span style = "background-color:#fdd">    }</span>

    IFileIO::Options ExtractOptionsFromFile(const std::string&amp; file)
<span style = "background-color:#fdd">    {
      boost::property_tree::ptree root;</span>

<span style = "background-color:#fdd">      if (itksys::SystemTools::FileExists(file))</span>
      {
        try
        {
<span style = "background-color:#fdd">          boost::property_tree::read_json(file, root, std::locale("C"));</span>
        }
        catch (const boost::property_tree::json_parser_error &amp; e)
<span style = "background-color:#fdd">        {
          MITK_WARN &lt;&lt; "Could not parse CEST meta file. Fall back to default values. Error was:\n" &lt;&lt; e.what();
        }
      }</span>
      else
      {
<span style = "background-color:#fdd">        MITK_DEBUG &lt;&lt; "CEST meta file does not exist. Fall back to default values. CEST meta file path: " &lt;&lt; file;</span>
      }

<span style = "background-color:#fdd">      IFileIO::Options options;
      ExtractOptionFromPropertyTree(CEST_PROPERTY_NAME_B1Amplitude(), root, options);
      ExtractOptionFromPropertyTree(CEST_PROPERTY_NAME_PULSEDURATION(), root, options);
      ExtractOptionFromPropertyTree(CEST_PROPERTY_NAME_DutyCycle(), root, options);
      ExtractOptionFromPropertyTree(CEST_PROPERTY_NAME_OFFSETS(), root, options);
      ExtractOptionFromPropertyTree(CEST_PROPERTY_NAME_TREC(), root, options);
      ExtractOptionFromPropertyTree(META_FILE_OPTION_NAME_MERGE(), root, options);</span>

<span style = "background-color:#fdd">      return options;
    }</span>

    void TransferOption(const mitk::IFileIO::Options&amp; sourceOptions, const std::string&amp; sourceName, mitk::IFileIO::Options&amp; options, const std::string&amp; newName)
<span style = "background-color:#fdd">    {
      auto sourceFinding = sourceOptions.find(sourceName);
      auto finding = options.find(newName);</span>

<span style = "background-color:#fdd">      bool replaceValue = finding == options.end();
      if (!replaceValue)</span>
      {
<span style = "background-color:#fdd">        replaceValue = us::any_cast&lt;double&gt;(finding-&gt;second) == 0.;</span>
      }

<span style = "background-color:#fdd">      if (sourceFinding != sourceOptions.end() &amp;&amp; us::any_cast&lt;double&gt;(sourceFinding-&gt;second) != 0. &amp;&amp; replaceValue)</span>
      {
<span style = "background-color:#fdd">        options[newName] = sourceFinding-&gt;second;</span>
      }
<span style = "background-color:#fdd">    }</span>

    void TransferMergeOption(const mitk::IFileIO::Options&amp; sourceOptions, const std::string&amp; sourceName, mitk::IFileIO::Options&amp; options, const std::string&amp; newName)
<span style = "background-color:#fdd">    {
      auto sourceFinding = sourceOptions.find(sourceName);
      auto finding = options.find(newName);</span>

<span style = "background-color:#fdd">      bool replaceValue = finding == options.end();
      if (!replaceValue)</span>
      {
        try
        {
<span style = "background-color:#fdd">          us::any_cast&lt;std::string&gt;(finding-&gt;second);</span>
        }
        catch (const us::BadAnyCastException&amp; /*e*/)
<span style = "background-color:#fdd">        {
          replaceValue = true;</span>
          //if we cannot cast in string the user has not made a selection yet
<span style = "background-color:#fdd">        }</span>
      }

<span style = "background-color:#fdd">      if (sourceFinding != sourceOptions.end() &amp;&amp; us::any_cast&lt;std::string&gt;(sourceFinding-&gt;second) != OPTION_NAME_MERGE_NO() &amp;&amp; replaceValue)</span>
      {
<span style = "background-color:#fdd">        options[newName] = sourceFinding-&gt;second;</span>
      }
<span style = "background-color:#fdd">    }</span>
  }

  std::string CESTDICOMManualReaderService::GetCESTMetaFilePath() const
<span style = "background-color:#fdd">  {
    auto dir = itksys::SystemTools::GetFilenamePath(this-&gt;GetInputLocation());
    std::string metafile = dir + "/" + "CEST_META.json";
    return metafile;
  }</span>

  std::string CESTDICOMManualReaderService::GetTRECFilePath() const
<span style = "background-color:#fdd">  {
    auto dir = itksys::SystemTools::GetFilenamePath(this-&gt;GetInputLocation());
    std::string metafile = dir + "/" + "TREC.txt";
    return metafile;
  }</span>

  std::string CESTDICOMManualReaderService::GetLISTFilePath() const
<span style = "background-color:#fdd">  {
    auto dir = itksys::SystemTools::GetFilenamePath(this-&gt;GetInputLocation());
    std::string metafile = dir + "/" + "LIST.txt";
    return metafile;
  }</span>


  IFileIO::Options CESTDICOMManualReaderService::GetOptions() const
<span style = "background-color:#fdd">  {
    auto options = AbstractFileReader::GetOptions();
    if (!this-&gt;GetInputLocation().empty())</span>
    {
<span style = "background-color:#fdd">      auto fileOptions = ExtractOptionsFromFile(this-&gt;GetCESTMetaFilePath());</span>

<span style = "background-color:#fdd">      TransferOption(fileOptions, CEST_PROPERTY_NAME_B1Amplitude(), options, OPTION_NAME_B1());
      TransferOption(fileOptions, CEST_PROPERTY_NAME_PULSEDURATION(), options, OPTION_NAME_PULSE());
      TransferOption(fileOptions, CEST_PROPERTY_NAME_DutyCycle(), options, OPTION_NAME_DC());
      TransferMergeOption(fileOptions, META_FILE_OPTION_NAME_MERGE(), options, OPTION_NAME_MERGE());
    }
    return options;
  }</span>

  us::Any CESTDICOMManualReaderService::GetOption(const std::string&amp; name) const
<span style = "background-color:#fdd">  {
    this-&gt;GetOptions(); //ensure (default) options are set.
    return AbstractFileReader::GetOption(name);
  }</span>

  DICOMFileReader::Pointer CESTDICOMManualReaderService::GetReader(const mitk::StringList&amp; relevantFiles) const
<span style = "background-color:#fdd">  {
    auto selector = mitk::DICOMFileReaderSelector::New();</span>

<span style = "background-color:#fdd">    const std::string mergeStrategy = this-&gt;GetOption(OPTION_NAME_MERGE()).ToString();</span>

<span style = "background-color:#fdd">    if (mergeStrategy == OPTION_NAME_MERGE_YES())</span>
    {
<span style = "background-color:#fdd">      auto r = ::us::GetModuleContext()-&gt;GetModule()-&gt;GetResource("cest_DKFZ.xml");
      selector-&gt;AddConfigFromResource(r);
    }</span>

<span style = "background-color:#fdd">    selector-&gt;LoadBuiltIn3DnTConfigs();
    selector-&gt;SetInputFiles(relevantFiles);</span>

<span style = "background-color:#fdd">    mitk::DICOMFileReader::Pointer reader = selector-&gt;GetFirstReaderWithMinimumNumberOfOutputImages();
    if (reader.IsNotNull())</span>
    {
      //reset tag cache to ensure that additional tags of interest
      //will be regarded by the reader if set later on.
<span style = "background-color:#fdd">      reader-&gt;SetTagCache(nullptr);</span>
    }

<span style = "background-color:#fdd">    return reader;
  }</span>

  std::vector&lt;itk::SmartPointer&lt;BaseData&gt;&gt; CESTDICOMManualReaderService::Read()
<span style = "background-color:#fdd">  {
    const Options userOptions = this-&gt;GetOptions();</span>

<span style = "background-color:#fdd">    const std::string mergeStrategy = userOptions.find(OPTION_NAME_MERGE())-&gt;second.ToString();
    this-&gt;SetOnlyRegardOwnSeries(mergeStrategy != OPTION_NAME_MERGE_YES());</span>

<span style = "background-color:#fdd">    std::vector&lt;BaseData::Pointer&gt; result;
    std::vector&lt;BaseData::Pointer&gt; dicomResult = BaseDICOMReaderService::Read();</span>

<span style = "background-color:#fdd">    const std::string normalizationStrategy = userOptions.find(OPTION_NAME_NORMALIZE())-&gt;second.ToString();</span>

<span style = "background-color:#fdd">    for (const auto &amp;item : dicomResult)</span>
    {
<span style = "background-color:#fdd">      auto fileOptions = ExtractOptionsFromFile(this-&gt;GetCESTMetaFilePath());
      IFileIO::Options options;
      TransferOption(userOptions, OPTION_NAME_B1(), options, CEST_PROPERTY_NAME_B1Amplitude());
      TransferOption(userOptions, OPTION_NAME_PULSE(), options, CEST_PROPERTY_NAME_PULSEDURATION());
      TransferOption(userOptions, OPTION_NAME_DC(), options, CEST_PROPERTY_NAME_DutyCycle());
      TransferOption(fileOptions, CEST_PROPERTY_NAME_B1Amplitude(), options, CEST_PROPERTY_NAME_B1Amplitude());
      TransferOption(fileOptions, CEST_PROPERTY_NAME_PULSEDURATION(), options, CEST_PROPERTY_NAME_PULSEDURATION());
      TransferOption(fileOptions, CEST_PROPERTY_NAME_DutyCycle(), options, CEST_PROPERTY_NAME_DutyCycle());</span>

<span style = "background-color:#fdd">      TransferOption(fileOptions, CEST_PROPERTY_NAME_OFFSETS(), options, CEST_PROPERTY_NAME_OFFSETS());
      TransferOption(fileOptions, CEST_PROPERTY_NAME_TREC(), options, CEST_PROPERTY_NAME_TREC());</span>

<span style = "background-color:#fdd">      auto trecValues = CustomTagParser::ReadListFromFile(this-&gt;GetTRECFilePath());
      auto offsetValues = CustomTagParser::ReadListFromFile(this-&gt;GetLISTFilePath());</span>

<span style = "background-color:#fdd">      bool isCEST = !offsetValues.empty();
      bool isT1 = !trecValues.empty();</span>

<span style = "background-color:#fdd">      if (!isCEST &amp;&amp; !isT1)</span>
      {//check if there are settings in the metafile
<span style = "background-color:#fdd">        auto finding = fileOptions.find(CEST_PROPERTY_NAME_OFFSETS());
        if (finding != fileOptions.end())</span>
        {
<span style = "background-color:#fdd">          isCEST = true;
          offsetValues = finding-&gt;second.ToString();</span>
        };

<span style = "background-color:#fdd">        finding = fileOptions.find(CEST_PROPERTY_NAME_TREC());
        if (finding != fileOptions.end())</span>
        {
<span style = "background-color:#fdd">          isT1 = true;
          trecValues = finding-&gt;second.ToString();</span>
        };
<span style = "background-color:#fdd">      }</span>

<span style = "background-color:#fdd">      if (isCEST)</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "CEST image detected due to LIST.txt or offset property in CEST_META.json";
        options[CEST_PROPERTY_NAME_OFFSETS()] = offsetValues;
      }
      else if (isT1)</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "T1 image detected due to TREC.txt or trec property in CEST_META.json";
        options[CEST_PROPERTY_NAME_TREC()] = trecValues;
      }</span>
      else
      {
<span style = "background-color:#fdd">        mitkThrow() &lt;&lt; "Cannot load CEST/T1 file. No CEST offsets or T1 trec values specified. LIST.txt/TREC.txt or information in CEST_META.json is missing.";</span>
      }

<span style = "background-color:#fdd">      for (const auto&amp; option : options)</span>
      {
<span style = "background-color:#fdd">        item-&gt;GetPropertyList()-&gt;SetStringProperty(option.first.c_str(), option.second.ToString().c_str());
      }</span>

<span style = "background-color:#fdd">      auto freqProp = item-&gt;GetProperty(mitk::DICOMTagPathToPropertyName(DICOM_IMAGING_FREQUENCY_PATH()).c_str());</span>

<span style = "background-color:#fdd">      if (freqProp.IsNull())</span>
      {
<span style = "background-color:#fdd">        mitkThrow() &lt;&lt; "Loaded image in invalid state. Does not contain the DICOM Imaging Frequency tag.";</span>
      }
<span style = "background-color:#fdd">      SetCESTFrequencyMHz(item, mitk::ConvertDICOMStrToValue&lt;double&gt;(freqProp-&gt;GetValueAsString()));</span>

<span style = "background-color:#fdd">      auto image = dynamic_cast&lt;mitk::Image*&gt;(item.GetPointer());</span>

<span style = "background-color:#fdd">      if (isCEST)</span>
      {
        try
        {
<span style = "background-color:#fdd">          auto offsets = ExtractCESTOffset(image);
        }</span>
        catch (...)
<span style = "background-color:#fdd">        {
          mitkThrow() &lt;&lt; "Cannot load CEST file. Number of CEST offsets do not equal the number of image time steps. Image time steps: " &lt;&lt; image-&gt;GetTimeSteps() &lt;&lt; "; offset values: " &lt;&lt; offsetValues;
        }
      }
      else if (isT1)</span>
      {
        try
        {
<span style = "background-color:#fdd">          auto t1s = ExtractCESTT1Time(image);
        }</span>
        catch (...)
<span style = "background-color:#fdd">        {
          mitkThrow() &lt;&lt; "Cannot load T1 file. Number of T1 times do not equal the number of image time steps. Image time steps: " &lt;&lt; image-&gt;GetTimeSteps() &lt;&lt; "; T1 values: " &lt;&lt; trecValues;
        }</span>
      }

<span style = "background-color:#fdd">      if (normalizationStrategy == OPTION_NAME_NORMALIZE_AUTOMATIC() &amp;&amp; mitk::IsNotNormalizedCESTImage(image))</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "Unnormalized CEST image was loaded and will be normalized automatically.";
        auto normalizationFilter = mitk::CESTImageNormalizationFilter::New();
        normalizationFilter-&gt;SetInput(image);
        normalizationFilter-&gt;Update();
        auto normalizedImage = normalizationFilter-&gt;GetOutput();</span>

<span style = "background-color:#fdd">        auto nameProp = item-&gt;GetProperty("name");
        if (!nameProp)</span>
        {
<span style = "background-color:#fdd">          mitkThrow() &lt;&lt; "Cannot load CEST file. Property \"name\" is missing after BaseDICOMReaderService::Read().";</span>
        }
<span style = "background-color:#fdd">        normalizedImage-&gt;SetProperty("name", mitk::StringProperty::New(nameProp-&gt;GetValueAsString() + "_normalized"));
        result.push_back(normalizedImage);
      }</span>
      else
      {
<span style = "background-color:#fdd">        result.push_back(item);</span>
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    return result;
  }</span>

  CESTDICOMManualReaderService *CESTDICOMManualReaderService::Clone() const
<span style = "background-color:#fdd">  {
    return new CESTDICOMManualReaderService(*this);
  }</span>
}</pre>
	</body>
</html>