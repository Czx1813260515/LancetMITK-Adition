<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>usAny.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*=============================================================================

  Library: CppMicroServices


Copyright Kevlin Henney, 2000, 2001, 2002. All rights reserved.
Extracted from Boost 1.46.1 and adapted for CppMicroServices.

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

=========================================================================*/

#ifndef US_ANY_H
#define US_ANY_H

#include &lt;algorithm&gt;
#include &lt;typeinfo&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;map&gt;

#include &lt;usCoreConfig.h&gt;

US_BEGIN_NAMESPACE

class Any;

US_Core_EXPORT std::string any_value_to_string(const Any&amp; any);

US_Core_EXPORT std::string any_value_to_json(const Any&amp; val);
US_Core_EXPORT std::string any_value_to_json(const std::string&amp; val);
US_Core_EXPORT std::string any_value_to_json(bool val);

template&lt;class T&gt;
std::string any_value_to_string(const T&amp; val)
<span style = "background-color:#dfd">{
  std::stringstream ss;
  ss &lt;&lt; val;
  return ss.str();
}</span>

template&lt;class T&gt;
std::string any_value_to_json(const T&amp; val)
<span style = "background-color:#fdd">{
  return any_value_to_string(val);
}</span>

/**
 * \internal
 */
template&lt;typename Iterator&gt;
std::string container_to_string(Iterator i1, Iterator i2)
<span style = "background-color:#fdd">{
  std::stringstream ss;
  ss &lt;&lt; "[";
  const Iterator begin = i1;
  for ( ; i1 != i2; ++i1)</span>
  {
<span style = "background-color:#fdd">    if (i1 == begin) ss &lt;&lt; any_value_to_string(*i1);
    else ss &lt;&lt; "," &lt;&lt; any_value_to_string(*i1);
  }
  ss &lt;&lt; "]";
  return ss.str();
}</span>

/**
 * \internal
 */
template&lt;typename Iterator&gt;
std::string container_to_json(Iterator i1, Iterator i2)
<span style = "background-color:#fdd">{
  std::stringstream ss;
  ss &lt;&lt; "[";
  const Iterator begin = i1;
  for ( ; i1 != i2; ++i1)</span>
  {
<span style = "background-color:#fdd">    if (i1 == begin) ss &lt;&lt; any_value_to_json(*i1);
    else ss &lt;&lt; "," &lt;&lt; any_value_to_json(*i1);
  }
  ss &lt;&lt; "]";
  return ss.str();
}</span>

template&lt;class E&gt;
std::string any_value_to_string(const std::vector&lt;E&gt;&amp; vec)
<span style = "background-color:#fdd">{
  return container_to_string(vec.begin(), vec.end());
}</span>

template&lt;class E&gt;
std::string any_value_to_json(const std::vector&lt;E&gt;&amp; vec)
<span style = "background-color:#fdd">{
  return container_to_json(vec.begin(), vec.end());
}</span>

template&lt;class E&gt;
std::string any_value_to_string(const std::list&lt;E&gt;&amp; l)
{
  return container_to_string(l.begin(), l.end());
}

template&lt;class E&gt;
std::string any_value_to_json(const std::list&lt;E&gt;&amp; l)
{
  return container_to_json(l.begin(), l.end());
}

template&lt;class E&gt;
std::string any_value_to_string(const std::set&lt;E&gt;&amp; s)
{
  return container_to_string(s.begin(), s.end());
}

template&lt;class E&gt;
std::string any_value_to_json(const std::set&lt;E&gt;&amp; s)
{
  return container_to_json(s.begin(), s.end());
}

template&lt;class M&gt;
std::string any_value_to_string(const std::map&lt;M, Any&gt;&amp; m);

template&lt;class K, class V&gt;
std::string any_value_to_string(const std::map&lt;K, V&gt;&amp; m);

template&lt;class M&gt;
std::string any_value_to_json(const std::map&lt;M, Any&gt;&amp; m);

template&lt;class K, class V&gt;
std::string any_value_to_json(const std::map&lt;K, V&gt;&amp; m);


/**
 * \ingroup MicroServicesUtils
 *
 * An Any class represents a general type and is capable of storing any type, supporting type-safe extraction
 * of the internally stored data.
 *
 * Code taken from the Boost 1.46.1 library. Original copyright by Kevlin Henney. Modified for CppMicroServices.
 */
class Any
{
public:

  /**
   * Creates an empty any type.
   */
<span style = "background-color:#dfd">  Any(): _content(nullptr)
  { }</span>

  /**
   * Creates an Any which stores the init parameter inside.
   *
   * \param value The content of the Any
   *
   * Example:
   * \code
   * Any a(13);
   * Any a(string("12345"));
   * \endcode
   */
  template &lt;typename ValueType&gt;
  Any(const ValueType&amp; value)
<span style = "background-color:#dfd">    : _content(new Holder&lt;ValueType&gt;(value))
  { }</span>

  /**
   * Copy constructor, works with empty Anys and initialized Any values.
   *
   * \param other The Any to copy
   */
  Any(const Any&amp; other)
<span style = "background-color:#dfd">    : _content(other._content ? other._content-&gt;Clone() : nullptr)
  { }</span>

  ~Any()
<span style = "background-color:#dfd">  {
    delete _content;
  }</span>

  /**
   * Swaps the content of the two Anys.
   *
   * \param rhs The Any to swap this Any with.
   */
  Any&amp; Swap(Any&amp; rhs)
<span style = "background-color:#dfd">  {
    std::swap(_content, rhs._content);
    return *this;
  }</span>

  /**
   * Assignment operator for all types != Any.
   *
   * \param rhs The value which should be assigned to this Any.
   *
   * Example:
   * \code
   * Any a = 13;
   * Any a = string("12345");
   * \endcode
   */
  template &lt;typename ValueType&gt;
  Any&amp; operator = (const ValueType&amp; rhs)
<span style = "background-color:#dfd">  {
    Any(rhs).Swap(*this);
    return *this;
  }</span>

  /**
   * Assignment operator for Any.
   *
   * \param rhs The Any which should be assigned to this Any.
   */
  Any&amp; operator = (const Any&amp; rhs)
<span style = "background-color:#dfd">  {
    Any(rhs).Swap(*this);
    return *this;
  }</span>

  /**
   * returns true if the Any is empty
   */
  bool Empty() const
<span style = "background-color:#dfd">  {
    return !_content;
  }</span>

  /**
   * Returns a string representation for the content.
   *
   * Custom types should either provide a &lt;code&gt;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CustomType&amp; ct)&lt;/code&gt;
   * function or specialize the any_value_to_string template function for meaningful output.
   */
  std::string ToString() const
<span style = "background-color:#dfd">  {
    return _content-&gt;ToString();
  }</span>

  /**
   * Returns a JSON representation for the content.
   *
   * Custom types should specialize the any_value_to_json template function for meaningful output.
   */
  std::string ToJSON() const
<span style = "background-color:#fdd">  {
    return Empty() ? "null" : _content-&gt;ToJSON();
  }</span>

  /**
   * Returns the type information of the stored content.
   * If the Any is empty typeid(void) is returned.
   * It is suggested to always query an Any for its type info before trying to extract
   * data via an any_cast/ref_any_cast.
   */
  const std::type_info&amp; Type() const
<span style = "background-color:#dfd">  {
    return _content ? _content-&gt;Type() : typeid(void);
  }</span>

private:

  class Placeholder
  {
  public:
    virtual ~Placeholder()
<span style = "background-color:#dfd">    { }</span>

    virtual std::string ToString() const = 0;
    virtual std::string ToJSON() const = 0;

    virtual const std::type_info&amp; Type() const = 0;
    virtual Placeholder* Clone() const = 0;
  };

  template &lt;typename ValueType&gt;
  class Holder: public Placeholder
  {
  public:
    Holder(const ValueType&amp; value)
<span style = "background-color:#dfd">      : _held(value)
    { }</span>

    std::string ToString() const override
<span style = "background-color:#dfd">    {
      return any_value_to_string(_held);
    }</span>

    std::string ToJSON() const override
<span style = "background-color:#fdd">    {
      return any_value_to_json(_held);
    }</span>

    const std::type_info&amp; Type() const override
<span style = "background-color:#dfd">    {
      return typeid(ValueType);
    }</span>

    Placeholder* Clone() const override
<span style = "background-color:#dfd">    {
      return new Holder(_held);
    }</span>

    ValueType _held;

  private: // intentionally left unimplemented
    Holder&amp; operator=(const Holder &amp;);
  };

private:
    template &lt;typename ValueType&gt;
    friend ValueType* any_cast(Any*);

    template &lt;typename ValueType&gt;
    friend ValueType* unsafe_any_cast(Any*);

    Placeholder* _content;
};

class BadAnyCastException : public std::bad_cast
{
public:

  BadAnyCastException(const std::string&amp; msg = "")
<span style = "background-color:#fdd">    : std::bad_cast(), _msg(msg)
  {}</span>

<span style = "background-color:#fdd">  ~BadAnyCastException() throw() override {}</span>

  const char * what() const throw() override
<span style = "background-color:#fdd">  {
    if (_msg.empty())
      return "US_PREPEND_NAMESPACE(BadAnyCastException): "</span>
             "failed conversion using US_PREPEND_NAMESPACE(any_cast)";
    else
<span style = "background-color:#fdd">      return _msg.c_str();
  }</span>

private:

  std::string _msg;
};

/**
 * any_cast operator used to extract the ValueType from an Any*. Will return a pointer
 * to the stored value.
 *
 * Example Usage:
 * \code
 * MyType* pTmp = any_cast&lt;MyType*&gt;(pAny)
 * \endcode
 * Will return nullptr if the cast fails, i.e. types don't match.
 */
template &lt;typename ValueType&gt;
ValueType* any_cast(Any* operand)
<span style = "background-color:#dfd">{
  return operand &amp;&amp; operand-&gt;Type() == typeid(ValueType)</span>
      ? &amp;static_cast&lt;Any::Holder&lt;ValueType&gt;*&gt;(operand-&gt;_content)-&gt;_held
      : nullptr;
<span style = "background-color:#dfd">}</span>

/**
 * any_cast operator used to extract a const ValueType pointer from an const Any*. Will return a const pointer
 * to the stored value.
 *
 * Example Usage:
 * \code
 * const MyType* pTmp = any_cast&lt;MyType*&gt;(pAny)
 * \endcode
 * Will return nullptr if the cast fails, i.e. types don't match.
 */
template &lt;typename ValueType&gt;
const ValueType* any_cast(const Any* operand)
<span style = "background-color:#dfd">{
  return any_cast&lt;ValueType&gt;(const_cast&lt;Any*&gt;(operand));
}</span>

/**
 * any_cast operator used to extract a copy of the ValueType from an const Any&amp;.
 *
 * Example Usage:
 * \code
 * MyType tmp = any_cast&lt;MyType&gt;(anAny)
 * \endcode
 * Will throw a BadCastException if the cast fails.
 * Dont use an any_cast in combination with references, i.e. MyType&amp; tmp = ... or const MyType&amp; = ...
 * Some compilers will accept this code although a copy is returned. Use the ref_any_cast in
 * these cases.
 */
template &lt;typename ValueType&gt;
ValueType any_cast(const Any&amp; operand)
<span style = "background-color:#dfd">{
  ValueType* result = any_cast&lt;ValueType&gt;(const_cast&lt;Any*&gt;(&amp;operand));
  if (!result) throw BadAnyCastException("Failed to convert between const Any types");
  return *result;
}</span>

/**
 * any_cast operator used to extract a copy of the ValueType from an Any&amp;.
 *
 * Example Usage:
 * \code
 * MyType tmp = any_cast&lt;MyType&gt;(anAny)
 * \endcode
 * Will throw a BadCastException if the cast fails.
 * Dont use an any_cast in combination with references, i.e. MyType&amp; tmp = ... or const MyType&amp; tmp = ...
 * Some compilers will accept this code although a copy is returned. Use the ref_any_cast in
 * these cases.
 */
template &lt;typename ValueType&gt;
ValueType any_cast(Any&amp; operand)
<span style = "background-color:#dfd">{
  ValueType* result = any_cast&lt;ValueType&gt;(&amp;operand);
  if (!result) throw BadAnyCastException("Failed to convert between Any types");
  return *result;
}</span>

/**
 * ref_any_cast operator used to return a const reference to the internal data.
 *
 * Example Usage:
 * \code
 * const MyType&amp; tmp = ref_any_cast&lt;MyType&gt;(anAny);
 * \endcode
 */
template &lt;typename ValueType&gt;
const ValueType&amp; ref_any_cast(const Any &amp; operand)
<span style = "background-color:#dfd">{
  ValueType* result = any_cast&lt;ValueType&gt;(const_cast&lt;Any*&gt;(&amp;operand));
  if (!result) throw BadAnyCastException("RefAnyCast: Failed to convert between const Any types");
  return *result;
}</span>

/**
 * ref_any_cast operator used to return a reference to the internal data.
 *
 * Example Usage:
 * \code
 * MyType&amp; tmp = ref_any_cast&lt;MyType&gt;(anAny);
 * \endcode
 */
template &lt;typename ValueType&gt;
ValueType&amp; ref_any_cast(Any&amp; operand)
<span style = "background-color:#fdd">{
  ValueType* result = any_cast&lt;ValueType&gt;(&amp;operand);
  if (!result) throw BadAnyCastException("RefAnyCast: Failed to convert between Any types");
  return *result;
}</span>

/**
 * \internal
 *
 * The "unsafe" versions of any_cast are not part of the
 * public interface and may be removed at any time. They are
 * required where we know what type is stored in the any and can't
 * use typeid() comparison, e.g., when our types may travel across
 * different shared libraries.
 */
template &lt;typename ValueType&gt;
ValueType* unsafe_any_cast(Any* operand)
{
  return &amp;static_cast&lt;Any::Holder&lt;ValueType&gt;*&gt;(operand-&gt;_content)-&gt;_held;
}

/**
 * \internal
 *
 * The "unsafe" versions of any_cast are not part of the
 * public interface and may be removed at any time. They are
 * required where we know what type is stored in the any and can't
 * use typeid() comparison, e.g., when our types may travel across
 * different shared libraries.
 */
template &lt;typename ValueType&gt;
const ValueType* unsafe_any_cast(const Any* operand)
{
  return any_cast&lt;ValueType&gt;(const_cast&lt;Any*&gt;(operand));
}


template&lt;class K&gt;
std::string any_value_to_string(const std::map&lt;K, Any&gt;&amp; m)
<span style = "background-color:#fdd">{
  std::stringstream ss;
  ss &lt;&lt; "{";</span>
  typedef typename std::map&lt;K, Any&gt;::const_iterator Iterator;
<span style = "background-color:#fdd">  Iterator i1 = m.begin();
  const Iterator begin = i1;
  const Iterator end = m.end();
  for ( ; i1 != end; ++i1)</span>
  {
<span style = "background-color:#fdd">    if (i1 == begin) ss &lt;&lt; i1-&gt;first &lt;&lt; " : " &lt;&lt; i1-&gt;second.ToString();
    else ss &lt;&lt; ", " &lt;&lt; i1-&gt;first &lt;&lt; " : " &lt;&lt; i1-&gt;second.ToString();
  }
  ss &lt;&lt; "}";
  return ss.str();
}</span>

template&lt;class K, class V&gt;
std::string any_value_to_string(const std::map&lt;K, V&gt;&amp; m)
{
  std::stringstream ss;
  ss &lt;&lt; "{";
  typedef typename std::map&lt;K, V&gt;::const_iterator Iterator;
  Iterator i1 = m.begin();
  const Iterator begin = i1;
  const Iterator end = m.end();
  for ( ; i1 != end; ++i1)
  {
    if (i1 == begin) ss &lt;&lt; i1-&gt;first &lt;&lt; " : " &lt;&lt; i1-&gt;second;
    else ss &lt;&lt; ", " &lt;&lt; i1-&gt;first &lt;&lt; " : " &lt;&lt; i1-&gt;second;
  }
  ss &lt;&lt; "}";
  return ss.str();
}

template&lt;class K&gt;
std::string any_value_to_json(const std::map&lt;K, Any&gt;&amp; m)
<span style = "background-color:#fdd">{
  std::stringstream ss;
  ss &lt;&lt; "{";</span>
  typedef typename std::map&lt;K, Any&gt;::const_iterator Iterator;
<span style = "background-color:#fdd">  Iterator i1 = m.begin();
  const Iterator begin = i1;
  const Iterator end = m.end();
  for ( ; i1 != end; ++i1)</span>
  {
<span style = "background-color:#fdd">    if (i1 == begin) ss &lt;&lt; "\"" &lt;&lt; i1-&gt;first &lt;&lt; "\" : " &lt;&lt; i1-&gt;second.ToJSON();
    else ss &lt;&lt; ", " &lt;&lt; "\"" &lt;&lt; i1-&gt;first &lt;&lt; "\" : " &lt;&lt; i1-&gt;second.ToJSON();
  }
  ss &lt;&lt; "}";
  return ss.str();
}</span>

template&lt;class K, class V&gt;
std::string any_value_to_json(const std::map&lt;K, V&gt;&amp; m)
{
  std::stringstream ss;
  ss &lt;&lt; "{";
  typedef typename std::map&lt;K, V&gt;::const_iterator Iterator;
  Iterator i1 = m.begin();
  const Iterator begin = i1;
  const Iterator end = m.end();
  for ( ; i1 != end; ++i1)
  {
    if (i1 == begin) ss &lt;&lt; "\"" &lt;&lt; i1-&gt;first &lt;&lt; "\" : " &lt;&lt; i1-&gt;second;
    else ss &lt;&lt; ", " &lt;&lt; "\"" &lt;&lt; i1-&gt;first &lt;&lt; "\" : " &lt;&lt; i1-&gt;second;
  }
  ss &lt;&lt; "}";
  return ss.str();
}

US_END_NAMESPACE

#endif // US_ANY_H</pre>
	</body>
</html>