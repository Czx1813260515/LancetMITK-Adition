<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkStaticIGTHelperFunctions.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;mitkStaticIGTHelperFunctions.h&gt;
#include &lt;itkVector.h&gt;

double mitk::StaticIGTHelperFunctions::GetAngleBetweenTwoQuaterions(mitk::Quaternion a, mitk::Quaternion b, itk::Vector&lt;double,3&gt; rotationVector)
<span style = "background-color:#fdd">  {</span>
  double returnValue;

  itk::Vector&lt;double,3&gt; point; //caution 5D-Tools: correct vector along the tool axis is needed
<span style = "background-color:#fdd">  point[0] = rotationVector[0];
  point[1] = rotationVector[1];
  point[2] = rotationVector[2];</span>

  //Quaternions used for rotations should alway be normalized, so just to be safe:
<span style = "background-color:#fdd">  a.normalize();
  b.normalize();</span>

<span style = "background-color:#fdd">  itk::Matrix&lt;double,3,3&gt; rotMatrixA;
  for(int i=0; i&lt;3; i++) for(int j=0; j&lt;3; j++) rotMatrixA[i][j] = a.rotation_matrix_transpose().transpose()[i][j];</span>

<span style = "background-color:#fdd">  itk::Matrix&lt;double,3,3&gt; rotMatrixB;
  for(int i=0; i&lt;3; i++) for(int j=0; j&lt;3; j++) rotMatrixB[i][j] = b.rotation_matrix_transpose().transpose()[i][j];</span>

<span style = "background-color:#fdd">  itk::Vector&lt;double,3&gt; pt1 = rotMatrixA * point;
  itk::Vector&lt;double,3&gt; pt2 = rotMatrixB * point;</span>

<span style = "background-color:#fdd">  returnValue = (pt1[0]*pt2[0]+pt1[1]*pt2[1]+pt1[2]*pt2[2]) / ( sqrt(pow(pt1[0],2.0)+pow(pt1[1],2.0)+pow(pt1[2],2.0)) * sqrt(pow(pt2[0],2.0)+pow(pt2[1],2.0)+pow(pt2[2],2.0)));
  returnValue = acos(returnValue) * 57.296; //57,296 = 180/Pi ; conversion to degrees</span>

<span style = "background-color:#fdd">  return returnValue;
  }</span>

double mitk::StaticIGTHelperFunctions::GetAngleBetweenTwoQuaterions(mitk::Quaternion a, mitk::Quaternion b)
<span style = "background-color:#fdd">{</span>
  //formula returnValue = 2 * acos ( a &lt;dotproduct&gt; b )
  //(+ normalization because we need unit quaternions)
  //derivation from here: https://fgiesen.wordpress.com/2013/01/07/small-note-on-quaternion-distance-metrics/
<span style = "background-color:#fdd">  double returnValue = ((a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]) / (sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3])*sqrt(b[0] * b[0] + b[1] * b[1] + b[2] * b[2] + b[3] * b[3])));
  returnValue = 2 * acos(returnValue);
  return returnValue;
}</span>

itk::Matrix&lt;double,3,3&gt; mitk::StaticIGTHelperFunctions::ConvertEulerAnglesToRotationMatrix(double alpha, double beta, double gamma)
<span style = "background-color:#fdd">{
    double PI = 3.141592653589793;
    alpha = alpha * PI / 180;
    beta = beta * PI / 180;
    gamma = gamma * PI / 180;</span>

    //convert angles to matrix:
<span style = "background-color:#fdd">    itk::Matrix&lt;double,3,3&gt; matrix;</span>

    /* x-Konvention (Z, X, Z)
    matrix[0][0] = cos(alpha) * cos(gamma) - sin(alpha) * cos(beta) * sin(gamma);
    matrix[0][1] = -cos(alpha) * sin(gamma)- sin(alpha) * cos(beta) * cos(gamma);
    matrix[0][2] = sin(alpha) * sin(beta);

    matrix[1][0] = sin(alpha) * cos(gamma) + cos(alpha) * cos(beta) * sin(gamma);
    matrix[1][1] = cos(alpha) * cos(beta) * cos(gamma) - sin(alpha) * sin(gamma);
    matrix[1][2] = -cos(alpha) * sin(beta);

    matrix[2][0] = sin(beta) * sin(gamma);
    matrix[2][1] = sin(beta) * cos(gamma);
    matrix[2][2] = cos(beta);
    */

    //Luftfahrtnorm (DIN 9300) (Yaw-Pitch-Roll, Z, Y, X)
<span style = "background-color:#fdd">    matrix[0][0] = cos(beta) * cos(alpha);
    matrix[0][1] = cos(beta) * sin(alpha);
    matrix[0][2] = -sin(beta);</span>

<span style = "background-color:#fdd">    matrix[1][0] = sin(gamma) * sin(beta) * cos(alpha) - cos(gamma) * sin(alpha) ;
    matrix[1][1] = sin(gamma) * sin(beta) * sin(alpha) + cos(gamma) * cos(alpha);
    matrix[1][2] = sin(gamma) * cos(beta);</span>

<span style = "background-color:#fdd">    matrix[2][0] = cos(gamma) * sin(beta) * cos(alpha) + sin(gamma) * sin(alpha);
    matrix[2][1] = cos(gamma) * sin(beta) * sin(alpha) - sin(gamma) * cos(alpha);
    matrix[2][2] = cos(gamma) * cos(beta);</span>

<span style = "background-color:#fdd">    return matrix;
}</span>

double mitk::StaticIGTHelperFunctions::ComputeFRE(mitk::PointSet::Pointer imageFiducials, mitk::PointSet::Pointer realWorldFiducials, vtkSmartPointer&lt;vtkLandmarkTransform&gt; transform)
<span style = "background-color:#fdd">{
  if (imageFiducials-&gt;GetSize() != realWorldFiducials-&gt;GetSize())</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Cannot compute FRE, got different numbers of points (1: " &lt;&lt; imageFiducials-&gt;GetSize() &lt;&lt; " /2: " &lt;&lt; realWorldFiducials-&gt;GetSize() &lt;&lt; ")";
    return -1;</span>
  }
<span style = "background-color:#fdd">  double FRE = 0;
  for (int i = 0; i &lt; imageFiducials-&gt;GetSize(); i++)</span>
  {
<span style = "background-color:#fdd">    itk::Point&lt;double&gt; current_image_fiducial_point = imageFiducials-&gt;GetPoint(i);
    if (transform != nullptr)</span>
    {
<span style = "background-color:#fdd">      current_image_fiducial_point = transform-&gt;TransformPoint(imageFiducials-&gt;GetPoint(i)[0], imageFiducials-&gt;GetPoint(i)[1], imageFiducials-&gt;GetPoint(i)[2]);</span>
    }
<span style = "background-color:#fdd">    double cur_error_squared = current_image_fiducial_point.SquaredEuclideanDistanceTo(realWorldFiducials-&gt;GetPoint(i));
    FRE += cur_error_squared;
  }</span>

<span style = "background-color:#fdd">  FRE = sqrt(FRE / (double)imageFiducials-&gt;GetSize());</span>

<span style = "background-color:#fdd">  return FRE;
}</span></pre>
	</body>
</html>