<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkVectorPropertySerializer.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef mitkVectorPropertySerializer_h
#define mitkVectorPropertySerializer_h

#include "mitkBasePropertySerializer.h"
#include "mitkVectorProperty.h"
#include &lt;mitkLexicalCast.h&gt;
#include &lt;tinyxml2.h&gt;

namespace mitk
{
  /**
    \brief Serializes a VectorProperty

    Serializes an instance of VectorProperty into a XML structure like

    \verbatim
    &lt;Values&gt;
      &lt;Value idx="0" value="17.3"/&gt;
      &lt;Value idx="1" value="7.2"/&gt;
      &lt;Value idx="2" value="-17.3"/&gt;
    &lt;/Values&gt;
    \endverbatim

    This class is implemented as a template and makes use of std::stringstream
    for necessary conversions of specific data types to and from string.

    For numeric types, the class adds a precision token to stringstream that
    should usually suffice.
  */
  template &lt;typename DATATYPE&gt;
  class MITKSCENESERIALIZATIONBASE_EXPORT VectorPropertySerializer : public BasePropertySerializer
  {
  public:
    // Expand manually most of mitkClassMacro:
    // mitkClassMacro(VectorProperty&lt;DATATYPE&gt;, mitk::BaseProperty);
    // This manual expansion is done to override explicitely
    // the GetNameOfClass methods
    typedef VectorProperty&lt;DATATYPE&gt; PropertyType;
    typedef VectorPropertySerializer&lt;DATATYPE&gt; Self;
    typedef BasePropertySerializer SuperClass;
    typedef itk::SmartPointer&lt;Self&gt; Pointer;
    typedef itk::SmartPointer&lt;const Self&gt; ConstPointer;
<span style = "background-color:#fdd">    std::vector&lt;std::string&gt; GetClassHierarchy() const override { return mitk::GetClassHierarchy&lt;Self&gt;(); }</span>
    // This function must return different
    // strings in function of the template parameter!
    // Serialization depends on this feature.
    static const char *GetStaticNameOfClass()
<span style = "background-color:#fdd">    {</span>
      // concatenate a prefix dependent on the template type and our own classname
<span style = "background-color:#fdd">      static std::string nameOfClass =
        std::string(VectorPropertyDataType&lt;DATATYPE&gt;::prefix()) + "VectorPropertySerializer";
      return nameOfClass.c_str();
    }</span>

<span style = "background-color:#fdd">    const char *GetNameOfClass() const override { return this-&gt;GetStaticNameOfClass(); }
    itkFactorylessNewMacro(Self);</span>
    itkCloneMacro(Self);

    //! Build an XML version of this property
    tinyxml2::XMLElement* Serialize(tinyxml2::XMLDocument&amp; doc) override
<span style = "background-color:#fdd">    {
      auto *listElement = doc.NewElement("Values");</span>

<span style = "background-color:#fdd">      if (const PropertyType *prop = dynamic_cast&lt;const PropertyType *&gt;(m_Property.GetPointer()))</span>
      {
<span style = "background-color:#fdd">        typename PropertyType::VectorType elements = prop-&gt;GetValue();
        unsigned int index(0);
        for (auto listEntry : elements)</span>
        {
<span style = "background-color:#fdd">          std::stringstream indexS;
          indexS &lt;&lt; index++;</span>

<span style = "background-color:#fdd">          auto *entryElement = doc.NewElement("Value");
          entryElement-&gt;SetAttribute("idx", indexS.str().c_str());
          entryElement-&gt;SetAttribute("value", boost::lexical_cast&lt;std::string&gt;(listEntry).c_str());
          listElement-&gt;InsertEndChild(entryElement);
        }</span>

<span style = "background-color:#fdd">        return listElement;
      }</span>
      else
      {
<span style = "background-color:#fdd">        return nullptr;</span>
      }
<span style = "background-color:#fdd">    }</span>

    //! Construct a property from an XML serialization
    BaseProperty::Pointer Deserialize(const tinyxml2::XMLElement *listElement) override
<span style = "background-color:#fdd">    {
      typename PropertyType::VectorType datalist;</span>

<span style = "background-color:#fdd">      if (listElement)</span>
      {
<span style = "background-color:#fdd">        unsigned int index(0);
        std::string valueString;</span>
        DATATYPE value;
<span style = "background-color:#fdd">        for (auto *valueElement = listElement-&gt;FirstChildElement("Value"); valueElement;
             valueElement = valueElement-&gt;NextSiblingElement("Value"))</span>
        {
<span style = "background-color:#fdd">          valueString = valueElement-&gt;Attribute("value");
          if (valueString.empty())</span>
          {
<span style = "background-color:#fdd">            MITK_ERROR &lt;&lt; "Missing value attribute in &lt;Values&gt; list";
            return nullptr;</span>
          }

          try
          {
<span style = "background-color:#fdd">            value = boost::lexical_cast&lt;DATATYPE&gt;(valueString);</span>
          }
          catch (boost::bad_lexical_cast &amp;e)
<span style = "background-color:#fdd">          {
            MITK_ERROR &lt;&lt; "Could not parse '" &lt;&lt; valueString &lt;&lt; "' as number: " &lt;&lt; e.what();
            return nullptr;
          }</span>

<span style = "background-color:#fdd">          datalist.push_back(value);
          ++index;
        }</span>

<span style = "background-color:#fdd">        typename PropertyType::Pointer property = PropertyType::New();
        property-&gt;SetValue(datalist);
        return property.GetPointer();
      }</span>
      else
      {
<span style = "background-color:#fdd">        MITK_ERROR &lt;&lt; "Missing &lt;Values&gt; tag.";</span>
      }

<span style = "background-color:#fdd">      return nullptr;
    }</span>
  };

  typedef VectorPropertySerializer&lt;double&gt; DoubleVectorPropertySerializer;
  typedef VectorPropertySerializer&lt;int&gt; IntVectorPropertySerializer;

} // namespace

#endif</pre>
	</body>
</html>