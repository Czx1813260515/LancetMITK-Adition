<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkLabeledImageVolumeCalculator.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkLabeledImageVolumeCalculator.h"
#include "mitkImageAccessByItk.h"

#include &lt;itkImageRegionConstIteratorWithIndex.h&gt;

namespace mitk
{
  LabeledImageVolumeCalculator::LabeledImageVolumeCalculator()
<span style = "background-color:#fdd">  {
    m_InputTimeSelector = ImageTimeSelector::New();</span>

<span style = "background-color:#fdd">    m_DummyPoint.Fill(0.0);
  }</span>

<span style = "background-color:#fdd">  LabeledImageVolumeCalculator::~LabeledImageVolumeCalculator() {}</span>
  double LabeledImageVolumeCalculator::GetVolume(unsigned int label) const
<span style = "background-color:#fdd">  {
    if (label &lt; m_VolumeVector.size())
      return m_VolumeVector[label];</span>
    else
<span style = "background-color:#fdd">      return 0.0;
  }</span>

  const Point3D &amp;LabeledImageVolumeCalculator::GetCentroid(unsigned int label) const
<span style = "background-color:#fdd">  {
    if (label &lt; m_CentroidVector.size())
      return m_CentroidVector[label];</span>
    else
<span style = "background-color:#fdd">      return m_DummyPoint;
  }</span>

  const LabeledImageVolumeCalculator::VolumeVector &amp;LabeledImageVolumeCalculator::GetVolumes() const
<span style = "background-color:#fdd">  {
    return m_VolumeVector;
  }</span>

  const LabeledImageVolumeCalculator::PointVector &amp;LabeledImageVolumeCalculator::GetCentroids() const
<span style = "background-color:#fdd">  {
    return m_CentroidVector;
  }</span>

  void LabeledImageVolumeCalculator::Calculate()
<span style = "background-color:#fdd">  {
    if (m_Image.IsNull())</span>
    {
<span style = "background-color:#fdd">      itkExceptionMacro(&lt;&lt; "Image not set!");
      return;</span>
    }

<span style = "background-color:#fdd">    m_InputTimeSelector-&gt;SetInput(m_Image);</span>

<span style = "background-color:#fdd">    m_InputTimeSelector-&gt;SetTimeNr(0);
    m_InputTimeSelector-&gt;UpdateLargestPossibleRegion();</span>

<span style = "background-color:#fdd">    AccessByItk_2(m_InputTimeSelector-&gt;GetOutput(), _InternalCalculateVolumes, this, m_Image-&gt;GetGeometry(0));</span>
    //}
<span style = "background-color:#fdd">  }</span>

  template &lt;typename TPixel, unsigned int VImageDimension&gt;
  void LabeledImageVolumeCalculator::_InternalCalculateVolumes(itk::Image&lt;TPixel, VImageDimension&gt; *image,
                                                               LabeledImageVolumeCalculator * /*volumeCalculator*/,
                                                               BaseGeometry *geometry)
<span style = "background-color:#fdd">  {</span>
    typedef itk::Image&lt;TPixel, VImageDimension&gt; ImageType;
    typedef typename ImageType::IndexType IndexType;
    typedef itk::ImageRegionConstIteratorWithIndex&lt;ImageType&gt; IteratorType;

    // Reset volume and centroid vectors
<span style = "background-color:#fdd">    m_VolumeVector.clear();
    m_CentroidVector.clear();</span>

    // Iterate over image and determine number of voxels and centroid
    // per label
<span style = "background-color:#fdd">    IteratorType it(image, image-&gt;GetBufferedRegion());
    for (it.GoToBegin(); !it.IsAtEnd(); ++it)</span>
    {
<span style = "background-color:#fdd">      const IndexType &amp;index = it.GetIndex();
      auto pixel = static_cast&lt;unsigned int&gt;(it.Get());</span>

<span style = "background-color:#fdd">      if (m_VolumeVector.size() &lt;= pixel)</span>
      {
<span style = "background-color:#fdd">        m_VolumeVector.resize(pixel + 1);
        m_CentroidVector.resize(pixel + 1);</span>
      }

<span style = "background-color:#fdd">      m_VolumeVector[pixel] += 1.0;</span>

<span style = "background-color:#fdd">      m_CentroidVector[pixel][0] += index[0];
      m_CentroidVector[pixel][1] += index[1];
      m_CentroidVector[pixel][2] += index[2];
    }</span>

    // Calculate voxel volume from spacing
<span style = "background-color:#fdd">    const Vector3D &amp;spacing = geometry-&gt;GetSpacing();
    double voxelVolume = spacing[0] * spacing[1] * spacing[2];</span>

    // Calculate centroid (in world coordinates) and volumes for all labels
<span style = "background-color:#fdd">    for (unsigned int i = 0; i &lt; m_VolumeVector.size(); ++i)</span>
    {
<span style = "background-color:#fdd">      if (m_VolumeVector[i] &gt; 0.0)</span>
      {
<span style = "background-color:#fdd">        m_CentroidVector[i][0] /= m_VolumeVector[i];
        m_CentroidVector[i][1] /= m_VolumeVector[i];
        m_CentroidVector[i][2] /= m_VolumeVector[i];
        geometry-&gt;IndexToWorld(m_CentroidVector[i], m_CentroidVector[i]);</span>

<span style = "background-color:#fdd">        m_VolumeVector[i] *= voxelVolume;</span>
      }
<span style = "background-color:#fdd">    }
  }</span>
}</pre>
	</body>
</html>