<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSurfaceDeformationDataInteractor3D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkSurfaceDeformationDataInteractor3D.h"

#include "mitkMouseWheelEvent.h"

#include &lt;vtkInteractorObserver.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkPolyData.h&gt;

<span style = "background-color:#fdd">mitk::SurfaceDeformationDataInteractor3D::SurfaceDeformationDataInteractor3D() : m_GaussSigma(30.0)
{
  m_OriginalPolyData = vtkPolyData::New();</span>

  // Initialize vector arithmetic
<span style = "background-color:#fdd">  m_ObjectNormal[0] = 0.0;
  m_ObjectNormal[1] = 0.0;
  m_ObjectNormal[2] = 1.0;
}</span>

mitk::SurfaceDeformationDataInteractor3D::~SurfaceDeformationDataInteractor3D()
<span style = "background-color:#fdd">{
  m_OriginalPolyData-&gt;Delete();
}</span>

void mitk::SurfaceDeformationDataInteractor3D::ConnectActionsAndFunctions()
<span style = "background-color:#fdd">{</span>
  // **Conditions** that can be used in the state machine, to ensure that certain conditions are met, before
  // actually executing an action
<span style = "background-color:#fdd">  CONNECT_CONDITION("isOverObject", CheckOverObject);</span>

  // **Function** in the statmachine patterns also referred to as **Actions**
<span style = "background-color:#fdd">  CONNECT_FUNCTION("selectObject", SelectObject);
  CONNECT_FUNCTION("deselectObject", DeselectObject);
  CONNECT_FUNCTION("initDeformation", InitDeformation);
  CONNECT_FUNCTION("deformObject", DeformObject);
  CONNECT_FUNCTION("scaleRadius", ScaleRadius);
}</span>

void mitk::SurfaceDeformationDataInteractor3D::DataNodeChanged()
<span style = "background-color:#fdd">{
  if (this-&gt;GetDataNode() != nullptr)</span>
  {
<span style = "background-color:#fdd">    m_Surface = dynamic_cast&lt;Surface *&gt;(this-&gt;GetDataNode()-&gt;GetData());</span>

<span style = "background-color:#fdd">    if (m_Surface == nullptr)
      MITK_ERROR &lt;&lt; "SurfaceDeformationDataInteractor3D::DataNodeChanged(): DataNode has to contain a surface.";
  }</span>
  else
<span style = "background-color:#fdd">    m_Surface = nullptr;
}</span>

bool mitk::SurfaceDeformationDataInteractor3D::CheckOverObject(const InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  const auto *positionEvent = dynamic_cast&lt;const InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return false;</span>

<span style = "background-color:#fdd">  Point2D currentPickedDisplayPoint = positionEvent-&gt;GetPointerPositionOnScreen();
  Point3D currentPickedPoint;</span>

<span style = "background-color:#fdd">  if (interactionEvent-&gt;GetSender()-&gt;PickObject(currentPickedDisplayPoint, currentPickedPoint) == this-&gt;GetDataNode())</span>
  {
    // Colorized surface at current picked position
<span style = "background-color:#fdd">    m_SurfaceColorizationCenter = currentPickedPoint;
    return true;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

void mitk::SurfaceDeformationDataInteractor3D::SelectObject(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  const auto *positionEvent = dynamic_cast&lt;const InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(this-&gt;GetDataNode()-&gt;GetData());
  vtkPolyData *polyData = m_Surface-&gt;GetVtkPolyData(timeStep);</span>

<span style = "background-color:#fdd">  this-&gt;GetDataNode()-&gt;SetColor(1.0, 0.0, 0.0);</span>

  // Colorize surface / wireframe dependend on distance from picked point
<span style = "background-color:#fdd">  this-&gt;ColorizeSurface(polyData, timeStep, m_SurfaceColorizationCenter, COLORIZATION_GAUSS);</span>

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::SurfaceDeformationDataInteractor3D::DeselectObject(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  const auto *positionEvent = dynamic_cast&lt;const InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(this-&gt;GetDataNode()-&gt;GetData());
  vtkPolyData *polyData = m_Surface-&gt;GetVtkPolyData(timeStep);</span>

<span style = "background-color:#fdd">  this-&gt;GetDataNode()-&gt;SetColor(1.0, 1.0, 1.0);</span>

  // Colorize surface / wireframe as inactive
<span style = "background-color:#fdd">  this-&gt;ColorizeSurface(polyData, timeStep, m_SurfaceColorizationCenter, COLORIZATION_CONSTANT, -1.0);</span>

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::SurfaceDeformationDataInteractor3D::InitDeformation(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  const auto *positionEvent = dynamic_cast&lt;const InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(this-&gt;GetDataNode()-&gt;GetData());
  vtkPolyData *polyData = m_Surface-&gt;GetVtkPolyData(timeStep);</span>

  // Store current picked point
<span style = "background-color:#fdd">  mitk::Point2D currentPickedDisplayPoint = positionEvent-&gt;GetPointerPositionOnScreen();
  interactionEvent-&gt;GetSender()-&gt;PickObject(currentPickedDisplayPoint, m_InitialPickedPoint);</span>

<span style = "background-color:#fdd">  vtkInteractorObserver::ComputeDisplayToWorld(interactionEvent-&gt;GetSender()-&gt;GetVtkRenderer(),</span>
                                               currentPickedDisplayPoint[0],
                                               currentPickedDisplayPoint[1],
                                               0.0, // m_InitialInteractionPickedPoint[2],
                                               m_InitialPickedWorldPoint);

  // Make deep copy of vtkPolyData interacted on
<span style = "background-color:#fdd">  m_OriginalPolyData-&gt;DeepCopy(polyData);
}</span>

void mitk::SurfaceDeformationDataInteractor3D::DeformObject(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  const auto *positionEvent = dynamic_cast&lt;const InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(this-&gt;GetDataNode()-&gt;GetData());
  vtkPolyData *polyData = m_Surface-&gt;GetVtkPolyData(timeStep);
  BaseGeometry::Pointer geometry = this-&gt;GetDataNode()-&gt;GetData()-&gt;GetGeometry(timeStep);</span>

  double currentWorldPoint[4];
<span style = "background-color:#fdd">  mitk::Point2D currentDisplayPoint = positionEvent-&gt;GetPointerPositionOnScreen();
  vtkInteractorObserver::ComputeDisplayToWorld(interactionEvent-&gt;GetSender()-&gt;GetVtkRenderer(),</span>
                                               currentDisplayPoint[0],
                                               currentDisplayPoint[1],
                                               0.0, // m_InitialInteractionPickedPoint[2],
                                               currentWorldPoint);

  // Calculate mouse move in 3D space
<span style = "background-color:#fdd">  Vector3D interactionMove;
  interactionMove[0] = currentWorldPoint[0] - m_InitialPickedWorldPoint[0];
  interactionMove[1] = currentWorldPoint[1] - m_InitialPickedWorldPoint[1];
  interactionMove[2] = currentWorldPoint[2] - m_InitialPickedWorldPoint[2];</span>

  // Transform mouse move into geometry space
<span style = "background-color:#fdd">  this-&gt;GetDataNode()-&gt;GetData()-&gt;UpdateOutputInformation(); // make sure that the Geometry is up-to-date
  Vector3D interactionMoveIndex;
  geometry-&gt;WorldToIndex(interactionMove, interactionMoveIndex);</span>

  // Get picked point and transform into local coordinates
<span style = "background-color:#fdd">  Point3D pickedPoint;
  geometry-&gt;WorldToIndex(m_InitialPickedPoint, pickedPoint);</span>

<span style = "background-color:#fdd">  Vector3D v1 = pickedPoint.GetVectorFromOrigin();</span>

<span style = "background-color:#fdd">  vtkDataArray *normal = polyData-&gt;GetPointData()-&gt;GetVectors("planeNormal");
  if (normal != nullptr)</span>
  {
<span style = "background-color:#fdd">    m_ObjectNormal[0] = normal-&gt;GetComponent(0, 0);
    m_ObjectNormal[1] = normal-&gt;GetComponent(0, 1);
    m_ObjectNormal[2] = normal-&gt;GetComponent(0, 2);</span>
  }

<span style = "background-color:#fdd">  Vector3D v2 = m_ObjectNormal * (interactionMoveIndex * m_ObjectNormal);</span>

<span style = "background-color:#fdd">  vtkPoints *originalPoints = m_OriginalPolyData-&gt;GetPoints();
  vtkPoints *deformedPoints = polyData-&gt;GetPoints();</span>

<span style = "background-color:#fdd">  double denom = m_GaussSigma * m_GaussSigma * 2;</span>
  double point[3];
<span style = "background-color:#fdd">  for (vtkIdType i = 0; i &lt; deformedPoints-&gt;GetNumberOfPoints(); ++i)</span>
  {
    // Get original point
<span style = "background-color:#fdd">    double *originalPoint = originalPoints-&gt;GetPoint(i);</span>

<span style = "background-color:#fdd">    Vector3D v0;
    v0[0] = originalPoint[0];
    v0[1] = originalPoint[1];
    v0[2] = originalPoint[2];</span>

    // Calculate distance of this point from line through picked point
<span style = "background-color:#fdd">    double d = itk::CrossProduct(m_ObjectNormal, (v1 - v0)).GetNorm();</span>

<span style = "background-color:#fdd">    Vector3D t = v2 * exp(-d * d / denom);</span>

<span style = "background-color:#fdd">    point[0] = originalPoint[0] + t[0];
    point[1] = originalPoint[1] + t[1];
    point[2] = originalPoint[2] + t[2];
    deformedPoints-&gt;SetPoint(i, point);
  }</span>

  // Make sure that surface is colorized at initial picked position as long as we are in deformation state
<span style = "background-color:#fdd">  m_SurfaceColorizationCenter = m_InitialPickedPoint;</span>

<span style = "background-color:#fdd">  polyData-&gt;Modified();
  m_Surface-&gt;Modified();</span>

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::SurfaceDeformationDataInteractor3D::ScaleRadius(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  const auto *wheelEvent = dynamic_cast&lt;const MouseWheelEvent *&gt;(interactionEvent);
  if (wheelEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  m_GaussSigma += (double)(wheelEvent-&gt;GetWheelDelta()) / 20;
  if (m_GaussSigma &lt; 10.0)</span>
  {
<span style = "background-color:#fdd">    m_GaussSigma = 10.0;
  }
  else if (m_GaussSigma &gt; 128.0)</span>
  {
<span style = "background-color:#fdd">    m_GaussSigma = 128.0;</span>
  }

<span style = "background-color:#fdd">  int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(this-&gt;GetDataNode()-&gt;GetData());
  vtkPolyData *polyData = m_Surface-&gt;GetVtkPolyData(timeStep);</span>

  // Colorize surface / wireframe dependend on sigma and distance from picked point
<span style = "background-color:#fdd">  this-&gt;ColorizeSurface(polyData, timeStep, m_SurfaceColorizationCenter, COLORIZATION_GAUSS);</span>

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::SurfaceDeformationDataInteractor3D::ColorizeSurface(
  vtkPolyData *polyData, int timeStep, const Point3D &amp;pickedPoint, int mode, double scalar)
<span style = "background-color:#fdd">{
  if (polyData == nullptr)
    return;</span>

<span style = "background-color:#fdd">  vtkPoints *points = polyData-&gt;GetPoints();
  vtkPointData *pointData = polyData-&gt;GetPointData();
  if (pointData == nullptr)
    return;</span>

<span style = "background-color:#fdd">  vtkDataArray *scalars = pointData-&gt;GetScalars();
  if (scalars == nullptr)
    return;</span>

<span style = "background-color:#fdd">  if (mode == COLORIZATION_GAUSS)</span>
  {
    // Get picked point and transform into local coordinates
<span style = "background-color:#fdd">    Point3D localPickedPoint;
    BaseGeometry::Pointer geometry = this-&gt;GetDataNode()-&gt;GetData()-&gt;GetGeometry(timeStep);
    geometry-&gt;WorldToIndex(pickedPoint, localPickedPoint);</span>

<span style = "background-color:#fdd">    Vector3D v1 = localPickedPoint.GetVectorFromOrigin();</span>

<span style = "background-color:#fdd">    vtkDataArray *normal = polyData-&gt;GetPointData()-&gt;GetVectors("planeNormal");
    if (normal != nullptr)</span>
    {
<span style = "background-color:#fdd">      m_ObjectNormal[0] = normal-&gt;GetComponent(0, 0);
      m_ObjectNormal[1] = normal-&gt;GetComponent(0, 1);
      m_ObjectNormal[2] = normal-&gt;GetComponent(0, 2);</span>
    }

<span style = "background-color:#fdd">    double denom = m_GaussSigma * m_GaussSigma * 2;
    for (vtkIdType i = 0; i &lt; points-&gt;GetNumberOfPoints(); ++i)</span>
    {
      // Get original point
<span style = "background-color:#fdd">      double *point = points-&gt;GetPoint(i);
      Vector3D v0;
      v0[0] = point[0];
      v0[1] = point[1];
      v0[2] = point[2];</span>

      // Calculate distance of this point from line through picked point
<span style = "background-color:#fdd">      double d = itk::CrossProduct(m_ObjectNormal, (v1 - v0)).GetNorm();
      double t = exp(-d * d / denom);</span>

<span style = "background-color:#fdd">      scalars-&gt;SetComponent(i, 0, t);
    }
  }
  else if (mode == COLORIZATION_CONSTANT)</span>
  {
<span style = "background-color:#fdd">    for (vtkIdType i = 0; i &lt; pointData-&gt;GetNumberOfTuples(); ++i)</span>
    {
<span style = "background-color:#fdd">      scalars-&gt;SetComponent(i, 0, scalar);
    }</span>
  }
<span style = "background-color:#fdd">  polyData-&gt;Modified();
  pointData-&gt;Update();
}</span></pre>
	</body>
</html>