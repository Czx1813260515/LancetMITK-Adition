<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkVtkLayerController.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkVtkLayerController.h"

#include &lt;algorithm&gt;
#include &lt;vtkObjectFactory.h&gt;
#include &lt;vtkRenderWindow.h&gt;
#include &lt;vtkRenderer.h&gt;
#include &lt;vtkRendererCollection.h&gt;

<span style = "background-color:#dfd">mitk::VtkLayerController::vtkLayerControllerMapType mitk::VtkLayerController::s_LayerControllerMap;</span>

mitk::VtkLayerController *mitk::VtkLayerController::GetInstance(vtkSmartPointer&lt;vtkRenderWindow&gt; renWin)
<span style = "background-color:#fdd">{
  for (auto mapit = s_LayerControllerMap.begin(); mapit != s_LayerControllerMap.end(); ++mapit)</span>
  {
<span style = "background-color:#fdd">    if ((*mapit).first == renWin)
      return (*mapit).second;
  }
  return nullptr;
}</span>

void mitk::VtkLayerController::AddInstance(vtkSmartPointer&lt;vtkRenderWindow&gt; renWin,
                                           vtkSmartPointer&lt;vtkRenderer&gt; mitkSceneRenderer)
<span style = "background-color:#fdd">{</span>
  // ensure that no vtkRenderWindow is managed twice
<span style = "background-color:#fdd">  mitk::VtkLayerController::RemoveInstance(renWin);</span>

  // instanciate controller, add it to the map
<span style = "background-color:#fdd">  mitk::VtkLayerController *ControllerInstance = new mitk::VtkLayerController(renWin);
  ControllerInstance-&gt;InsertSceneRenderer(mitkSceneRenderer);</span>

<span style = "background-color:#fdd">  s_LayerControllerMap.insert(vtkLayerControllerMapType::value_type(renWin, ControllerInstance));
}</span>

void mitk::VtkLayerController::RemoveInstance(vtkSmartPointer&lt;vtkRenderWindow&gt; renWin)
<span style = "background-color:#fdd">{
  auto mapit = s_LayerControllerMap.find(renWin);
  if (mapit != s_LayerControllerMap.end())</span>
  {
<span style = "background-color:#fdd">    delete mapit-&gt;second;
    s_LayerControllerMap.erase(mapit);</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::VtkLayerController::VtkLayerController(vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow)
<span style = "background-color:#fdd">{
  m_RenderWindow = renderWindow;
  m_RenderWindow-&gt;Register(nullptr);
  m_BackgroundRenderers.clear();
  m_ForegroundRenderers.clear();
  m_SceneRenderers.clear();
}</span>

mitk::VtkLayerController::~VtkLayerController()
<span style = "background-color:#fdd">{
  if (m_RenderWindow != nullptr)</span>
  {
<span style = "background-color:#fdd">    m_RenderWindow-&gt;UnRegister(nullptr);</span>
  }
<span style = "background-color:#fdd">}</span>

/**
 * Connects a VTK renderer with a vtk renderwindow. The renderer will be rendered in the background.
 * With forceAbsoluteBackground set true a renderer can be placed at the absolute background of the scene.
 * Multiple calls with forceAbsoluteBackground set true will set the latest registered renderer as background.
 */
void mitk::VtkLayerController::InsertBackgroundRenderer(vtkSmartPointer&lt;vtkRenderer&gt; renderer,
                                                        bool forceAbsoluteBackground)
<span style = "background-color:#fdd">{
  if (renderer == nullptr)
    return;</span>

  // Remove renderer if it already exists
<span style = "background-color:#fdd">  RemoveRenderer(renderer);</span>

<span style = "background-color:#fdd">  if (forceAbsoluteBackground)</span>
  {
<span style = "background-color:#fdd">    auto it = m_BackgroundRenderers.begin();
    m_BackgroundRenderers.insert(it, renderer);
  }</span>
  else
<span style = "background-color:#fdd">    m_BackgroundRenderers.push_back(renderer);
  UpdateLayers();
}</span>
/**
 * Connects a VTK renderer with a vtk renderwindow. The renderer will be rendered in the foreground.
 * With forceAbsoluteBackground set true a renderer can be placed at the absolute foreground of the scene.
 * Multiple calls with forceAbsoluteForeground set true will set the latest registered renderer as foreground.
 */
void mitk::VtkLayerController::InsertForegroundRenderer(vtkSmartPointer&lt;vtkRenderer&gt; renderer,
                                                        bool forceAbsoluteForeground)
<span style = "background-color:#fdd">{
  if (renderer == nullptr)
    return;</span>

  // Remove renderer if it already exists
<span style = "background-color:#fdd">  RemoveRenderer(renderer);</span>

<span style = "background-color:#fdd">  if (forceAbsoluteForeground)</span>
  {
<span style = "background-color:#fdd">    auto it = m_ForegroundRenderers.begin();
    m_ForegroundRenderers.insert(it, renderer);
  }</span>
  else
<span style = "background-color:#fdd">    m_ForegroundRenderers.push_back(renderer);</span>

<span style = "background-color:#fdd">  renderer-&gt;PreserveDepthBufferOn();
  UpdateLayers();
}</span>
/**
 * Returns the Scene Renderer
 */
vtkSmartPointer&lt;vtkRenderer&gt; mitk::VtkLayerController::GetSceneRenderer()
<span style = "background-color:#fdd">{
  if (m_SceneRenderers.size() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    auto it = m_SceneRenderers.begin();
    return (*it);
  }</span>
  else
<span style = "background-color:#fdd">    return nullptr;
}</span>
/**
 * Connects a VTK renderer with a vtk renderwindow. The renderer will be rendered between background renderers and
 * foreground renderers.
 */
void mitk::VtkLayerController::InsertSceneRenderer(vtkSmartPointer&lt;vtkRenderer&gt; renderer)
<span style = "background-color:#fdd">{
  if (renderer == nullptr)
    return;</span>

  // Remove renderer if it already exists
<span style = "background-color:#fdd">  RemoveRenderer(renderer);</span>

<span style = "background-color:#fdd">  m_SceneRenderers.push_back(renderer);
  UpdateLayers();
}</span>
/**
 * A renderer which has been inserted via a insert... function can be removed from the vtkRenderWindow with
 * RemoveRenderer.
 */
void mitk::VtkLayerController::RemoveRenderer(vtkSmartPointer&lt;vtkRenderer&gt; renderer)
<span style = "background-color:#fdd">{
  RendererVectorType::iterator it;</span>
  // background layers
<span style = "background-color:#fdd">  if (m_BackgroundRenderers.size() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    it = std::find(m_BackgroundRenderers.begin(), m_BackgroundRenderers.end(), renderer);
    if (it != m_BackgroundRenderers.end())</span>
    {
<span style = "background-color:#fdd">      m_BackgroundRenderers.erase(it);
      UpdateLayers();
      return;</span>
    }
  }
  // scene layers
<span style = "background-color:#fdd">  if (m_SceneRenderers.size() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    it = std::find(m_SceneRenderers.begin(), m_SceneRenderers.end(), renderer);
    if (it != m_SceneRenderers.end())</span>
    {
<span style = "background-color:#fdd">      m_SceneRenderers.erase(it);
      UpdateLayers();
      return;</span>
    }
  }
  // foreground layers
<span style = "background-color:#fdd">  if (m_ForegroundRenderers.size() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    it = std::find(m_ForegroundRenderers.begin(), m_ForegroundRenderers.end(), renderer);
    if (it != m_ForegroundRenderers.end())</span>
    {
<span style = "background-color:#fdd">      m_ForegroundRenderers.erase(it);
      UpdateLayers();
      return;</span>
    }
  }
<span style = "background-color:#fdd">}</span>
/**
 * Connects a VtkRenderWindow with the layer controller.
 */
void mitk::VtkLayerController::SetRenderWindow(vtkSmartPointer&lt;vtkRenderWindow&gt; renwin)
<span style = "background-color:#fdd">{
  if (renwin != nullptr)</span>
  {
<span style = "background-color:#fdd">    RendererVectorType::iterator it;</span>
    // Tell all renderers that there is a new renderwindow
<span style = "background-color:#fdd">    for (it = m_BackgroundRenderers.begin(); it != m_BackgroundRenderers.end(); ++it)</span>
    {
<span style = "background-color:#fdd">      (*it)-&gt;SetRenderWindow(renwin);
    }
    for (it = m_SceneRenderers.begin(); it != m_SceneRenderers.end(); ++it)</span>
    {
<span style = "background-color:#fdd">      (*it)-&gt;SetRenderWindow(renwin);
    }
    for (it = m_ForegroundRenderers.begin(); it != m_ForegroundRenderers.end(); ++it)</span>
    {
<span style = "background-color:#fdd">      (*it)-&gt;SetRenderWindow(renwin);
    }</span>
    // Set the new RenderWindow
<span style = "background-color:#fdd">    m_RenderWindow = renwin;
  }</span>
  // Now sort renderers and add them to the renderwindow
<span style = "background-color:#fdd">  UpdateLayers();
}</span>

/**
* Returns true if a renderer has been inserted
*/
bool mitk::VtkLayerController::IsRendererInserted(vtkSmartPointer&lt;vtkRenderer&gt; renderer)
<span style = "background-color:#fdd">{
  RendererVectorType::iterator it;</span>
  // background layers
<span style = "background-color:#fdd">  if (m_BackgroundRenderers.size() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    it = std::find(m_BackgroundRenderers.begin(), m_BackgroundRenderers.end(), renderer);
    if (it != m_BackgroundRenderers.end())</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }
  }
  // scene layers
<span style = "background-color:#fdd">  if (m_SceneRenderers.size() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    it = std::find(m_SceneRenderers.begin(), m_SceneRenderers.end(), renderer);
    if (it != m_SceneRenderers.end())</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }
  }
  // foreground layers
<span style = "background-color:#fdd">  if (m_ForegroundRenderers.size() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    it = std::find(m_ForegroundRenderers.begin(), m_ForegroundRenderers.end(), renderer);
    if (it != m_ForegroundRenderers.end())</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }
  }
<span style = "background-color:#fdd">  return false;
}</span>
/**
 * Internally used to sort all registered renderers and to connect the with the vtkRenderWindow.
 * Mention that VTK Version 5 and above is rendering higher numbers in the background and VTK
 * Verison &lt; 5 in the foreground.
 */
void mitk::VtkLayerController::UpdateLayers()
<span style = "background-color:#fdd">{</span>
  // Remove all Renderers from renderwindow
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkRendererCollection&gt; v = m_RenderWindow-&gt;GetRenderers();
  v-&gt;RemoveAllItems();</span>

<span style = "background-color:#fdd">  auto numberOfLayers =</span>
    static_cast&lt;unsigned int&gt;(m_BackgroundRenderers.size() + m_SceneRenderers.size() + m_ForegroundRenderers.size());
  int currentLayerNumber;
  bool traverseUpwards;

<span style = "background-color:#fdd">  currentLayerNumber = 0;
  traverseUpwards = true;</span>

<span style = "background-color:#fdd">  m_RenderWindow-&gt;SetNumberOfLayers(numberOfLayers);
  RendererVectorType::iterator it;</span>
  // assign a layer number for the backround renderers
<span style = "background-color:#fdd">  for (it = m_BackgroundRenderers.begin(); it != m_BackgroundRenderers.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    (*it)-&gt;SetRenderWindow(m_RenderWindow);
    (*it)-&gt;SetLayer(currentLayerNumber);
    m_RenderWindow-&gt;AddRenderer((*it));</span>

<span style = "background-color:#fdd">    if (traverseUpwards)
      currentLayerNumber++;</span>
    else
<span style = "background-color:#fdd">      currentLayerNumber--;
  }</span>
  // assign a layer number for the scene renderers
<span style = "background-color:#fdd">  for (it = m_SceneRenderers.begin(); it != m_SceneRenderers.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    (*it)-&gt;SetRenderWindow(m_RenderWindow);
    (*it)-&gt;SetLayer(currentLayerNumber);
    m_RenderWindow-&gt;AddRenderer((*it));</span>

<span style = "background-color:#fdd">    if (traverseUpwards)
      currentLayerNumber++;</span>
    else
<span style = "background-color:#fdd">      currentLayerNumber--;
  }</span>
  // assign a layer number for the foreground renderers
<span style = "background-color:#fdd">  for (it = m_ForegroundRenderers.begin(); it != m_ForegroundRenderers.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    (*it)-&gt;SetRenderWindow(m_RenderWindow);
    (*it)-&gt;SetLayer(currentLayerNumber);
    m_RenderWindow-&gt;AddRenderer((*it));</span>

<span style = "background-color:#fdd">    if (traverseUpwards)
      currentLayerNumber++;</span>
    else
<span style = "background-color:#fdd">      currentLayerNumber--;
  }
}</span>
/**
 * Returns the number of renderers in the renderwindow.
 */
unsigned int mitk::VtkLayerController::GetNumberOfRenderers()
<span style = "background-color:#fdd">{
  return static_cast&lt;unsigned int&gt;(m_BackgroundRenderers.size() + m_SceneRenderers.size() +</span>
                                   m_ForegroundRenderers.size());
<span style = "background-color:#fdd">}</span>

void mitk::VtkLayerController::SetEraseForAllRenderers(int i)
<span style = "background-color:#fdd">{
  this-&gt;m_RenderWindow-&gt;SetErase(i);</span>

<span style = "background-color:#fdd">  RendererVectorType::iterator it;
  for (it = m_BackgroundRenderers.begin(); it != m_BackgroundRenderers.end(); ++it)
    (*it)-&gt;SetErase(i);</span>

<span style = "background-color:#fdd">  for (it = m_SceneRenderers.begin(); it != m_SceneRenderers.end(); ++it)
    (*it)-&gt;SetErase(i);</span>

<span style = "background-color:#fdd">  for (it = m_ForegroundRenderers.begin(); it != m_ForegroundRenderers.end(); ++it)
    (*it)-&gt;SetErase(i);
}</span></pre>
	</body>
</html>