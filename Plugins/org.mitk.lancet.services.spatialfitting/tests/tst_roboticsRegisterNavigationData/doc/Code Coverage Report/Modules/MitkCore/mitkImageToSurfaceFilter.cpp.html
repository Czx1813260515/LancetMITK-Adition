<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageToSurfaceFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkException.h"
#include &lt;mitkImageToSurfaceFilter.h&gt;
#include &lt;vtkDecimatePro.h&gt;
#include &lt;vtkImageChangeInformation.h&gt;
#include &lt;vtkImageData.h&gt;
#include &lt;vtkLinearTransform.h&gt;
#include &lt;vtkMath.h&gt;
#include &lt;vtkMatrix4x4.h&gt;
#include &lt;vtkQuadricDecimation.h&gt;

#include &lt;vtkCleanPolyData.h&gt;
#include &lt;vtkPolyDataNormals.h&gt;
#include &lt;vtkSmartPointer.h&gt;

#include "mitkProgressBar.h"

mitk::ImageToSurfaceFilter::ImageToSurfaceFilter()
<span style = "background-color:#fdd">  : m_Smooth(false),
    m_Decimate(NoDecimation),
    m_Threshold(1.0),
    m_TargetReduction(0.95f),
    m_SmoothIteration(50),
    m_SmoothRelaxation(0.1)
{
}</span>

mitk::ImageToSurfaceFilter::~ImageToSurfaceFilter()
<span style = "background-color:#fdd">{
}</span>

void mitk::ImageToSurfaceFilter::CreateSurface(int time,
                                               vtkImageData *vtkimage,
                                               mitk::Surface *surface,
                                               const ScalarType threshold)
<span style = "background-color:#fdd">{
  vtkImageChangeInformation *indexCoordinatesImageFilter = vtkImageChangeInformation::New();
  indexCoordinatesImageFilter-&gt;SetInputData(vtkimage);
  indexCoordinatesImageFilter-&gt;SetOutputOrigin(0.0, 0.0, 0.0);</span>

  // MarchingCube --&gt;create Surface
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkMarchingCubes&gt; skinExtractor = vtkSmartPointer&lt;vtkMarchingCubes&gt;::New();
  skinExtractor-&gt;ComputeScalarsOff();
  skinExtractor-&gt;SetInputConnection(indexCoordinatesImageFilter-&gt;GetOutputPort()); // RC++
  indexCoordinatesImageFilter-&gt;Delete();
  skinExtractor-&gt;SetValue(0, threshold);</span>

  vtkPolyData *polydata;
<span style = "background-color:#fdd">  skinExtractor-&gt;Update();
  polydata = skinExtractor-&gt;GetOutput();
  polydata-&gt;Register(nullptr); // RC++</span>

<span style = "background-color:#fdd">  if (m_Smooth &amp;&amp; polydata-&gt;GetNumberOfPoints() &gt; 0 &amp;&amp; polydata-&gt;GetNumberOfCells() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    vtkSmoothPolyDataFilter *smoother = vtkSmoothPolyDataFilter::New();</span>
    // read poly1 (poly1 can be the original polygon, or the decimated polygon)
<span style = "background-color:#fdd">    smoother-&gt;SetInputConnection(skinExtractor-&gt;GetOutputPort()); // RC++
    smoother-&gt;SetNumberOfIterations(m_SmoothIteration);
    smoother-&gt;SetRelaxationFactor(m_SmoothRelaxation);
    smoother-&gt;SetFeatureAngle(60);
    smoother-&gt;FeatureEdgeSmoothingOff();
    smoother-&gt;BoundarySmoothingOff();
    smoother-&gt;SetConvergence(0);
    smoother-&gt;Update();</span>

<span style = "background-color:#fdd">    polydata-&gt;Delete(); // RC--
    polydata = smoother-&gt;GetOutput();
    polydata-&gt;Register(nullptr); // RC++
    smoother-&gt;Delete();</span>
  }
<span style = "background-color:#fdd">  ProgressBar::GetInstance()-&gt;Progress();</span>

  // decimate = to reduce number of polygons
<span style = "background-color:#fdd">  if (m_Decimate == DecimatePro)</span>
  {
<span style = "background-color:#fdd">    vtkDecimatePro *decimate = vtkDecimatePro::New();
    decimate-&gt;SplittingOff();
    decimate-&gt;SetErrorIsAbsolute(5);
    decimate-&gt;SetFeatureAngle(30);
    decimate-&gt;PreserveTopologyOn();
    decimate-&gt;BoundaryVertexDeletionOff();
    decimate-&gt;SetDegree(10); // std-value is 25!</span>

<span style = "background-color:#fdd">    decimate-&gt;SetInputData(polydata); // RC++
    decimate-&gt;SetTargetReduction(m_TargetReduction);
    decimate-&gt;SetMaximumError(0.002);
    decimate-&gt;Update();</span>

<span style = "background-color:#fdd">    polydata-&gt;Delete(); // RC--
    polydata = decimate-&gt;GetOutput();
    polydata-&gt;Register(nullptr); // RC++
    decimate-&gt;Delete();
  }
  else if (m_Decimate == QuadricDecimation)</span>
  {
<span style = "background-color:#fdd">    vtkQuadricDecimation *decimate = vtkQuadricDecimation::New();
    decimate-&gt;SetTargetReduction(m_TargetReduction);</span>

<span style = "background-color:#fdd">    decimate-&gt;SetInputData(polydata);
    decimate-&gt;Update();
    polydata-&gt;Delete();
    polydata = decimate-&gt;GetOutput();
    polydata-&gt;Register(nullptr);
    decimate-&gt;Delete();</span>
  }

<span style = "background-color:#fdd">  ProgressBar::GetInstance()-&gt;Progress();</span>

<span style = "background-color:#fdd">  if (polydata-&gt;GetNumberOfPoints() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    mitk::Vector3D spacing = GetInput()-&gt;GetGeometry(time)-&gt;GetSpacing();</span>

<span style = "background-color:#fdd">    vtkPoints *points = polydata-&gt;GetPoints();
    vtkMatrix4x4 *vtkmatrix = vtkMatrix4x4::New();
    GetInput()-&gt;GetGeometry(time)-&gt;GetVtkTransform()-&gt;GetMatrix(vtkmatrix);
    double(*matrix)[4] = vtkmatrix-&gt;Element;</span>

    unsigned int i, j;
<span style = "background-color:#fdd">    for (i = 0; i &lt; 3; ++i)
      for (j = 0; j &lt; 3; ++j)
        matrix[i][j] /= spacing[j];</span>

<span style = "background-color:#fdd">    unsigned int n = points-&gt;GetNumberOfPoints();</span>
    double point[3];

<span style = "background-color:#fdd">    for (i = 0; i &lt; n; i++)</span>
    {
<span style = "background-color:#fdd">      points-&gt;GetPoint(i, point);
      mitkVtkLinearTransformPoint(matrix, point, point);
      points-&gt;SetPoint(i, point);
    }
    vtkmatrix-&gt;Delete();</span>
  }
<span style = "background-color:#fdd">  ProgressBar::GetInstance()-&gt;Progress();</span>

  // determine point_data normals for the poly data points.
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPolyDataNormals&gt; normalsGenerator = vtkSmartPointer&lt;vtkPolyDataNormals&gt;::New();
  normalsGenerator-&gt;SetInputData(polydata);
  normalsGenerator-&gt;FlipNormalsOn();</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkCleanPolyData&gt; cleanPolyDataFilter = vtkSmartPointer&lt;vtkCleanPolyData&gt;::New();
  cleanPolyDataFilter-&gt;SetInputConnection(normalsGenerator-&gt;GetOutputPort());
  cleanPolyDataFilter-&gt;PieceInvariantOff();
  cleanPolyDataFilter-&gt;ConvertLinesToPointsOff();
  cleanPolyDataFilter-&gt;ConvertPolysToLinesOff();
  cleanPolyDataFilter-&gt;ConvertStripsToPolysOff();
  cleanPolyDataFilter-&gt;PointMergingOn();
  cleanPolyDataFilter-&gt;Update();</span>

<span style = "background-color:#fdd">  surface-&gt;SetVtkPolyData(cleanPolyDataFilter-&gt;GetOutput(), time);
  polydata-&gt;UnRegister(nullptr);
}</span>

void mitk::ImageToSurfaceFilter::GenerateData()
<span style = "background-color:#fdd">{
  mitk::Surface *surface = this-&gt;GetOutput();
  auto *image = (mitk::Image *)GetInput();
  if (image == nullptr || !image-&gt;IsInitialized())
    mitkThrow() &lt;&lt; "No input image set, please set an valid input image!";</span>

<span style = "background-color:#fdd">  mitk::Image::RegionType outputRegion = image-&gt;GetRequestedRegion();</span>

<span style = "background-color:#fdd">  int tstart = outputRegion.GetIndex(3);
  int tmax = tstart + outputRegion.GetSize(3); // GetSize()==1 - will aber 0 haben, wenn nicht zeitaufgeloest</span>

<span style = "background-color:#fdd">  if ((tmax - tstart) &gt; 0)</span>
  {
<span style = "background-color:#fdd">    ProgressBar::GetInstance()-&gt;AddStepsToDo(4 * (tmax - tstart));</span>
  }

  int t;
<span style = "background-color:#fdd">  for (t = tstart; t &lt; tmax; ++t)</span>
  {
<span style = "background-color:#fdd">    vtkImageData *vtkimagedata = image-&gt;GetVtkImageData(t);
    CreateSurface(t, vtkimagedata, surface, m_Threshold);
    ProgressBar::GetInstance()-&gt;Progress();
  }
}</span>

void mitk::ImageToSurfaceFilter::SetSmoothIteration(int smoothIteration)
<span style = "background-color:#fdd">{
  m_SmoothIteration = smoothIteration;
}</span>

void mitk::ImageToSurfaceFilter::SetSmoothRelaxation(float smoothRelaxation)
<span style = "background-color:#fdd">{
  m_SmoothRelaxation = smoothRelaxation;
}</span>

void mitk::ImageToSurfaceFilter::SetInput(const mitk::Image *image)
<span style = "background-color:#fdd">{</span>
  // Process object is not const-correct so the const_cast is required here
<span style = "background-color:#fdd">  this-&gt;ProcessObject::SetNthInput(0, const_cast&lt;mitk::Image *&gt;(image));
}</span>

const mitk::Image *mitk::ImageToSurfaceFilter::GetInput(void)
<span style = "background-color:#fdd">{
  if (this-&gt;GetNumberOfInputs() &lt; 1)</span>
  {
<span style = "background-color:#fdd">    return nullptr;</span>
  }

<span style = "background-color:#fdd">  return static_cast&lt;const mitk::Image *&gt;(this-&gt;ProcessObject::GetInput(0));
}</span>

void mitk::ImageToSurfaceFilter::GenerateOutputInformation()
<span style = "background-color:#fdd">{
  mitk::Image::ConstPointer inputImage = (mitk::Image *)this-&gt;GetInput();</span>

  // mitk::Image *inputImage = (mitk::Image*)this-&gt;GetImage();
<span style = "background-color:#fdd">  mitk::Surface::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  itkDebugMacro(&lt;&lt; "GenerateOutputInformation()");</span>

<span style = "background-color:#fdd">  if (inputImage.IsNull())
    return;</span>

  // Set Data
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>