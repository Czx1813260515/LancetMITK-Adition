<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkLevelWindowManager.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkLevelWindowManager.h"

#include "mitkImage.h"
#include "mitkMessage.h"
#include "mitkNodePredicateAnd.h"
#include "mitkNodePredicateBase.h"
#include "mitkNodePredicateDataType.h"
#include "mitkNodePredicateNot.h"
#include "mitkNodePredicateOr.h"
#include "mitkNodePredicateProperty.h"
#include "mitkProperties.h"
#include "mitkRenderingModeProperty.h"
#include &lt;itkCommand.h&gt;

mitk::LevelWindowManager::LevelWindowManager()
<span style = "background-color:#fdd">  : m_DataStorage(nullptr)
  , m_LevelWindowProperty(nullptr)
  , m_AutoTopMost(true)
  , m_SelectedImagesMode(false)
  , m_CurrentImage(nullptr)
  , m_IsPropertyModifiedTagSet(false)
  , m_LevelWindowMutex(false)
{
}</span>

mitk::LevelWindowManager::~LevelWindowManager()
<span style = "background-color:#fdd">{
  if (m_DataStorage.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    m_DataStorage-&gt;AddNodeEvent.RemoveListener(</span>
      MessageDelegate1&lt;LevelWindowManager, const DataNode *&gt;(this, &amp;LevelWindowManager::DataStorageAddedNode));
<span style = "background-color:#fdd">    m_DataStorage-&gt;RemoveNodeEvent.RemoveListener(</span>
      MessageDelegate1&lt;LevelWindowManager, const DataNode *&gt;(this, &amp;LevelWindowManager::DataStorageRemovedNode));
<span style = "background-color:#fdd">    m_DataStorage = nullptr;</span>
  }

<span style = "background-color:#fdd">  if (m_IsPropertyModifiedTagSet &amp;&amp; m_LevelWindowProperty.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    m_LevelWindowProperty-&gt;RemoveObserver(m_PropertyModifiedTag);
    m_IsPropertyModifiedTagSet = false;</span>
  }

<span style = "background-color:#fdd">  this-&gt;ClearPropertyObserverMaps();
}</span>

void mitk::LevelWindowManager::SetDataStorage(DataStorage *dataStorage)
<span style = "background-color:#fdd">{
  if (nullptr == dataStorage)
    return;</span>

  // remove listeners of old DataStorage
<span style = "background-color:#fdd">  if (m_DataStorage.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    m_DataStorage-&gt;AddNodeEvent.RemoveListener(</span>
      MessageDelegate1&lt;LevelWindowManager, const DataNode *&gt;(this, &amp;LevelWindowManager::DataStorageAddedNode));
<span style = "background-color:#fdd">    m_DataStorage-&gt;RemoveNodeEvent.RemoveListener(</span>
      MessageDelegate1&lt;LevelWindowManager, const DataNode *&gt;(this, &amp;LevelWindowManager::DataStorageRemovedNode));
  }

  // register listener for new DataStorage
<span style = "background-color:#fdd">  m_DataStorage = dataStorage;
  m_DataStorage-&gt;AddNodeEvent.AddListener(</span>
    MessageDelegate1&lt;LevelWindowManager, const DataNode *&gt;(this, &amp;LevelWindowManager::DataStorageAddedNode));
<span style = "background-color:#fdd">  m_DataStorage-&gt;RemoveNodeEvent.AddListener(</span>
    MessageDelegate1&lt;LevelWindowManager, const DataNode *&gt;(this, &amp;LevelWindowManager::DataStorageRemovedNode));

<span style = "background-color:#fdd">  this-&gt;DataStorageAddedNode();
}</span>

mitk::DataStorage *mitk::LevelWindowManager::GetDataStorage()
<span style = "background-color:#fdd">{
  return m_DataStorage.GetPointer();
}</span>

void mitk::LevelWindowManager::SetAutoTopMostImage(bool autoTopMost, const DataNode *removedNode/* = nullptr*/)
<span style = "background-color:#fdd">{
  m_AutoTopMost = autoTopMost;
  if (false == m_AutoTopMost)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // deactivate other mode
<span style = "background-color:#fdd">  m_SelectedImagesMode = false;</span>

<span style = "background-color:#fdd">  if (m_IsPropertyModifiedTagSet &amp;&amp; m_LevelWindowProperty.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    m_LevelWindowProperty-&gt;RemoveObserver(m_PropertyModifiedTag);
    m_IsPropertyModifiedTagSet = false;</span>
  }

  // find topmost image in the data storage
<span style = "background-color:#fdd">  if (m_DataStorage.IsNull())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "DataStorage not set";</span>
  }

<span style = "background-color:#fdd">  DataNode::Pointer topLevelNode;
  int maxVisibleLayer = itk::NumericTraits&lt;int&gt;::min();
  m_LevelWindowProperty = nullptr;
  m_CurrentImage = nullptr;</span>

<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer all = this-&gt;GetRelevantNodes();
  for (DataStorage::SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = it-&gt;Value();
    if (node.IsNull() || node == removedNode)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

    // reset the "imageForLevelWindow" of each node
<span style = "background-color:#fdd">    m_LevelWindowMutex = true;
    node-&gt;SetBoolProperty("imageForLevelWindow", false);
    m_LevelWindowMutex = false;</span>

<span style = "background-color:#fdd">    if (false == node-&gt;IsVisible(nullptr))</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    bool validRenderingMode = HasLevelWindowRenderingMode(node);
    if (false == validRenderingMode)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    int layer = -1;
    node-&gt;GetIntProperty("layer", layer);
    if (layer &lt;= maxVisibleLayer)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    m_LevelWindowProperty = dynamic_cast&lt;LevelWindowProperty*&gt;(node-&gt;GetProperty("levelwindow"));
    topLevelNode = node;
    maxVisibleLayer = layer;
  }</span>

  // this will set the "imageForLevelWindow" property and the 'm_CurrentImage' and call 'Modified()'
<span style = "background-color:#fdd">  this-&gt;SetLevelWindowProperty(m_LevelWindowProperty);</span>

<span style = "background-color:#fdd">  if (m_LevelWindowProperty.IsNull())</span>
  {
<span style = "background-color:#fdd">    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::LevelWindowManager::SetSelectedImages(bool selectedImagesMode, const DataNode *removedNode/* = nullptr*/)
<span style = "background-color:#fdd">{
  m_SelectedImagesMode = selectedImagesMode;
  if (false == m_SelectedImagesMode)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // deactivate other mode
<span style = "background-color:#fdd">  m_AutoTopMost = false;</span>

<span style = "background-color:#fdd">  if (m_IsPropertyModifiedTagSet &amp;&amp; m_LevelWindowProperty.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    m_LevelWindowProperty-&gt;RemoveObserver(m_PropertyModifiedTag);
    m_IsPropertyModifiedTagSet = false;</span>
  }

  // find selected images in the data storage
<span style = "background-color:#fdd">  if (m_DataStorage.IsNull())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "DataStorage not set";</span>
  }

<span style = "background-color:#fdd">  m_LevelWindowProperty = nullptr;
  m_CurrentImage = nullptr;</span>

<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer all = this-&gt;GetRelevantNodes();
  for (DataStorage::SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = it-&gt;Value();
    if (node.IsNull() || node == removedNode)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

    // reset the "imageForLevelWindow" of each node
<span style = "background-color:#fdd">    m_LevelWindowMutex = true;
    node-&gt;SetBoolProperty("imageForLevelWindow", false);
    m_LevelWindowMutex = false;</span>

<span style = "background-color:#fdd">    if (false == node-&gt;IsSelected())</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    bool validRenderingMode = HasLevelWindowRenderingMode(node);
    if (false == validRenderingMode)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    m_LevelWindowProperty = dynamic_cast&lt;LevelWindowProperty*&gt;(node-&gt;GetProperty("levelwindow"));
    m_DataNodesForLevelWindow.push_back(node); // nodes are used inside "SetLevelWindow" if the level window is changed
  }</span>

  // this will set the "imageForLevelWindow" property and the 'm_CurrentImage' and call 'Modified()'
<span style = "background-color:#fdd">  this-&gt;SetLevelWindowProperty(m_LevelWindowProperty);</span>

<span style = "background-color:#fdd">  if (m_LevelWindowProperty.IsNull())</span>
  {
<span style = "background-color:#fdd">    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::LevelWindowManager::RecalculateLevelWindowForSelectedComponent(const itk::EventObject &amp;event)
<span style = "background-color:#fdd">{
  DataStorage::SetOfObjects::ConstPointer all = this-&gt;GetRelevantNodes();
  for (DataStorage::SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = it-&gt;Value();
    if (node.IsNull())
      continue;</span>

<span style = "background-color:#fdd">    bool isSelected = false;
    node-&gt;GetBoolProperty("selected", isSelected);
    if (isSelected)</span>
    {
<span style = "background-color:#fdd">      LevelWindow selectedLevelWindow;
      node-&gt;GetLevelWindow(selectedLevelWindow); // node is an image node because of predicates</span>

<span style = "background-color:#fdd">      auto *image = dynamic_cast&lt;Image *&gt;(node-&gt;GetData());
      int displayedComponent = 0;
      if (image &amp;&amp; (node-&gt;GetIntProperty("Image.Displayed Component", displayedComponent)))</span>
      { // we found a selected image with a displayed component
        // let's recalculate the levelwindow for this.
<span style = "background-color:#fdd">        selectedLevelWindow.SetAuto(image, true, true, static_cast&lt;unsigned&gt;(displayedComponent));
        node-&gt;SetLevelWindow(selectedLevelWindow);</span>
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    LevelWindow levelWindow;
    node-&gt;GetLevelWindow(levelWindow);
  }</span>

<span style = "background-color:#fdd">  this-&gt;Update(event);
}</span>

void mitk::LevelWindowManager::Update(const itk::EventObject &amp;)
<span style = "background-color:#fdd">{
  if (m_LevelWindowMutex) // no mutex, should still help</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  m_DataNodesForLevelWindow.clear();
  if (m_AutoTopMost)</span>
  {
<span style = "background-color:#fdd">    this-&gt;SetAutoTopMostImage(true);
    return;</span>
  }

<span style = "background-color:#fdd">  if (m_SelectedImagesMode)</span>
  {
<span style = "background-color:#fdd">    this-&gt;SetSelectedImages(true);
    return;</span>
  }

<span style = "background-color:#fdd">  int maxVisibleLayer = itk::NumericTraits&lt;int&gt;::min();
  DataNode::Pointer topLevelNode = nullptr;
  std::vector&lt;DataNode::Pointer&gt; nodesForLevelWindow;</span>

<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer all = this-&gt;GetRelevantNodes();
  for (DataStorage::SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = it-&gt;Value();
    if (node.IsNull())</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    if (false == node-&gt;IsVisible(nullptr))</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    bool validRenderingMode = HasLevelWindowRenderingMode(node);
    if (false == validRenderingMode)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    bool prop = false;
    node-&gt;GetBoolProperty("imageForLevelWindow", prop);
    if (prop)</span>
    {
<span style = "background-color:#fdd">      nodesForLevelWindow.push_back(node);
      continue;</span>
    }

<span style = "background-color:#fdd">    int layer = -1;
    node-&gt;GetIntProperty("layer", layer);
    if (layer &lt;= maxVisibleLayer)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

    // top level node is backup node, if no node with
    // "imageForLevelWindow" property with value "true" is found
<span style = "background-color:#fdd">    topLevelNode = node;
    maxVisibleLayer = layer;
  }</span>

<span style = "background-color:#fdd">  int nodesForLevelWindowSize = nodesForLevelWindow.size();
  if (nodesForLevelWindowSize &gt; 2)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Error: not more than two visible nodes are expected to have the imageForLevelWindow property set at "</span>
                  "any point.";
  }

<span style = "background-color:#fdd">  if (nodesForLevelWindowSize &gt; 0)</span>
  {
    // 1 or 2 nodes for level window found
<span style = "background-color:#fdd">    for (const auto&amp; node : nodesForLevelWindow)</span>
    {
<span style = "background-color:#fdd">      LevelWindowProperty::Pointer newProp = dynamic_cast&lt;LevelWindowProperty *&gt;(node-&gt;GetProperty("levelwindow"));
      if (newProp != m_LevelWindowProperty)</span>
      {
<span style = "background-color:#fdd">        this-&gt;SetLevelWindowProperty(newProp);
        return;</span>
      }
<span style = "background-color:#fdd">    }
  }
  else if (topLevelNode)</span>
  {
    // no nodes for level window found
<span style = "background-color:#fdd">    LevelWindowProperty::Pointer lvlProp = dynamic_cast&lt;LevelWindowProperty *&gt;(topLevelNode-&gt;GetProperty("levelwindow"));
    this-&gt;SetLevelWindowProperty(lvlProp);
  }</span>
  else
  {
    // no nodes for level window found and no visible top level node found
<span style = "background-color:#fdd">    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::LevelWindowManager::UpdateSelected(const itk::EventObject &amp;)
<span style = "background-color:#fdd">{
  if (m_LevelWindowMutex) // no mutex, should still help</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  m_DataNodesForLevelWindow.clear();
  if (m_SelectedImagesMode)</span>
  {
<span style = "background-color:#fdd">    this-&gt;SetSelectedImages(true);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::LevelWindowManager::SetLevelWindowProperty(LevelWindowProperty::Pointer levelWindowProperty)
<span style = "background-color:#fdd">{
  if (levelWindowProperty.IsNull())</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // find data node that belongs to the property
<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer all = m_DataStorage-&gt;GetAll();
  DataNode::Pointer propNode = nullptr;
  for (DataStorage::SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = it.Value();
    LevelWindowProperty::Pointer property = dynamic_cast&lt;LevelWindowProperty *&gt;(node-&gt;GetProperty("levelwindow"));
    if (property == levelWindowProperty)</span>
    {
<span style = "background-color:#fdd">      propNode = node;
    }</span>
    else
    {
<span style = "background-color:#fdd">      m_LevelWindowMutex = true;
      node-&gt;SetBoolProperty("imageForLevelWindow", false);
      m_LevelWindowMutex = false;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  if (propNode.IsNull())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "No Image in the data storage that belongs to level-window property " &lt;&lt; m_LevelWindowProperty;</span>
  }

<span style = "background-color:#fdd">  if (m_IsPropertyModifiedTagSet) // remove listener for old property</span>
  {
<span style = "background-color:#fdd">    m_LevelWindowProperty-&gt;RemoveObserver(m_PropertyModifiedTag);
    m_IsPropertyModifiedTagSet = false;</span>
  }

<span style = "background-color:#fdd">  m_LevelWindowProperty = levelWindowProperty;</span>

<span style = "background-color:#fdd">  auto command = itk::ReceptorMemberCommand&lt;LevelWindowManager&gt;::New(); // register listener for new property
  command-&gt;SetCallbackFunction(this, &amp;LevelWindowManager::OnPropertyModified);
  m_PropertyModifiedTag = m_LevelWindowProperty-&gt;AddObserver(itk::ModifiedEvent(), command);
  m_IsPropertyModifiedTagSet = true;</span>

<span style = "background-color:#fdd">  m_CurrentImage = dynamic_cast&lt;Image *&gt;(propNode-&gt;GetData());</span>

<span style = "background-color:#fdd">  m_LevelWindowMutex = true;
  propNode-&gt;SetBoolProperty("imageForLevelWindow", true);
  m_LevelWindowMutex = false;</span>

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span>

void mitk::LevelWindowManager::SetLevelWindow(const LevelWindow &amp;levelWindow)
<span style = "background-color:#fdd">{
  if (m_LevelWindowProperty.IsNull())</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  m_LevelWindowProperty-&gt;SetLevelWindow(levelWindow);
  for (const auto &amp;dataNode : m_DataNodesForLevelWindow)</span>
  {
<span style = "background-color:#fdd">    auto levelWindowProperty = dynamic_cast&lt;LevelWindowProperty *&gt;(dataNode-&gt;GetProperty("levelwindow"));
    if (nullptr == levelWindowProperty)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    levelWindowProperty-&gt;SetLevelWindow(levelWindow);
  }</span>

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span>

mitk::LevelWindowProperty::Pointer mitk::LevelWindowManager::GetLevelWindowProperty() const
<span style = "background-color:#fdd">{
  return m_LevelWindowProperty;
}</span>

const mitk::LevelWindow &amp;mitk::LevelWindowManager::GetLevelWindow() const
<span style = "background-color:#fdd">{
  if (m_LevelWindowProperty.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    return m_LevelWindowProperty-&gt;GetLevelWindow();
  }</span>
  else
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "No LevelWindow available!";</span>
  }
<span style = "background-color:#fdd">}</span>

bool mitk::LevelWindowManager::IsAutoTopMost() const
<span style = "background-color:#fdd">{
  return m_AutoTopMost;
}</span>

bool mitk::LevelWindowManager::IsSelectedImages() const
<span style = "background-color:#fdd">{
  return m_SelectedImagesMode;
}</span>

void mitk::LevelWindowManager::DataStorageAddedNode(const DataNode *)
<span style = "background-color:#fdd">{</span>
  // update observers with new data storage
<span style = "background-color:#fdd">  this-&gt;UpdateObservers();</span>

  // initialize LevelWindowManager to new image
<span style = "background-color:#fdd">  this-&gt;SetAutoTopMostImage(true);</span>

  // check if everything is still ok
<span style = "background-color:#fdd">  if ((m_ObserverToVisibleProperty.size() != m_ObserverToLayerProperty.size()) ||</span>
      (m_ObserverToLayerProperty.size() != this-&gt;GetRelevantNodes()-&gt;size()))
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Wrong number of observers in Level Window Manager!";</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::LevelWindowManager::DataStorageRemovedNode(const DataNode *removedNode)
<span style = "background-color:#fdd">{</span>
  // First: check if deleted node is part of relevant nodes.
  // If not, abort method because there is no need change anything.
<span style = "background-color:#fdd">  bool removedNodeIsRelevant = false;
  DataStorage::SetOfObjects::ConstPointer relevantNodes = GetRelevantNodes();
  for (DataStorage::SetOfObjects::ConstIterator it = relevantNodes-&gt;Begin(); it != relevantNodes-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    if (it-&gt;Value() == removedNode)</span>
    {
<span style = "background-color:#fdd">      removedNodeIsRelevant = true;
    }
  }</span>

<span style = "background-color:#fdd">  if (false == removedNodeIsRelevant)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // remember node which will be removed
<span style = "background-color:#fdd">  m_NodeMarkedToDelete = removedNode;</span>

  // update observers
<span style = "background-color:#fdd">  this-&gt;UpdateObservers();</span>

  // search image that belongs to the property
<span style = "background-color:#fdd">  if (m_LevelWindowProperty.IsNull())</span>
  {
<span style = "background-color:#fdd">    this-&gt;SetAutoTopMostImage(true, removedNode);
  }</span>
  else
  {
<span style = "background-color:#fdd">    auto property = NodePredicateProperty::New("levelwindow", m_LevelWindowProperty);
    DataNode *n = m_DataStorage-&gt;GetNode(property);
    if (n == nullptr || m_AutoTopMost) // if node was deleted, change our behavior to AutoTopMost, if AutoTopMost is</span>
                                       // true change level window to topmost node
    {
<span style = "background-color:#fdd">      this-&gt;SetAutoTopMostImage(true, removedNode);</span>
    }
<span style = "background-color:#fdd">  }</span>

  // reset variable
<span style = "background-color:#fdd">  m_NodeMarkedToDelete = nullptr;</span>

  // check if everything is still ok
<span style = "background-color:#fdd">  if ((m_ObserverToVisibleProperty.size() != m_ObserverToLayerProperty.size()) ||</span>
      (m_ObserverToLayerProperty.size() != (relevantNodes-&gt;size() - 1)))
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Wrong number of observers in Level Window Manager!";</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::LevelWindowManager::OnPropertyModified(const itk::EventObject &amp;)
<span style = "background-color:#fdd">{
  this-&gt;Modified();
}</span>

mitk::Image *mitk::LevelWindowManager::GetCurrentImage() const
<span style = "background-color:#fdd">{
  return m_CurrentImage;
}</span>

int mitk::LevelWindowManager::GetNumberOfObservers() const
<span style = "background-color:#fdd">{
  return m_ObserverToVisibleProperty.size();
}</span>

mitk::DataStorage::SetOfObjects::ConstPointer mitk::LevelWindowManager::GetRelevantNodes() const
<span style = "background-color:#fdd">{
  if (m_DataStorage.IsNull())</span>
  {
<span style = "background-color:#fdd">    return DataStorage::SetOfObjects::ConstPointer(DataStorage::SetOfObjects::New());</span>
  }

<span style = "background-color:#fdd">  auto notBinary = NodePredicateProperty::New("binary", BoolProperty::New(false));
  auto hasLevelWindow = NodePredicateProperty::New("levelwindow", nullptr);</span>

<span style = "background-color:#fdd">  auto isImage = NodePredicateDataType::New("Image");
  auto isDImage = NodePredicateDataType::New("DiffusionImage");
  auto isTImage = NodePredicateDataType::New("TensorImage");
  auto isOdfImage = NodePredicateDataType::New("OdfImage");
  auto isShImage = NodePredicateDataType::New("ShImage");
  auto predicateTypes = NodePredicateOr::New();
  predicateTypes-&gt;AddPredicate(isImage);
  predicateTypes-&gt;AddPredicate(isDImage);
  predicateTypes-&gt;AddPredicate(isTImage);
  predicateTypes-&gt;AddPredicate(isOdfImage);
  predicateTypes-&gt;AddPredicate(isShImage);</span>

<span style = "background-color:#fdd">  NodePredicateAnd::Pointer predicate = NodePredicateAnd::New();
  predicate-&gt;AddPredicate(notBinary);
  predicate-&gt;AddPredicate(hasLevelWindow);
  predicate-&gt;AddPredicate(predicateTypes);</span>

<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer relevantNodes = m_DataStorage-&gt;GetSubset(predicate);</span>

<span style = "background-color:#fdd">  return relevantNodes;
}</span>

void mitk::LevelWindowManager::UpdateObservers()
<span style = "background-color:#fdd">{
  this-&gt;ClearPropertyObserverMaps();
  this-&gt;CreatePropertyObserverMaps();
}</span>

void mitk::LevelWindowManager::ClearPropertyObserverMaps()
<span style = "background-color:#fdd">{
  for (auto iter = m_ObserverToVisibleProperty.begin(); iter != m_ObserverToVisibleProperty.end(); ++iter)</span>
  {
<span style = "background-color:#fdd">    (*iter).second-&gt;RemoveObserver((*iter).first.first);
    (*iter).second = nullptr;
  }
  m_ObserverToVisibleProperty.clear();</span>

<span style = "background-color:#fdd">  for (auto iter = m_ObserverToLayerProperty.begin(); iter != m_ObserverToLayerProperty.end(); ++iter)</span>
  {
<span style = "background-color:#fdd">    (*iter).second-&gt;RemoveObserver((*iter).first.first);
    (*iter).second = nullptr;
  }
  m_ObserverToLayerProperty.clear();</span>

<span style = "background-color:#fdd">  for (auto iter = m_ObserverToRenderingModeProperty.begin(); iter != m_ObserverToRenderingModeProperty.end(); ++iter)</span>
  {
<span style = "background-color:#fdd">    (*iter).second-&gt;RemoveObserver((*iter).first.first);
    (*iter).second = nullptr;
  }
  m_ObserverToRenderingModeProperty.clear();</span>

<span style = "background-color:#fdd">  for (auto iter = m_ObserverToDisplayedComponentProperty.begin(); iter != m_ObserverToDisplayedComponentProperty.end(); ++iter)</span>
  {
<span style = "background-color:#fdd">    (*iter).second-&gt;RemoveObserver((*iter).first.first);
    (*iter).second = nullptr;
  }
  m_ObserverToDisplayedComponentProperty.clear();</span>

<span style = "background-color:#fdd">  for (auto iter = m_ObserverToLevelWindowImageProperty.begin(); iter != m_ObserverToLevelWindowImageProperty.end(); ++iter)</span>
  {
<span style = "background-color:#fdd">    (*iter).second-&gt;RemoveObserver((*iter).first.first);
    (*iter).second = nullptr;
  }
  m_ObserverToLevelWindowImageProperty.clear();</span>

<span style = "background-color:#fdd">  for (auto iter = m_ObserverToSelectedProperty.begin(); iter != m_ObserverToSelectedProperty.end(); ++iter)</span>
  {
<span style = "background-color:#fdd">    (*iter).second-&gt;RemoveObserver((*iter).first.first);
    (*iter).second = nullptr;
  }
  m_ObserverToSelectedProperty.clear();
}</span>

void mitk::LevelWindowManager::CreatePropertyObserverMaps()
<span style = "background-color:#fdd">{
  if (m_DataStorage.IsNull())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "DataStorage not set";</span>
  }

  // add observers for all relevant nodes
<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer all = this-&gt;GetRelevantNodes();
  for (DataStorage::SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = it-&gt;Value();
    if (node.IsNull() || node == m_NodeMarkedToDelete)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    auto command = itk::ReceptorMemberCommand&lt;LevelWindowManager&gt;::New();
    command-&gt;SetCallbackFunction(this, &amp;LevelWindowManager::Update);
    unsigned long visIdx = node-&gt;GetProperty("visible")-&gt;AddObserver(itk::ModifiedEvent(), command);
    m_ObserverToVisibleProperty[PropDataPair(visIdx, node)] = node-&gt;GetProperty("visible");</span>

<span style = "background-color:#fdd">    auto command2 = itk::ReceptorMemberCommand&lt;LevelWindowManager&gt;::New();
    command2-&gt;SetCallbackFunction(this, &amp;LevelWindowManager::Update);
    unsigned long layerIdx = node-&gt;GetProperty("layer")-&gt;AddObserver(itk::ModifiedEvent(), command2);
    m_ObserverToLayerProperty[PropDataPair(layerIdx, node)] = node-&gt;GetProperty("layer");</span>

<span style = "background-color:#fdd">   auto command3 = itk::ReceptorMemberCommand&lt;LevelWindowManager&gt;::New();
    command3-&gt;SetCallbackFunction(this, &amp;LevelWindowManager::Update);
    BaseProperty::Pointer imageRenderingMode = node-&gt;GetProperty("Image Rendering.Mode");
    if (imageRenderingMode.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      unsigned long rendIdx = imageRenderingMode-&gt;AddObserver(itk::ModifiedEvent(), command3);
      m_ObserverToRenderingModeProperty[PropDataPair(rendIdx, node)] = imageRenderingMode.GetPointer();</span>
    }

<span style = "background-color:#fdd">    auto command4 = itk::ReceptorMemberCommand&lt;LevelWindowManager&gt;::New();
    command4-&gt;SetCallbackFunction(this, &amp;LevelWindowManager::RecalculateLevelWindowForSelectedComponent);
    BaseProperty::Pointer displayedImageComponent = node-&gt;GetProperty("Image.Displayed Component");
    if (displayedImageComponent.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      unsigned long dispIdx = displayedImageComponent-&gt;AddObserver(itk::ModifiedEvent(), command4);
      m_ObserverToDisplayedComponentProperty[PropDataPair(dispIdx, node)] = displayedImageComponent.GetPointer();</span>
    }

<span style = "background-color:#fdd">    auto command5 = itk::ReceptorMemberCommand&lt;LevelWindowManager&gt;::New();
    command5-&gt;SetCallbackFunction(this, &amp;LevelWindowManager::Update);
    BaseProperty::Pointer imgForLvlWin = node-&gt;GetProperty("imageForLevelWindow");
    if (imgForLvlWin.IsNull())</span>
    {
<span style = "background-color:#fdd">      node-&gt;SetBoolProperty("imageForLevelWindow", false);
      imgForLvlWin = node-&gt;GetProperty("imageForLevelWindow");</span>
    }
<span style = "background-color:#fdd">    unsigned long lvlWinIdx = imgForLvlWin-&gt;AddObserver(itk::ModifiedEvent(), command5);
    m_ObserverToLevelWindowImageProperty[PropDataPair(lvlWinIdx, node)] = node-&gt;GetProperty("imageForLevelWindow");</span>

<span style = "background-color:#fdd">    auto command6 = itk::ReceptorMemberCommand&lt;LevelWindowManager&gt;::New();
    command6-&gt;SetCallbackFunction(this, &amp;LevelWindowManager::UpdateSelected);
    BaseProperty::Pointer selectedDataNode = node-&gt;GetProperty("selected");
    if (selectedDataNode.IsNull())</span>
    {
<span style = "background-color:#fdd">      node-&gt;SetBoolProperty("selected", false);
      selectedDataNode = node-&gt;GetProperty("selected");</span>
    }
<span style = "background-color:#fdd">    unsigned long selectedIdx = selectedDataNode-&gt;AddObserver(itk::ModifiedEvent(), command5);
    m_ObserverToSelectedProperty[PropDataPair(selectedIdx, node)] = node-&gt;GetProperty("selected");
  }
}</span>

bool mitk::LevelWindowManager::HasLevelWindowRenderingMode(DataNode *dataNode) const
<span style = "background-color:#fdd">{
  RenderingModeProperty::Pointer mode =</span>
    dynamic_cast&lt;RenderingModeProperty*&gt;(dataNode-&gt;GetProperty("Image Rendering.Mode"));

<span style = "background-color:#fdd">  if (mode.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    int currMode = mode-&gt;GetRenderingMode();
    if (currMode == RenderingModeProperty::LOOKUPTABLE_LEVELWINDOW_COLOR ||</span>
        currMode == RenderingModeProperty::COLORTRANSFERFUNCTION_LEVELWINDOW_COLOR)
    {
<span style = "background-color:#fdd">      return true;</span>
    }
  }

<span style = "background-color:#fdd">  return false;
}</span></pre>
	</body>
</html>