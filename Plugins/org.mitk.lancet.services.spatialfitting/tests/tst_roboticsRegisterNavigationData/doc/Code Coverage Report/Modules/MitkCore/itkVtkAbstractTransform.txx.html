<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>itkVtkAbstractTransform.txx</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "itkVtkAbstractTransform.h"
#include &lt;mitkNumericTypes.h&gt;
#include &lt;vtkAbstractTransform.h&gt;

namespace itk
{
  template &lt;class TScalarType&gt;
  itk::VtkAbstractTransform&lt;TScalarType&gt;::VtkAbstractTransform()
<span style = "background-color:#fdd">    : m_VtkAbstractTransform(nullptr), m_InverseVtkAbstractTransform(nullptr), m_LastVtkAbstractTransformTimeStamp(0)
  {
  }</span>

  template &lt;class TScalarType&gt;
  itk::VtkAbstractTransform&lt;TScalarType&gt;::~VtkAbstractTransform()
<span style = "background-color:#fdd">  {
    if (m_VtkAbstractTransform != nullptr)
      m_VtkAbstractTransform-&gt;UnRegister(nullptr);
  }</span>

  template &lt;class TScalarType&gt;
  vtkAbstractTransform *itk::VtkAbstractTransform&lt;TScalarType&gt;::GetVtkAbstractTransform() const
<span style = "background-color:#fdd">  {
    return m_VtkAbstractTransform;
  }</span>

  template &lt;class TScalarType&gt;
  vtkAbstractTransform *itk::VtkAbstractTransform&lt;TScalarType&gt;::GetInverseVtkAbstractTransform() const
<span style = "background-color:#fdd">  {
    return m_InverseVtkAbstractTransform;
  }</span>

  template &lt;class TScalarType&gt;
  void itk::VtkAbstractTransform&lt;TScalarType&gt;::SetVtkAbstractTransform(vtkAbstractTransform *aVtkAbstractTransform)
<span style = "background-color:#fdd">  {
    if (m_VtkAbstractTransform == aVtkAbstractTransform)
      return;</span>

<span style = "background-color:#fdd">    if (m_VtkAbstractTransform != nullptr)
      m_VtkAbstractTransform-&gt;UnRegister(nullptr);</span>

<span style = "background-color:#fdd">    m_VtkAbstractTransform = aVtkAbstractTransform;
    if (m_VtkAbstractTransform != nullptr)</span>
    {
<span style = "background-color:#fdd">      m_VtkAbstractTransform-&gt;Register(nullptr);
      m_InverseVtkAbstractTransform = m_VtkAbstractTransform-&gt;GetInverse(); // memory managed by m_VtkAbstractTransform</span>
    }

<span style = "background-color:#fdd">    m_LastVtkAbstractTransformTimeStamp = m_VtkAbstractTransform-&gt;GetMTime();</span>

<span style = "background-color:#fdd">    this-&gt;Modified();
  }</span>

  // Transform a point
  template &lt;class TScalarType&gt;
  typename itk::VtkAbstractTransform&lt;TScalarType&gt;::OutputPointType
    itk::VtkAbstractTransform&lt;TScalarType&gt;::TransformPoint(const InputPointType &amp;point) const
<span style = "background-color:#fdd">  {
    assert(m_VtkAbstractTransform != nullptr);</span>

    OutputPointType outputpoint;
<span style = "background-color:#fdd">    vnl_vector&lt;TScalarType&gt; vnl_vec;</span>
    mitk::ScalarType vtkpt[3];
<span style = "background-color:#fdd">    mitk::itk2vtk(point, vtkpt);
    m_VtkAbstractTransform-&gt;TransformPoint(vtkpt, vtkpt);
    mitk::vtk2itk(vtkpt, outputpoint);
    return outputpoint;
  }</span>

  // Transform a vector
  template &lt;class TScalarType&gt;
  typename itk::VtkAbstractTransform&lt;TScalarType&gt;::OutputVectorType
    itk::VtkAbstractTransform&lt;TScalarType&gt;::TransformVector(const InputVectorType &amp;vect) const
<span style = "background-color:#fdd">  {
    assert(m_VtkAbstractTransform != nullptr);</span>

    OutputVectorType outputvector;
<span style = "background-color:#fdd">    vnl_vector&lt;TScalarType&gt; vnl_vec;
    mitk::ScalarType vtkpt[3] = {0, 0, 0};</span>
    mitk::ScalarType vtkvec[3];
<span style = "background-color:#fdd">    mitk::vnl2vtk&lt;TScalarType, mitk::ScalarType&gt;(vect.GetVnlVector(), vtkvec);
    m_VtkAbstractTransform-&gt;TransformVectorAtPoint(vtkpt, vtkvec, vtkvec);
    mitk::vtk2itk(vtkvec, outputvector);
    return outputvector;
  }</span>

  // Transform a vnl_vector_fixed
  template &lt;class TScalarType&gt;
  typename itk::VtkAbstractTransform&lt;TScalarType&gt;::OutputVnlVectorType
    itk::VtkAbstractTransform&lt;TScalarType&gt;::TransformVector(const InputVnlVectorType &amp;vect) const
<span style = "background-color:#fdd">  {
    assert(m_VtkAbstractTransform != nullptr);</span>

    OutputVnlVectorType outputvector;
<span style = "background-color:#fdd">    mitk::ScalarType vtkpt[3] = {0, 0, 0};</span>
    mitk::ScalarType vtkvec[3];
<span style = "background-color:#fdd">    mitk::vnl2vtk&lt;TScalarType, mitk::ScalarType&gt;(vect, vtkvec);
    m_VtkAbstractTransform-&gt;TransformVectorAtPoint(vtkpt, vtkvec, vtkvec);
    mitk::vtk2itk(vtkvec, outputvector);
    return outputvector;
  }</span>

  // Transform a CovariantVector
  template &lt;class TScalarType&gt;
  typename itk::VtkAbstractTransform&lt;TScalarType&gt;::OutputCovariantVectorType
    itk::VtkAbstractTransform&lt;TScalarType&gt;::TransformCovariantVector(const InputCovariantVectorType &amp; /*vec*/) const
<span style = "background-color:#fdd">  {
    itkExceptionMacro(&lt;&lt; "implement before using!");</span>
    OutputCovariantVectorType result; // Converted vector

    //  for (unsigned int i = 0; i &lt; NDimensions; i++)
    //    {
    //    result[i] = NumericTraits&lt;mitk::ScalarType&gt;::Zero;
    //    for (unsigned int j = 0; j &lt; NDimensions; j++)
    //      {
    //      result[i] += m_Inverse[j][i]*vec[j]; // Inverse transposed
    //      }
    //    }
<span style = "background-color:#fdd">    return result;
  }</span>

  // Back transform a point
  template &lt;class TScalarType&gt;
  typename VtkAbstractTransform&lt;TScalarType&gt;::InputPointType itk::VtkAbstractTransform&lt;TScalarType&gt;::BackTransform(
    const OutputPointType &amp;point) const
<span style = "background-color:#fdd">  {
    assert(m_VtkAbstractTransform != nullptr);</span>

    OutputPointType outputpoint;
    mitk::ScalarType vtkpt[3];
<span style = "background-color:#fdd">    mitk::itk2vtk(point, vtkpt);
    m_InverseVtkAbstractTransform-&gt;TransformPoint(vtkpt, vtkpt);
    mitk::vtk2itk(vtkpt, outputpoint);
    return outputpoint;
  }</span>

  // Back transform a vector
  template &lt;class TScalarType&gt;
  typename VtkAbstractTransform&lt;TScalarType&gt;::InputVectorType itk::VtkAbstractTransform&lt;TScalarType&gt;::BackTransform(
    const OutputVectorType &amp;vect) const
<span style = "background-color:#fdd">  {
    assert(m_VtkAbstractTransform != nullptr);</span>

    OutputVectorType outputvector;
<span style = "background-color:#fdd">    mitk::ScalarType vtkpt[3] = {0, 0, 0};</span>
    mitk::ScalarType vtkvec[3];
<span style = "background-color:#fdd">    mitk::itk2vtk(vect, vtkvec);
    m_InverseVtkAbstractTransform-&gt;TransformVectorAtPoint(vtkpt, vtkvec, vtkvec);
    mitk::vtk2itk(vtkvec, outputvector);
    return outputvector;
  }</span>

  // Back transform a vnl_vector
  template &lt;class TScalarType&gt;
  typename VtkAbstractTransform&lt;TScalarType&gt;::InputVnlVectorType itk::VtkAbstractTransform&lt;TScalarType&gt;::BackTransform(
    const OutputVnlVectorType &amp;vect) const
<span style = "background-color:#fdd">  {
    assert(m_InverseVtkAbstractTransform != nullptr);</span>

    OutputVnlVectorType outputvector;
<span style = "background-color:#fdd">    mitk::ScalarType vtkpt[3] = {0, 0, 0};</span>
    mitk::ScalarType vtkvec[3];
<span style = "background-color:#fdd">    mitk::itk2vtk(vect, vtkvec);
    m_InverseVtkAbstractTransform-&gt;TransformVectorAtPoint(vtkpt, vtkvec, vtkvec);
    mitk::vtk2itk(vtkvec, outputvector);
    return outputvector;
  }</span>

  // Back Transform a CovariantVector
  template &lt;class TScalarType&gt;
  typename VtkAbstractTransform&lt;TScalarType&gt;::InputCovariantVectorType
    itk::VtkAbstractTransform&lt;TScalarType&gt;::BackTransform(const OutputCovariantVectorType &amp;vec) const
<span style = "background-color:#fdd">  {
    itkExceptionMacro(&lt;&lt; "implement before using!");</span>
    //  for (unsigned int i = 0; i &lt; NDimensions; i++)
    //    {
    //    result[i] = NumericTraits&lt;mitk::ScalarType&gt;::Zero;
    //    for (unsigned int j = 0; j &lt; NDimensions; j++)
    //      {
    //      result[i] += m_Matrix[j][i]*vec[j]; // Direct matrix transposed
    //      }
    //    }
<span style = "background-color:#fdd">    return vec;
  }</span>

  template &lt;class TScalarType&gt;
  itk::ModifiedTimeType itk::VtkAbstractTransform&lt;TScalarType&gt;::GetMTime() const
<span style = "background-color:#fdd">  {
    if ((m_VtkAbstractTransform != nullptr) &amp;&amp;</span>
        (m_LastVtkAbstractTransformTimeStamp &lt; m_VtkAbstractTransform-&gt;GetMTime()))
    {
<span style = "background-color:#fdd">      m_LastVtkAbstractTransformTimeStamp = m_VtkAbstractTransform-&gt;GetMTime();
      this-&gt;Modified();</span>
    }

<span style = "background-color:#fdd">    return Superclass::GetMTime();
  }</span>

  template &lt;class TScalarType&gt;
  void itk::VtkAbstractTransform&lt;TScalarType&gt;::SetParameters(const ParametersType &amp;)
<span style = "background-color:#fdd">  {</span>
    // TODO
<span style = "background-color:#fdd">  }</span>

  template &lt;class TScalarType&gt;
  void itk::VtkAbstractTransform&lt;TScalarType&gt;::SetFixedParameters(const ParametersType &amp;)
<span style = "background-color:#fdd">  {</span>
    // TODO
<span style = "background-color:#fdd">  }</span>

  template &lt;class TScalarType&gt;
  void itk::VtkAbstractTransform&lt;TScalarType&gt;::ComputeJacobianWithRespectToParameters(const InputPointType &amp;,
                                                                                      JacobianType &amp;) const
<span style = "background-color:#fdd">  {</span>
    // TODO
<span style = "background-color:#fdd">  }</span>

  template &lt;class TScalarType&gt;
  void itk::VtkAbstractTransform&lt;TScalarType&gt;::ComputeJacobianWithRespectToPosition(const InputPointType &amp;,
                                                                                    JacobianPositionType &amp;) const
<span style = "background-color:#fdd">  {</span>
    // TODO
<span style = "background-color:#fdd">  }</span>

} // namespace itk</pre>
	</body>
</html>