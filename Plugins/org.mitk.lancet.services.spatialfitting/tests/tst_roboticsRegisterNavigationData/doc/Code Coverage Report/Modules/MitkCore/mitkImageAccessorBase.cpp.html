<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageAccessorBase.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkImageAccessorBase.h"
#include "mitkImage.h"

mitk::ImageAccessorBase::ThreadIDType mitk::ImageAccessorBase::CurrentThreadHandle()
<span style = "background-color:#fdd">{</span>
#ifdef ITK_USE_SPROC
  return GetCurrentThreadId();
#endif

#ifdef ITK_USE_PTHREADS
  return pthread_self();
#endif

#ifdef ITK_USE_WIN32_THREADS
<span style = "background-color:#fdd">  return GetCurrentThreadId();</span>
#endif
<span style = "background-color:#fdd">}</span>

bool mitk::ImageAccessorBase::CompareThreadHandles(mitk::ImageAccessorBase::ThreadIDType handle1,
                                                   mitk::ImageAccessorBase::ThreadIDType handle2)
<span style = "background-color:#fdd">{
  return handle1 == handle2;
}</span>

mitk::ImageAccessorBase::~ImageAccessorBase()
<span style = "background-color:#fdd">{
}</span>

mitk::ImageAccessorBase::ImageAccessorBase(ImageConstPointer image,
                                           const ImageDataItem *imageDataItem,
                                           int OptionFlags)
  : // m_Image(iP)
    //, imageDataItem(iDI)
<span style = "background-color:#fdd">    m_SubRegion(nullptr),
    m_Options(OptionFlags),
    m_CoherentMemory(false)
{
  m_Thread = CurrentThreadHandle();</span>

  // Initialize WaitLock
<span style = "background-color:#fdd">  m_WaitLock = new ImageAccessorWaitLock();
  m_WaitLock-&gt;m_WaiterCount = 0;</span>

  // Check validity of ImageAccessor

  // Is there an Image?
  /*
  if(!m_Image)
  {
    mitkThrow() &lt;&lt; "Invalid ImageAccessor: No Image was specified in constructor of ImageAccessor";
  }
  */

<span style = "background-color:#fdd">  if (image)</span>
  {
    // Make sure, that the Image is initialized properly
<span style = "background-color:#fdd">    if (image-&gt;m_Initialized == false)</span>
    {
<span style = "background-color:#fdd">      if (image-&gt;GetSource().IsNull())</span>
      {
<span style = "background-color:#fdd">        mitkThrow() &lt;&lt; "ImageAccessor: No image source is defined";</span>
      }
<span style = "background-color:#fdd">      image-&gt;m_ReadWriteLock.lock();
      if (image-&gt;GetSource()-&gt;Updating() == false)</span>
      {
<span style = "background-color:#fdd">        image-&gt;GetSource()-&gt;UpdateOutputInformation();</span>
      }
<span style = "background-color:#fdd">      image-&gt;m_ReadWriteLock.unlock();</span>
    }
  }

  // Investigate 4 cases of possible image parts/regions

  // Case 1: No ImageDataItem and no Subregion =&gt; Whole Image is accessed
<span style = "background-color:#fdd">  if (imageDataItem == nullptr &amp;&amp; m_SubRegion == nullptr)</span>
  {
<span style = "background-color:#fdd">    m_CoherentMemory = true;</span>

    // Organize first image channel
<span style = "background-color:#fdd">    image-&gt;m_ReadWriteLock.lock();
    imageDataItem = image-&gt;GetChannelData();
    image-&gt;m_ReadWriteLock.unlock();</span>

    // Set memory area
<span style = "background-color:#fdd">    m_AddressBegin = imageDataItem-&gt;m_Data;
    m_AddressEnd = (unsigned char *)m_AddressBegin + imageDataItem-&gt;m_Size;</span>
  }

  // Case 2: ImageDataItem but no Subregion
<span style = "background-color:#fdd">  if (imageDataItem &amp;&amp; m_SubRegion == nullptr)</span>
  {
<span style = "background-color:#fdd">    m_CoherentMemory = true;</span>

    // Set memory area
<span style = "background-color:#fdd">    m_AddressBegin = imageDataItem-&gt;m_Data;
    m_AddressEnd = (unsigned char *)m_AddressBegin + imageDataItem-&gt;m_Size;</span>
  }

  // Case 3: No ImageDataItem but a SubRegion
<span style = "background-color:#fdd">  if (imageDataItem == nullptr &amp;&amp; m_SubRegion)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Invalid ImageAccessor: The use of a SubRegion is not supported (yet).";</span>
  }

  // Case 4: ImageDataItem and SubRegion
<span style = "background-color:#fdd">  if (imageDataItem == nullptr &amp;&amp; m_SubRegion)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Invalid ImageAccessor: The use of a SubRegion is not supported (yet).";</span>
  }
<span style = "background-color:#fdd">}</span>

/** \brief Computes if there is an Overlap of the image part between this instantiation and another ImageAccessor object
 * \throws mitk::Exception if memory area is incoherent (not supported yet)
 */
bool mitk::ImageAccessorBase::Overlap(const ImageAccessorBase *iAB)
<span style = "background-color:#fdd">{
  if (m_CoherentMemory)</span>
  {
<span style = "background-color:#fdd">    if ((iAB-&gt;m_AddressBegin &gt;= m_AddressBegin &amp;&amp; iAB-&gt;m_AddressBegin &lt; m_AddressEnd) ||</span>
        (iAB-&gt;m_AddressEnd &gt; m_AddressBegin &amp;&amp; iAB-&gt;m_AddressEnd &lt;= m_AddressEnd))
    {
<span style = "background-color:#fdd">      return true;</span>
    }
<span style = "background-color:#fdd">    if ((m_AddressBegin &gt;= iAB-&gt;m_AddressBegin &amp;&amp; m_AddressBegin &lt; iAB-&gt;m_AddressEnd) ||</span>
        (m_AddressEnd &gt; iAB-&gt;m_AddressBegin &amp;&amp; m_AddressEnd &lt;= iAB-&gt;m_AddressEnd))
    {
<span style = "background-color:#fdd">      return true;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    GetImage()-&gt;m_ReadWriteLock.unlock();
    mitkThrow() &lt;&lt; "ImageAccessor: incoherent memory area is not supported yet";</span>
  }

<span style = "background-color:#fdd">  return false;
}</span>

/** \brief Uses the WaitLock to wait for another ImageAccessor*/
void mitk::ImageAccessorBase::WaitForReleaseOf(ImageAccessorWaitLock *wL)
<span style = "background-color:#fdd">{
  wL-&gt;m_Mutex.lock();</span>

  // Decrement
<span style = "background-color:#fdd">  wL-&gt;m_WaiterCount -= 1;</span>

  // If there are no more waiting ImageAccessors, delete the Mutex
  // (Der Letzte macht das Licht aus!)
<span style = "background-color:#fdd">  if (wL-&gt;m_WaiterCount &lt;= 0)</span>
  {
<span style = "background-color:#fdd">    wL-&gt;m_Mutex.unlock();
    delete wL;
  }</span>
  else
  {
<span style = "background-color:#fdd">    wL-&gt;m_Mutex.unlock();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ImageAccessorBase::PreventRecursiveMutexLock(mitk::ImageAccessorBase *iAB)
<span style = "background-color:#fdd">{</span>
#ifdef MITK_USE_RECURSIVE_MUTEX_PREVENTION
  // Prevent deadlock
<span style = "background-color:#fdd">  ThreadIDType id = CurrentThreadHandle();
  if (CompareThreadHandles(id, iAB-&gt;m_Thread))</span>
  {
<span style = "background-color:#fdd">    GetImage()-&gt;m_ReadWriteLock.unlock();
    mitkThrow()</span>
      &lt;&lt; "Prohibited image access: the requested image part is already in use and cannot be requested recursively!";
  }
#endif
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>