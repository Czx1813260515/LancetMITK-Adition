<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkLimitedLinearUndo.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkLimitedLinearUndo.h"
#include &lt;mitkRenderingManager.h&gt;

namespace mitk
{
<span style = "background-color:#fdd">  itkEventMacroDefinition(UndoStackEvent, itk::ModifiedEvent);
  itkEventMacroDefinition(UndoEmptyEvent, UndoStackEvent);
  itkEventMacroDefinition(RedoEmptyEvent, UndoStackEvent);
  itkEventMacroDefinition(UndoNotEmptyEvent, UndoStackEvent);
  itkEventMacroDefinition(RedoNotEmptyEvent, UndoStackEvent);
  itkEventMacroDefinition(UndoFullEvent, UndoStackEvent);
  itkEventMacroDefinition(RedoFullEvent, UndoStackEvent);</span>
}

mitk::LimitedLinearUndo::LimitedLinearUndo()
<span style = "background-color:#fdd">: m_UndoLimit(0)
{</span>
  // nothing to do
<span style = "background-color:#fdd">}</span>

mitk::LimitedLinearUndo::~LimitedLinearUndo()
<span style = "background-color:#fdd">{</span>
  // delete undo and redo list
<span style = "background-color:#fdd">  this-&gt;ClearList(&amp;m_UndoList);
  this-&gt;ClearList(&amp;m_RedoList);
}</span>

void mitk::LimitedLinearUndo::ClearList(UndoContainer *list)
<span style = "background-color:#fdd">{
  while (!list-&gt;empty())</span>
  {
<span style = "background-color:#fdd">    UndoStackItem *item = list-&gt;back();
    list-&gt;pop_back();
    delete item;
  }
}</span>

bool mitk::LimitedLinearUndo::SetOperationEvent(UndoStackItem *stackItem)
<span style = "background-color:#fdd">{
  auto *operationEvent = dynamic_cast&lt;OperationEvent *&gt;(stackItem);
  if (!operationEvent)
    return false;</span>

  // clear the redolist, if a new operation is saved
<span style = "background-color:#fdd">  if (!m_RedoList.empty())</span>
  {
<span style = "background-color:#fdd">    this-&gt;ClearList(&amp;m_RedoList);
    InvokeEvent(RedoEmptyEvent());</span>
  }

<span style = "background-color:#fdd">  if (0 != m_UndoLimit &amp;&amp; m_UndoList.size() == m_UndoLimit)</span>
  {
<span style = "background-color:#fdd">    auto item = m_UndoList.front();
    m_UndoList.pop_front();
    delete item;</span>
  }
<span style = "background-color:#fdd">  m_UndoList.push_back(operationEvent);</span>

<span style = "background-color:#fdd">  InvokeEvent(UndoNotEmptyEvent());</span>

<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::LimitedLinearUndo::Undo(bool fine)
<span style = "background-color:#fdd">{
  if (fine)</span>
  {
    // undo one object event ID
<span style = "background-color:#fdd">    return Undo();
  }</span>
  else
  {
    // undo one group event ID
<span style = "background-color:#fdd">    int oeid = FirstObjectEventIdOfCurrentGroup(</span>
      m_UndoList); // get the Object Event ID of the first item with a differnt Group ID (as seen from the end of stack)
<span style = "background-color:#fdd">    return Undo(oeid);</span>
  }
<span style = "background-color:#fdd">}</span>

bool mitk::LimitedLinearUndo::Undo()
<span style = "background-color:#fdd">{
  if (m_UndoList.empty())
    return false;</span>

<span style = "background-color:#fdd">  int undoObjectEventId = m_UndoList.back()-&gt;GetObjectEventId();
  return Undo(undoObjectEventId);
}</span>

bool mitk::LimitedLinearUndo::Undo(int oeid)
<span style = "background-color:#fdd">{
  if (m_UndoList.empty())
    return false;</span>

<span style = "background-color:#fdd">  bool rc = true;</span>
  do
  {
<span style = "background-color:#fdd">    m_UndoList.back()-&gt;ReverseAndExecute();</span>

<span style = "background-color:#fdd">    m_RedoList.push_back(m_UndoList.back()); // move to redo stack
    m_UndoList.pop_back();
    InvokeEvent(RedoNotEmptyEvent());</span>

<span style = "background-color:#fdd">    if (m_UndoList.empty())</span>
    {
<span style = "background-color:#fdd">      InvokeEvent(UndoEmptyEvent());
      rc = false;
      break;</span>
    }
<span style = "background-color:#fdd">  } while (m_UndoList.back()-&gt;GetObjectEventId() &gt;= oeid);</span>

  // Update. Check Rendering Mechanism where to request updates
<span style = "background-color:#fdd">  mitk::RenderingManager::GetInstance()-&gt;RequestUpdateAll();
  return rc;
}</span>

bool mitk::LimitedLinearUndo::Redo(bool)
<span style = "background-color:#fdd">{
  return Redo();
}</span>

bool mitk::LimitedLinearUndo::Redo()
<span style = "background-color:#fdd">{
  if (m_RedoList.empty())
    return false;</span>

<span style = "background-color:#fdd">  int redoObjectEventId = m_RedoList.back()-&gt;GetObjectEventId();
  return Redo(redoObjectEventId);
}</span>

bool mitk::LimitedLinearUndo::Redo(int oeid)
<span style = "background-color:#fdd">{
  if (m_RedoList.empty())
    return false;</span>

  do
  {
<span style = "background-color:#fdd">    m_RedoList.back()-&gt;ReverseAndExecute();</span>

<span style = "background-color:#fdd">    m_UndoList.push_back(m_RedoList.back());
    m_RedoList.pop_back();
    InvokeEvent(UndoNotEmptyEvent());</span>

<span style = "background-color:#fdd">    if (m_RedoList.empty())</span>
    {
<span style = "background-color:#fdd">      InvokeEvent(RedoEmptyEvent());
      break;</span>
    }
<span style = "background-color:#fdd">  } while (m_RedoList.back()-&gt;GetObjectEventId() &lt;= oeid);</span>

  // Update. This should belong into the ExecuteOperation() of OperationActors, but it seems not to be used everywhere
<span style = "background-color:#fdd">  mitk::RenderingManager::GetInstance()-&gt;RequestUpdateAll();
  return true;
}</span>

void mitk::LimitedLinearUndo::Clear()
<span style = "background-color:#fdd">{
  this-&gt;ClearList(&amp;m_UndoList);
  InvokeEvent(UndoEmptyEvent());</span>

<span style = "background-color:#fdd">  this-&gt;ClearList(&amp;m_RedoList);
  InvokeEvent(RedoEmptyEvent());
}</span>

void mitk::LimitedLinearUndo::ClearRedoList()
<span style = "background-color:#fdd">{
  this-&gt;ClearList(&amp;m_RedoList);
  InvokeEvent(RedoEmptyEvent());
}</span>

bool mitk::LimitedLinearUndo::RedoListEmpty()
<span style = "background-color:#fdd">{
  return m_RedoList.empty();
}</span>

std::size_t mitk::LimitedLinearUndo::GetUndoLimit() const
<span style = "background-color:#fdd">{
  return m_UndoLimit;
}</span>

void mitk::LimitedLinearUndo::SetUndoLimit(std::size_t undoLimit)
<span style = "background-color:#fdd">{
  if (undoLimit != m_UndoLimit)</span>
  {
<span style = "background-color:#fdd">    if (m_UndoList.size() &gt; undoLimit)</span>
    {
<span style = "background-color:#fdd">      m_UndoList.erase(m_UndoList.begin(), m_UndoList.end() - undoLimit);</span>
    }
<span style = "background-color:#fdd">    m_UndoLimit = undoLimit;</span>
  }
<span style = "background-color:#fdd">}</span>

int mitk::LimitedLinearUndo::GetLastObjectEventIdInList()
<span style = "background-color:#fdd">{
  return m_UndoList.back()-&gt;GetObjectEventId();
}</span>

int mitk::LimitedLinearUndo::GetLastGroupEventIdInList()
<span style = "background-color:#fdd">{
  return m_UndoList.back()-&gt;GetGroupEventId();
}</span>

mitk::OperationEvent *mitk::LimitedLinearUndo::GetLastOfType(OperationActor *destination, OperationType opType)
<span style = "background-color:#fdd">{</span>
  // When/where is this function needed? In CoordinateSupplier...
<span style = "background-color:#fdd">  for (auto iter = m_UndoList.rbegin(); iter != m_UndoList.rend(); ++iter)</span>
  {
<span style = "background-color:#fdd">    auto *opEvent = dynamic_cast&lt;OperationEvent *&gt;(*iter);
    if (!opEvent)
      continue;</span>

    if (opEvent-&gt;GetOperation() != nullptr &amp;&amp; opEvent-&gt;GetOperation()-&gt;GetOperationType() == opType &amp;&amp;
<span style = "background-color:#fdd">        opEvent-&gt;IsValid() &amp;&amp; opEvent-&gt;GetDestination() == destination)
      return opEvent;
  }</span>

<span style = "background-color:#fdd">  return nullptr;
}</span>

int mitk::LimitedLinearUndo::FirstObjectEventIdOfCurrentGroup(mitk::LimitedLinearUndo::UndoContainer &amp;stack)
<span style = "background-color:#fdd">{
  int currentGroupEventId = stack.back()-&gt;GetGroupEventId();
  int firstObjectEventId = -1;</span>

<span style = "background-color:#fdd">  for (auto iter = stack.rbegin(); iter != stack.rend(); ++iter)</span>
  {
<span style = "background-color:#fdd">    if ((*iter)-&gt;GetGroupEventId() == currentGroupEventId)</span>
    {
<span style = "background-color:#fdd">      firstObjectEventId = (*iter)-&gt;GetObjectEventId();
    }</span>
    else
<span style = "background-color:#fdd">      break;
  }</span>

<span style = "background-color:#fdd">  return firstObjectEventId;
}</span></pre>
	</body>
</html>