<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDisplayActionEventBroadcast.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkDisplayActionEventBroadcast.h"

 // us
#include "usGetModuleContext.h"
#include "usModuleContext.h"

// mitk core module
#include &lt;mitkCompositePixelValueToString.h&gt;
#include &lt;mitkDisplayActionEvents.h&gt;
#include &lt;mitkImage.h&gt;
#include &lt;mitkImagePixelReadAccessor.h&gt;
#include &lt;mitkInteractionConst.h&gt;
#include &lt;mitkInteractionPositionEvent.h&gt;
#include &lt;mitkLine.h&gt;
#include &lt;mitkNodePredicateDataType.h&gt;
#include &lt;mitkPixelTypeMultiplex.h&gt;
#include &lt;mitkRotationOperation.h&gt;
#include &lt;mitkStatusBar.h&gt;

#include &lt;rotate_cursor.xpm&gt;

mitk::DisplayActionEventBroadcast::DisplayActionEventBroadcast()
<span style = "background-color:#fdd">  : m_AlwaysReact(false)
  , m_AutoRepeat(false)
  , m_IndexToSliceModifier(4)
  , m_InvertScrollDirection(false)
  , m_InvertZoomDirection(false)
  , m_ZoomFactor(2)
  , m_InvertMoveDirection(false)
  , m_InvertLevelWindowDirection(false)
  , m_LinkPlanes(true)
{
  m_StartCoordinateInMM.Fill(0);
  m_LastDisplayCoordinate.Fill(0);
  m_LastCoordinateInMM.Fill(0);
  m_CurrentDisplayCoordinate.Fill(0);</span>

  // register the broadcast class (itself) as an interaction event observer via micro services
<span style = "background-color:#fdd">  us::ServiceProperties props;
  props["name"] = std::string("DisplayActionEventBroadcast");
  m_ServiceRegistration = us::GetModuleContext()-&gt;RegisterService&lt;InteractionEventObserver&gt;(this, props);
}</span>

mitk::DisplayActionEventBroadcast::~DisplayActionEventBroadcast()
<span style = "background-color:#fdd">{
  m_ServiceRegistration.Unregister();
}</span>

void mitk::DisplayActionEventBroadcast::Notify(InteractionEvent* interactionEvent, bool isHandled)
<span style = "background-color:#fdd">{</span>
  // the event is passed to the state machine interface to be handled
<span style = "background-color:#fdd">  if (!isHandled || m_AlwaysReact)</span>
  {
<span style = "background-color:#fdd">    HandleEvent(interactionEvent, nullptr);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::DisplayActionEventBroadcast::ConnectActionsAndFunctions()
<span style = "background-color:#fdd">{
  CONNECT_CONDITION("check_position_event", CheckPositionEvent);
  CONNECT_CONDITION("check_can_rotate", CheckRotationPossible);
  CONNECT_CONDITION("check_can_swivel", CheckSwivelPossible);</span>

<span style = "background-color:#fdd">  CONNECT_FUNCTION("init", Init);
  CONNECT_FUNCTION("move", Move);
  CONNECT_FUNCTION("zoom", Zoom);
  CONNECT_FUNCTION("scroll", Scroll);
  CONNECT_FUNCTION("ScrollOneUp", ScrollOneUp);
  CONNECT_FUNCTION("ScrollOneDown", ScrollOneDown);
  CONNECT_FUNCTION("levelWindow", AdjustLevelWindow);
  CONNECT_FUNCTION("setCrosshair", SetCrosshair);</span>

<span style = "background-color:#fdd">  CONNECT_FUNCTION("updateStatusbar", UpdateStatusbar)</span>

<span style = "background-color:#fdd">  CONNECT_FUNCTION("startRotation", StartRotation);
  CONNECT_FUNCTION("endRotation", EndRotation);
  CONNECT_FUNCTION("rotate", Rotate);</span>

<span style = "background-color:#fdd">  CONNECT_FUNCTION("swivel", Swivel);</span>

<span style = "background-color:#fdd">  CONNECT_FUNCTION("IncreaseTimeStep", IncreaseTimeStep);
  CONNECT_FUNCTION("DecreaseTimeStep", DecreaseTimeStep);
}</span>

void mitk::DisplayActionEventBroadcast::ConfigurationChanged()
<span style = "background-color:#fdd">{
  PropertyList::Pointer properties = GetAttributes();</span>

  // allwaysReact
<span style = "background-color:#fdd">  std::string strAlwaysReact = "";
  m_AlwaysReact = false;
  if (properties-&gt;GetStringProperty("alwaysReact", strAlwaysReact))</span>
  {
<span style = "background-color:#fdd">    if (strAlwaysReact == "true")</span>
    {
<span style = "background-color:#fdd">      m_AlwaysReact = true;</span>
    }
  }

  // auto repeat
<span style = "background-color:#fdd">  std::string strAutoRepeat = "";
  m_AutoRepeat = false;
  if (properties-&gt;GetStringProperty("autoRepeat", strAutoRepeat))</span>
  {
<span style = "background-color:#fdd">    if (strAutoRepeat == "true")</span>
    {
<span style = "background-color:#fdd">      m_AutoRepeat = true;</span>
    }
  }

  // pixel movement for scrolling one slice
<span style = "background-color:#fdd">  std::string strPixelPerSlice = "";
  m_IndexToSliceModifier = 4;
  if (properties-&gt;GetStringProperty("pixelPerSlice", strPixelPerSlice))</span>
  {
<span style = "background-color:#fdd">    m_IndexToSliceModifier = atoi(strPixelPerSlice.c_str());</span>
  }

  // scroll direction
<span style = "background-color:#fdd">  if (!properties-&gt;GetStringProperty("scrollDirection", m_ScrollDirection))</span>
  {
<span style = "background-color:#fdd">    m_ScrollDirection = "updown";</span>
  }

<span style = "background-color:#fdd">  m_InvertScrollDirection = GetBoolProperty(properties, "invertScrollDirection", false);</span>

  // zoom direction
<span style = "background-color:#fdd">  if (!properties-&gt;GetStringProperty("zoomDirection", m_ZoomDirection))</span>
  {
<span style = "background-color:#fdd">    m_ZoomDirection = "updown";</span>
  }

<span style = "background-color:#fdd">  m_InvertZoomDirection = GetBoolProperty(properties, "invertZoomDirection", false);
  m_InvertMoveDirection = GetBoolProperty(properties, "invertMoveDirection", false);</span>

<span style = "background-color:#fdd">  if (!properties-&gt;GetStringProperty("levelWindowDirection", m_LevelDirection))</span>
  {
<span style = "background-color:#fdd">    m_LevelDirection = "leftright";</span>
  }

<span style = "background-color:#fdd">  m_InvertLevelWindowDirection = GetBoolProperty(properties, "invertLevelWindowDirection", false);</span>

  // coupled rotation
<span style = "background-color:#fdd">  std::string strCoupled = "";
  m_LinkPlanes = false;
  if (properties-&gt;GetStringProperty("coupled", strCoupled))</span>
  {
<span style = "background-color:#fdd">    if (strCoupled == "true")</span>
    {
<span style = "background-color:#fdd">      m_LinkPlanes = true;</span>
    }
  }

  // zoom factor
<span style = "background-color:#fdd">  std::string strZoomFactor = "";
  properties-&gt;GetStringProperty("zoomFactor", strZoomFactor);
  m_ZoomFactor = .05;
  if (atoi(strZoomFactor.c_str()) &gt; 0)</span>
  {
<span style = "background-color:#fdd">    m_ZoomFactor = 1.0 + (atoi(strZoomFactor.c_str()) / 100.0);</span>
  }
<span style = "background-color:#fdd">}</span>

bool mitk::DisplayActionEventBroadcast::FilterEvents(InteractionEvent* interactionEvent, DataNode * /*dataNode*/)
<span style = "background-color:#fdd">{
  BaseRenderer* sendingRenderer = interactionEvent-&gt;GetSender();
  if (nullptr == sendingRenderer)</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  if (BaseRenderer::Standard3D == sendingRenderer-&gt;GetMapperID())</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::DisplayActionEventBroadcast::CheckPositionEvent(const InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  const auto* positionEvent = dynamic_cast&lt;const InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::DisplayActionEventBroadcast::CheckRotationPossible(const InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{</span>
  // Decide between moving and rotation slices.
  /*
  Detailed logic:

  1. Find the SliceNavigationController that has sent the event: this one defines our rendering plane and will NOT be
  rotated. Needs not even be counted or checked.
  2. Inspect every other SliceNavigationController
  - calculate the line intersection of this SliceNavigationController's plane with our rendering plane
  - if there is NO intersection, ignore and continue
  - IF there is an intersection
  - check the mouse cursor's distance from that line.
  0. if the line is NOT near the cursor, remember the plane as "one of the other planes" (which can be rotated in
  "locked" mode)
  1. on first line near the cursor,  just remember this intersection line as THE other plane that we want to rotate
  2. on every consecutive line near the cursor, check if the line is geometrically identical to the line that we want to
  rotate
  - if yes, we just push this line to the "other" lines and rotate it along
  - if no, then we have a situation where the mouse is near two other lines (e.g. crossing point) and don't want to
  rotate
  */
<span style = "background-color:#fdd">  const auto* positionEvent = dynamic_cast&lt;const InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  BaseRenderer* renderer = positionEvent-&gt;GetSender();
  if (nullptr == renderer)</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  const PlaneGeometry* rendererWorldPlaneGeometry = renderer-&gt;GetCurrentWorldPlaneGeometry();
  if (nullptr == rendererWorldPlaneGeometry)</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  Point3D position = positionEvent-&gt;GetPositionInWorld();
  const auto spacing = rendererWorldPlaneGeometry-&gt;GetSpacing();
  const PlaneGeometry *geometryToBeRotated = nullptr; // this one is under the mouse cursor
  const PlaneGeometry *anyOtherGeometry = nullptr;    // this is also visible (for calculation of intersection ONLY)
  Line3D intersectionLineWithGeometryToBeRotated;</span>

<span style = "background-color:#fdd">  bool hitMultipleLines(false);
  m_SNCsToBeRotated.clear();</span>

<span style = "background-color:#fdd">  const ScalarType threshholdDistancePixels = 12.0;</span>

<span style = "background-color:#fdd">  auto allRenderWindows = RenderingManager::GetInstance()-&gt;GetAllRegisteredRenderWindows();
  for (auto renderWindow : allRenderWindows)</span>
  {
<span style = "background-color:#fdd">    SliceNavigationController* snc = BaseRenderer::GetInstance(renderWindow)-&gt;GetSliceNavigationController();</span>

    // If the mouse cursor is in 3D Renderwindow, do not check for intersecting planes.
<span style = "background-color:#fdd">    if (BaseRenderer::Standard3D == BaseRenderer::GetInstance(renderWindow)-&gt;GetMapperID())</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    const PlaneGeometry* rendererPlaneGeometry = snc-&gt;GetCurrentPlaneGeometry();
    if (nullptr == rendererPlaneGeometry)</span>
    {
<span style = "background-color:#fdd">      continue; // ignore, we don't see a plane</span>
    }

    // check if there is an intersection between rendered / clicked geometry and the one being analyzed
<span style = "background-color:#fdd">    Line3D intersectionLine;
    if (!rendererWorldPlaneGeometry-&gt;IntersectionLine(rendererPlaneGeometry, intersectionLine))</span>
    {
<span style = "background-color:#fdd">      continue; // we ignore this plane, it's parallel to our plane</span>
    }

    // check distance from intersection line
<span style = "background-color:#fdd">    const double distanceFromIntersectionLine = intersectionLine.Distance(position) / spacing[snc-&gt;GetDefaultViewDirection()];</span>

    // far away line, only remember for linked rotation if necessary
<span style = "background-color:#fdd">    if (distanceFromIntersectionLine &gt; threshholdDistancePixels)</span>
    {
      // we just take the last one, so overwrite each iteration (we just need some crossing point)
      // TODO what about multiple crossings? NOW we have undefined behavior / random crossing point is used
<span style = "background-color:#fdd">      anyOtherGeometry = rendererPlaneGeometry;
      if (m_LinkPlanes)</span>
      {
        // if planes are linked, apply rotation to all planes
<span style = "background-color:#fdd">        m_SNCsToBeRotated.push_back(snc);</span>
      }
<span style = "background-color:#fdd">    }</span>
    else // close to cursor
    {
<span style = "background-color:#fdd">      if (nullptr == geometryToBeRotated) // first one close to the cursor</span>
      {
<span style = "background-color:#fdd">        geometryToBeRotated = rendererPlaneGeometry;
        intersectionLineWithGeometryToBeRotated = intersectionLine;
        m_SNCsToBeRotated.push_back(snc);
      }</span>
      else
      {
        // compare to the line defined by geometryToBeRotated: if identical, just rotate this otherRenderersRenderPlane
        // together with the primary one
        //                                                     if different, DON'T rotate
        if (intersectionLine.IsParallel(intersectionLineWithGeometryToBeRotated)
<span style = "background-color:#fdd">         &amp;&amp; intersectionLine.Distance(intersectionLineWithGeometryToBeRotated.GetPoint1()) &lt; eps)</span>
        {
<span style = "background-color:#fdd">          m_SNCsToBeRotated.push_back(snc);
        }</span>
        else
        {
<span style = "background-color:#fdd">          hitMultipleLines = true;</span>
        }
      }
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  bool moveSlices(true);</span>

<span style = "background-color:#fdd">  if (geometryToBeRotated &amp;&amp; anyOtherGeometry &amp;&amp; rendererWorldPlaneGeometry &amp;&amp; !hitMultipleLines)</span>
  {
    // assure all three are valid, so calculation of center of rotation can be done
<span style = "background-color:#fdd">    moveSlices = false;</span>
  }
  // question in state machine is: "rotate?"
<span style = "background-color:#fdd">  if (moveSlices) // i.e. NOT rotate</span>
  {
<span style = "background-color:#fdd">    return false;
  }</span>
  else
  {
    // we have enough information for rotation
    // remember where the last cursor position ON THE LINE has been observed
<span style = "background-color:#fdd">    m_LastCursorPosition = intersectionLineWithGeometryToBeRotated.Project(position);</span>

    // find center of rotation by intersection with any of the OTHER lines
<span style = "background-color:#fdd">    if (anyOtherGeometry-&gt;IntersectionPoint(intersectionLineWithGeometryToBeRotated, m_CenterOfRotation))</span>
    {
<span style = "background-color:#fdd">      return true;
    }</span>
    else
    {
<span style = "background-color:#fdd">      return false;</span>
    }
  }
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::DisplayActionEventBroadcast::CheckSwivelPossible(const InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{</span>
  // Decide between moving and rotation: if we're close to the crossing
  // point of the planes, moving mode is entered, otherwise
  // rotation/swivel mode
<span style = "background-color:#fdd">  const auto* positionEvent = dynamic_cast&lt;const InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  BaseRenderer* renderer = positionEvent-&gt;GetSender();
  if (nullptr == renderer)</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  const Point3D&amp; position = positionEvent-&gt;GetPositionInWorld();</span>

<span style = "background-color:#fdd">  m_SNCsToBeRotated.clear();</span>

<span style = "background-color:#fdd">  const PlaneGeometry* clickedGeometry(nullptr);
  const PlaneGeometry* otherGeometry1(nullptr);
  const PlaneGeometry* otherGeometry2(nullptr);</span>

<span style = "background-color:#fdd">  const ScalarType threshholdDistancePixels = 6.0;</span>

<span style = "background-color:#fdd">  auto allRenderWindows = RenderingManager::GetInstance()-&gt;GetAllRegisteredRenderWindows();
  for (auto renderWindow : allRenderWindows)</span>
  {
<span style = "background-color:#fdd">    SliceNavigationController* snc = BaseRenderer::GetInstance(renderWindow)-&gt;GetSliceNavigationController();</span>

    // If the mouse cursor is in 3D Renderwindow, do not check for intersecting planes.
<span style = "background-color:#fdd">    if (BaseRenderer::Standard3D == BaseRenderer::GetInstance(renderWindow)-&gt;GetMapperID())</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    const PlaneGeometry* rendererPlaneGeometry = snc-&gt;GetCurrentPlaneGeometry();
    if (nullptr == rendererPlaneGeometry)</span>
    {
<span style = "background-color:#fdd">      continue; // ignore, we don't see a plane</span>
    }

<span style = "background-color:#fdd">    if (snc == renderer-&gt;GetSliceNavigationController())</span>
    {
<span style = "background-color:#fdd">      clickedGeometry = rendererPlaneGeometry;
      m_SNCsToBeRotated.push_back(snc);
    }</span>
    else
    {
<span style = "background-color:#fdd">      if (nullptr == otherGeometry1)</span>
      {
<span style = "background-color:#fdd">        otherGeometry1 = rendererPlaneGeometry;
      }</span>
      else
      {
<span style = "background-color:#fdd">        otherGeometry2 = rendererPlaneGeometry;</span>
      }
<span style = "background-color:#fdd">      if (m_LinkPlanes)</span>
      {
        // if planes are linked, apply rotation to all planes
<span style = "background-color:#fdd">        m_SNCsToBeRotated.push_back(snc);</span>
      }
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  Line3D line;
  Point3D point;</span>
  if ((nullptr != clickedGeometry) &amp;&amp; (nullptr != otherGeometry1) &amp;&amp; (nullptr != otherGeometry2)
<span style = "background-color:#fdd">   &amp;&amp; clickedGeometry-&gt;IntersectionLine(otherGeometry1, line) &amp;&amp; otherGeometry2-&gt;IntersectionPoint(line, point))</span>
  {
<span style = "background-color:#fdd">    m_CenterOfRotation = point;
    if (m_CenterOfRotation.EuclideanDistanceTo(position) &lt; threshholdDistancePixels)</span>
    {
<span style = "background-color:#fdd">      return false;
    }</span>
    else
    {
<span style = "background-color:#fdd">      m_ReferenceCursor = positionEvent-&gt;GetPointerPositionOnScreen();</span>

      // Get main axes of rotation plane and store it for rotation step
<span style = "background-color:#fdd">      m_RotationPlaneNormal = clickedGeometry-&gt;GetNormal();</span>

<span style = "background-color:#fdd">      ScalarType xVector[] = { 1.0, 0.0, 0.0 };
      ScalarType yVector[] = { 0.0, 1.0, 0.0 };
      clickedGeometry-&gt;BaseGeometry::IndexToWorld(Vector3D(xVector), m_RotationPlaneXVector);
      clickedGeometry-&gt;BaseGeometry::IndexToWorld(Vector3D(yVector), m_RotationPlaneYVector);</span>

<span style = "background-color:#fdd">      m_RotationPlaneNormal.Normalize();
      m_RotationPlaneXVector.Normalize();
      m_RotationPlaneYVector.Normalize();</span>

<span style = "background-color:#fdd">      m_PreviousRotationAxis.Fill(0.0);
      m_PreviousRotationAxis[2] = 1.0;
      m_PreviousRotationAngle = 0.0;</span>

<span style = "background-color:#fdd">      return true;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

void mitk::DisplayActionEventBroadcast::Init(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  const auto* positionEvent = dynamic_cast&lt;InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  m_LastDisplayCoordinate = positionEvent-&gt;GetPointerPositionOnScreen();
  m_CurrentDisplayCoordinate = m_LastDisplayCoordinate;
  positionEvent-&gt;GetSender()-&gt;DisplayToPlane(m_LastDisplayCoordinate, m_StartCoordinateInMM);
  m_LastCoordinateInMM = m_StartCoordinateInMM;
}</span>

void mitk::DisplayActionEventBroadcast::Move(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  const auto* positionEvent = dynamic_cast&lt;InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  BaseRenderer* sender = interactionEvent-&gt;GetSender();
  Vector2D moveVector = m_LastDisplayCoordinate - positionEvent-&gt;GetPointerPositionOnScreen();</span>

<span style = "background-color:#fdd">  if (m_InvertMoveDirection)</span>
  {
<span style = "background-color:#fdd">    moveVector *= -1.0;</span>
  }

<span style = "background-color:#fdd">  moveVector *= sender-&gt;GetScaleFactorMMPerDisplayUnit(); // #TODO: put here?</span>

  // store new display coordinate
<span style = "background-color:#fdd">  m_LastDisplayCoordinate = positionEvent-&gt;GetPointerPositionOnScreen();</span>

  // propagate move event with computed geometry values
<span style = "background-color:#fdd">  InvokeEvent(DisplayMoveEvent(interactionEvent, moveVector));
}</span>

void mitk::DisplayActionEventBroadcast::SetCrosshair(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  const auto* positionEvent = dynamic_cast&lt;InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  Point3D position = positionEvent-&gt;GetPositionInWorld();</span>

  // propagate set crosshair event with computed geometry values
<span style = "background-color:#fdd">  InvokeEvent(DisplaySetCrosshairEvent(interactionEvent, position));
}</span>

void mitk::DisplayActionEventBroadcast::Zoom(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  const auto* positionEvent = dynamic_cast&lt;InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  float factor = 1.0;
  float distance = 0;</span>

<span style = "background-color:#fdd">  if (m_ZoomDirection == "updown")</span>
  {
<span style = "background-color:#fdd">    distance = m_CurrentDisplayCoordinate[1] - m_LastDisplayCoordinate[1];
  }</span>
  else
  {
<span style = "background-color:#fdd">    distance = m_CurrentDisplayCoordinate[0] - m_LastDisplayCoordinate[0];</span>
  }

<span style = "background-color:#fdd">  if (m_InvertZoomDirection)</span>
  {
<span style = "background-color:#fdd">    distance *= -1.0;</span>
  }

  // set zooming speed
<span style = "background-color:#fdd">  if (distance &lt; 0.0)</span>
  {
<span style = "background-color:#fdd">    factor = 1.0 / m_ZoomFactor;
  }
  else if (distance &gt; 0.0)</span>
  {
<span style = "background-color:#fdd">    factor = 1.0 * m_ZoomFactor;</span>
  }

  // store new display coordinates
<span style = "background-color:#fdd">  m_LastDisplayCoordinate = m_CurrentDisplayCoordinate;
  m_CurrentDisplayCoordinate = positionEvent-&gt;GetPointerPositionOnScreen();</span>

  // propagate zoom event with computed geometry values
<span style = "background-color:#fdd">  InvokeEvent(DisplayZoomEvent(interactionEvent, factor, m_StartCoordinateInMM));
}</span>

void mitk::DisplayActionEventBroadcast::Scroll(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  const auto* positionEvent = dynamic_cast&lt;InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  int sliceDelta = 0;</span>

  // scroll direction
<span style = "background-color:#fdd">  if (m_ScrollDirection == "updown")</span>
  {
<span style = "background-color:#fdd">    sliceDelta = static_cast&lt;int&gt;(m_CurrentDisplayCoordinate[1] - m_LastDisplayCoordinate[1]);
  }</span>
  else
  {
<span style = "background-color:#fdd">    sliceDelta = static_cast&lt;int&gt;(m_CurrentDisplayCoordinate[0] - m_LastDisplayCoordinate[0]);</span>
  }

<span style = "background-color:#fdd">  if (m_InvertScrollDirection)</span>
  {
<span style = "background-color:#fdd">    sliceDelta *= -1;</span>
  }

  // set how many pixels the mouse has to be moved to scroll one slice
  // if the mouse has been moved less than 'm_IndexToSliceModifier', pixels slice ONE slice only
<span style = "background-color:#fdd">  if (sliceDelta &gt; 0 &amp;&amp; sliceDelta &lt; m_IndexToSliceModifier)</span>
  {
<span style = "background-color:#fdd">    sliceDelta = m_IndexToSliceModifier;
  }
  else if (sliceDelta &lt; 0 &amp;&amp; sliceDelta &gt; -m_IndexToSliceModifier)</span>
  {
<span style = "background-color:#fdd">    sliceDelta = -m_IndexToSliceModifier;</span>
  }
<span style = "background-color:#fdd">  sliceDelta /= m_IndexToSliceModifier;</span>

  // store new display coordinates
<span style = "background-color:#fdd">  m_LastDisplayCoordinate = m_CurrentDisplayCoordinate;
  m_CurrentDisplayCoordinate = positionEvent-&gt;GetPointerPositionOnScreen();</span>

  // propagate scroll event with computed geometry values
<span style = "background-color:#fdd">  InvokeEvent(DisplayScrollEvent(interactionEvent, sliceDelta, m_AutoRepeat));
}</span>

void mitk::DisplayActionEventBroadcast::ScrollOneUp(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  int sliceDelta = 1;
  if (m_InvertScrollDirection)</span>
  {
<span style = "background-color:#fdd">    sliceDelta = -1;</span>
  }

  // propagate scroll event with a single slice delta (increase)
<span style = "background-color:#fdd">  InvokeEvent(DisplayScrollEvent(interactionEvent, sliceDelta, m_AutoRepeat));
}</span>

void mitk::DisplayActionEventBroadcast::ScrollOneDown(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  int sliceDelta = -1;
  if (m_InvertScrollDirection)</span>
  {
<span style = "background-color:#fdd">    sliceDelta = 1;</span>
  }

  // propagate scroll event with a single slice delta (decrease)
<span style = "background-color:#fdd">  InvokeEvent(DisplayScrollEvent(interactionEvent, sliceDelta, m_AutoRepeat));
}</span>

void mitk::DisplayActionEventBroadcast::AdjustLevelWindow(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  const auto* positionEvent = dynamic_cast&lt;InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  ScalarType level;
  ScalarType window;

<span style = "background-color:#fdd">  if (m_LevelDirection == "leftright")</span>
  {
<span style = "background-color:#fdd">    level = m_CurrentDisplayCoordinate[0] - m_LastDisplayCoordinate[0];
    window = m_CurrentDisplayCoordinate[1] - m_LastDisplayCoordinate[1];
  }</span>
  else
  {
<span style = "background-color:#fdd">    level = m_CurrentDisplayCoordinate[1] - m_LastDisplayCoordinate[1];
    window = m_CurrentDisplayCoordinate[0] - m_LastDisplayCoordinate[0];</span>
  }

<span style = "background-color:#fdd">  if (m_InvertLevelWindowDirection)</span>
  {
<span style = "background-color:#fdd">    level *= -1;
    window *= -1;</span>
  }

<span style = "background-color:#fdd">  level *= static_cast&lt;ScalarType&gt;(2);
  window *= static_cast&lt;ScalarType&gt;(2);</span>

  // store new display coordinates
<span style = "background-color:#fdd">  m_LastDisplayCoordinate = m_CurrentDisplayCoordinate;
  m_CurrentDisplayCoordinate = positionEvent-&gt;GetPointerPositionOnScreen();</span>

  // propagate set level window event with the level and window delta
<span style = "background-color:#fdd">  InvokeEvent(DisplaySetLevelWindowEvent(interactionEvent, level, window));
}</span>

void mitk::DisplayActionEventBroadcast::StartRotation(StateMachineAction* /*stateMachineAction*/, InteractionEvent* /*interactionEvent*/)
<span style = "background-color:#fdd">{
  SetMouseCursor(rotate_cursor_xpm, 0, 0);
}</span>

void mitk::DisplayActionEventBroadcast::EndRotation(StateMachineAction* /*stateMachineAction*/, InteractionEvent* /*interactionEvent*/)
<span style = "background-color:#fdd">{
  ResetMouseCursor();
}</span>

void mitk::DisplayActionEventBroadcast::Rotate(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  const auto* positionEvent = dynamic_cast&lt;InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  Point3D position = positionEvent-&gt;GetPositionInWorld();</span>

<span style = "background-color:#fdd">  Vector3D toProjected = m_LastCursorPosition - m_CenterOfRotation;
  Vector3D toCursor = position - m_CenterOfRotation;</span>

  // cross product: | A x B | = |A| * |B| * sin(angle)
<span style = "background-color:#fdd">  Vector3D axisOfRotation;
  vnl_vector_fixed&lt;ScalarType, 3&gt; vnlDirection = vnl_cross_3d(toCursor.GetVnlVector(), toProjected.GetVnlVector());
  axisOfRotation.SetVnlVector(vnlDirection.as_ref());</span>

  // scalar product: A * B = |A| * |B| * cos(angle)
  // tan = sin / cos
<span style = "background-color:#fdd">  ScalarType angle = -atan2((double)(axisOfRotation.GetNorm()), (double)(toCursor * toProjected));
  angle *= 180.0 / vnl_math::pi;
  m_LastCursorPosition = position;</span>

  // create RotationOperation and apply to all SNCs that should be rotated
<span style = "background-color:#fdd">  RotationOperation rotationOperation(OpROTATE, m_CenterOfRotation, axisOfRotation, angle);</span>

  // iterate the OTHER slice navigation controllers
<span style = "background-color:#fdd">  for (auto iter = m_SNCsToBeRotated.begin(); iter != m_SNCsToBeRotated.end(); ++iter)</span>
  {
<span style = "background-color:#fdd">    TimeGeometry* timeGeometry = (*iter)-&gt;GetCreatedWorldGeometry();
    if (nullptr == timeGeometry)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    timeGeometry-&gt;ExecuteOperation(&amp;rotationOperation);</span>

<span style = "background-color:#fdd">    (*iter)-&gt;SendCreatedWorldGeometryUpdate();
  }</span>

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::DisplayActionEventBroadcast::Swivel(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  const auto* positionEvent = dynamic_cast&lt;InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // Determine relative mouse movement projected onto world space
<span style = "background-color:#fdd">  Point2D position = positionEvent-&gt;GetPointerPositionOnScreen();</span>

<span style = "background-color:#fdd">  Vector2D relativeCursor = position - m_ReferenceCursor;
  Vector3D relativeCursorAxis = m_RotationPlaneXVector * relativeCursor[0] + m_RotationPlaneYVector * relativeCursor[1];</span>

  // Determine rotation axis (perpendicular to rotation plane and cursor movement)
<span style = "background-color:#fdd">  Vector3D rotationAxis = itk::CrossProduct(m_RotationPlaneNormal, relativeCursorAxis);</span>

<span style = "background-color:#fdd">  ScalarType rotationAngle = relativeCursor.GetNorm() / 2.0;</span>

  // Restore the initial plane pose by undoing the previous rotation operation
<span style = "background-color:#fdd">  RotationOperation op(OpROTATE, m_CenterOfRotation, m_PreviousRotationAxis, -m_PreviousRotationAngle);</span>

<span style = "background-color:#fdd">  SNCVector::iterator iter;
  for (iter = m_SNCsToBeRotated.begin(); iter != m_SNCsToBeRotated.end(); ++iter)</span>
  {
<span style = "background-color:#fdd">    if (!(*iter)-&gt;GetSliceRotationLocked())</span>
    {
<span style = "background-color:#fdd">      TimeGeometry* timeGeometry = (*iter)-&gt;GetCreatedWorldGeometry();
      if (nullptr == timeGeometry)</span>
      {
<span style = "background-color:#fdd">        continue;</span>
      }

<span style = "background-color:#fdd">      timeGeometry-&gt;ExecuteOperation(&amp;op);
      (*iter)-&gt;SendCreatedWorldGeometryUpdate();</span>
    }
<span style = "background-color:#fdd">  }</span>

  // Apply new rotation operation to all relevant SNCs
<span style = "background-color:#fdd">  RotationOperation op2(OpROTATE, m_CenterOfRotation, rotationAxis, rotationAngle);</span>

<span style = "background-color:#fdd">  for (iter = m_SNCsToBeRotated.begin(); iter != m_SNCsToBeRotated.end(); ++iter)</span>
  {
<span style = "background-color:#fdd">    if (!(*iter)-&gt;GetSliceRotationLocked())</span>
    {
      // Retrieve the TimeGeometry of this SliceNavigationController
<span style = "background-color:#fdd">      TimeGeometry *timeGeometry = (*iter)-&gt;GetCreatedWorldGeometry();
      if (nullptr == timeGeometry)</span>
      {
<span style = "background-color:#fdd">        continue;</span>
      }

      // Execute the new rotation
<span style = "background-color:#fdd">      timeGeometry-&gt;ExecuteOperation(&amp;op2);</span>

      // Notify listeners
<span style = "background-color:#fdd">      (*iter)-&gt;SendCreatedWorldGeometryUpdate();</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  m_PreviousRotationAxis = rotationAxis;
  m_PreviousRotationAngle = rotationAngle;</span>

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
  return;
}</span>

void mitk::DisplayActionEventBroadcast::IncreaseTimeStep(StateMachineAction*, InteractionEvent*)
<span style = "background-color:#fdd">{
  auto sliceNaviController = RenderingManager::GetInstance()-&gt;GetTimeNavigationController();
  auto stepper = sliceNaviController-&gt;GetTime();
  stepper-&gt;SetAutoRepeat(true);
  stepper-&gt;Next();
}</span>

void mitk::DisplayActionEventBroadcast::DecreaseTimeStep(StateMachineAction*, InteractionEvent*)
<span style = "background-color:#fdd">{
  auto sliceNaviController = RenderingManager::GetInstance()-&gt;GetTimeNavigationController();
  auto stepper = sliceNaviController-&gt;GetTime();
  stepper-&gt;SetAutoRepeat(true);
  stepper-&gt;Previous();
}</span>

void mitk::DisplayActionEventBroadcast::UpdateStatusbar(StateMachineAction* /*stateMachineAction*/, InteractionEvent* interactionEvent)
<span style = "background-color:#fdd">{
  const auto* positionEvent = dynamic_cast&lt;InteractionPositionEvent*&gt;(interactionEvent);
  if (nullptr == positionEvent)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  BaseRenderer::Pointer renderer = positionEvent-&gt;GetSender();</span>

<span style = "background-color:#fdd">  TNodePredicateDataType&lt;Image&gt;::Pointer isImageData = TNodePredicateDataType&lt;Image&gt;::New();
  DataStorage::SetOfObjects::ConstPointer nodes = renderer-&gt;GetDataStorage()-&gt;GetSubset(isImageData).GetPointer();
  if (nodes.IsNull())</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  Point3D worldposition;
  renderer-&gt;DisplayToWorld(positionEvent-&gt;GetPointerPositionOnScreen(), worldposition);
  auto globalCurrentTimePoint = renderer-&gt;GetTime();</span>

<span style = "background-color:#fdd">  Image::Pointer image3D;
  DataNode::Pointer node;
  DataNode::Pointer topSourceNode;</span>

<span style = "background-color:#fdd">  int component = 0;</span>

<span style = "background-color:#fdd">  node = FindTopmostVisibleNode(nodes, worldposition, globalCurrentTimePoint, renderer);
  if (node.IsNull())</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  bool isBinary(false);
  node-&gt;GetBoolProperty("binary", isBinary);
  if (isBinary)</span>
  {
<span style = "background-color:#fdd">    DataStorage::SetOfObjects::ConstPointer sourcenodes = renderer-&gt;GetDataStorage()-&gt;GetSources(node, nullptr, true);
    if (!sourcenodes-&gt;empty())</span>
    {
<span style = "background-color:#fdd">      topSourceNode = FindTopmostVisibleNode(nodes, worldposition, globalCurrentTimePoint, renderer);</span>
    }
<span style = "background-color:#fdd">    if (topSourceNode.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      image3D = dynamic_cast&lt;Image*&gt;(topSourceNode-&gt;GetData());
      topSourceNode-&gt;GetIntProperty("Image.Displayed Component", component);
    }</span>
    else
    {
<span style = "background-color:#fdd">      image3D = dynamic_cast&lt;Image*&gt;(node-&gt;GetData());
      node-&gt;GetIntProperty("Image.Displayed Component", component);</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    image3D = dynamic_cast&lt;Image *&gt;(node-&gt;GetData());
    node-&gt;GetIntProperty("Image.Displayed Component", component);</span>
  }

  // get the position and pixel value from the image and build up status bar text
<span style = "background-color:#fdd">  auto statusBar = StatusBar::GetInstance();
  if (image3D.IsNotNull() &amp;&amp; statusBar != nullptr)</span>
  {
    itk::Index&lt;3&gt; p;
<span style = "background-color:#fdd">    image3D-&gt;GetGeometry()-&gt;WorldToIndex(worldposition, p);</span>

<span style = "background-color:#fdd">    auto pixelType = image3D-&gt;GetChannelDescriptor().GetPixelType().GetPixelType();
    if (pixelType == itk::IOPixelEnum::RGB || pixelType == itk::IOPixelEnum::RGBA)</span>
    {
<span style = "background-color:#fdd">      std::string pixelValue = "Pixel RGB(A) value: ";
      pixelValue.append(ConvertCompositePixelValueToString(image3D, p));
      statusBar-&gt;DisplayImageInfo(worldposition, p, renderer-&gt;GetTime(), pixelValue.c_str());
    }
    else if (pixelType == itk::IOPixelEnum::DIFFUSIONTENSOR3D || pixelType == itk::IOPixelEnum::SYMMETRICSECONDRANKTENSOR)</span>
    {
<span style = "background-color:#fdd">      std::string pixelValue = "See ODF Details view. ";
      statusBar-&gt;DisplayImageInfo(worldposition, p, renderer-&gt;GetTime(), pixelValue.c_str());
    }</span>
    else
    {
      ScalarType pixelValue;
<span style = "background-color:#fdd">      mitkPixelTypeMultiplex5(</span>
        FastSinglePixelAccess,
        image3D-&gt;GetChannelDescriptor().GetPixelType(),
        image3D,
        image3D-&gt;GetVolumeData(renderer-&gt;GetTimeStep()),
        p,
        pixelValue,
        component);
<span style = "background-color:#fdd">      statusBar-&gt;DisplayImageInfo(worldposition, p, renderer-&gt;GetTime(), pixelValue);</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    statusBar-&gt;DisplayImageInfoInvalid();</span>
  }
<span style = "background-color:#fdd">}</span>

bool mitk::DisplayActionEventBroadcast::GetBoolProperty(PropertyList::Pointer propertyList, const char* propertyName, bool defaultValue)
<span style = "background-color:#fdd">{
  std::string valueAsString;
  if (!propertyList-&gt;GetStringProperty(propertyName, valueAsString))</span>
  {
<span style = "background-color:#fdd">    return defaultValue;
  }</span>
  else
  {
<span style = "background-color:#fdd">    if (valueAsString == "true")</span>
    {
<span style = "background-color:#fdd">      return true;
    }</span>
    else
    {
<span style = "background-color:#fdd">      return false;</span>
    }
  }
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>