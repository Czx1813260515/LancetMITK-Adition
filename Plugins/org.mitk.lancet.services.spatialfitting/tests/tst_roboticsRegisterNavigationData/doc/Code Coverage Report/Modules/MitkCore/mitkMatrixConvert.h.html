<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkMatrixConvert.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKMATRIXCONVERT_H_HEADER_INCLUDED_C1EBD0AD
#define MITKMATRIXCONVERT_H_HEADER_INCLUDED_C1EBD0AD

#include "mitkBaseGeometry.h"
#include "mitkItkMatrixHack.h"
#include &lt;vtkMatrix4x4.h&gt;

namespace mitk
{
  template &lt;class TTransformType&gt;
  void TransferVtkMatrixToItkTransform(const vtkMatrix4x4 *vtkmatrix, TTransformType *itkTransform)
<span style = "background-color:#fdd">  {
    if (itkTransform == nullptr)
      return;</span>

<span style = "background-color:#fdd">    typename TTransformType::MatrixType::InternalMatrixType &amp;vnlMatrix =</span>
      const_cast&lt;typename TTransformType::MatrixType::InternalMatrixType &amp;&gt;(itkTransform-&gt;GetMatrix().GetVnlMatrix());

<span style = "background-color:#fdd">    for (int i = 0; i &lt; 3; ++i)
      for (int j = 0; j &lt; 3; ++j)
        vnlMatrix[i][j] = vtkmatrix-&gt;GetElement(i, j);</span>
    // *This* ensures m_MatrixMTime.Modified(), which is therewith not equal to
    // m_InverseMatrixMTime, thus a new inverse will be calculated (when
    // requested).
<span style = "background-color:#fdd">    static_cast&lt;mitk::ItkMatrixHack&lt;TTransformType&gt; *&gt;(itkTransform)-&gt;MatrixChanged();</span>

    typename TTransformType::OffsetType offset;
<span style = "background-color:#fdd">    offset[0] = vtkmatrix-&gt;GetElement(0, 3);
    offset[1] = vtkmatrix-&gt;GetElement(1, 3);
    offset[2] = vtkmatrix-&gt;GetElement(2, 3);
    itkTransform-&gt;SetOffset(offset);
  }</span>

  template &lt;class TTransformType&gt;
  void TransferItkTransformToVtkMatrix(const TTransformType *itkTransform, vtkMatrix4x4 *vtkmatrix)
<span style = "background-color:#fdd">  {</span>
    int i, j;
<span style = "background-color:#fdd">    for (i = 0; i &lt; 3; ++i)
      for (j = 0; j &lt; 3; ++j)
        vtkmatrix-&gt;SetElement(i, j, itkTransform-&gt;GetMatrix().GetVnlMatrix().get(i, j));
    for (i = 0; i &lt; 3; ++i)
      vtkmatrix-&gt;SetElement(i, 3, itkTransform-&gt;GetOffset()[i]);
    for (i = 0; i &lt; 3; ++i)
      vtkmatrix-&gt;SetElement(3, i, 0.0);
    vtkmatrix-&gt;SetElement(3, 3, 1);
  }</span>

  template &lt;class TTransformType1, class TTransformType2&gt;
  void ConvertItkTransform(const TTransformType1 *sourceTransform, TTransformType2 *destTransform)
  {
    if ((sourceTransform == nullptr) || (destTransform == nullptr))
      return;

    destTransform-&gt;SetMatrix(sourceTransform-&gt;GetMatrix());
    destTransform-&gt;SetOffset(sourceTransform-&gt;GetOffset());
  }

  template &lt;class TMatrixType&gt;
  void GetRotation(const mitk::BaseGeometry *geometry, TMatrixType &amp;itkmatrix)
  {
    const mitk::Vector3D &amp;spacing = geometry-&gt;GetSpacing();
    auto &amp;geometryVnlMatrix = geometry-&gt;GetIndexToWorldTransform()-&gt;GetMatrix().GetVnlMatrix();

    typename TMatrixType::InternalMatrixType &amp;outputVnlMatrix =
      itkmatrix.GetVnlMatrix();

    for (int i = 0; i &lt; 3; ++i)
      for (int j = 0; j &lt; 3; ++j)
        outputVnlMatrix[i][j] = geometryVnlMatrix[i][j] / spacing[j];
  }

  template &lt;class TTransformType&gt;
  void GetWorldToItkPhysicalTransform(const mitk::BaseGeometry *geometry, TTransformType *itkTransform)
  {
    if (itkTransform == nullptr)
      return;

    // get rotation matrix and offset from Geometry and transfer in TTransformType types
    typename TTransformType::MatrixType rotationMatrix;
    GetRotation(geometry, rotationMatrix);

    const typename mitk::BaseGeometry::TransformType::OffsetType &amp;geometryOffset =
      geometry-&gt;GetIndexToWorldTransform()-&gt;GetOffset();

    vnl_vector&lt;typename TTransformType::MatrixType::ValueType&gt; vnlOffset(3);
    vnlOffset[0] = geometryOffset[0];
    vnlOffset[1] = geometryOffset[1];
    vnlOffset[2] = geometryOffset[2];

    // do calculations
    typename TTransformType::MatrixType::InternalMatrixType inverseRotationVnlMatrix = rotationMatrix.GetTranspose();

    vnlOffset -= inverseRotationVnlMatrix * vnlOffset;

    typename TTransformType::OutputVectorType offset; // vnl_vector&lt;TTransformType::MatrixType::ValueType&gt; offset;
    offset[0] = vnlOffset[0];
    offset[1] = vnlOffset[1];
    offset[2] = vnlOffset[2];
    itkTransform-&gt;SetOffset(offset);

    // copy in destination itkTransform
    typename TTransformType::MatrixType::InternalMatrixType &amp;destVnlMatrix =
      itkTransform-&gt;GetMatrix().GetVnlMatrix();

    for (int i = 0; i &lt; 3; ++i)
      for (int j = 0; j &lt; 3; ++j)
        destVnlMatrix[i][j] = inverseRotationVnlMatrix[i][j];
    // *This* ensures m_MatrixMTime.Modified(), which is therewith not equal to
    // m_InverseMatrixMTime, thus a new inverse will be calculated (when
    // requested).
    static_cast&lt;mitk::ItkMatrixHack&lt;TTransformType&gt; *&gt;(itkTransform)-&gt;MatrixChanged();
  }
}

#endif /* MITKMATRIXCONVERT_H_HEADER_INCLUDED_C1EBD0AD */</pre>
	</body>
</html>