<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlaneClipping.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKPLANECLIPPING_H_HEADER_INCLUDED
#define MITKPLANECLIPPING_H_HEADER_INCLUDED

#include &lt;mitkGeometry3D.h&gt;
#include &lt;mitkPlaneGeometry.h&gt;
#include &lt;vtkPoints.h&gt;
#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkTransform.h&gt;

namespace mitk
{
  namespace PlaneClipping
  {
    /** \brief Internal helper method for intersection testing used only in CalculateClippedPlaneBounds() */
    static bool LineIntersectZero(vtkPoints *points, int p1, int p2, double *bounds)
<span style = "background-color:#fdd">    {</span>
      double point1[3];
      double point2[3];
<span style = "background-color:#fdd">      points-&gt;GetPoint(p1, point1);
      points-&gt;GetPoint(p2, point2);</span>

<span style = "background-color:#fdd">      if ((point1[2] * point2[2] &lt;= 0.0) &amp;&amp; (point1[2] != point2[2]))</span>
      {
        double x, y;
<span style = "background-color:#fdd">        x = (point1[0] * point2[2] - point1[2] * point2[0]) / (point2[2] - point1[2]);
        y = (point1[1] * point2[2] - point1[2] * point2[1]) / (point2[2] - point1[2]);</span>

<span style = "background-color:#fdd">        if (x &lt; bounds[0])</span>
        {
<span style = "background-color:#fdd">          bounds[0] = x;</span>
        }
<span style = "background-color:#fdd">        if (x &gt; bounds[1])</span>
        {
<span style = "background-color:#fdd">          bounds[1] = x;</span>
        }
<span style = "background-color:#fdd">        if (y &lt; bounds[2])</span>
        {
<span style = "background-color:#fdd">          bounds[2] = y;</span>
        }
<span style = "background-color:#fdd">        if (y &gt; bounds[3])</span>
        {
<span style = "background-color:#fdd">          bounds[3] = y;</span>
        }
<span style = "background-color:#fdd">        bounds[4] = bounds[5] = 0.0;
        return true;</span>
      }
<span style = "background-color:#fdd">      return false;
    }</span>

    /** \brief Calculate the bounding box of the resliced image. This is necessary for
        arbitrarily rotated planes in an image volume. A rotated plane (e.g. in swivel mode)
        will have a new bounding box, which needs to be calculated. */
    static bool CalculateClippedPlaneBounds(const BaseGeometry *boundingGeometry,
                                            const PlaneGeometry *planeGeometry,
                                            double *bounds)
<span style = "background-color:#fdd">    {</span>
      // Clip the plane with the bounding geometry. To do so, the corner points
      // of the bounding box are transformed by the inverse transformation
      // matrix, and the transformed bounding box edges derived therefrom are
      // clipped with the plane z=0. The resulting min/max values are taken as
      // bounds for the image reslicer.
<span style = "background-color:#fdd">      const mitk::BoundingBox *boundingBox = boundingGeometry-&gt;GetBoundingBox();</span>

<span style = "background-color:#fdd">      mitk::BoundingBox::PointType bbMin = boundingBox-&gt;GetMinimum();
      mitk::BoundingBox::PointType bbMax = boundingBox-&gt;GetMaximum();</span>

<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkPoints&gt; points = vtkSmartPointer&lt;vtkPoints&gt;::New();
      if (boundingGeometry-&gt;GetImageGeometry())</span>
      {
<span style = "background-color:#fdd">        points-&gt;InsertPoint(0, bbMin[0] - 0.5, bbMin[1] - 0.5, bbMin[2] - 0.5);
        points-&gt;InsertPoint(1, bbMin[0] - 0.5, bbMin[1] - 0.5, bbMax[2] - 0.5);
        points-&gt;InsertPoint(2, bbMin[0] - 0.5, bbMax[1] - 0.5, bbMax[2] - 0.5);
        points-&gt;InsertPoint(3, bbMin[0] - 0.5, bbMax[1] - 0.5, bbMin[2] - 0.5);
        points-&gt;InsertPoint(4, bbMax[0] - 0.5, bbMin[1] - 0.5, bbMin[2] - 0.5);
        points-&gt;InsertPoint(5, bbMax[0] - 0.5, bbMin[1] - 0.5, bbMax[2] - 0.5);
        points-&gt;InsertPoint(6, bbMax[0] - 0.5, bbMax[1] - 0.5, bbMax[2] - 0.5);
        points-&gt;InsertPoint(7, bbMax[0] - 0.5, bbMax[1] - 0.5, bbMin[2] - 0.5);
      }</span>
      else
      {
<span style = "background-color:#fdd">        points-&gt;InsertPoint(0, bbMin[0], bbMin[1], bbMin[2]);
        points-&gt;InsertPoint(1, bbMin[0], bbMin[1], bbMax[2]);
        points-&gt;InsertPoint(2, bbMin[0], bbMax[1], bbMax[2]);
        points-&gt;InsertPoint(3, bbMin[0], bbMax[1], bbMin[2]);
        points-&gt;InsertPoint(4, bbMax[0], bbMin[1], bbMin[2]);
        points-&gt;InsertPoint(5, bbMax[0], bbMin[1], bbMax[2]);
        points-&gt;InsertPoint(6, bbMax[0], bbMax[1], bbMax[2]);
        points-&gt;InsertPoint(7, bbMax[0], bbMax[1], bbMin[2]);</span>
      }

<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkPoints&gt; newPoints = vtkSmartPointer&lt;vtkPoints&gt;::New();</span>

<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkTransform&gt; transform = vtkSmartPointer&lt;vtkTransform&gt;::New();
      transform-&gt;Identity();
      transform-&gt;Concatenate(planeGeometry-&gt;GetVtkTransform()-&gt;GetLinearInverse());</span>

<span style = "background-color:#fdd">      transform-&gt;Concatenate(boundingGeometry-&gt;GetVtkTransform());</span>

<span style = "background-color:#fdd">      transform-&gt;TransformPoints(points, newPoints);</span>

<span style = "background-color:#fdd">      bounds[0] = bounds[2] = 10000000.0;
      bounds[1] = bounds[3] = -10000000.0;
      bounds[4] = bounds[5] = 0.0;</span>

<span style = "background-color:#fdd">      LineIntersectZero(newPoints, 0, 1, bounds);
      LineIntersectZero(newPoints, 1, 2, bounds);
      LineIntersectZero(newPoints, 2, 3, bounds);
      LineIntersectZero(newPoints, 3, 0, bounds);
      LineIntersectZero(newPoints, 0, 4, bounds);
      LineIntersectZero(newPoints, 1, 5, bounds);
      LineIntersectZero(newPoints, 2, 6, bounds);
      LineIntersectZero(newPoints, 3, 7, bounds);
      LineIntersectZero(newPoints, 4, 5, bounds);
      LineIntersectZero(newPoints, 5, 6, bounds);
      LineIntersectZero(newPoints, 6, 7, bounds);
      LineIntersectZero(newPoints, 7, 4, bounds);</span>

<span style = "background-color:#fdd">      if ((bounds[0] &gt; 9999999.0) || (bounds[2] &gt; 9999999.0) || (bounds[1] &lt; -9999999.0) || (bounds[3] &lt; -9999999.0))</span>
      {
<span style = "background-color:#fdd">        return false;
      }</span>
      else
      {
        // The resulting bounds must be adjusted by the plane spacing, since we
        // we have so far dealt with index coordinates
<span style = "background-color:#fdd">        const mitk::Vector3D planeSpacing = planeGeometry-&gt;GetSpacing();
        bounds[0] *= planeSpacing[0];
        bounds[1] *= planeSpacing[0];
        bounds[2] *= planeSpacing[1];
        bounds[3] *= planeSpacing[1];
        bounds[4] *= planeSpacing[2];
        bounds[5] *= planeSpacing[2];
        return true;</span>
      }
<span style = "background-color:#fdd">    }</span>
  }
}

#endif</pre>
	</body>
</html>