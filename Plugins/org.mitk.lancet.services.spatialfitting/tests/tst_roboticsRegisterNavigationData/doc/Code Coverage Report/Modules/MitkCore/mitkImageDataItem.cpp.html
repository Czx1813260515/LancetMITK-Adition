<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageDataItem.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkImageDataItem.h"
#include "mitkMemoryUtilities.h"
#include &lt;vtkImageData.h&gt;
#include &lt;vtkPointData.h&gt;

#include &lt;vtkBitArray.h&gt;
#include &lt;vtkCharArray.h&gt;
#include &lt;vtkDoubleArray.h&gt;
#include &lt;vtkFloatArray.h&gt;
#include &lt;vtkIntArray.h&gt;
#include &lt;vtkLongArray.h&gt;
#include &lt;vtkShortArray.h&gt;
#include &lt;vtkUnsignedCharArray.h&gt;
#include &lt;vtkUnsignedIntArray.h&gt;
#include &lt;vtkUnsignedLongArray.h&gt;
#include &lt;vtkUnsignedShortArray.h&gt;

#include &lt;mitkImage.h&gt;
#include &lt;mitkImageVtkReadAccessor.h&gt;
#include &lt;mitkImageVtkWriteAccessor.h&gt;

mitk::ImageDataItem::ImageDataItem(const ImageDataItem &amp;aParent,
                                   const mitk::ImageDescriptor::Pointer desc,
                                   int timestep,
                                   unsigned int dimension,
                                   void *data,
                                   bool manageMemory,
                                   size_t offset)
<span style = "background-color:#fdd">  : m_Data(static_cast&lt;unsigned char *&gt;(aParent.m_Data) + offset),
    m_PixelType(new mitk::PixelType(aParent.GetPixelType())),
    m_ManageMemory(false),
    m_VtkImageData(nullptr),
    m_VtkImageReadAccessor(nullptr),
    m_VtkImageWriteAccessor(nullptr),
    m_Offset(offset),
    m_IsComplete(false),
    m_Size(0),
    m_Parent(&amp;aParent),
    m_Dimension(dimension),
    m_Timestep(timestep)
{</span>
  // compute size
  // const unsigned int *dims = desc-&gt;GetDimensions();
<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; dimension; i++)</span>
  {
<span style = "background-color:#fdd">    m_Dimensions[i] = desc-&gt;GetDimensions()[i];
  }
  this-&gt;ComputeItemSize(m_Dimensions, dimension);</span>

<span style = "background-color:#fdd">  if (data != nullptr &amp;&amp; data != m_Data)</span>
  {
<span style = "background-color:#fdd">    memcpy(m_Data, data, m_Size);
    if (manageMemory)</span>
    {
<span style = "background-color:#fdd">      delete[](unsigned char *) data;</span>
    }
  }

<span style = "background-color:#fdd">  m_ReferenceCount = 0;
}</span>

mitk::ImageDataItem::~ImageDataItem()
<span style = "background-color:#fdd">{
  if (m_VtkImageData != nullptr)</span>
  {
<span style = "background-color:#fdd">    m_VtkImageData-&gt;Delete();</span>
  }

<span style = "background-color:#fdd">  if (m_VtkImageReadAccessor != nullptr)</span>
  {
<span style = "background-color:#fdd">    delete m_VtkImageReadAccessor;</span>
  }
<span style = "background-color:#fdd">  if (m_VtkImageWriteAccessor != nullptr)</span>
  {
<span style = "background-color:#fdd">    delete m_VtkImageWriteAccessor;</span>
  }

<span style = "background-color:#fdd">  if (m_Parent.IsNull())</span>
  {
<span style = "background-color:#fdd">    if (m_ManageMemory)
      delete[] m_Data;</span>
  }
<span style = "background-color:#fdd">  delete m_PixelType;
}</span>

mitk::ImageDataItem::ImageDataItem(const mitk::ImageDescriptor::Pointer desc,
                                   int timestep,
                                   void *data,
                                   bool manageMemory)
<span style = "background-color:#fdd">  : m_Data(static_cast&lt;unsigned char *&gt;(data)),
    m_PixelType(new mitk::PixelType(desc-&gt;GetChannelDescriptor(0).GetPixelType())),
    m_ManageMemory(manageMemory),
    m_VtkImageData(nullptr),
    m_VtkImageReadAccessor(nullptr),
    m_VtkImageWriteAccessor(nullptr),
    m_Offset(0),
    m_IsComplete(false),
    m_Size(0),
    m_Dimension(desc-&gt;GetNumberOfDimensions()),
    m_Timestep(timestep)
{</span>
  // compute size
<span style = "background-color:#fdd">  const unsigned int *dimensions = desc-&gt;GetDimensions();
  for (unsigned int i = 0; i &lt; m_Dimension; i++)</span>
  {
<span style = "background-color:#fdd">    m_Dimensions[i] = dimensions[i];
  }</span>

<span style = "background-color:#fdd">  this-&gt;ComputeItemSize(m_Dimensions, m_Dimension);</span>

<span style = "background-color:#fdd">  if (m_Data == nullptr)</span>
  {
<span style = "background-color:#fdd">    m_Data = mitk::MemoryUtilities::AllocateElements&lt;unsigned char&gt;(m_Size);
    m_ManageMemory = true;</span>
  }

<span style = "background-color:#fdd">  m_ReferenceCount = 0;
}</span>

mitk::ImageDataItem::ImageDataItem(const mitk::PixelType &amp;type,
                                   int timestep,
                                   unsigned int dimension,
                                   unsigned int *dimensions,
                                   void *data,
                                   bool manageMemory)
<span style = "background-color:#fdd">  : m_Data(static_cast&lt;unsigned char *&gt;(data)),
    m_PixelType(new mitk::PixelType(type)),
    m_ManageMemory(manageMemory),
    m_VtkImageData(nullptr),
    m_VtkImageReadAccessor(nullptr),
    m_VtkImageWriteAccessor(nullptr),
    m_Offset(0),
    m_IsComplete(false),
    m_Size(0),
    m_Parent(nullptr),
    m_Dimension(dimension),
    m_Timestep(timestep)
{
  for (unsigned int i = 0; i &lt; m_Dimension; i++)</span>
  {
<span style = "background-color:#fdd">    m_Dimensions[i] = dimensions[i];
  }</span>

<span style = "background-color:#fdd">  this-&gt;ComputeItemSize(dimensions, dimension);</span>

<span style = "background-color:#fdd">  if (m_Data == nullptr)</span>
  {
<span style = "background-color:#fdd">    m_Data = mitk::MemoryUtilities::AllocateElements&lt;unsigned char&gt;(m_Size);
    m_ManageMemory = true;</span>
  }

<span style = "background-color:#fdd">  m_ReferenceCount = 0;
}</span>

mitk::ImageDataItem::ImageDataItem(const ImageDataItem &amp;other)
<span style = "background-color:#fdd">  : itk::LightObject(),
    m_Data(other.m_Data),
    m_PixelType(new mitk::PixelType(*other.m_PixelType)),
    m_ManageMemory(other.m_ManageMemory),
    m_VtkImageData(nullptr),
    m_VtkImageReadAccessor(nullptr),
    m_VtkImageWriteAccessor(nullptr),
    m_Offset(other.m_Offset),
    m_IsComplete(other.m_IsComplete),
    m_Size(other.m_Size),
    m_Parent(other.m_Parent),
    m_Dimension(other.m_Dimension),
    m_Timestep(other.m_Timestep)
{</span>
  // copy m_Data ??
<span style = "background-color:#fdd">  for (int i = 0; i &lt; MAX_IMAGE_DIMENSIONS; ++i)
    m_Dimensions[i] = other.m_Dimensions[i];
}</span>

itk::LightObject::Pointer mitk::ImageDataItem::InternalClone() const
<span style = "background-color:#fdd">{
  Self::Pointer newGeometry = new Self(*this);
  newGeometry-&gt;UnRegister();
  return newGeometry.GetPointer();
}</span>

void mitk::ImageDataItem::ComputeItemSize(const unsigned int *dimensions, unsigned int dimension)
<span style = "background-color:#fdd">{
  m_Size = m_PixelType-&gt;GetSize();
  for (unsigned int i = 0; i &lt; dimension; i++)</span>
  {
<span style = "background-color:#fdd">    m_Size *= *(dimensions + i);
  }
}</span>

void mitk::ImageDataItem::ConstructVtkImageData(ImageConstPointer iP) const
<span style = "background-color:#fdd">{
  vtkImageData *inData = vtkImageData::New();
  vtkDataArray *scalars = nullptr;</span>

<span style = "background-color:#fdd">  const unsigned int *dims = m_Dimensions;
  const unsigned int dim = m_Dimension;</span>

<span style = "background-color:#fdd">  unsigned long size = 0;
  if (dim == 1)</span>
  {
<span style = "background-color:#fdd">    inData-&gt;SetDimensions(dims[0] - 1, 1, 1);
    size = dims[0];
    inData-&gt;SetOrigin(((mitk::ScalarType)dims[0]) / 2.0, 0, 0);
  }
  else if (dim == 2)</span>
  {
<span style = "background-color:#fdd">    inData-&gt;SetDimensions(dims[0], dims[1], 1);
    size = dims[0] * dims[1];
    inData-&gt;SetOrigin(((mitk::ScalarType)dims[0]) / 2.0f, ((mitk::ScalarType)dims[1]) / 2.0f, 0);
  }
  else if (dim &gt;= 3)</span>
  {
<span style = "background-color:#fdd">    inData-&gt;SetDimensions(dims[0], dims[1], dims[2]);
    size = dims[0] * dims[1] * dims[2];</span>
    // Test
    // inData-&gt;SetOrigin( (float) dims[0] / 2.0f, (float) dims[1] / 2.0f, (float) dims[2] / 2.0f );
<span style = "background-color:#fdd">    inData-&gt;SetOrigin(0, 0, 0);
  }</span>
  else
  {
<span style = "background-color:#fdd">    inData-&gt;Delete();
    return;</span>
  }

<span style = "background-color:#fdd">  if (m_Timestep &gt;= 0)</span>
  {
    SlicedGeometry3D *geom3d;
<span style = "background-color:#fdd">    geom3d = iP-&gt;GetSlicedGeometry(m_Timestep);</span>

<span style = "background-color:#fdd">    const mitk::Vector3D vspacing = geom3d-&gt;GetSpacing();
    double dspacing[3] = {vspacing[0], vspacing[1], vspacing[2]};
    inData-&gt;SetSpacing(dspacing);</span>
  }

<span style = "background-color:#fdd">  if (m_PixelType-&gt;GetComponentType() == itk::IOComponentEnum::CHAR)</span>
  {
<span style = "background-color:#fdd">    scalars = vtkCharArray::New();
  }
  else if (m_PixelType-&gt;GetComponentType() == itk::IOComponentEnum::UCHAR)</span>
  {
<span style = "background-color:#fdd">    scalars = vtkUnsignedCharArray::New();
  }
  else if (m_PixelType-&gt;GetComponentType() == itk::IOComponentEnum::SHORT)</span>
  {
<span style = "background-color:#fdd">    scalars = vtkShortArray::New();
  }
  else if (m_PixelType-&gt;GetComponentType() == itk::IOComponentEnum::USHORT)</span>
  {
<span style = "background-color:#fdd">    scalars = vtkUnsignedShortArray::New();
  }
  else if (m_PixelType-&gt;GetComponentType() == itk::IOComponentEnum::INT)</span>
  {
<span style = "background-color:#fdd">    scalars = vtkIntArray::New();
  }
  else if (m_PixelType-&gt;GetComponentType() == itk::IOComponentEnum::UINT)</span>
  {
<span style = "background-color:#fdd">    scalars = vtkUnsignedIntArray::New();
  }
  else if (m_PixelType-&gt;GetComponentType() == itk::IOComponentEnum::LONG)</span>
  {
<span style = "background-color:#fdd">    scalars = vtkLongArray::New();
  }
  else if (m_PixelType-&gt;GetComponentType() == itk::IOComponentEnum::ULONG)</span>
  {
<span style = "background-color:#fdd">    scalars = vtkUnsignedLongArray::New();
  }
  else if (m_PixelType-&gt;GetComponentType() == itk::IOComponentEnum::FLOAT)</span>
  {
<span style = "background-color:#fdd">    scalars = vtkFloatArray::New();
  }
  else if (m_PixelType-&gt;GetComponentType() == itk::IOComponentEnum::DOUBLE)</span>
  {
<span style = "background-color:#fdd">    scalars = vtkDoubleArray::New();
  }</span>
  else
  {
<span style = "background-color:#fdd">    inData-&gt;Delete();
    return;</span>
  }

<span style = "background-color:#fdd">  m_VtkImageData = inData;</span>

  // set mitk imageDataItem void array to vtk scalar values
<span style = "background-color:#fdd">  scalars-&gt;SetNumberOfComponents(m_PixelType-&gt;GetNumberOfComponents());
  scalars-&gt;SetVoidArray(m_Data, size * m_PixelType-&gt;GetNumberOfComponents(), 1);</span>

<span style = "background-color:#fdd">  m_VtkImageData-&gt;GetPointData()-&gt;SetScalars(scalars);
  scalars-&gt;Delete();
}</span>

void mitk::ImageDataItem::Modified() const
<span style = "background-color:#fdd">{
  if (m_VtkImageData)
    m_VtkImageData-&gt;Modified();
}</span>

mitk::ImageVtkReadAccessor *mitk::ImageDataItem::GetVtkImageAccessor(mitk::ImageDataItem::ImageConstPointer iP) const
<span style = "background-color:#fdd">{
  if (m_VtkImageData == nullptr)</span>
  {
<span style = "background-color:#fdd">    ConstructVtkImageData(iP);</span>
  }
<span style = "background-color:#fdd">  if (m_VtkImageReadAccessor == nullptr)</span>
  {
<span style = "background-color:#fdd">    m_VtkImageReadAccessor = new ImageVtkReadAccessor(iP, this, m_VtkImageData);</span>
  }
<span style = "background-color:#fdd">  return m_VtkImageReadAccessor;
}</span>

mitk::ImageVtkWriteAccessor *mitk::ImageDataItem::GetVtkImageAccessor(ImagePointer iP)
<span style = "background-color:#fdd">{
  if (m_VtkImageData == nullptr)</span>
  {
<span style = "background-color:#fdd">    ConstructVtkImageData(iP.GetPointer());</span>
  }
<span style = "background-color:#fdd">  if (m_VtkImageWriteAccessor == nullptr)</span>
  {
<span style = "background-color:#fdd">    m_VtkImageWriteAccessor = new ImageVtkWriteAccessor(iP, this, m_VtkImageData);</span>
  }
<span style = "background-color:#fdd">  return m_VtkImageWriteAccessor;
}</span></pre>
	</body>
</html>