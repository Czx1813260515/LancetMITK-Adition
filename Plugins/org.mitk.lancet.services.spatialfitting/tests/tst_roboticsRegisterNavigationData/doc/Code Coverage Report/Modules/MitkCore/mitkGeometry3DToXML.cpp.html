<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkGeometry3DToXML.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkGeometry3DToXML.h"

#include &lt;mitkLexicalCast.h&gt;

#include &lt;tinyxml2.h&gt;

#include &lt;array&gt;

tinyxml2::XMLElement *mitk::Geometry3DToXML::ToXML(tinyxml2::XMLDocument&amp; doc, const Geometry3D *geom3D)
<span style = "background-color:#fdd">{
  assert(geom3D);</span>

  // really serialize
<span style = "background-color:#fdd">  const AffineTransform3D *transform = geom3D-&gt;GetIndexToWorldTransform();</span>

  // get transform parameters that would need to be serialized
<span style = "background-color:#fdd">  AffineTransform3D::MatrixType matrix = transform-&gt;GetMatrix();
  AffineTransform3D::OffsetType offset = transform-&gt;GetOffset();</span>

<span style = "background-color:#fdd">  bool isImageGeometry = geom3D-&gt;GetImageGeometry();
  BaseGeometry::BoundsArrayType bounds = geom3D-&gt;GetBounds();</span>

  // create XML file
  // construct XML tree describing the geometry
<span style = "background-color:#fdd">  auto *geomElem = doc.NewElement("Geometry3D");
  geomElem-&gt;SetAttribute("ImageGeometry", isImageGeometry);
  geomElem-&gt;SetAttribute("FrameOfReferenceID", geom3D-&gt;GetFrameOfReferenceID());</span>

  // coefficients are matrix[row][column]!
<span style = "background-color:#fdd">  auto *matrixElem = doc.NewElement("IndexToWorld");
  matrixElem-&gt;SetAttribute("type", "Matrix3x3");
  matrixElem-&gt;SetAttribute("m_0_0", boost::lexical_cast&lt;std::string&gt;(matrix[0][0]).c_str());
  matrixElem-&gt;SetAttribute("m_0_1", boost::lexical_cast&lt;std::string&gt;(matrix[0][1]).c_str());
  matrixElem-&gt;SetAttribute("m_0_2", boost::lexical_cast&lt;std::string&gt;(matrix[0][2]).c_str());
  matrixElem-&gt;SetAttribute("m_1_0", boost::lexical_cast&lt;std::string&gt;(matrix[1][0]).c_str());
  matrixElem-&gt;SetAttribute("m_1_1", boost::lexical_cast&lt;std::string&gt;(matrix[1][1]).c_str());
  matrixElem-&gt;SetAttribute("m_1_2", boost::lexical_cast&lt;std::string&gt;(matrix[1][2]).c_str());
  matrixElem-&gt;SetAttribute("m_2_0", boost::lexical_cast&lt;std::string&gt;(matrix[2][0]).c_str());
  matrixElem-&gt;SetAttribute("m_2_1", boost::lexical_cast&lt;std::string&gt;(matrix[2][1]).c_str());
  matrixElem-&gt;SetAttribute("m_2_2", boost::lexical_cast&lt;std::string&gt;(matrix[2][2]).c_str());
  geomElem-&gt;InsertEndChild(matrixElem);</span>

<span style = "background-color:#fdd">  auto *offsetElem = doc.NewElement("Offset");
  offsetElem-&gt;SetAttribute("type", "Vector3D");
  offsetElem-&gt;SetAttribute("x", boost::lexical_cast&lt;std::string&gt;(offset[0]).c_str());
  offsetElem-&gt;SetAttribute("y", boost::lexical_cast&lt;std::string&gt;(offset[1]).c_str());
  offsetElem-&gt;SetAttribute("z", boost::lexical_cast&lt;std::string&gt;(offset[2]).c_str());
  geomElem-&gt;InsertEndChild(offsetElem);</span>

<span style = "background-color:#fdd">  auto *boundsElem = doc.NewElement("Bounds");
  auto *boundsMinElem = doc.NewElement("Min");
  boundsMinElem-&gt;SetAttribute("type", "Vector3D");
  boundsMinElem-&gt;SetAttribute("x", boost::lexical_cast&lt;std::string&gt;(bounds[0]).c_str());
  boundsMinElem-&gt;SetAttribute("y", boost::lexical_cast&lt;std::string&gt;(bounds[2]).c_str());
  boundsMinElem-&gt;SetAttribute("z", boost::lexical_cast&lt;std::string&gt;(bounds[4]).c_str());
  boundsElem-&gt;InsertEndChild(boundsMinElem);
  auto *boundsMaxElem = doc.NewElement("Max");
  boundsMaxElem-&gt;SetAttribute("type", "Vector3D");
  boundsMaxElem-&gt;SetAttribute("x", boost::lexical_cast&lt;std::string&gt;(bounds[1]).c_str());
  boundsMaxElem-&gt;SetAttribute("y", boost::lexical_cast&lt;std::string&gt;(bounds[3]).c_str());
  boundsMaxElem-&gt;SetAttribute("z", boost::lexical_cast&lt;std::string&gt;(bounds[5]).c_str());
  boundsElem-&gt;InsertEndChild(boundsMaxElem);
  geomElem-&gt;InsertEndChild(boundsElem);</span>

<span style = "background-color:#fdd">  return geomElem;
}</span>

mitk::Geometry3D::Pointer mitk::Geometry3DToXML::FromXML(const tinyxml2::XMLElement *geometryElement)
<span style = "background-color:#fdd">{
  if (!geometryElement)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Cannot deserialize Geometry3D from nullptr.";
    return nullptr;</span>
  }

<span style = "background-color:#fdd">  AffineTransform3D::MatrixType matrix;</span>
  AffineTransform3D::OffsetType offset;
<span style = "background-color:#fdd">  bool isImageGeometry(false);
  unsigned int frameOfReferenceID(0);</span>
  BaseGeometry::BoundsArrayType bounds;

<span style = "background-color:#fdd">  if (tinyxml2::XML_SUCCESS != geometryElement-&gt;QueryUnsignedAttribute("FrameOfReferenceID", &amp;frameOfReferenceID))</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Missing FrameOfReference for Geometry3D.";</span>
  }

<span style = "background-color:#fdd">  if (tinyxml2::XML_SUCCESS != geometryElement-&gt;QueryBoolAttribute("ImageGeometry", &amp;isImageGeometry))</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Missing bool ImageGeometry for Geometry3D.";</span>
  }

  // matrix
<span style = "background-color:#fdd">  if (auto *matrixElem = geometryElement-&gt;FirstChildElement("IndexToWorld"))</span>
  {
<span style = "background-color:#fdd">    bool matrixComplete = true;
    for (unsigned int r = 0; r &lt; 3; ++r)</span>
    {
<span style = "background-color:#fdd">      for (unsigned int c = 0; c &lt; 3; ++c)</span>
      {
<span style = "background-color:#fdd">        std::stringstream element_namer;
        element_namer &lt;&lt; "m_" &lt;&lt; r &lt;&lt; "_" &lt;&lt; c;</span>

<span style = "background-color:#fdd">        const char* string_value = matrixElem-&gt;Attribute(element_namer.str().c_str());
        if (nullptr != string_value)</span>
        {
          try
          {
<span style = "background-color:#fdd">            matrix[r][c] = boost::lexical_cast&lt;double&gt;(string_value);</span>
          }
          catch ( const boost::bad_lexical_cast &amp;e )
<span style = "background-color:#fdd">          {
            MITK_ERROR &lt;&lt; "Could not parse '" &lt;&lt; string_value &lt;&lt; "' as number: " &lt;&lt; e.what();
            return nullptr;
          }
        }</span>
        else
        {
<span style = "background-color:#fdd">          matrixComplete = false;</span>
        }
<span style = "background-color:#fdd">      }
    }</span>

<span style = "background-color:#fdd">    if (!matrixComplete)</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Could not parse all Geometry3D matrix coefficients!";
      return nullptr;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Parse error: expected Matrix3x3 child below Geometry3D node";
    return nullptr;</span>
  }

  // offset
<span style = "background-color:#fdd">  if (auto *offsetElem = geometryElement-&gt;FirstChildElement("Offset"))</span>
  {
    std::array&lt;const char*, 3&gt; offset_string = {
<span style = "background-color:#fdd">      offsetElem-&gt;Attribute("x"),
      offsetElem-&gt;Attribute("y"),
      offsetElem-&gt;Attribute("z")</span>
    };

<span style = "background-color:#fdd">    if (nullptr == offset_string[0] || nullptr == offset_string[1] || nullptr == offset_string[2])</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Could not parse complete Geometry3D offset!";
      return nullptr;</span>
    }

<span style = "background-color:#fdd">    for (unsigned int d = 0; d &lt; 3; ++d)</span>
      try
      {
<span style = "background-color:#fdd">        offset[d] = boost::lexical_cast&lt;double&gt;(offset_string[d]);
      }</span>
      catch ( const boost::bad_lexical_cast &amp;e )
<span style = "background-color:#fdd">      {
        MITK_ERROR &lt;&lt; "Could not parse '" &lt;&lt; offset_string[d] &lt;&lt; "' as number: " &lt;&lt; e.what();
        return nullptr;
      }
  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Parse error: expected Offset3D child below Geometry3D node";
    return nullptr;</span>
  }

  // bounds
<span style = "background-color:#fdd">  if (auto *boundsElem = geometryElement-&gt;FirstChildElement("Bounds"))</span>
  {
    bool vectorsComplete;
    std::array&lt;const char*, 6&gt; bounds_string;
<span style = "background-color:#fdd">    if (auto* minElem = boundsElem-&gt;FirstChildElement("Min"))</span>
    {
<span style = "background-color:#fdd">      bounds_string[0] = minElem-&gt;Attribute("x");
      bounds_string[2] = minElem-&gt;Attribute("y");
      bounds_string[4] = minElem-&gt;Attribute("z");</span>

<span style = "background-color:#fdd">      vectorsComplete = !(nullptr == bounds_string[0] || nullptr == bounds_string[2] || nullptr == bounds_string[4]);
    }</span>
    else
    {
<span style = "background-color:#fdd">      vectorsComplete = false;</span>
    }

<span style = "background-color:#fdd">    if (auto *maxElem = boundsElem-&gt;FirstChildElement("Max"))</span>
    {
<span style = "background-color:#fdd">      bounds_string[1] = maxElem-&gt;Attribute("x");
      bounds_string[3] = maxElem-&gt;Attribute("y");
      bounds_string[5] = maxElem-&gt;Attribute("z");</span>

<span style = "background-color:#fdd">      vectorsComplete = !(nullptr == bounds_string[1] || nullptr == bounds_string[3] || nullptr == bounds_string[5]);
    }</span>
    else
    {
<span style = "background-color:#fdd">      vectorsComplete = false;</span>
    }

<span style = "background-color:#fdd">    if (!vectorsComplete)</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Could not parse complete Geometry3D bounds!";
      return nullptr;</span>
    }

<span style = "background-color:#fdd">    for (unsigned int d = 0; d &lt; 6; ++d)</span>
      try
      {
<span style = "background-color:#fdd">        bounds[d] = boost::lexical_cast&lt;double&gt;(bounds_string[d]);
      }</span>
      catch ( const boost::bad_lexical_cast &amp;e )
<span style = "background-color:#fdd">      {
        MITK_ERROR &lt;&lt; "Could not parse '" &lt;&lt; bounds_string[d] &lt;&lt; "' as number: " &lt;&lt; e.what();
        return nullptr;
      }</span>
  }

  // build GeometryData from matrix/offset
<span style = "background-color:#fdd">  AffineTransform3D::Pointer newTransform = AffineTransform3D::New();
  newTransform-&gt;SetMatrix(matrix);
  newTransform-&gt;SetOffset(offset);</span>

<span style = "background-color:#fdd">  Geometry3D::Pointer newGeometry = Geometry3D::New();
  newGeometry-&gt;SetFrameOfReferenceID(frameOfReferenceID);
  newGeometry-&gt;SetImageGeometry(isImageGeometry);</span>

<span style = "background-color:#fdd">  newGeometry-&gt;SetIndexToWorldTransform(newTransform);</span>

<span style = "background-color:#fdd">  newGeometry-&gt;SetBounds(bounds);</span>

<span style = "background-color:#fdd">  return newGeometry;
}</span></pre>
	</body>
</html>