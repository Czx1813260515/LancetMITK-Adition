<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkCameraController.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkCameraController.h"
#include "mitkRenderingManager.h"
#include "mitkVtkPropRenderer.h"
#include "vtkCommand.h"
#include &lt;vtkRenderWindowInteractor.h&gt;

#include "vtkCamera.h"
#include "vtkRenderer.h"
#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkTransform.h&gt;

<span style = "background-color:#fdd">mitk::CameraController::CameraController() : BaseController(), m_Renderer(nullptr)
{
}</span>

mitk::CameraController::~CameraController()
<span style = "background-color:#fdd">{
}</span>

mitk::ScalarType mitk::CameraController::ComputeMaxParallelScale()
<span style = "background-color:#fdd">{
  double widthInMM = this-&gt;GetRenderer()-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetExtentInMM(0);
  double heightInMM = this-&gt;GetRenderer()-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetExtentInMM(1);</span>

<span style = "background-color:#fdd">  double dispHeight = this-&gt;GetRenderer()-&gt;GetViewportSize()[1]; // in pixel!
  double dispWidth = this-&gt;GetRenderer()-&gt;GetViewportSize()[0];</span>

  // To get the right zooming factor, we need to set the (half) height to the vtk camera using SetParallelScale.
  // However, it could be, that our picture is so wide or the display so small, that we cannot take the height of the
  // picture.
  // For a wide picture, we have to take the width and adapt the width so that our image fits to the screen.
  // But we can only set the height. Therefore, if the width is the limiting factor, we need to get the ratio of scaling
  // for the width and multiply it with the height, so that we have a modified height and set this one. Believe us, we
  // figured it out...
<span style = "background-color:#fdd">  if ((dispWidth / widthInMM) &lt; (dispHeight / heightInMM))</span>
  {
<span style = "background-color:#fdd">    heightInMM = widthInMM / dispWidth * dispHeight;</span>
  }

<span style = "background-color:#fdd">  return heightInMM * 0.5;
}</span>

void mitk::CameraController::AdjustConstrainedCameraPosition(mitk::Point2D &amp;planePoint)
<span style = "background-color:#fdd">{</span>
  // TODO: GetExtentInMM is calculated wrong for rotated planes, e.g. crosshair rotation (bug 19105)
<span style = "background-color:#fdd">  double widthInMM = this-&gt;GetRenderer()-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetExtentInMM(0);
  double heightInMM = this-&gt;GetRenderer()-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetExtentInMM(1);</span>

<span style = "background-color:#fdd">  mitk::Point2D dispSizeInMM = this-&gt;GetRenderer()-&gt;GetViewportSizeInMM();</span>

  double xMin, xMax, yMin, yMax;

  // different calculation of min/max if display is lager/smaller than image.
  // note, that the plane Position defines the middle of the display but is in image coordinates
  //([0,0] is defined by the image, so planePosition can sometimes be negative).
<span style = "background-color:#fdd">  if (dispSizeInMM[0] &gt; widthInMM)</span>
  {
<span style = "background-color:#fdd">    xMin = widthInMM - 0.5 * dispSizeInMM[0];
    xMax = 0.5 * dispSizeInMM[0];
  }</span>
  else
  {
<span style = "background-color:#fdd">    xMin = 0.5 * dispSizeInMM[0];
    xMax = widthInMM - 0.5 * dispSizeInMM[0];</span>
  }

<span style = "background-color:#fdd">  if (dispSizeInMM[1] &gt; heightInMM)</span>
  {
<span style = "background-color:#fdd">    yMin = heightInMM - 0.5 * dispSizeInMM[1];
    yMax = 0.5 * dispSizeInMM[1];
  }</span>
  else
  {
<span style = "background-color:#fdd">    yMin = 0.5 * dispSizeInMM[1];
    yMax = heightInMM - 0.5 * dispSizeInMM[1];</span>
  }

<span style = "background-color:#fdd">  if (planePoint[0] &lt; xMin)</span>
  {
<span style = "background-color:#fdd">    planePoint[0] = xMin;</span>
  }
<span style = "background-color:#fdd">  if (planePoint[1] &lt; yMin)</span>
  {
<span style = "background-color:#fdd">    planePoint[1] = yMin;</span>
  }
<span style = "background-color:#fdd">  if (planePoint[0] &gt; xMax)</span>
  {
<span style = "background-color:#fdd">    planePoint[0] = xMax;</span>
  }
<span style = "background-color:#fdd">  if (planePoint[1] &gt; yMax)</span>
  {
<span style = "background-color:#fdd">    planePoint[1] = yMax;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::CameraController::SetViewToAnterior()
<span style = "background-color:#fdd">{
  this-&gt;SetStandardView(ANTERIOR);
}</span>

void mitk::CameraController::SetViewToPosterior()
<span style = "background-color:#fdd">{
  this-&gt;SetStandardView(POSTERIOR);
}</span>

void mitk::CameraController::SetViewToSinister()
<span style = "background-color:#fdd">{
  this-&gt;SetStandardView(SINISTER);
}</span>

void mitk::CameraController::SetViewToDexter()
<span style = "background-color:#fdd">{
  this-&gt;SetStandardView(DEXTER);
}</span>

void mitk::CameraController::SetViewToCranial()
<span style = "background-color:#fdd">{
  this-&gt;SetStandardView(CRANIAL);
}</span>

void mitk::CameraController::SetViewToCaudal()
<span style = "background-color:#fdd">{
  this-&gt;SetStandardView(CAUDAL);
}</span>

void mitk::CameraController::SetStandardView(mitk::CameraController::StandardView view)
<span style = "background-color:#fdd">{
  const auto *glRenderer = dynamic_cast&lt;const mitk::VtkPropRenderer *&gt;(m_Renderer);
  if (glRenderer == nullptr)
    return;
  vtkRenderer *vtkRenderer = glRenderer-&gt;GetVtkRenderer();
  assert(vtkRenderer);</span>

<span style = "background-color:#fdd">  mitk::BoundingBox::Pointer bb;
  mitk::DataStorage *ds = m_Renderer-&gt;GetDataStorage();
  if (ds != nullptr)
    bb = ds-&gt;ComputeBoundingBox();</span>
  else
<span style = "background-color:#fdd">    return;</span>

<span style = "background-color:#fdd">  if (m_Renderer-&gt;GetMapperID() == mitk::BaseRenderer::Standard3D)</span>
  {
    // set up the view for the 3D render window. The views for 2D are set up in the mitkVtkPropRenderer
<span style = "background-color:#fdd">    mitk::Point3D middle = bb-&gt;GetCenter();
    vtkRenderer-&gt;GetActiveCamera()-&gt;SetFocalPoint(middle[0], middle[1], middle[2]);
    switch (view)</span>
    {
      case ANTERIOR:
      case POSTERIOR:
      case SINISTER:
      case DEXTER:
<span style = "background-color:#fdd">        vtkRenderer-&gt;GetActiveCamera()-&gt;SetViewUp(0, 0, 1);
        break;</span>
      case CRANIAL:
      case CAUDAL:
<span style = "background-color:#fdd">        vtkRenderer-&gt;GetActiveCamera()-&gt;SetViewUp(0, -1, 0);</span>
        break;
    }
<span style = "background-color:#fdd">    switch (view)</span>
    {
      case ANTERIOR:
<span style = "background-color:#fdd">        vtkRenderer-&gt;GetActiveCamera()-&gt;SetPosition(middle[0], -100000, middle[2]);
        break;</span>
      case POSTERIOR:
<span style = "background-color:#fdd">        vtkRenderer-&gt;GetActiveCamera()-&gt;SetPosition(middle[0], +100000, middle[2]);
        break;</span>
      case SINISTER:
<span style = "background-color:#fdd">        vtkRenderer-&gt;GetActiveCamera()-&gt;SetPosition(+100000, middle[1], middle[2]);
        break;</span>
      case DEXTER:
<span style = "background-color:#fdd">        vtkRenderer-&gt;GetActiveCamera()-&gt;SetPosition(-100000, middle[1], middle[2]);
        break;</span>
      case CRANIAL:
<span style = "background-color:#fdd">        vtkRenderer-&gt;GetActiveCamera()-&gt;SetPosition(middle[0], middle[1], 100000);
        break;</span>
      case CAUDAL:
<span style = "background-color:#fdd">        vtkRenderer-&gt;GetActiveCamera()-&gt;SetPosition(middle[0], middle[1], -100000);</span>
        break;
    }
<span style = "background-color:#fdd">    vtkRenderer-&gt;ResetCamera();</span>

<span style = "background-color:#fdd">    vtkRenderer-&gt;ResetCameraClippingRange();</span>
  }

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::CameraController::MoveCameraToPoint(const mitk::Point2D &amp;planePoint)
<span style = "background-color:#fdd">{
  Point2D moveToPoint = planePoint;
  AdjustCameraToPlane(moveToPoint);</span>

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span>

void mitk::CameraController::MoveBy(const mitk::Vector2D &amp;moveVectorInMM)
<span style = "background-color:#fdd">{
  MoveCameraToPoint(GetCameraPositionOnPlane() + moveVectorInMM);
}</span>

void mitk::CameraController::Zoom(ScalarType factor, const Point2D &amp;zoomPointInMM)
<span style = "background-color:#fdd">{
  if (factor &lt;= 0.0)
    return;
  if (this-&gt;GetRenderer()-&gt;GetMapperID() == BaseRenderer::Standard2D)</span>
  {
<span style = "background-color:#fdd">    double parallelScale = this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;GetParallelScale() / factor;
    if (this-&gt;GetRenderer()-&gt;GetConstrainZoomingAndPanning() &amp;&amp; factor &lt; 1.0)</span>
    {
<span style = "background-color:#fdd">      double maxParallelScale = ComputeMaxParallelScale();
      if (maxParallelScale - parallelScale * factor &lt;</span>
          mitk::eps) // this is not the famous 05-bug... Return if already near max zooming
<span style = "background-color:#fdd">        return;</span>

<span style = "background-color:#fdd">      if (parallelScale &gt; maxParallelScale)</span>
      {
<span style = "background-color:#fdd">        parallelScale = maxParallelScale;</span>
      }
    }
<span style = "background-color:#fdd">    this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;SetParallelScale(parallelScale);</span>
    // Move camera in a way that the clicked point stays visible on the display where it was.
<span style = "background-color:#fdd">    Point2D planePoint = GetCameraPositionOnPlane();
    MoveCameraToPoint(planePoint + ((zoomPointInMM - planePoint) * (factor - 1)));</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::Point2D mitk::CameraController::GetCameraPositionOnPlane()
<span style = "background-color:#fdd">{
  Point2D CamPosOnPlane;
  CamPosOnPlane[0] = this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetCenter()[0];
  CamPosOnPlane[1] = this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetCenter()[1];
  this-&gt;GetRenderer()-&gt;DisplayToPlane(CamPosOnPlane, CamPosOnPlane);
  return CamPosOnPlane;
}</span>

void mitk::CameraController::AdjustCameraToPlane()
<span style = "background-color:#fdd">{
  if (this-&gt;GetRenderer()-&gt;GetMapperID() == BaseRenderer::Standard2D)</span>
  {
<span style = "background-color:#fdd">    AdjustCameraToPlane(GetCameraPositionOnPlane());</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::CameraController::AdjustCameraToPlane(const Point2D &amp;PlanePoint)
<span style = "background-color:#fdd">{
  if (this-&gt;GetRenderer()-&gt;GetMapperID() == BaseRenderer::Standard2D)</span>
  {
<span style = "background-color:#fdd">    Point2D _planePoint = PlanePoint; // PlanePoint is const...
    if (this-&gt;GetRenderer()-&gt;GetConstrainZoomingAndPanning())</span>
    {
<span style = "background-color:#fdd">      double parallelScale = this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;GetParallelScale();
      double maxParallelScale = ComputeMaxParallelScale();
      if (parallelScale &gt; maxParallelScale)</span>
      {
<span style = "background-color:#fdd">        this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;SetParallelScale(maxParallelScale);</span>
      }
<span style = "background-color:#fdd">      AdjustConstrainedCameraPosition(_planePoint);</span>
    }
<span style = "background-color:#fdd">    const PlaneGeometry *planeGeometry = this-&gt;GetRenderer()-&gt;GetCurrentWorldPlaneGeometry();
    if (planeGeometry != nullptr)</span>
    {
<span style = "background-color:#fdd">      this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;SetViewUp(0, 1, 0); // set the view-up for the camera
      this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;SetPosition(_planePoint[0], _planePoint[1], 900000);
      this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;SetFocalPoint(_planePoint[0], _planePoint[1], 0);</span>
      // Transform the camera to the current position (transversal, coronal and sagittal plane).
      // This is necessary, because the SetUserTransform() method does not manipulate the vtkCamera.
      //(Without not all three planes would be visible).
<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkTransform&gt; trans = vtkSmartPointer&lt;vtkTransform&gt;::New();
      vtkSmartPointer&lt;vtkMatrix4x4&gt; matrix = vtkSmartPointer&lt;vtkMatrix4x4&gt;::New();
      Point3D origin;
      Vector3D right, bottom, normal;</span>

<span style = "background-color:#fdd">      origin = planeGeometry-&gt;GetOrigin();
      right = planeGeometry-&gt;GetAxisVector(0); // right = Extent of Image in mm (worldspace)
      bottom = planeGeometry-&gt;GetAxisVector(1);
      normal = planeGeometry-&gt;GetNormal();</span>

<span style = "background-color:#fdd">      right.Normalize();
      bottom.Normalize();
      normal.Normalize();</span>

<span style = "background-color:#fdd">      matrix-&gt;SetElement(0, 0, right[0]);
      matrix-&gt;SetElement(1, 0, right[1]);
      matrix-&gt;SetElement(2, 0, right[2]);
      matrix-&gt;SetElement(0, 1, bottom[0]);
      matrix-&gt;SetElement(1, 1, bottom[1]);
      matrix-&gt;SetElement(2, 1, bottom[2]);
      matrix-&gt;SetElement(0, 2, normal[0]);
      matrix-&gt;SetElement(1, 2, normal[1]);
      matrix-&gt;SetElement(2, 2, normal[2]);
      matrix-&gt;SetElement(0, 3, origin[0]);
      matrix-&gt;SetElement(1, 3, origin[1]);
      matrix-&gt;SetElement(2, 3, origin[2]);
      matrix-&gt;SetElement(3, 0, 0.0);
      matrix-&gt;SetElement(3, 1, 0.0);
      matrix-&gt;SetElement(3, 2, 0.0);
      matrix-&gt;SetElement(3, 3, 1.0);</span>

<span style = "background-color:#fdd">      trans-&gt;SetMatrix(matrix);</span>
      // Transform the camera to the current position (transversal, coronal and sagittal plane).
<span style = "background-color:#fdd">      this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;ApplyTransform(trans);
    }</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::CameraController::Fit()
<span style = "background-color:#fdd">{
  if (this-&gt;GetRenderer()-&gt;GetMapperID() == BaseRenderer::Standard2D)</span>
  {
<span style = "background-color:#fdd">    this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;SetParallelScale(ComputeMaxParallelScale());</span>

<span style = "background-color:#fdd">    this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;SetClippingRange(0.1, 1000000);</span>
    // Reason for huge range: VTK seems to calculate the clipping planes wrong for small values. See VTK bug (id #7823)
    // in VTK bugtracker.

<span style = "background-color:#fdd">    Point2D planePoint;
    planePoint[0] = this-&gt;GetRenderer()-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetExtentInMM(0) * 0.5;
    planePoint[1] = this-&gt;GetRenderer()-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetExtentInMM(1) * 0.5;
    MoveCameraToPoint(planePoint);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::CameraController::SetScaleFactorInMMPerDisplayUnit(ScalarType scale)
<span style = "background-color:#fdd">{
  if (this-&gt;GetRenderer()-&gt;GetMapperID() != BaseRenderer::Standard2D)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  this-&gt;GetRenderer()-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;SetParallelScale(this-&gt;GetRenderer()-&gt;GetViewportSize()[1] *</span>
                                                                             scale * 0.5);

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span></pre>
	</body>
</html>