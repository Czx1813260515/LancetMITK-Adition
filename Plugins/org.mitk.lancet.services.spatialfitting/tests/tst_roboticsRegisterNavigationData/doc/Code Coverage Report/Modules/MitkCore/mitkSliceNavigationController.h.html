<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSliceNavigationController.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef SLICENAVIGATIONCONTROLLER_H_HEADER_INCLUDED_C1C55A2F
#define SLICENAVIGATIONCONTROLLER_H_HEADER_INCLUDED_C1C55A2F

#include "mitkBaseController.h"
#include "mitkMessage.h"
#include "mitkRenderingManager.h"
#include "mitkTimeGeometry.h"
#include &lt;MitkCoreExports.h&gt;
#pragma GCC visibility push(default)
#include &lt;itkEventObject.h&gt;
#pragma GCC visibility pop
#include "mitkDataStorage.h"
#include "mitkRestorePlanePositionOperation.h"
#include &lt;itkCommand.h&gt;
#include &lt;sstream&gt;

namespace mitk
{
#define mitkTimeGeometryEventMacro(classname, super)                                                                   \
  class MITKCORE_EXPORT classname : public super                                                                       \
  {                                                                                                                    \
  public:                                                                                                              \
    typedef classname Self;                                                                                            \
    typedef super Superclass;                                                                                          \
    classname(TimeGeometry *aTimeGeometry, unsigned int aPos) : Superclass(aTimeGeometry, aPos) {}                     \
    virtual ~classname() {}                                                                                            \
    virtual const char *GetEventName() const { return #classname; }                                                    \
    virtual bool CheckEvent(const ::itk::EventObject *e) const { return dynamic_cast&lt;const Self *&gt;(e); }               \
    virtual ::itk::EventObject *MakeObject() const { return new Self(GetTimeGeometry(), GetPos()); }                   \
  private:                                                                                                             \
    void operator=(const Self &amp;);                                                                                      \
  }

  class PlaneGeometry;
  class BaseGeometry;
  class BaseRenderer;

  /**
   * \brief Controls the selection of the slice the associated BaseRenderer
   * will display
   *
   * A SliceNavigationController takes a BaseGeometry or a TimeGeometry as input world geometry
   * (TODO what are the exact requirements?) and generates a TimeGeometry
   * as output. The TimeGeometry holds a number of SlicedGeometry3Ds and
   * these in turn hold a series of PlaneGeometries. One of these PlaneGeometries is
   * selected as world geometry for the BaseRenderers associated to 2D views.
   *
   * The SliceNavigationController holds has Steppers (one for the slice, a
   * second for the time step), which control the selection of a single
   * PlaneGeometry from the TimeGeometry. SliceNavigationController generates
   * ITK events to tell observers, like a BaseRenderer,  when the selected slice
   * or timestep changes.
   *
   * Example:
   * \code
   * // Initialization
   * sliceCtrl = mitk::SliceNavigationController::New();
   *
   * // Tell the navigator the geometry to be sliced (with geometry a
   * // BaseGeometry::ConstPointer)
   * sliceCtrl-&gt;SetInputWorldGeometry3D(geometry.GetPointer());
   *
   * // Tell the navigator in which direction it shall slice the data
   * sliceCtrl-&gt;SetViewDirection(mitk::SliceNavigationController::Axial);
   *
   * // Connect one or more BaseRenderer to this navigator, i.e.: events sent
   * // by the navigator when stepping through the slices (e.g. by
   * // sliceCtrl-&gt;GetSlice()-&gt;Next()) will be received by the BaseRenderer
   * // (in this example only slice-changes, see also ConnectGeometryTimeEvent
   * // and ConnectGeometryEvents.)
   * sliceCtrl-&gt;ConnectGeometrySliceEvent(renderer.GetPointer());
   *
   * //create a world geometry and send the information to the connected renderer(s)
   * sliceCtrl-&gt;Update();
   * \endcode
   *
   *
   * You can connect visible navigators to a SliceNavigationController, e.g., a
   * QmitkSliderNavigator (for Qt):
   *
   * \code
   * // Create the visible navigator (a slider with a spin-box)
   * QmitkSliderNavigator* navigator =
   *   new QmitkSliderNavigator(parent, "slidernavigator");
   *
   * // Connect the navigator to the slice-stepper of the
   * // SliceNavigationController. For initialization (position, mininal and
   * // maximal values) the values of the SliceNavigationController are used.
   * // Thus, accessing methods of a navigator is normally not necessary, since
   * // everything can be set via the (Qt-independent) SliceNavigationController.
   * // The QmitkStepperAdapter converts the Qt-signals to Qt-independent
   * // itk-events.
   * new QmitkStepperAdapter(navigator, sliceCtrl-&gt;GetSlice(), "navigatoradaptor");
   * \endcode
   *
   * If you do not want that all renderwindows are updated when a new slice is
   * selected, you can use a specific RenderingManager, which updates only those
   * renderwindows that should be updated. This is sometimes useful when a 3D view
   * does not need to be updated when the slices in some 2D views are changed.
   * QmitkSliderNavigator (for Qt):
   *
   * \code
   * // create a specific RenderingManager
   * mitk::RenderingManager::Pointer myManager = mitk::RenderingManager::New();
   *
   * // tell the RenderingManager to update only renderwindow1 and renderwindow2
   * myManager-&gt;AddRenderWindow(renderwindow1);
   * myManager-&gt;AddRenderWindow(renderwindow2);
   *
   * // tell the SliceNavigationController of renderwindow1 and renderwindow2
   * // to use the specific RenderingManager instead of the global one
   * renderwindow1-&gt;GetSliceNavigationController()-&gt;SetRenderingManager(myManager);
   * renderwindow2-&gt;GetSliceNavigationController()-&gt;SetRenderingManager(myManager);
   * \endcode
   *
   * \todo implement for non-evenly-timed geometry!
   * \ingroup NavigationControl
   */
  class MITKCORE_EXPORT SliceNavigationController : public BaseController
  {
  public:
<span style = "background-color:#fdd">    mitkClassMacro(SliceNavigationController, BaseController);</span>
    // itkFactorylessNewMacro(Self)
    // mitkNewMacro1Param(Self, const char *);
<span style = "background-color:#fdd">    itkNewMacro(Self);</span>
    // itkCloneMacro(Self)

    /**
     * \brief Possible view directions, \a Original will uses
     * the PlaneGeometry instances in a SlicedGeometry3D provided
     * as input world geometry (by SetInputWorldGeometry3D).
     */
    enum ViewDirection
    {
      Axial,
      Sagittal,
      Frontal,
      Original
    };

    /**
     * \brief Set the input world geometry3D out of which the
     * geometries for slicing will be created.
     *
     * Any previous previous set input geometry (3D or Time) will
     * be ignored in future.
     */
    void SetInputWorldGeometry3D(const mitk::BaseGeometry *geometry);
<span style = "background-color:#fdd">    itkGetConstObjectMacro(InputWorldGeometry3D, mitk::BaseGeometry);</span>

    void SetInputWorldTimeGeometry(const mitk::TimeGeometry *geometry);
<span style = "background-color:#fdd">    itkGetConstObjectMacro(InputWorldTimeGeometry, mitk::TimeGeometry);</span>

    /**
     * \brief Access the created geometry
     */
<span style = "background-color:#fdd">    itkGetConstObjectMacro(CreatedWorldGeometry, mitk::TimeGeometry);</span>

    /**
     * \brief Set the desired view directions
     *
     * \sa ViewDirection
     * \sa Update(ViewDirection viewDirection, bool top = true,
     *     bool frontside = true, bool rotated = false)
     */
<span style = "background-color:#fdd">    itkSetEnumMacro(ViewDirection, ViewDirection);
    itkGetEnumMacro(ViewDirection, ViewDirection);</span>

    /**
     * \brief Set the default view direction
     *
     * This is used to re-initialize the view direction of the SNC to the
     * default value with SetViewDirectionToDefault()
     *
     * \sa ViewDirection
     * \sa Update(ViewDirection viewDirection, bool top = true,
     *     bool frontside = true, bool rotated = false)
     */
<span style = "background-color:#fdd">    itkSetEnumMacro(DefaultViewDirection, ViewDirection);
    itkGetEnumMacro(DefaultViewDirection, ViewDirection);</span>

    const char *GetViewDirectionAsString() const;

    virtual void SetViewDirectionToDefault();

    /**
     * \brief Do the actual creation and send it to the connected
     * observers (renderers)
     *
     */
    virtual void Update();

    /**
     * \brief Extended version of Update, additionally allowing to
     * specify the direction/orientation of the created geometry.
     *
     */
    virtual void Update(ViewDirection viewDirection, bool top = true, bool frontside = true, bool rotated = false);

    /**
     * \brief Send the created geometry to the connected
     * observers (renderers)
     *
     * Called by Update().
     */
    virtual void SendCreatedWorldGeometry();

    /**
     * \brief Tell observers to re-read the currently selected 2D geometry
     *
     */
    virtual void SendCreatedWorldGeometryUpdate();

    /**
     * \brief Send the currently selected slice to the connected
     * observers (renderers)
     *
     * Called by Update().
     */
    virtual void SendSlice();

    /**
     * \brief Send the currently selected time to the connected
     * observers (renderers)
     *
     * Called by Update().
     */
    virtual void SendTime();

    class MITKCORE_EXPORT TimeGeometryEvent : public itk::AnyEvent
    {
    public:
      typedef TimeGeometryEvent Self;
      typedef itk::AnyEvent Superclass;

<span style = "background-color:#fdd">      TimeGeometryEvent(TimeGeometry *aTimeGeometry, unsigned int aPos) : m_TimeGeometry(aTimeGeometry), m_Pos(aPos) {}
      ~TimeGeometryEvent() override {}
      const char *GetEventName() const override { return "TimeGeometryEvent"; }
      bool CheckEvent(const ::itk::EventObject *e) const override { return dynamic_cast&lt;const Self *&gt;(e); }
      ::itk::EventObject *MakeObject() const override { return new Self(m_TimeGeometry, m_Pos); }
      TimeGeometry *GetTimeGeometry() const { return m_TimeGeometry; }
      unsigned int GetPos() const { return m_Pos; }</span>
    private:
      TimeGeometry::Pointer m_TimeGeometry;
      unsigned int m_Pos;
      // TimeGeometryEvent(const Self&amp;);
      void operator=(const Self &amp;); // just hide
    };


<span style = "background-color:#fdd">    mitkTimeGeometryEventMacro(GeometrySendEvent, TimeGeometryEvent);
    mitkTimeGeometryEventMacro(GeometryUpdateEvent, TimeGeometryEvent);
    mitkTimeGeometryEventMacro(GeometryTimeEvent, TimeGeometryEvent);
    mitkTimeGeometryEventMacro(GeometrySliceEvent, TimeGeometryEvent);</span>

    template &lt;typename T&gt;
    void ConnectGeometrySendEvent(T *receiver)
<span style = "background-color:#fdd">    {</span>
      typedef typename itk::ReceptorMemberCommand&lt;T&gt;::Pointer ReceptorMemberCommandPointer;
<span style = "background-color:#fdd">      ReceptorMemberCommandPointer eventReceptorCommand = itk::ReceptorMemberCommand&lt;T&gt;::New();
      eventReceptorCommand-&gt;SetCallbackFunction(receiver, &amp;T::SetGeometry);
      unsigned long tag = AddObserver(GeometrySendEvent(nullptr, 0), eventReceptorCommand);
      m_ReceiverToObserverTagsMap[static_cast&lt;void *&gt;(receiver)].push_back(tag);
    }</span>

    template &lt;typename T&gt;
    void ConnectGeometryUpdateEvent(T *receiver)
<span style = "background-color:#fdd">    {</span>
      typedef typename itk::ReceptorMemberCommand&lt;T&gt;::Pointer ReceptorMemberCommandPointer;
<span style = "background-color:#fdd">      ReceptorMemberCommandPointer eventReceptorCommand = itk::ReceptorMemberCommand&lt;T&gt;::New();
      eventReceptorCommand-&gt;SetCallbackFunction(receiver, &amp;T::UpdateGeometry);
      unsigned long tag = AddObserver(GeometryUpdateEvent(nullptr, 0), eventReceptorCommand);
      m_ReceiverToObserverTagsMap[static_cast&lt;void *&gt;(receiver)].push_back(tag);
    }</span>

    template &lt;typename T&gt;
    void ConnectGeometrySliceEvent(T *receiver, bool connectSendEvent = true)
<span style = "background-color:#fdd">    {</span>
      typedef typename itk::ReceptorMemberCommand&lt;T&gt;::Pointer ReceptorMemberCommandPointer;
<span style = "background-color:#fdd">      ReceptorMemberCommandPointer eventReceptorCommand = itk::ReceptorMemberCommand&lt;T&gt;::New();
      eventReceptorCommand-&gt;SetCallbackFunction(receiver, &amp;T::SetGeometrySlice);
      unsigned long tag = AddObserver(GeometrySliceEvent(nullptr, 0), eventReceptorCommand);
      m_ReceiverToObserverTagsMap[static_cast&lt;void *&gt;(receiver)].push_back(tag);
      if (connectSendEvent)
        ConnectGeometrySendEvent(receiver);
    }</span>

    template &lt;typename T&gt;
    void ConnectGeometryTimeEvent(T *receiver, bool connectSendEvent = true)
<span style = "background-color:#fdd">    {</span>
      typedef typename itk::ReceptorMemberCommand&lt;T&gt;::Pointer ReceptorMemberCommandPointer;
<span style = "background-color:#fdd">      ReceptorMemberCommandPointer eventReceptorCommand = itk::ReceptorMemberCommand&lt;T&gt;::New();
      eventReceptorCommand-&gt;SetCallbackFunction(receiver, &amp;T::SetGeometryTime);
      unsigned long tag = AddObserver(GeometryTimeEvent(nullptr, 0), eventReceptorCommand);
      m_ReceiverToObserverTagsMap[static_cast&lt;void *&gt;(receiver)].push_back(tag);
      if (connectSendEvent)
        ConnectGeometrySendEvent(receiver);
    }</span>

    template &lt;typename T&gt;
    void ConnectGeometryEvents(T *receiver)
    {
      // connect sendEvent only once
      ConnectGeometrySliceEvent(receiver, false);
      ConnectGeometryTimeEvent(receiver);
    }

    // use a templated method to get the right offset when casting to void*
    template &lt;typename T&gt;
    void Disconnect(T *receiver)
    {
      auto i = m_ReceiverToObserverTagsMap.find(static_cast&lt;void *&gt;(receiver));
      if (i == m_ReceiverToObserverTagsMap.end())
        return;
      const std::list&lt;unsigned long&gt; &amp;tags = i-&gt;second;
      for (auto tagIter = tags.begin(); tagIter != tags.end(); ++tagIter)
      {
        RemoveObserver(*tagIter);
      }
      m_ReceiverToObserverTagsMap.erase(i);
    }

    Message1&lt;mitk::Point3D&gt; SetCrosshairEvent;

    /**
     * \brief To connect multiple SliceNavigationController, we can
     * act as an observer ourselves: implemented interface
     * \warning not implemented
     */
    virtual void SetGeometry(const itk::EventObject &amp;geometrySliceEvent);

    /**
     * \brief To connect multiple SliceNavigationController, we can
     * act as an observer ourselves: implemented interface
     */
    virtual void SetGeometrySlice(const itk::EventObject &amp;geometrySliceEvent);

    /**
     * \brief To connect multiple SliceNavigationController, we can
     * act as an observer ourselves: implemented interface
     */
    virtual void SetGeometryTime(const itk::EventObject &amp;geometryTimeEvent);

    /** \brief Positions the SNC according to the specified point */
    void SelectSliceByPoint(const mitk::Point3D &amp;point);

    /** \brief Returns the TimeGeometry created by the SNC. */
    mitk::TimeGeometry *GetCreatedWorldGeometry();

    /** \brief Returns the BaseGeometry of the currently selected time step. */
    const mitk::BaseGeometry *GetCurrentGeometry3D();

    /** \brief Returns the currently selected Plane in the current
     * BaseGeometry (if existent).
     */
    const mitk::PlaneGeometry *GetCurrentPlaneGeometry();

    /** \brief Sets the BaseRenderer associated with this SNC (if any). While
     * the BaseRenderer is not directly used by SNC, this is a convenience
     * method to enable BaseRenderer access via the SNC. */
    void SetRenderer(BaseRenderer *renderer);

    /** \brief Gets the BaseRenderer associated with this SNC (if any). While
     * the BaseRenderer is not directly used by SNC, this is a convenience
     * method to enable BaseRenderer access via the SNC. Returns nullptr if no
     * BaseRenderer has been specified*/
    BaseRenderer *GetRenderer() const;

    /** \brief Re-orients the slice stack. All slices will be oriented to the given normal vector.
         The given point (world coordinates) defines the selected slice.
         Careful: The resulting axis vectors are not clearly defined this way. If you want to define them clearly, use
         ReorientSlices (const mitk::Point3D &amp;point, const mitk::Vector3D &amp;axisVec0, const mitk::Vector3D &amp;axisVec1).
     */
    void ReorientSlices(const mitk::Point3D &amp;point, const mitk::Vector3D &amp;normal);

    /** \brief Re-orients the slice stack so that all planes are oriented according to the
    * given axis vectors. The given Point eventually defines selected slice.
    */
    void ReorientSlices(const mitk::Point3D &amp;point, const mitk::Vector3D &amp;axisVec0, const mitk::Vector3D &amp;axisVec1);

    void ExecuteOperation(Operation *operation) override;

    /**
     * \brief Feature option to lock planes during mouse interaction.
     * This option flag disables the mouse event which causes the center
     * cross to move near by.
     */
<span style = "background-color:#fdd">    itkSetMacro(SliceLocked, bool);
    itkGetMacro(SliceLocked, bool);
    itkBooleanMacro(SliceLocked);</span>

    /**
     * \brief Feature option to lock slice rotation.
     *
     * This option flag disables separately the rotation of a slice which is
     * implemented in mitkSliceRotator.
     */
<span style = "background-color:#fdd">    itkSetMacro(SliceRotationLocked, bool);
    itkGetMacro(SliceRotationLocked, bool);
    itkBooleanMacro(SliceRotationLocked);</span>

    /**
     * \brief Adjusts the numerical range of the slice stepper according to
     * the current geometry orientation of this SNC's SlicedGeometry.
     */
    void AdjustSliceStepperRange();

    /** \brief Convenience method that returns the time step currently selected by the controller.*/
    TimeStepType GetSelectedTimeStep() const;

    /** \brief Convenience method that returns the time point that corresponds to the selected
     * time step. The conversion is done using the time geometry of the SliceNavigationController.
     * If the time geometry is not yet set, this function will always return 0.0.*/
    TimePointType GetSelectedTimePoint() const;

  protected:
    SliceNavigationController();
    ~SliceNavigationController() override;

    mitk::BaseGeometry::ConstPointer m_InputWorldGeometry3D;
    mitk::TimeGeometry::ConstPointer m_InputWorldTimeGeometry;

    mitk::TimeGeometry::Pointer m_CreatedWorldGeometry;

    ViewDirection m_ViewDirection;
    ViewDirection m_DefaultViewDirection;

    mitk::RenderingManager::Pointer m_RenderingManager;

    mitk::BaseRenderer *m_Renderer;

<span style = "background-color:#fdd">    itkSetMacro(Top, bool);
    itkGetMacro(Top, bool);
    itkBooleanMacro(Top);</span>

<span style = "background-color:#fdd">    itkSetMacro(FrontSide, bool);
    itkGetMacro(FrontSide, bool);
    itkBooleanMacro(FrontSide);</span>

<span style = "background-color:#fdd">    itkSetMacro(Rotated, bool);
    itkGetMacro(Rotated, bool);
    itkBooleanMacro(Rotated);</span>

    bool m_Top;
    bool m_FrontSide;
    bool m_Rotated;

    bool m_BlockUpdate;

    bool m_SliceLocked;
    bool m_SliceRotationLocked;
    unsigned int m_OldPos;

    typedef std::map&lt;void *, std::list&lt;unsigned long&gt;&gt; ObserverTagsMapType;
    ObserverTagsMapType m_ReceiverToObserverTagsMap;
  };

} // namespace mitk

#endif /* SLICENAVIGATIONCONTROLLER_H_HEADER_INCLUDED_C1C55A2F */</pre>
	</body>
</html>