<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDispatcher.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkDispatcher.h"
#include "mitkInteractionEvent.h"
#include "mitkInteractionEventObserver.h"
#include "mitkInternalEvent.h"
#include "usGetModuleContext.h"

namespace
{
  struct cmp
  {
    bool operator()(mitk::WeakPointer&lt;mitk::DataInteractor&gt; d1, mitk::WeakPointer&lt;mitk::DataInteractor&gt; d2)
<span style = "background-color:#fdd">    {
      return (d1.Lock()-&gt;GetLayer() &gt; d2.Lock()-&gt;GetLayer());
    }</span>
  };
}

<span style = "background-color:#fdd">mitk::Dispatcher::Dispatcher(const std::string &amp;rendererName) : m_ProcessingMode(REGULAR)
{</span>
  // LDAP filter string to find all listeners specific for the renderer
  // corresponding to this dispatcher
<span style = "background-color:#fdd">  std::string specificRenderer = "(rendererName=" + rendererName + ")";</span>

  // LDAP filter string to find all listeners that are not specific
  // to any renderer
<span style = "background-color:#fdd">  std::string anyRenderer = "(!(rendererName=*))";</span>

  // LDAP filter string to find only instances of  InteractionEventObserver
<span style = "background-color:#fdd">  std::string classInteractionEventObserver =</span>
    "(" + us::ServiceConstants::OBJECTCLASS() + "=" + us_service_interface_iid&lt;InteractionEventObserver&gt;() + ")";

  // Configure the LDAP filter to find all instances of InteractionEventObserver
  // that are specific to this dispatcher or unspecific to any dispatchers (real global listener)
<span style = "background-color:#fdd">  us::LDAPFilter filter("(&amp;(|" + specificRenderer + anyRenderer + ")" + classInteractionEventObserver + ")");</span>

  // Give the filter to the ObserverTracker
<span style = "background-color:#fdd">  m_EventObserverTracker = new us::ServiceTracker&lt;InteractionEventObserver&gt;(us::GetModuleContext(), filter);
  m_EventObserverTracker-&gt;Open();
}</span>

void mitk::Dispatcher::AddDataInteractor(const DataNode *dataNode)
<span style = "background-color:#fdd">{
  RemoveDataInteractor(dataNode);
  RemoveOrphanedInteractors();</span>

<span style = "background-color:#fdd">  auto dataInteractor = dataNode-&gt;GetDataInteractor().GetPointer();</span>

<span style = "background-color:#fdd">  if (dataInteractor != nullptr)
    m_Interactors.push_back(dataInteractor);
}</span>

/*
 * Note: One DataInteractor can only have one DataNode and vice versa,
 * BUT the m_Interactors list may contain another DataInteractor that is still connected to this DataNode,
 * in this case we have to remove &gt;1 DataInteractor. (Some special case of switching DataNodes between DataInteractors
 * and registering a
 * DataNode to a DataStorage after assigning it to an DataInteractor)
 */

void mitk::Dispatcher::RemoveDataInteractor(const DataNode *dataNode)
<span style = "background-color:#fdd">{
  for (auto it = m_Interactors.begin(); it != m_Interactors.end();)</span>
  {
<span style = "background-color:#fdd">    if ((*it).IsExpired() || (*it).Lock()-&gt;GetDataNode() == nullptr || (*it).Lock()-&gt;GetDataNode() == dataNode)</span>
    {
<span style = "background-color:#fdd">      it = m_Interactors.erase(it);
    }</span>
    else
    {
<span style = "background-color:#fdd">      ++it;
    }
  }
}</span>

size_t mitk::Dispatcher::GetNumberOfInteractors()
<span style = "background-color:#fdd">{
  return m_Interactors.size();
}</span>

mitk::Dispatcher::~Dispatcher()
<span style = "background-color:#fdd">{
  m_EventObserverTracker-&gt;Close();
  delete m_EventObserverTracker;</span>

<span style = "background-color:#fdd">  m_Interactors.clear();
}</span>

bool mitk::Dispatcher::ProcessEvent(InteractionEvent *event)
<span style = "background-color:#fdd">{
  InteractionEvent::Pointer p = event;
  bool eventIsHandled = false;</span>
  /* Filter out and handle Internal Events separately */
<span style = "background-color:#fdd">  auto *internalEvent = dynamic_cast&lt;InternalEvent *&gt;(event);
  if (internalEvent != nullptr)</span>
  {
<span style = "background-color:#fdd">    eventIsHandled = HandleInternalEvent(internalEvent);</span>
    // InternalEvents that are handled are not sent to the listeners
<span style = "background-color:#fdd">    if (eventIsHandled)</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }
  }
<span style = "background-color:#fdd">  switch (m_ProcessingMode)</span>
  {
    case CONNECTEDMOUSEACTION:
      // finished connected mouse action
<span style = "background-color:#fdd">      if (std::strcmp(p-&gt;GetNameOfClass(), "MouseReleaseEvent") == 0)</span>
      {
<span style = "background-color:#fdd">        m_ProcessingMode = REGULAR;</span>

<span style = "background-color:#fdd">        if (!m_SelectedInteractor.IsExpired())
          eventIsHandled = m_SelectedInteractor.Lock()-&gt;HandleEvent(event, m_SelectedInteractor.Lock()-&gt;GetDataNode());</span>

<span style = "background-color:#fdd">        m_SelectedInteractor = nullptr;</span>
      }
      // give event to selected interactor
<span style = "background-color:#fdd">      if (eventIsHandled == false &amp;&amp; !m_SelectedInteractor.IsExpired())
        eventIsHandled = m_SelectedInteractor.Lock()-&gt;HandleEvent(event, m_SelectedInteractor.Lock()-&gt;GetDataNode());</span>

<span style = "background-color:#fdd">      break;</span>

    case GRABINPUT:
<span style = "background-color:#fdd">      if (!m_SelectedInteractor.IsExpired())</span>
      {
<span style = "background-color:#fdd">        eventIsHandled = m_SelectedInteractor.Lock()-&gt;HandleEvent(event, m_SelectedInteractor.Lock()-&gt;GetDataNode());
        SetEventProcessingMode(m_SelectedInteractor.Lock());</span>
      }

<span style = "background-color:#fdd">      break;</span>

    case PREFERINPUT:
<span style = "background-color:#fdd">      if (!m_SelectedInteractor.IsExpired() &amp;&amp;</span>
          m_SelectedInteractor.Lock()-&gt;HandleEvent(event, m_SelectedInteractor.Lock()-&gt;GetDataNode()) == true)
      {
<span style = "background-color:#fdd">        SetEventProcessingMode(m_SelectedInteractor.Lock());
        eventIsHandled = true;</span>
      }

      break;

    case REGULAR:
      break;
  }

  // Standard behavior. Is executed in STANDARD mode  and PREFERINPUT mode, if preferred interactor rejects event.
<span style = "background-color:#fdd">  if (m_ProcessingMode == REGULAR || (m_ProcessingMode == PREFERINPUT &amp;&amp; eventIsHandled == false))</span>
  {
<span style = "background-color:#fdd">    if (std::strcmp(p-&gt;GetNameOfClass(), "MousePressEvent") == 0)
      RenderingManager::GetInstance()-&gt;SetRenderWindowFocus(event-&gt;GetSender()-&gt;GetRenderWindow());
    m_Interactors.sort(cmp()); // sorts interactors by layer (descending);</span>

    // copy the list to prevent iterator invalidation as executing actions
    // in HandleEvent() can cause the m_Interactors list to be updated
<span style = "background-color:#fdd">    const ListInteractorType tmpInteractorList(m_Interactors);
    ListInteractorType::const_iterator it;
    for (it = tmpInteractorList.cbegin(); it != tmpInteractorList.cend(); ++it)</span>
    {
<span style = "background-color:#fdd">      if (!(*it).IsExpired() &amp;&amp; (*it).Lock()-&gt;HandleEvent(event, (*it).Lock()-&gt;GetDataNode()))</span>
      {
        // Interactor can be deleted during HandleEvent(), so check it again
<span style = "background-color:#fdd">        if (!(*it).IsExpired())</span>
        {
          // if an event is handled several properties are checked, in order to determine the processing mode of the
          // dispatcher
<span style = "background-color:#fdd">          SetEventProcessingMode((*it).Lock());</span>
        }
<span style = "background-color:#fdd">        if (std::strcmp(p-&gt;GetNameOfClass(), "MousePressEvent") == 0 &amp;&amp; m_ProcessingMode == REGULAR)</span>
        {
<span style = "background-color:#fdd">          m_SelectedInteractor = *it;
          m_ProcessingMode = CONNECTEDMOUSEACTION;</span>
        }
<span style = "background-color:#fdd">        eventIsHandled = true;
        break;</span>
      }
<span style = "background-color:#fdd">    }
  }</span>

  /* Notify InteractionEventObserver  */
<span style = "background-color:#fdd">  const std::vector&lt;us::ServiceReference&lt;InteractionEventObserver&gt;&gt; listEventObserver =</span>
    m_EventObserverTracker-&gt;GetServiceReferences();
<span style = "background-color:#fdd">  for (auto it = listEventObserver.cbegin();
       it != listEventObserver.cend();
       ++it)</span>
  {
<span style = "background-color:#fdd">    InteractionEventObserver *interactionEventObserver = m_EventObserverTracker-&gt;GetService(*it);
    if (interactionEventObserver != nullptr)</span>
    {
<span style = "background-color:#fdd">      if (interactionEventObserver-&gt;IsEnabled())</span>
      {
<span style = "background-color:#fdd">        interactionEventObserver-&gt;Notify(event, eventIsHandled);</span>
      }
<span style = "background-color:#fdd">    }
  }</span>

  // Process event queue
<span style = "background-color:#fdd">  if (!m_QueuedEvents.empty())</span>
  {
<span style = "background-color:#fdd">    InteractionEvent::Pointer e = m_QueuedEvents.front();
    m_QueuedEvents.pop_front();
    ProcessEvent(e);
  }
  return eventIsHandled;
}</span>

/*
 * Checks if DataNodes associated with DataInteractors point back to them.
 * If not remove the DataInteractors. (This can happen when s.o. tries to set DataNodes to multiple DataInteractors)
 */
void mitk::Dispatcher::RemoveOrphanedInteractors()
<span style = "background-color:#fdd">{
  for (auto it = m_Interactors.begin(); it != m_Interactors.end();)</span>
  {
<span style = "background-color:#fdd">    if ((*it).IsExpired())</span>
    {
<span style = "background-color:#fdd">      it = m_Interactors.erase(it);
    }</span>
    else
    {
<span style = "background-color:#fdd">      DataNode::Pointer node = (*it).Lock()-&gt;GetDataNode();</span>

<span style = "background-color:#fdd">      if (node.IsNull())</span>
      {
<span style = "background-color:#fdd">        it = m_Interactors.erase(it);
      }</span>
      else
      {
<span style = "background-color:#fdd">        DataInteractor::Pointer interactor = node-&gt;GetDataInteractor();</span>

<span style = "background-color:#fdd">        if (interactor != it-&gt;Lock().GetPointer())</span>
        {
<span style = "background-color:#fdd">          it = m_Interactors.erase(it);
        }</span>
        else
        {
<span style = "background-color:#fdd">          ++it;</span>
        }
<span style = "background-color:#fdd">      }
    }
  }
}</span>

void mitk::Dispatcher::QueueEvent(InteractionEvent *event)
<span style = "background-color:#fdd">{
  m_QueuedEvents.push_back(event);
}</span>

void mitk::Dispatcher::SetEventProcessingMode(DataInteractor *dataInteractor)
<span style = "background-color:#fdd">{
  m_ProcessingMode = dataInteractor-&gt;GetMode();
  if (dataInteractor-&gt;GetMode() != REGULAR)</span>
  {
<span style = "background-color:#fdd">    m_SelectedInteractor = dataInteractor;</span>
  }
<span style = "background-color:#fdd">}</span>

bool mitk::Dispatcher::HandleInternalEvent(InternalEvent *internalEvent)
<span style = "background-color:#fdd">{
  if (internalEvent-&gt;GetSignalName() == DataInteractor::IntDeactivateMe &amp;&amp;</span>
      internalEvent-&gt;GetTargetInteractor() != nullptr)
  {
<span style = "background-color:#fdd">    internalEvent-&gt;GetTargetInteractor()-&gt;GetDataNode()-&gt;SetDataInteractor(nullptr);
    internalEvent-&gt;GetTargetInteractor()-&gt;SetDataNode(nullptr);</span>

<span style = "background-color:#fdd">    mitk::RenderingManager::GetInstance()-&gt;RequestUpdateAll();
    return true;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span></pre>
	</body>
</html>