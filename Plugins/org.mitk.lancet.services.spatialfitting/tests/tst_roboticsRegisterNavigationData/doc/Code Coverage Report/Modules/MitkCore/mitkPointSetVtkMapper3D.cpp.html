<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPointSetVtkMapper3D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPointSetVtkMapper3D.h"
#include "mitkColorProperty.h"
#include "mitkDataNode.h"
#include "mitkPointSet.h"
#include "mitkProperties.h"
#include "mitkVtkPropRenderer.h"

#include &lt;vtkActor.h&gt;
#include &lt;vtkAppendPolyData.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkConeSource.h&gt;
#include &lt;vtkCubeSource.h&gt;
#include &lt;vtkCylinderSource.h&gt;
#include &lt;vtkPolyDataAlgorithm.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkPropAssembly.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkRenderer.h&gt;
#include &lt;vtkSphereSource.h&gt;
#include &lt;vtkTransform.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;
#include &lt;vtkTubeFilter.h&gt;
#include &lt;vtkVectorText.h&gt;

#include &lt;cstdlib&gt;

#include &lt;mitkPropertyObserver.h&gt;
#include &lt;vtk_glew.h&gt;

// constructor LocalStorage
mitk::PointSetVtkMapper3D::LocalStorage::LocalStorage()
<span style = "background-color:#fdd">  : m_NumberOfSelectedAdded(0),
    m_NumberOfUnselectedAdded(0),
    m_NumberOfMarkedAdded(0),
    m_NumberOfHidedAdded(0)
{</span>
  /// All point positions, already in world coordinates
<span style = "background-color:#fdd">  m_WorldPositions = vtkSmartPointer&lt;vtkPoints&gt;::New();</span>
  /// All connections between two points (used for contour drawing)
<span style = "background-color:#fdd">  m_PointConnections = vtkSmartPointer&lt;vtkCellArray&gt;::New(); // m_PointConnections between points</span>

<span style = "background-color:#fdd">  m_vtkSelectedPointList = vtkSmartPointer&lt;vtkAppendPolyData&gt;::New();
  m_vtkUnselectedPointList = vtkSmartPointer&lt;vtkAppendPolyData&gt;::New();
  m_vtkHidedPointList = vtkSmartPointer&lt;vtkAppendPolyData&gt;::New();
  m_vtkMarkedPointList = vtkSmartPointer&lt;vtkAppendPolyData&gt;::New();</span>

<span style = "background-color:#fdd">  m_VtkSelectedPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
  m_VtkUnselectedPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
  m_VtkHidedPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
  m_VtkMarkedPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();</span>

  // creating actors to be able to set transform
<span style = "background-color:#fdd">  m_SelectedActor = vtkSmartPointer&lt;vtkActor&gt;::New();
  m_UnselectedActor = vtkSmartPointer&lt;vtkActor&gt;::New();
  m_HidedActor = vtkSmartPointer&lt;vtkActor&gt;::New();
  m_MarkedActor = vtkSmartPointer&lt;vtkActor&gt;::New();
  m_ContourActor = vtkSmartPointer&lt;vtkActor&gt;::New();</span>

  // propassembly
<span style = "background-color:#fdd">  m_PointsAssembly = vtkSmartPointer&lt;vtkPropAssembly&gt;::New();
}</span>

// destructor LocalStorage
mitk::PointSetVtkMapper3D::LocalStorage::~LocalStorage()
<span style = "background-color:#fdd">{
}</span>


const mitk::PointSet *mitk::PointSetVtkMapper3D::GetInput()
<span style = "background-color:#fdd">{
  return static_cast&lt;const mitk::PointSet *&gt;(GetDataNode()-&gt;GetData());
}</span>

mitk::PointSetVtkMapper3D::PointSetVtkMapper3D()
    : 
<span style = "background-color:#fdd">    m_vtkTextList(nullptr),
    m_PointSize(1.0),
    m_ContourRadius(0.5)
{
}</span>

mitk::PointSetVtkMapper3D::~PointSetVtkMapper3D()
<span style = "background-color:#fdd">{
}</span>

//void mitk::PointSetVtkMapper3D::ReleaseGraphicsResources(vtkWindow *renWin)
//{
//  ls-&gt;m_PointsAssembly-&gt;ReleaseGraphicsResources(renWin);
//
//  ls-&gt;m_SelectedActor-&gt;ReleaseGraphicsResources(renWin);
//  ls-&gt;m_UnselectedActor-&gt;ReleaseGraphicsResources(renWin);
//  ls-&gt;m_ContourActor-&gt;ReleaseGraphicsResources(renWin);
//  ls-&gt;m_HidedActor-&gt;ReleaseGraphicsResources(renWin);
//  ls-&gt;m_MarkedActor-&gt;ReleaseGraphicsResources(renWin);
//}

void mitk::PointSetVtkMapper3D::ReleaseGraphicsResources(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
    LocalStorage* ls = m_LSH.GetLocalStorage(renderer);
    ls-&gt;m_PointsAssembly-&gt;ReleaseGraphicsResources(renderer-&gt;GetRenderWindow());</span>

<span style = "background-color:#fdd">    ls-&gt;m_SelectedActor-&gt;ReleaseGraphicsResources(renderer-&gt;GetRenderWindow());
    ls-&gt;m_UnselectedActor-&gt;ReleaseGraphicsResources(renderer-&gt;GetRenderWindow());
    ls-&gt;m_MarkedActor-&gt;ReleaseGraphicsResources(renderer-&gt;GetRenderWindow());
    ls-&gt;m_HidedActor-&gt;ReleaseGraphicsResources(renderer-&gt;GetRenderWindow());
    ls-&gt;m_ContourActor-&gt;ReleaseGraphicsResources(renderer-&gt;GetRenderWindow());
}</span>

void mitk::PointSetVtkMapper3D::CreateVTKRenderObjects(mitk::BaseRenderer* renderer)
<span style = "background-color:#fdd">{
    LocalStorage* ls = m_LSH.GetLocalStorage(renderer);
    ls-&gt;m_PointsAssembly-&gt;VisibilityOn();</span>

<span style = "background-color:#fdd">  ls-&gt;m_PointsAssembly-&gt;VisibilityOn();</span>

<span style = "background-color:#fdd">  if (ls-&gt;m_PointsAssembly-&gt;GetParts()-&gt;IsItemPresent(ls-&gt;m_SelectedActor))
    ls-&gt;m_PointsAssembly-&gt;RemovePart(ls-&gt;m_SelectedActor);
  if (ls-&gt;m_PointsAssembly-&gt;GetParts()-&gt;IsItemPresent(ls-&gt;m_UnselectedActor))
    ls-&gt;m_PointsAssembly-&gt;RemovePart(ls-&gt;m_UnselectedActor);
  if (ls-&gt;m_PointsAssembly-&gt;GetParts()-&gt;IsItemPresent(ls-&gt;m_ContourActor))
    ls-&gt;m_PointsAssembly-&gt;RemovePart(ls-&gt;m_ContourActor);
  if (ls-&gt;m_PointsAssembly-&gt;GetParts()-&gt;IsItemPresent(ls-&gt;m_HidedActor))
      ls-&gt;m_PointsAssembly-&gt;RemovePart(ls-&gt;m_HidedActor);
  if (ls-&gt;m_PointsAssembly-&gt;GetParts()-&gt;IsItemPresent(ls-&gt;m_MarkedActor))
      ls-&gt;m_PointsAssembly-&gt;RemovePart(ls-&gt;m_MarkedActor);</span>

  // exceptional displaying for PositionTracker -&gt; MouseOrientationTool
  int mapperID;
<span style = "background-color:#fdd">  bool isInputDevice = false;
  if (this-&gt;GetDataNode()-&gt;GetBoolProperty("inputdevice", isInputDevice) &amp;&amp; isInputDevice)</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;GetDataNode()-&gt;GetIntProperty("BaseRendererMapperID", mapperID) &amp;&amp; mapperID == BaseRenderer::Standard3D)
      return; // The event for the PositionTracker came from the 3d widget and  not needs to be displayed</span>
  }

<span style = "background-color:#fdd">  ls-&gt;m_vtkSelectedPointList = vtkSmartPointer&lt;vtkAppendPolyData&gt;::New();
  ls-&gt;m_vtkUnselectedPointList = vtkSmartPointer&lt;vtkAppendPolyData&gt;::New();
  ls-&gt;m_vtkMarkedPointList = vtkSmartPointer&lt;vtkAppendPolyData&gt;::New();
  ls-&gt;m_vtkHidedPointList = vtkSmartPointer&lt;vtkAppendPolyData&gt;::New();</span>
  // get and update the PointSet
<span style = "background-color:#fdd">  mitk::PointSet::Pointer input = const_cast&lt;mitk::PointSet *&gt;(this-&gt;GetInput());</span>

  /* only update the input data, if the property tells us to */
<span style = "background-color:#fdd">  bool update = true;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("updateDataOnRender", update);
  if (update == true)
    input-&gt;Update();</span>

<span style = "background-color:#fdd">  int timestep = this-&gt;GetTimestep();</span>

<span style = "background-color:#fdd">  mitk::PointSet::DataType::Pointer itkPointSet = input-&gt;GetPointSet(timestep);</span>

<span style = "background-color:#fdd">  if (itkPointSet.GetPointer() == nullptr)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_PointsAssembly-&gt;VisibilityOff();
    return;</span>
  }

  // now fill selected and unselected pointList
  // get size of Points in Property
<span style = "background-color:#fdd">  m_PointSize = 2;
  mitk::FloatProperty::Pointer pointSizeProp =</span>
    dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("pointsize"));
<span style = "background-color:#fdd">  if (pointSizeProp.IsNotNull())
    m_PointSize = pointSizeProp-&gt;GetValue();</span>

  // get the property for creating a label onto every point only once
<span style = "background-color:#fdd">  bool showLabel = true;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("show label", showLabel);
  const char *pointLabel = nullptr;
  if (showLabel)</span>
  {
<span style = "background-color:#fdd">    if (dynamic_cast&lt;mitk::StringProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList()-&gt;GetProperty("label")) != nullptr)
      pointLabel =</span>
        dynamic_cast&lt;mitk::StringProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList()-&gt;GetProperty("label"))-&gt;GetValue();
    else
<span style = "background-color:#fdd">      showLabel = false;</span>
  }

  // whether or not to creat a "contour" - connecting lines between all the points
<span style = "background-color:#fdd">  int nbPoints = itkPointSet-&gt;GetPointData()-&gt;Size();
  bool makeContour = false;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("show contour", makeContour);</span>

<span style = "background-color:#fdd">  bool closeContour = false;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("close contour", closeContour);
  int contourPointLimit = 0; // NO contour
  if (makeContour)</span>
  {
<span style = "background-color:#fdd">    if (closeContour)
      contourPointLimit = nbPoints;</span>
    else
<span style = "background-color:#fdd">      contourPointLimit = nbPoints - 1;</span>
  }

  // build list of all positions for later transform in one go
<span style = "background-color:#fdd">  mitk::PointSet::PointsContainer::Iterator pointsIter;</span>
  int ptIdx;

<span style = "background-color:#fdd">  ls-&gt;m_NumberOfSelectedAdded = 0;
  ls-&gt;m_NumberOfUnselectedAdded = 0;
  ls-&gt;m_NumberOfHidedAdded = 0;
  ls-&gt;m_NumberOfMarkedAdded = 0;
  vtkSmartPointer&lt;vtkPoints&gt; localPoints = vtkSmartPointer&lt;vtkPoints&gt;::New();
  ls-&gt;m_WorldPositions = vtkSmartPointer&lt;vtkPoints&gt;::New();
  ls-&gt;m_PointConnections = vtkSmartPointer&lt;vtkCellArray&gt;::New(); // m_PointConnections between points
  for (ptIdx = 0, pointsIter = itkPointSet-&gt;GetPoints()-&gt;Begin(); pointsIter != itkPointSet-&gt;GetPoints()-&gt;End();
       pointsIter++, ptIdx++)</span>
  {
<span style = "background-color:#fdd">    itk::Point&lt;float&gt; currentPoint = pointsIter-&gt;Value();
    localPoints-&gt;InsertPoint(ptIdx, currentPoint[0], currentPoint[1], currentPoint[2]);</span>

<span style = "background-color:#fdd">    if (makeContour &amp;&amp; ptIdx &lt; contourPointLimit)</span>
    {
<span style = "background-color:#fdd">      vtkIdType cell[2] = {(ptIdx + 1) % nbPoints, ptIdx};
      ls-&gt;m_PointConnections-&gt;InsertNextCell(2, cell);</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkLinearTransform&gt; vtktransform = this-&gt;GetDataNode()-&gt;GetVtkTransform(this-&gt;GetTimestep());
  vtktransform-&gt;TransformPoints(localPoints, ls-&gt;m_WorldPositions);</span>

  // create contour
<span style = "background-color:#fdd">  if (makeContour)</span>
  {
<span style = "background-color:#fdd">      this-&gt;CreateContour(ls-&gt;m_WorldPositions, ls-&gt;m_PointConnections, renderer);</span>
  }

  // check if the list for the PointDataContainer is the same size as the PointsContainer. Is not, then the points were
  // inserted manually and can not be visualized according to the PointData (selected/unselected)
<span style = "background-color:#fdd">  bool pointDataBroken = (itkPointSet-&gt;GetPointData()-&gt;Size() != itkPointSet-&gt;GetPoints()-&gt;Size());</span>

  // now add an object for each point in data
<span style = "background-color:#fdd">  mitk::PointSet::PointDataContainer::Iterator pointDataIter = itkPointSet-&gt;GetPointData()-&gt;Begin();
  for (ptIdx = 0; ptIdx &lt; nbPoints; ++ptIdx) // pointDataIter moved at end of loop</span>
  {
    double currentPoint[3];
<span style = "background-color:#fdd">    ls-&gt;m_WorldPositions-&gt;GetPoint(ptIdx, currentPoint);
    vtkSmartPointer&lt;vtkPolyDataAlgorithm&gt; source;</span>

    // check for the pointtype in data and decide which geom-object to take and then add to the selected or unselected
    // list
    int pointType;
<span style = "background-color:#fdd">    if (itkPointSet-&gt;GetPointData()-&gt;size() == 0 || pointDataBroken)
      pointType = mitk::PTUNDEFINED;</span>
    else
<span style = "background-color:#fdd">      pointType = pointDataIter.Value().pointSpec;</span>

<span style = "background-color:#fdd">    switch (pointType)</span>
    {
      case mitk::PTUNDEFINED:
      {
<span style = "background-color:#fdd">        vtkSmartPointer&lt;vtkSphereSource&gt; sphere = vtkSmartPointer&lt;vtkSphereSource&gt;::New();
        sphere-&gt;SetRadius(m_PointSize / 2.0f);
        sphere-&gt;SetCenter(currentPoint);</span>
        // sphere-&gt;SetCenter(pointsIter.Value()[0],pointsIter.Value()[1],pointsIter.Value()[2]);

        // MouseOrientation Tool (PositionTracker)
<span style = "background-color:#fdd">        if (isInputDevice)</span>
        {
<span style = "background-color:#fdd">          sphere-&gt;SetThetaResolution(10);
          sphere-&gt;SetPhiResolution(10);
        }</span>
        else
        {
<span style = "background-color:#fdd">          sphere-&gt;SetThetaResolution(20);
          sphere-&gt;SetPhiResolution(20);</span>
        }
<span style = "background-color:#fdd">        source = sphere;
      }
      break;</span>
      case mitk::PTSTART:
      {
<span style = "background-color:#fdd">        vtkSmartPointer&lt;vtkCubeSource&gt; cube = vtkSmartPointer&lt;vtkCubeSource&gt;::New();
        cube-&gt;SetXLength(m_PointSize / 2);
        cube-&gt;SetYLength(m_PointSize / 2);
        cube-&gt;SetZLength(m_PointSize / 2);
        cube-&gt;SetCenter(currentPoint);
        source = cube;
      }
      break;</span>
      case mitk::PTCORNER:
      {
<span style = "background-color:#fdd">        vtkSmartPointer&lt;vtkConeSource&gt; cone = vtkSmartPointer&lt;vtkConeSource&gt;::New();
        cone-&gt;SetRadius(m_PointSize / 2.0f);
        cone-&gt;SetCenter(currentPoint);
        cone-&gt;SetResolution(20);
        source = cone;
      }
      break;</span>
      case mitk::PTEDGE:
      {
<span style = "background-color:#fdd">        vtkSmartPointer&lt;vtkCylinderSource&gt; cylinder = vtkSmartPointer&lt;vtkCylinderSource&gt;::New();
        cylinder-&gt;SetRadius(m_PointSize / 2.0f);
        cylinder-&gt;SetCenter(currentPoint);
        cylinder-&gt;SetResolution(20);
        source = cylinder;
      }
      break;</span>
      case mitk::PTEND:
      {
<span style = "background-color:#fdd">        vtkSmartPointer&lt;vtkSphereSource&gt; sphere = vtkSmartPointer&lt;vtkSphereSource&gt;::New();
        sphere-&gt;SetRadius(m_PointSize / 2.0f);</span>
        // no SetCenter?? this functionality should be explained!
        // otherwise: join with default block!
<span style = "background-color:#fdd">        sphere-&gt;SetThetaResolution(20);
        sphere-&gt;SetPhiResolution(20);
        source = sphere;
      }
      break;</span>

      // case PBIG:
      // {
      //     vtkSmartPointer&lt;vtkSphereSource&gt; sphere = vtkSmartPointer&lt;vtkSphereSource&gt;::New();
      //     sphere-&gt;SetRadius((m_PointSize+1) / 2.0f);
      //     sphere-&gt;SetCenter(currentPoint);
      //     sphere-&gt;SetThetaResolution(20);
      //     sphere-&gt;SetPhiResolution(20);
      //     source = sphere;
      // }
      // break;
      // case PSMALL:
      // {
      //     vtkSmartPointer&lt;vtkSphereSource&gt; sphere = vtkSmartPointer&lt;vtkSphereSource&gt;::New();
      //     ScalarType pointsize = 1;
      //     if (m_PointSize&gt;1)
      //     {
      //         pointsize = m_PointSize - 1;
      //     }
      //     else
      //     {
      //         pointsize = m_PointSize;
      //     }
      //     sphere-&gt;SetRadius(pointsize / 2.0f);
      //     sphere-&gt;SetCenter(currentPoint);
      //     sphere-&gt;SetThetaResolution(20);
      //     sphere-&gt;SetPhiResolution(20);
      //     source = sphere;
      // }
      //break;
      default:
      {
<span style = "background-color:#fdd">        vtkSmartPointer&lt;vtkSphereSource&gt; sphere = vtkSmartPointer&lt;vtkSphereSource&gt;::New();
        sphere-&gt;SetRadius(m_PointSize / 2.0f);
        sphere-&gt;SetCenter(currentPoint);
        sphere-&gt;SetThetaResolution(20);
        sphere-&gt;SetPhiResolution(20);
        source = sphere;
      }</span>
      break;
    }
   
<span style = "background-color:#fdd">    if (pointDataIter.Value().selected &amp;&amp; !pointDataBroken)</span>
    {
<span style = "background-color:#fdd">        ls-&gt;m_vtkSelectedPointList-&gt;AddInputConnection(source-&gt;GetOutputPort());
      ++ls-&gt;m_NumberOfSelectedAdded;
    }</span>
    // else if (pointDataIter.Value().hided &amp;&amp; !pointDataBroken)
    // {
    //     ls-&gt;m_vtkHidedPointList-&gt;AddInputConnection(source-&gt;GetOutputPort());
    //     ++ls-&gt;m_NumberOfHidedAdded;
    // }
    // else if (pointDataIter.Value().marked &amp;&amp; !pointDataBroken)
    // {
    //     ls-&gt;m_vtkMarkedPointList-&gt;AddInputConnection(source-&gt;GetOutputPort());
    //     ++ls-&gt;m_NumberOfMarkedAdded;
    // }
    else
    {
<span style = "background-color:#fdd">        ls-&gt;m_vtkUnselectedPointList-&gt;AddInputConnection(source-&gt;GetOutputPort());
      ++ls-&gt;m_NumberOfUnselectedAdded;</span>
    }
<span style = "background-color:#fdd">    if (showLabel)</span>
    {
      char buffer[20];
<span style = "background-color:#fdd">      std::string l = pointLabel;
      if (input-&gt;GetSize() &gt; 1)</span>
      {
<span style = "background-color:#fdd">        sprintf(buffer, "%d", ptIdx + 1);
        l.append(buffer);</span>
      }
      // Define the text for the label
<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkVectorText&gt; label = vtkSmartPointer&lt;vtkVectorText&gt;::New();
      label-&gt;SetText(l.c_str());</span>

      //# Set up a transform to move the label to a new position.
<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkTransform&gt; aLabelTransform = vtkSmartPointer&lt;vtkTransform&gt;::New();
      aLabelTransform-&gt;Identity();
      aLabelTransform-&gt;Translate(currentPoint[0] + 2, currentPoint[1] + 2, currentPoint[2]);
      aLabelTransform-&gt;Scale(5.7, 5.7, 5.7);</span>

      //# Move the label to a new position.
<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt; labelTransform = vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt;::New();
      labelTransform-&gt;SetTransform(aLabelTransform);
      labelTransform-&gt;SetInputConnection(label-&gt;GetOutputPort());</span>

      // add it to the wright PointList
<span style = "background-color:#fdd">      if (pointType)</span>
      {
<span style = "background-color:#fdd">          ls-&gt;m_vtkSelectedPointList-&gt;AddInputConnection(labelTransform-&gt;GetOutputPort());
        ++ls-&gt;m_NumberOfSelectedAdded;
      }</span>
      else
      {
<span style = "background-color:#fdd">          ls-&gt;m_vtkUnselectedPointList-&gt;AddInputConnection(labelTransform-&gt;GetOutputPort());
        ++ls-&gt;m_NumberOfUnselectedAdded;</span>
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    if (pointDataIter != itkPointSet-&gt;GetPointData()-&gt;End())
      pointDataIter++;
  } // end FOR</span>

  // now according to number of elements added to selected or unselected, build up the rendering pipeline
<span style = "background-color:#fdd">  if (ls-&gt;m_NumberOfSelectedAdded &gt; 0)</span>
  {
<span style = "background-color:#fdd">      ls-&gt;m_VtkSelectedPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
      ls-&gt;m_VtkSelectedPolyDataMapper-&gt;SetInputConnection(ls-&gt;m_vtkSelectedPointList-&gt;GetOutputPort());</span>

    // create a new instance of the actor
<span style = "background-color:#fdd">    ls-&gt;m_SelectedActor = vtkSmartPointer&lt;vtkActor&gt;::New();</span>

<span style = "background-color:#fdd">    ls-&gt;m_SelectedActor-&gt;SetMapper(ls-&gt;m_VtkSelectedPolyDataMapper);
    ls-&gt;m_PointsAssembly-&gt;AddPart(ls-&gt;m_SelectedActor);</span>
  }

<span style = "background-color:#fdd">  if (ls-&gt;m_NumberOfUnselectedAdded &gt; 0)</span>
  {
<span style = "background-color:#fdd">      ls-&gt;m_VtkUnselectedPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
      ls-&gt;m_VtkUnselectedPolyDataMapper-&gt;SetInputConnection(ls-&gt;m_vtkUnselectedPointList-&gt;GetOutputPort());</span>

    // create a new instance of the actor
<span style = "background-color:#fdd">    ls-&gt;m_UnselectedActor = vtkSmartPointer&lt;vtkActor&gt;::New();</span>

<span style = "background-color:#fdd">    ls-&gt;m_UnselectedActor-&gt;SetMapper(ls-&gt;m_VtkUnselectedPolyDataMapper);
    ls-&gt;m_PointsAssembly-&gt;AddPart(ls-&gt;m_UnselectedActor);</span>
  }

<span style = "background-color:#fdd">  if (ls-&gt;m_NumberOfHidedAdded &gt; 0)</span>
  {
<span style = "background-color:#fdd">      ls-&gt;m_VtkHidedPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
      ls-&gt;m_VtkHidedPolyDataMapper-&gt;SetInputConnection(ls-&gt;m_vtkHidedPointList-&gt;GetOutputPort());</span>

      // create a new instance of the actor
<span style = "background-color:#fdd">      ls-&gt;m_HidedActor = vtkSmartPointer&lt;vtkActor&gt;::New();</span>

<span style = "background-color:#fdd">      ls-&gt;m_HidedActor-&gt;SetMapper(ls-&gt;m_VtkHidedPolyDataMapper);
      ls-&gt;m_PointsAssembly-&gt;AddPart(ls-&gt;m_HidedActor);</span>
  }

<span style = "background-color:#fdd">  if (ls-&gt;m_NumberOfMarkedAdded &gt; 0)</span>
  {
<span style = "background-color:#fdd">      ls-&gt;m_VtkMarkedPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
      ls-&gt;m_VtkMarkedPolyDataMapper-&gt;SetInputConnection(ls-&gt;m_vtkMarkedPointList-&gt;GetOutputPort());</span>

      // create a new instance of the actor
<span style = "background-color:#fdd">      ls-&gt;m_MarkedActor = vtkSmartPointer&lt;vtkActor&gt;::New();</span>

<span style = "background-color:#fdd">      ls-&gt;m_MarkedActor-&gt;SetMapper(ls-&gt;m_VtkMarkedPolyDataMapper);
      ls-&gt;m_PointsAssembly-&gt;AddPart(ls-&gt;m_MarkedActor);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::PointSetVtkMapper3D::GenerateDataForRenderer(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  LocalStorage* ls = m_LSH.GetLocalStorage(renderer);
  bool visible = true;
  GetDataNode()-&gt;GetVisibility(visible, renderer, "visible");
  if (!visible)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_UnselectedActor-&gt;VisibilityOff();
    ls-&gt;m_SelectedActor-&gt;VisibilityOff();
    ls-&gt;m_ContourActor-&gt;VisibilityOff();
    ls-&gt;m_MarkedActor-&gt;VisibilityOff();
    ls-&gt;m_HidedActor-&gt;VisibilityOff();
    return;</span>
  }

  // create new vtk render objects (e.g. sphere for a point)
  //BaseLocalStorage *ls = m_LSH.GetLocalStorage(renderer);
<span style = "background-color:#fdd">  bool needGenerateData = ls-&gt;IsGenerateDataRequired(renderer, this, GetDataNode());</span>

<span style = "background-color:#fdd">  if (!needGenerateData)</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;GetDataNode()-&gt;GetPropertyList()-&gt;GetMTime() &gt; ls-&gt;GetLastGenerateDataTime() ||</span>
        this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetMTime() &gt; ls-&gt;GetLastGenerateDataTime())
    {
<span style = "background-color:#fdd">      needGenerateData = true;</span>
    }
  }

<span style = "background-color:#fdd">  if (needGenerateData)</span>
  {
<span style = "background-color:#fdd">    this-&gt;CreateVTKRenderObjects(renderer);
    ls-&gt;UpdateGenerateDataTime();</span>
  }

<span style = "background-color:#fdd">  this-&gt;ApplyAllProperties(renderer, ls-&gt;m_ContourActor);</span>

<span style = "background-color:#fdd">  bool showPoints = true;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("show points", showPoints);</span>

<span style = "background-color:#fdd">  ls-&gt;m_UnselectedActor-&gt;SetVisibility(showPoints);
  ls-&gt;m_SelectedActor-&gt;SetVisibility(showPoints);
  ls-&gt;m_MarkedActor-&gt;SetVisibility(showPoints);
  ls-&gt;m_HidedActor-&gt;SetVisibility(false);</span>

<span style = "background-color:#fdd">  if (false &amp;&amp; dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("opacity")) != nullptr)</span>
  {
<span style = "background-color:#fdd">    mitk::FloatProperty::Pointer pointOpacity =</span>
      dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("opacity"));
<span style = "background-color:#fdd">    float opacity = pointOpacity-&gt;GetValue();
    ls-&gt;m_ContourActor-&gt;GetProperty()-&gt;SetOpacity(opacity);
    ls-&gt;m_UnselectedActor-&gt;GetProperty()-&gt;SetOpacity(opacity);
    ls-&gt;m_SelectedActor-&gt;GetProperty()-&gt;SetOpacity(opacity);
  }</span>

<span style = "background-color:#fdd">  bool showContour = false;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("show contour", showContour);
  ls-&gt;m_ContourActor-&gt;SetVisibility(showContour);
}</span>

void mitk::PointSetVtkMapper3D::ResetMapper(BaseRenderer * renderer)
<span style = "background-color:#fdd">{
    LocalStorage* ls = m_LSH.GetLocalStorage(renderer);
  ls-&gt;m_PointsAssembly-&gt;VisibilityOff();
}</span>

vtkProp *mitk::PointSetVtkMapper3D::GetVtkProp(mitk::BaseRenderer * renderer)
<span style = "background-color:#fdd">{
    LocalStorage* ls = m_LSH.GetLocalStorage(renderer);
  return ls-&gt;m_PointsAssembly;
}</span>

void mitk::PointSetVtkMapper3D::UpdateVtkTransform(mitk::BaseRenderer * /*renderer*/)
<span style = "background-color:#fdd">{
}</span>

void mitk::PointSetVtkMapper3D::ApplyAllProperties(mitk::BaseRenderer *renderer, vtkActor *actor)
<span style = "background-color:#fdd">{
    LocalStorage* ls = m_LSH.GetLocalStorage(renderer);
  Superclass::ApplyColorAndOpacityProperties(renderer, actor);</span>
  // check for color props and use it for rendering of selected/unselected points and contour
  // due to different params in VTK (double/float) we have to convert!

  // vars to convert to
<span style = "background-color:#fdd">  double unselectedColor[4] = {1.0f, 1.0f, 0.0f, 1.0f}; // yellow
  double selectedColor[4] = {1.0f, 0.0f, 0.0f, 1.0f};   // red
  double contourColor[4] = {1.0f, 0.0f, 0.0f, 1.0f};    // red
  double markedColor[4] = { 0.0f, 1.0f, 0.0f, 1.0f };    // green</span>

  // different types for color!!!
<span style = "background-color:#fdd">  mitk::Color tmpColor;
  double opacity = 1.0;</span>

  // check if there is an unselected property
  if (dynamic_cast&lt;mitk::ColorProperty *&gt;(
<span style = "background-color:#fdd">        this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("unselectedcolor")) != nullptr)</span>
  {
<span style = "background-color:#fdd">    tmpColor = dynamic_cast&lt;mitk::ColorProperty *&gt;(</span>
                 this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("unselectedcolor"))
                 -&gt;GetValue();
<span style = "background-color:#fdd">    unselectedColor[0] = tmpColor[0];
    unselectedColor[1] = tmpColor[1];
    unselectedColor[2] = tmpColor[2];
    unselectedColor[3] = 1.0f; //!!define a new ColorProp to be able to pass alpha value
  }</span>
  else if (dynamic_cast&lt;mitk::ColorProperty *&gt;(
<span style = "background-color:#fdd">             this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("unselectedcolor")) != nullptr)</span>
  {
<span style = "background-color:#fdd">    tmpColor =</span>
      dynamic_cast&lt;mitk::ColorProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("unselectedcolor"))
        -&gt;GetValue();
<span style = "background-color:#fdd">    unselectedColor[0] = tmpColor[0];
    unselectedColor[1] = tmpColor[1];
    unselectedColor[2] = tmpColor[2];
    unselectedColor[3] = 1.0f; //!!define a new ColorProp to be able to pass alpha value
  }</span>
  else
  {
    // check if the node has a color
<span style = "background-color:#fdd">    float unselectedColorTMP[4] = {1.0f, 1.0f, 0.0f, 1.0f}; // yellow
    m_DataNode-&gt;GetColor(unselectedColorTMP, nullptr);
    unselectedColor[0] = unselectedColorTMP[0];
    unselectedColor[1] = unselectedColorTMP[1];
    unselectedColor[2] = unselectedColorTMP[2];</span>
    // unselectedColor[3] stays 1.0f
  }

  // get selected property
  if (dynamic_cast&lt;mitk::ColorProperty *&gt;(
<span style = "background-color:#fdd">        this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("selectedcolor")) != nullptr)</span>
  {
<span style = "background-color:#fdd">    tmpColor =</span>
      dynamic_cast&lt;mitk::ColorProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("selectedcolor"))
        -&gt;GetValue();
<span style = "background-color:#fdd">    selectedColor[0] = tmpColor[0];
    selectedColor[1] = tmpColor[1];
    selectedColor[2] = tmpColor[2];
    selectedColor[3] = 1.0f;
  }</span>
  else if (dynamic_cast&lt;mitk::ColorProperty *&gt;(
<span style = "background-color:#fdd">             this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("selectedcolor")) != nullptr)</span>
  {
<span style = "background-color:#fdd">    tmpColor =</span>
      dynamic_cast&lt;mitk::ColorProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("selectedcolor"))
        -&gt;GetValue();
<span style = "background-color:#fdd">    selectedColor[0] = tmpColor[0];
    selectedColor[1] = tmpColor[1];
    selectedColor[2] = tmpColor[2];
    selectedColor[3] = 1.0f;</span>
  }

  // get contour property
  if (dynamic_cast&lt;mitk::ColorProperty *&gt;(
<span style = "background-color:#fdd">        this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("contourcolor")) != nullptr)</span>
  {
<span style = "background-color:#fdd">    tmpColor =</span>
      dynamic_cast&lt;mitk::ColorProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("contourcolor"))
        -&gt;GetValue();
<span style = "background-color:#fdd">    contourColor[0] = tmpColor[0];
    contourColor[1] = tmpColor[1];
    contourColor[2] = tmpColor[2];
    contourColor[3] = 1.0f;
  }</span>
  else if (dynamic_cast&lt;mitk::ColorProperty *&gt;(
<span style = "background-color:#fdd">             this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("contourcolor")) != nullptr)</span>
  {
<span style = "background-color:#fdd">    tmpColor =</span>
      dynamic_cast&lt;mitk::ColorProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("contourcolor"))
        -&gt;GetValue();
<span style = "background-color:#fdd">    contourColor[0] = tmpColor[0];
    contourColor[1] = tmpColor[1];
    contourColor[2] = tmpColor[2];
    contourColor[3] = 1.0f;</span>
  }

<span style = "background-color:#fdd">  if (dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("opacity")) !=</span>
      nullptr)
  {
<span style = "background-color:#fdd">    mitk::FloatProperty::Pointer pointOpacity =</span>
      dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("opacity"));
<span style = "background-color:#fdd">    opacity = pointOpacity-&gt;GetValue();
  }
  else if (dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("opacity")) !=</span>
           nullptr)
  {
<span style = "background-color:#fdd">    mitk::FloatProperty::Pointer pointOpacity =</span>
      dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("opacity"));
<span style = "background-color:#fdd">    opacity = pointOpacity-&gt;GetValue();
  }</span>
  // finished color / opacity fishing!

  // check if a contour shall be drawn
<span style = "background-color:#fdd">  bool showContour = false;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("show contour", showContour, renderer);
  if (showContour &amp;&amp; (ls-&gt;m_ContourActor != nullptr))</span>
  {
<span style = "background-color:#fdd">    this-&gt;CreateContour(ls-&gt;m_WorldPositions, ls-&gt;m_PointConnections,renderer);
    ls-&gt;m_ContourActor-&gt;GetProperty()-&gt;SetColor(contourColor);
    ls-&gt;m_ContourActor-&gt;GetProperty()-&gt;SetOpacity(opacity);</span>
  }

<span style = "background-color:#fdd">  ls-&gt;m_SelectedActor-&gt;GetProperty()-&gt;SetColor(selectedColor);
  ls-&gt;m_SelectedActor-&gt;GetProperty()-&gt;SetOpacity(opacity);</span>

<span style = "background-color:#fdd">  ls-&gt;m_UnselectedActor-&gt;GetProperty()-&gt;SetColor(unselectedColor);
  ls-&gt;m_UnselectedActor-&gt;GetProperty()-&gt;SetOpacity(opacity);</span>

<span style = "background-color:#fdd">  ls-&gt;m_MarkedActor-&gt;GetProperty()-&gt;SetColor(markedColor);
  ls-&gt;m_MarkedActor-&gt;GetProperty()-&gt;SetOpacity(opacity);
}</span>

void mitk::PointSetVtkMapper3D::CreateContour(vtkPoints* points, vtkCellArray* PointConnections, mitk::BaseRenderer* renderer)
<span style = "background-color:#fdd">{
    LocalStorage* ls = m_LSH.GetLocalStorage(renderer);
  vtkSmartPointer&lt;vtkAppendPolyData&gt; vtkContourPolyData = vtkSmartPointer&lt;vtkAppendPolyData&gt;::New();
  vtkSmartPointer&lt;vtkPolyDataMapper&gt; vtkContourPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPolyData&gt; contour = vtkSmartPointer&lt;vtkPolyData&gt;::New();
  contour-&gt;SetPoints(points);
  contour-&gt;SetLines(PointConnections);</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkTubeFilter&gt; tubeFilter = vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
  tubeFilter-&gt;SetNumberOfSides(12);
  tubeFilter-&gt;SetInputData(contour);</span>

  // check for property contoursize.
<span style = "background-color:#fdd">  m_ContourRadius = 0.5;
  mitk::FloatProperty::Pointer contourSizeProp =</span>
    dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("contoursize"));

<span style = "background-color:#fdd">  if (contourSizeProp.IsNotNull())
    m_ContourRadius = contourSizeProp-&gt;GetValue();</span>

<span style = "background-color:#fdd">  tubeFilter-&gt;SetRadius(m_ContourRadius);
  tubeFilter-&gt;Update();</span>

  // add to pipeline
<span style = "background-color:#fdd">  vtkContourPolyData-&gt;AddInputConnection(tubeFilter-&gt;GetOutputPort());
  vtkContourPolyDataMapper-&gt;SetInputConnection(vtkContourPolyData-&gt;GetOutputPort());</span>

<span style = "background-color:#fdd">  ls-&gt;m_ContourActor-&gt;SetMapper(vtkContourPolyDataMapper);
  ls-&gt;m_PointsAssembly-&gt;AddPart(ls-&gt;m_ContourActor);
}</span>

void mitk::PointSetVtkMapper3D::SetDefaultProperties(mitk::DataNode *node, mitk::BaseRenderer *renderer, bool overwrite)
<span style = "background-color:#fdd">{
  node-&gt;AddProperty("line width", mitk::IntProperty::New(2), renderer, overwrite);
  node-&gt;AddProperty("pointsize", mitk::FloatProperty::New(1.0), renderer, overwrite);
  node-&gt;AddProperty("selectedcolor", mitk::ColorProperty::New(1.0f, 0.0f, 0.0f), renderer, overwrite); // red
  node-&gt;AddProperty("color", mitk::ColorProperty::New(1.0f, 1.0f, 0.0f), renderer, overwrite);         // yellow
  node-&gt;AddProperty("opacity", mitk::FloatProperty::New(1.0f), renderer, overwrite);
  node-&gt;AddProperty("show contour", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("close contour", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("contourcolor", mitk::ColorProperty::New(1.0f, 0.0f, 0.0f), renderer, overwrite);
  node-&gt;AddProperty("contoursize", mitk::FloatProperty::New(0.5), renderer, overwrite);
  node-&gt;AddProperty("show points", mitk::BoolProperty::New(true), renderer, overwrite);
  node-&gt;AddProperty("updateDataOnRender", mitk::BoolProperty::New(true), renderer, overwrite);
  Superclass::SetDefaultProperties(node, renderer, overwrite);
}</span></pre>
	</body>
</html>