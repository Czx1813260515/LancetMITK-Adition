<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkCoreObjectFactory.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkCoreObjectFactory.h"
#include "mitkConfig.h"

#include "mitkColorProperty.h"
#include "mitkDataNode.h"
#include "mitkEnumerationProperty.h"
#include "mitkGeometry3D.h"
#include "mitkGeometryData.h"
#include "mitkImage.h"
#include "mitkLevelWindowProperty.h"
#include "mitkLookupTable.h"
#include "mitkLookupTableProperty.h"
#include "mitkPlaneGeometry.h"
#include "mitkPlaneGeometryData.h"
#include "mitkPlaneGeometryDataMapper2D.h"
#include "mitkPlaneGeometryDataVtkMapper3D.h"
#include "mitkPointSet.h"
#include "mitkPointSetVtkMapper2D.h"
#include "mitkPointSetVtkMapper3D.h"
#include "mitkProperties.h"
#include "mitkPropertyList.h"
#include "mitkSlicedGeometry3D.h"
#include "mitkSmartPointerProperty.h"
#include "mitkStringProperty.h"
#include "mitkSurface.h"
#include "mitkSurface.h"
#include "mitkSurfaceVtkMapper2D.h"
#include "mitkSurfaceVtkMapper3D.h"
#include "mitkTimeGeometry.h"
#include "mitkTransferFunctionProperty.h"
#include "mitkVtkInterpolationProperty.h"
#include "mitkVtkRepresentationProperty.h"
#include "mitkVtkResliceInterpolationProperty.h"
#include &lt;mitkImageVtkMapper2D.h&gt;

// Legacy Support:
#include &lt;mitkCoreServices.h&gt;
#include &lt;mitkLegacyFileReaderService.h&gt;
#include &lt;mitkLegacyFileWriterService.h&gt;

void mitk::CoreObjectFactory::RegisterExtraFactory(CoreObjectFactoryBase *factory)
<span style = "background-color:#dfd">{
  MITK_DEBUG &lt;&lt; "CoreObjectFactory: registering extra factory of type " &lt;&lt; factory-&gt;GetNameOfClass();
  m_ExtraFactories.insert(CoreObjectFactoryBase::Pointer(factory));</span>
  // Register Legacy Reader and Writer
<span style = "background-color:#dfd">  this-&gt;RegisterLegacyReaders(factory);
  this-&gt;RegisterLegacyWriters(factory);
}</span>

void mitk::CoreObjectFactory::UnRegisterExtraFactory(CoreObjectFactoryBase *factory)
<span style = "background-color:#dfd">{
  MITK_DEBUG &lt;&lt; "CoreObjectFactory: un-registering extra factory of type " &lt;&lt; factory-&gt;GetNameOfClass();
  this-&gt;UnRegisterLegacyWriters(factory);
  this-&gt;UnRegisterLegacyReaders(factory);</span>
  try
  {
<span style = "background-color:#dfd">    m_ExtraFactories.erase(factory);</span>
  }
  catch ( const std::exception &amp;e )
<span style = "background-color:#fdd">  {
    MITK_ERROR &lt;&lt; "Caugt exception while unregistering: " &lt;&lt; e.what();
  }</span>
<span style = "background-color:#dfd">}</span>

mitk::CoreObjectFactory::Pointer mitk::CoreObjectFactory::GetInstance()
<span style = "background-color:#dfd">{
  static mitk::CoreObjectFactory::Pointer instance;
  if (instance.IsNull())</span>
  {
<span style = "background-color:#dfd">    instance = mitk::CoreObjectFactory::New();</span>
  }
<span style = "background-color:#dfd">  return instance;
}</span>

mitk::CoreObjectFactory::~CoreObjectFactory()
<span style = "background-color:#dfd">{
  for (auto iter =</span>
         m_LegacyReaders.begin();
<span style = "background-color:#dfd">       iter != m_LegacyReaders.end();</span>
<span style = "background-color:#fdd">       ++iter)</span>
  {
<span style = "background-color:#fdd">    for (auto &amp;elem : iter-&gt;second)</span>
    {
<span style = "background-color:#fdd">      delete elem;
    }
  }</span>

<span style = "background-color:#dfd">  for (auto iter =</span>
         m_LegacyWriters.begin();
<span style = "background-color:#dfd">       iter != m_LegacyWriters.end();</span>
<span style = "background-color:#fdd">       ++iter)</span>
  {
<span style = "background-color:#fdd">    for (auto &amp;elem : iter-&gt;second)</span>
    {
<span style = "background-color:#fdd">      delete elem;
    }
  }</span>
<span style = "background-color:#dfd">}</span>

void mitk::CoreObjectFactory::SetDefaultProperties(mitk::DataNode *node)
<span style = "background-color:#fdd">{
  if (node == nullptr)
    return;</span>

<span style = "background-color:#fdd">  mitk::DataNode::Pointer nodePointer = node;</span>

<span style = "background-color:#fdd">  mitk::Image::Pointer image = dynamic_cast&lt;mitk::Image *&gt;(node-&gt;GetData());
  if (image.IsNotNull() &amp;&amp; image-&gt;IsInitialized())</span>
  {
<span style = "background-color:#fdd">    mitk::ImageVtkMapper2D::SetDefaultProperties(node);</span>
  }

<span style = "background-color:#fdd">  mitk::PlaneGeometryData::Pointer planeGeometry = dynamic_cast&lt;mitk::PlaneGeometryData *&gt;(node-&gt;GetData());
  if (planeGeometry.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    mitk::PlaneGeometryDataMapper2D::SetDefaultProperties(node);</span>
  }

<span style = "background-color:#fdd">  mitk::Surface::Pointer surface = dynamic_cast&lt;mitk::Surface *&gt;(node-&gt;GetData());
  if (surface.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    mitk::SurfaceVtkMapper2D::SetDefaultProperties(node);
    mitk::SurfaceVtkMapper3D::SetDefaultProperties(node);</span>
  }

<span style = "background-color:#fdd">  mitk::PointSet::Pointer pointSet = dynamic_cast&lt;mitk::PointSet *&gt;(node-&gt;GetData());
  if (pointSet.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    mitk::PointSetVtkMapper2D::SetDefaultProperties(node);
    mitk::PointSetVtkMapper3D::SetDefaultProperties(node);</span>
  }
<span style = "background-color:#fdd">  for (auto it = m_ExtraFactories.begin(); it != m_ExtraFactories.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    (*it)-&gt;SetDefaultProperties(node);
  }
}</span>

mitk::CoreObjectFactory::CoreObjectFactory()
<span style = "background-color:#dfd">{</span>
  static bool alreadyDone = false;
<span style = "background-color:#dfd">  if (!alreadyDone)</span>
  {
<span style = "background-color:#dfd">    CreateFileExtensionsMap();</span>

    // RegisterLegacyReaders(this);
    // RegisterLegacyWriters(this);

<span style = "background-color:#dfd">    alreadyDone = true;</span>
  }
<span style = "background-color:#dfd">}</span>

mitk::Mapper::Pointer mitk::CoreObjectFactory::CreateMapper(mitk::DataNode *node, MapperSlotId id)
<span style = "background-color:#fdd">{
  mitk::Mapper::Pointer newMapper = nullptr;
  mitk::Mapper::Pointer tmpMapper = nullptr;</span>

  // check whether extra factories provide mapper
<span style = "background-color:#fdd">  for (auto it = m_ExtraFactories.begin(); it != m_ExtraFactories.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    tmpMapper = (*it)-&gt;CreateMapper(node, id);
    if (tmpMapper.IsNotNull())
      newMapper = tmpMapper;
  }</span>

<span style = "background-color:#fdd">  if (newMapper.IsNull())</span>
  {
<span style = "background-color:#fdd">    mitk::BaseData *data = node-&gt;GetData();</span>

<span style = "background-color:#fdd">    if (id == mitk::BaseRenderer::Standard2D)</span>
    {
<span style = "background-color:#fdd">      if ((dynamic_cast&lt;Image *&gt;(data) != nullptr))</span>
      {
<span style = "background-color:#fdd">        newMapper = mitk::ImageVtkMapper2D::New();
        newMapper-&gt;SetDataNode(node);
      }
      else if ((dynamic_cast&lt;PlaneGeometryData *&gt;(data) != nullptr))</span>
      {
<span style = "background-color:#fdd">        newMapper = mitk::PlaneGeometryDataMapper2D::New();
        newMapper-&gt;SetDataNode(node);
      }
      else if ((dynamic_cast&lt;Surface *&gt;(data) != nullptr))</span>
      {
<span style = "background-color:#fdd">        newMapper = mitk::SurfaceVtkMapper2D::New();</span>
        // cast because SetDataNode is not virtual
<span style = "background-color:#fdd">        auto *castedMapper = dynamic_cast&lt;mitk::SurfaceVtkMapper2D *&gt;(newMapper.GetPointer());
        castedMapper-&gt;SetDataNode(node);
      }
      else if ((dynamic_cast&lt;PointSet *&gt;(data) != nullptr))</span>
      {
<span style = "background-color:#fdd">        newMapper = mitk::PointSetVtkMapper2D::New();
        newMapper-&gt;SetDataNode(node);</span>
      }
<span style = "background-color:#fdd">    }
    else if (id == mitk::BaseRenderer::Standard3D)</span>
    {
<span style = "background-color:#fdd">      if ((dynamic_cast&lt;PlaneGeometryData *&gt;(data) != nullptr))</span>
      {
<span style = "background-color:#fdd">        newMapper = mitk::PlaneGeometryDataVtkMapper3D::New();
        newMapper-&gt;SetDataNode(node);
      }
      else if ((dynamic_cast&lt;Surface *&gt;(data) != nullptr))</span>
      {
<span style = "background-color:#fdd">        newMapper = mitk::SurfaceVtkMapper3D::New();
        newMapper-&gt;SetDataNode(node);
      }
      else if ((dynamic_cast&lt;PointSet *&gt;(data) != nullptr))</span>
      {
<span style = "background-color:#fdd">        newMapper = mitk::PointSetVtkMapper3D::New();
        newMapper-&gt;SetDataNode(node);</span>
      }
    }
  }

<span style = "background-color:#fdd">  return newMapper;
}</span>

std::string mitk::CoreObjectFactory::GetFileExtensions()
<span style = "background-color:#fdd">{
  MultimapType aMap;
  for (auto it = m_ExtraFactories.begin(); it != m_ExtraFactories.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    aMap = (*it)-&gt;GetFileExtensionsMap();
    this-&gt;MergeFileExtensions(m_FileExtensionsMap, aMap);
  }
  this-&gt;CreateFileExtensions(m_FileExtensionsMap, m_FileExtensions);
  return m_FileExtensions.c_str();
}</span>

void mitk::CoreObjectFactory::MergeFileExtensions(MultimapType &amp;fileExtensionsMap, MultimapType inputMap)
<span style = "background-color:#fdd">{
  std::pair&lt;MultimapType::iterator, MultimapType::iterator&gt; pairOfIter;
  for (auto it = inputMap.begin(); it != inputMap.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    bool duplicateFound = false;
    pairOfIter = fileExtensionsMap.equal_range((*it).first);
    for (auto it2 = pairOfIter.first; it2 != pairOfIter.second; ++it2)</span>
    {
      // cout &lt;&lt; "  [" &lt;&lt; (*it).first &lt;&lt; ", " &lt;&lt; (*it).second &lt;&lt; "]" &lt;&lt; endl;
<span style = "background-color:#fdd">      std::string aString = (*it2).second;
      if (aString.compare((*it).second) == 0)</span>
      {
        // cout &lt;&lt; "  DUP!! [" &lt;&lt; (*it).first &lt;&lt; ", " &lt;&lt; (*it).second &lt;&lt; "]" &lt;&lt; endl;
<span style = "background-color:#fdd">        duplicateFound = true;
        break;</span>
      }
<span style = "background-color:#fdd">    }
    if (!duplicateFound)</span>
    {
<span style = "background-color:#fdd">      fileExtensionsMap.insert(std::pair&lt;std::string, std::string&gt;((*it).first, (*it).second));
    }
  }
}</span>

mitk::CoreObjectFactoryBase::MultimapType mitk::CoreObjectFactory::GetFileExtensionsMap()
<span style = "background-color:#fdd">{
  return m_FileExtensionsMap;
}</span>

void mitk::CoreObjectFactory::CreateFileExtensionsMap()
<span style = "background-color:#dfd">{</span>
  /*
  m_FileExtensionsMap.insert(std::pair&lt;std::string, std::string&gt;("*.dcm", "DICOM files"));
  m_FileExtensionsMap.insert(std::pair&lt;std::string, std::string&gt;("*.DCM", "DICOM files"));
  m_FileExtensionsMap.insert(std::pair&lt;std::string, std::string&gt;("*.dc3", "DICOM files"));
  m_FileExtensionsMap.insert(std::pair&lt;std::string, std::string&gt;("*.DC3", "DICOM files"));
  m_FileExtensionsMap.insert(std::pair&lt;std::string, std::string&gt;("*.gdcm", "DICOM files"));
  m_FileExtensionsMap.insert(std::pair&lt;std::string, std::string&gt;("*.seq", "DKFZ Pic"));
  m_FileExtensionsMap.insert(std::pair&lt;std::string, std::string&gt;("*.seq.gz", "DKFZ Pic"));
  m_FileExtensionsMap.insert(std::pair&lt;std::string, std::string&gt;("*.dcm", "Sets of 2D slices"));
  m_FileExtensionsMap.insert(std::pair&lt;std::string, std::string&gt;("*.gdcm", "Sets of 2D slices"));
  */
<span style = "background-color:#dfd">}</span>

std::string mitk::CoreObjectFactory::GetSaveFileExtensions()
<span style = "background-color:#fdd">{
  MultimapType aMap;
  for (auto it = m_ExtraFactories.begin(); it != m_ExtraFactories.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    aMap = (*it)-&gt;GetSaveFileExtensionsMap();
    this-&gt;MergeFileExtensions(m_SaveFileExtensionsMap, aMap);
  }
  this-&gt;CreateFileExtensions(m_SaveFileExtensionsMap, m_SaveFileExtensions);
  return m_SaveFileExtensions.c_str();
}</span>

mitk::CoreObjectFactoryBase::MultimapType mitk::CoreObjectFactory::GetSaveFileExtensionsMap()
<span style = "background-color:#fdd">{
  return m_SaveFileExtensionsMap;
}</span>

mitk::CoreObjectFactory::FileWriterList mitk::CoreObjectFactory::GetFileWriters()
<span style = "background-color:#fdd">{
  FileWriterList allWriters = m_FileWriters;</span>
  // sort to merge lists later on
  typedef std::set&lt;mitk::FileWriterWithInformation::Pointer&gt; FileWriterSet;
<span style = "background-color:#fdd">  FileWriterSet fileWritersSet;</span>

<span style = "background-color:#fdd">  fileWritersSet.insert(allWriters.begin(), allWriters.end());</span>

  // collect all extra factories
<span style = "background-color:#fdd">  for (auto it = m_ExtraFactories.begin(); it != m_ExtraFactories.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    FileWriterList list2 = (*it)-&gt;GetFileWriters();</span>

    // add them to the sorted set
<span style = "background-color:#fdd">    fileWritersSet.insert(list2.begin(), list2.end());
  }</span>

  // write back to allWriters to return a list
<span style = "background-color:#fdd">  allWriters.clear();
  allWriters.insert(allWriters.end(), fileWritersSet.begin(), fileWritersSet.end());</span>

<span style = "background-color:#fdd">  return allWriters;
}</span>

void mitk::CoreObjectFactory::MapEvent(const mitk::Event *, const int)
<span style = "background-color:#fdd">{
}</span>

std::string mitk::CoreObjectFactory::GetDescriptionForExtension(const std::string &amp;extension)
<span style = "background-color:#fdd">{
  std::multimap&lt;std::string, std::string&gt; fileExtensionMap = GetSaveFileExtensionsMap();
  for (auto it = fileExtensionMap.begin(); it != fileExtensionMap.end();
       ++it)
    if (it-&gt;first == extension)
      return it-&gt;second;
  return ""; // If no matching extension was found, return emtpy string
}</span>

void mitk::CoreObjectFactory::RegisterLegacyReaders(mitk::CoreObjectFactoryBase *factory)
<span style = "background-color:#dfd">{</span>
  // We are not really interested in the string, just call the method since
  // many readers initialize the map the first time when this method is called
<span style = "background-color:#dfd">  factory-&gt;GetFileExtensions();</span>

<span style = "background-color:#dfd">  std::map&lt;std::string, std::vector&lt;std::string&gt;&gt; extensionsByCategories;
  std::multimap&lt;std::string, std::string&gt; fileExtensionMap = factory-&gt;GetFileExtensionsMap();
  for (auto it = fileExtensionMap.begin(); it != fileExtensionMap.end();
       ++it)</span>
  {
<span style = "background-color:#dfd">    std::string extension = it-&gt;first;</span>
    // remove "*."
<span style = "background-color:#dfd">    extension = extension.erase(0, 2);</span>

<span style = "background-color:#dfd">    extensionsByCategories[it-&gt;second].push_back(extension);
  }</span>

<span style = "background-color:#dfd">  for (auto &amp;extensionsByCategorie : extensionsByCategories)</span>
  {
<span style = "background-color:#dfd">    m_LegacyReaders[factory].push_back(</span>
      new mitk::LegacyFileReaderService(extensionsByCategorie.second, extensionsByCategorie.first));
<span style = "background-color:#dfd">  }
}</span>

void mitk::CoreObjectFactory::UnRegisterLegacyReaders(mitk::CoreObjectFactoryBase *factory)
<span style = "background-color:#dfd">{
  auto iter =</span>
    m_LegacyReaders.find(factory);
<span style = "background-color:#dfd">  if (iter != m_LegacyReaders.end())</span>
  {
<span style = "background-color:#dfd">    for (auto &amp;elem : iter-&gt;second)</span>
    {
<span style = "background-color:#dfd">      delete elem;
    }</span>

<span style = "background-color:#dfd">    m_LegacyReaders.erase(iter);</span>
  }
<span style = "background-color:#dfd">}</span>

void mitk::CoreObjectFactory::RegisterLegacyWriters(mitk::CoreObjectFactoryBase *factory)
<span style = "background-color:#dfd">{</span>
  // Get all external Writers
<span style = "background-color:#dfd">  mitk::CoreObjectFactory::FileWriterList writers = factory-&gt;GetFileWriters();</span>

  // We are not really interested in the string, just call the method since
  // many writers initialize the map the first time when this method is called
<span style = "background-color:#dfd">  factory-&gt;GetSaveFileExtensions();</span>

<span style = "background-color:#dfd">  MultimapType fileExtensionMap = factory-&gt;GetSaveFileExtensionsMap();</span>

<span style = "background-color:#dfd">  for (auto it = writers.begin(); it != writers.end(); ++it)</span>
  {
<span style = "background-color:#dfd">    std::vector&lt;std::string&gt; extensions = (*it)-&gt;GetPossibleFileExtensions();
    if (extensions.empty())</span>
<span style = "background-color:#fdd">      continue;</span>

<span style = "background-color:#dfd">    std::string description;
    for (auto ext = extensions.begin(); ext != extensions.end(); ++ext)</span>
    {
<span style = "background-color:#dfd">      if (ext-&gt;empty())</span>
<span style = "background-color:#fdd">        continue;</span>

<span style = "background-color:#dfd">      std::string extension = *ext;
      std::string extensionWithStar = extension;
      if (extension.find_first_of('*') == 0)</span>
      {
        // remove "*."
<span style = "background-color:#fdd">        extension = extension.substr(0, extension.size() - 2);
      }</span>
      else
      {
<span style = "background-color:#dfd">        extensionWithStar.insert(extensionWithStar.begin(), '*');</span>
      }

<span style = "background-color:#dfd">      for (auto fileExtensionIter = fileExtensionMap.begin();
           fileExtensionIter != fileExtensionMap.end();
           ++fileExtensionIter)</span>
      {
<span style = "background-color:#dfd">        if (fileExtensionIter-&gt;first == extensionWithStar)</span>
        {
<span style = "background-color:#dfd">          description = fileExtensionIter-&gt;second;
          break;
        }
      }
      if (!description.empty())
        break;</span>
<span style = "background-color:#fdd">    }</span>
<span style = "background-color:#dfd">    if (description.empty())</span>
    {
<span style = "background-color:#fdd">      description = std::string("Legacy ") + (*it)-&gt;GetNameOfClass() + " Reader";</span>
    }

<span style = "background-color:#dfd">    mitk::FileWriter::Pointer fileWriter(it-&gt;GetPointer());
    mitk::LegacyFileWriterService *lfws = new mitk::LegacyFileWriterService(fileWriter, description);
    m_LegacyWriters[factory].push_back(lfws);
  }
}</span>

void mitk::CoreObjectFactory::UnRegisterLegacyWriters(mitk::CoreObjectFactoryBase *factory)
<span style = "background-color:#dfd">{
  auto iter =</span>
    m_LegacyWriters.find(factory);
<span style = "background-color:#dfd">  if (iter != m_LegacyWriters.end())</span>
  {
<span style = "background-color:#dfd">    for (auto &amp;elem : iter-&gt;second)</span>
    {
<span style = "background-color:#dfd">      delete elem;
    }</span>

<span style = "background-color:#dfd">    m_LegacyWriters.erase(iter);</span>
  }
<span style = "background-color:#dfd">}</span></pre>
	</body>
</html>