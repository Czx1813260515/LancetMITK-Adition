<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageStatisticsHolder.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/
#include "mitkImageStatisticsHolder.h"

#include "mitkHistogramGenerator.h"
#include &lt;mitkProperties.h&gt;
#include "mitkImageAccessByItk.h"
//#define BOUNDINGOBJECT_IGNORE

mitk::ImageStatisticsHolder::ImageStatisticsHolder(mitk::Image *image)
<span style = "background-color:#fdd">  : m_Image(image)
{
  m_CountOfMinValuedVoxels.resize(1, 0);
  m_CountOfMaxValuedVoxels.resize(1, 0);
  m_ScalarMin.resize(1, itk::NumericTraits&lt;ScalarType&gt;::max());
  m_ScalarMax.resize(1, itk::NumericTraits&lt;ScalarType&gt;::NonpositiveMin());
  m_Scalar2ndMin.resize(1, itk::NumericTraits&lt;ScalarType&gt;::max());
  m_Scalar2ndMax.resize(1, itk::NumericTraits&lt;ScalarType&gt;::NonpositiveMin());</span>

<span style = "background-color:#fdd">  mitk::HistogramGenerator::Pointer generator = mitk::HistogramGenerator::New();
  m_HistogramGeneratorObject = generator;
}</span>

mitk::ImageStatisticsHolder::~ImageStatisticsHolder()
<span style = "background-color:#fdd">{
  m_HistogramGeneratorObject = nullptr;
}</span>

const mitk::ImageStatisticsHolder::HistogramType *mitk::ImageStatisticsHolder::GetScalarHistogram(
  int t, unsigned int /*component*/)
<span style = "background-color:#fdd">{
  mitk::ImageTimeSelector *timeSelector = this-&gt;GetTimeSelector();
  if (timeSelector != nullptr)</span>
  {
<span style = "background-color:#fdd">    timeSelector-&gt;SetTimeNr(t);
    timeSelector-&gt;UpdateLargestPossibleRegion();</span>

<span style = "background-color:#fdd">    auto *generator =</span>
      static_cast&lt;mitk::HistogramGenerator *&gt;(m_HistogramGeneratorObject.GetPointer());
<span style = "background-color:#fdd">    generator-&gt;SetImage(timeSelector-&gt;GetOutput());
    generator-&gt;ComputeHistogram();
    return static_cast&lt;const mitk::ImageStatisticsHolder::HistogramType *&gt;(generator-&gt;GetHistogram());</span>
  }
<span style = "background-color:#fdd">  return nullptr;
}</span>

bool mitk::ImageStatisticsHolder::IsValidTimeStep(int t) const
<span style = "background-color:#fdd">{
  return m_Image-&gt;IsValidTimeStep(t);
}</span>

mitk::ImageTimeSelector::Pointer mitk::ImageStatisticsHolder::GetTimeSelector()
<span style = "background-color:#fdd">{
  ImageTimeSelector::Pointer timeSelector =</span>
    ImageTimeSelector::New();
<span style = "background-color:#fdd">  timeSelector-&gt;SetInput(m_Image);</span>

<span style = "background-color:#fdd">  return timeSelector;
}</span>

void mitk::ImageStatisticsHolder::Expand(unsigned int timeSteps)
<span style = "background-color:#fdd">{
  if (!m_Image-&gt;IsValidTimeStep(timeSteps - 1))
    return;</span>

  // The BaseData needs to be expanded, call the mitk::Image::Expand() method
<span style = "background-color:#fdd">  m_Image-&gt;Expand(timeSteps);</span>

<span style = "background-color:#fdd">  if (timeSteps &gt; m_ScalarMin.size())</span>
  {
<span style = "background-color:#fdd">    m_ScalarMin.resize(timeSteps, itk::NumericTraits&lt;ScalarType&gt;::max());
    m_ScalarMax.resize(timeSteps, itk::NumericTraits&lt;ScalarType&gt;::NonpositiveMin());
    m_Scalar2ndMin.resize(timeSteps, itk::NumericTraits&lt;ScalarType&gt;::max());
    m_Scalar2ndMax.resize(timeSteps, itk::NumericTraits&lt;ScalarType&gt;::NonpositiveMin());
    m_CountOfMinValuedVoxels.resize(timeSteps, 0);
    m_CountOfMaxValuedVoxels.resize(timeSteps, 0);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ImageStatisticsHolder::ResetImageStatistics()
<span style = "background-color:#fdd">{
  m_ScalarMin.assign(1, itk::NumericTraits&lt;ScalarType&gt;::max());
  m_ScalarMax.assign(1, itk::NumericTraits&lt;ScalarType&gt;::NonpositiveMin());
  m_Scalar2ndMin.assign(1, itk::NumericTraits&lt;ScalarType&gt;::max());
  m_Scalar2ndMax.assign(1, itk::NumericTraits&lt;ScalarType&gt;::NonpositiveMin());
  m_CountOfMinValuedVoxels.assign(1, 0);
  m_CountOfMaxValuedVoxels.assign(1, 0);
}</span>

/// \cond SKIP_DOXYGEN
template &lt;typename ItkImageType&gt;
void mitk::_ComputeExtremaInItkImage(const ItkImageType *itkImage, mitk::ImageStatisticsHolder *statisticsHolder, int t)
<span style = "background-color:#fdd">{
  typename ItkImageType::RegionType region;
  region = itkImage-&gt;GetBufferedRegion();
  if (region.Crop(itkImage-&gt;GetRequestedRegion()) == false)
    return;
  if (region != itkImage-&gt;GetRequestedRegion())
    return;</span>

<span style = "background-color:#fdd">  itk::ImageRegionConstIterator&lt;ItkImageType&gt; it(itkImage, region);</span>
  typedef typename ItkImageType::PixelType TPixel;
<span style = "background-color:#fdd">  TPixel value = 0;</span>

<span style = "background-color:#fdd">  if (statisticsHolder == nullptr || !statisticsHolder-&gt;IsValidTimeStep(t))
    return;
  statisticsHolder-&gt;Expand(t + 1); // make sure we have initialized all arrays
  statisticsHolder-&gt;m_CountOfMinValuedVoxels[t] = 0;
  statisticsHolder-&gt;m_CountOfMaxValuedVoxels[t] = 0;</span>

<span style = "background-color:#fdd">  statisticsHolder-&gt;m_Scalar2ndMin[t] = statisticsHolder-&gt;m_ScalarMin[t] = itk::NumericTraits&lt;ScalarType&gt;::max();
  statisticsHolder-&gt;m_Scalar2ndMax[t] = statisticsHolder-&gt;m_ScalarMax[t] =</span>
    itk::NumericTraits&lt;ScalarType&gt;::NonpositiveMin();

<span style = "background-color:#fdd">  while (!it.IsAtEnd())</span>
  {
<span style = "background-color:#fdd">    value = it.Get();</span>
#ifdef BOUNDINGOBJECT_IGNORE
    if (value &gt; -32765)
    {
#endif
      // update min
<span style = "background-color:#fdd">      if (value &lt; statisticsHolder-&gt;m_ScalarMin[t])</span>
      {
<span style = "background-color:#fdd">        statisticsHolder-&gt;m_Scalar2ndMin[t] = statisticsHolder-&gt;m_ScalarMin[t];
        statisticsHolder-&gt;m_ScalarMin[t] = value;
        statisticsHolder-&gt;m_CountOfMinValuedVoxels[t] = 1;
      }
      else if (value == statisticsHolder-&gt;m_ScalarMin[t])</span>
      {
<span style = "background-color:#fdd">        ++statisticsHolder-&gt;m_CountOfMinValuedVoxels[t];
      }
      else if (value &lt; statisticsHolder-&gt;m_Scalar2ndMin[t])</span>
      {
<span style = "background-color:#fdd">        statisticsHolder-&gt;m_Scalar2ndMin[t] = value;</span>
      }

      // update max
<span style = "background-color:#fdd">      if (value &gt; statisticsHolder-&gt;m_ScalarMax[t])</span>
      {
<span style = "background-color:#fdd">        statisticsHolder-&gt;m_Scalar2ndMax[t] = statisticsHolder-&gt;m_ScalarMax[t];
        statisticsHolder-&gt;m_ScalarMax[t] = value;
        statisticsHolder-&gt;m_CountOfMaxValuedVoxels[t] = 1;
      }
      else if (value == statisticsHolder-&gt;m_ScalarMax[t])</span>
      {
<span style = "background-color:#fdd">        ++statisticsHolder-&gt;m_CountOfMaxValuedVoxels[t];
      }
      else if (value &gt; statisticsHolder-&gt;m_Scalar2ndMax[t])</span>
      {
<span style = "background-color:#fdd">        statisticsHolder-&gt;m_Scalar2ndMax[t] = value;</span>
      }
#ifdef BOUNDINGOBJECT_IGNORE
    }
#endif

<span style = "background-color:#fdd">    ++it;
  }</span>

  //// guard for wrong 2dMin/Max on single constant value images
<span style = "background-color:#fdd">  if (statisticsHolder-&gt;m_ScalarMax[t] == statisticsHolder-&gt;m_ScalarMin[t])</span>
  {
<span style = "background-color:#fdd">    statisticsHolder-&gt;m_Scalar2ndMax[t] = statisticsHolder-&gt;m_Scalar2ndMin[t] = statisticsHolder-&gt;m_ScalarMax[t];</span>
  }
<span style = "background-color:#fdd">  statisticsHolder-&gt;m_LastRecomputeTimeStamp.Modified();
}</span>
/// \endcond SKIP_DOXYGEN

/// \cond SKIP_DOXYGEN
template &lt;typename ItkImageType&gt;
void mitk::_ComputeExtremaInItkVectorImage(const ItkImageType *itkImage,
                                           mitk::ImageStatisticsHolder *statisticsHolder,
                                           int t,
                                           unsigned int component)
<span style = "background-color:#fdd">{
  typename ItkImageType::RegionType region;
  region = itkImage-&gt;GetBufferedRegion();
  if (region.Crop(itkImage-&gt;GetRequestedRegion()) == false)
    return;
  if (region != itkImage-&gt;GetRequestedRegion())
    return;</span>

<span style = "background-color:#fdd">  itk::ImageRegionConstIterator&lt;ItkImageType&gt; it(itkImage, region);</span>

<span style = "background-color:#fdd">  if (statisticsHolder == nullptr || !statisticsHolder-&gt;IsValidTimeStep(t))
    return;
  statisticsHolder-&gt;Expand(t + 1); // make sure we have initialized all arrays
  statisticsHolder-&gt;m_CountOfMinValuedVoxels[t] = 0;
  statisticsHolder-&gt;m_CountOfMaxValuedVoxels[t] = 0;</span>

<span style = "background-color:#fdd">  statisticsHolder-&gt;m_Scalar2ndMin[t] = statisticsHolder-&gt;m_ScalarMin[t] = itk::NumericTraits&lt;ScalarType&gt;::max();
  statisticsHolder-&gt;m_Scalar2ndMax[t] = statisticsHolder-&gt;m_ScalarMax[t] =</span>
    itk::NumericTraits&lt;ScalarType&gt;::NonpositiveMin();

<span style = "background-color:#fdd">  while (!it.IsAtEnd())</span>
  {
<span style = "background-color:#fdd">    double value = it.Get()[component];</span>
#ifdef BOUNDINGOBJECT_IGNORE
    if (value &gt; -32765)
    {
#endif
      // update min
<span style = "background-color:#fdd">      if (value &lt; statisticsHolder-&gt;m_ScalarMin[t])</span>
      {
<span style = "background-color:#fdd">        statisticsHolder-&gt;m_Scalar2ndMin[t] = statisticsHolder-&gt;m_ScalarMin[t];
        statisticsHolder-&gt;m_ScalarMin[t] = value;
        statisticsHolder-&gt;m_CountOfMinValuedVoxels[t] = 1;
      }
      else if (value == statisticsHolder-&gt;m_ScalarMin[t])</span>
      {
<span style = "background-color:#fdd">        ++statisticsHolder-&gt;m_CountOfMinValuedVoxels[t];
      }
      else if (value &lt; statisticsHolder-&gt;m_Scalar2ndMin[t])</span>
      {
<span style = "background-color:#fdd">        statisticsHolder-&gt;m_Scalar2ndMin[t] = value;</span>
      }

      // update max
<span style = "background-color:#fdd">      if (value &gt; statisticsHolder-&gt;m_ScalarMax[t])</span>
      {
<span style = "background-color:#fdd">        statisticsHolder-&gt;m_Scalar2ndMax[t] = statisticsHolder-&gt;m_ScalarMax[t];
        statisticsHolder-&gt;m_ScalarMax[t] = value;
        statisticsHolder-&gt;m_CountOfMaxValuedVoxels[t] = 1;
      }
      else if (value == statisticsHolder-&gt;m_ScalarMax[t])</span>
      {
<span style = "background-color:#fdd">        ++statisticsHolder-&gt;m_CountOfMaxValuedVoxels[t];
      }
      else if (value &gt; statisticsHolder-&gt;m_Scalar2ndMax[t])</span>
      {
<span style = "background-color:#fdd">        statisticsHolder-&gt;m_Scalar2ndMax[t] = value;</span>
      }
#ifdef BOUNDINGOBJECT_IGNORE
    }
#endif

<span style = "background-color:#fdd">    ++it;
  }</span>

  //// guard for wrong 2dMin/Max on single constant value images
<span style = "background-color:#fdd">  if (statisticsHolder-&gt;m_ScalarMax[t] == statisticsHolder-&gt;m_ScalarMin[t])</span>
  {
<span style = "background-color:#fdd">    statisticsHolder-&gt;m_Scalar2ndMax[t] = statisticsHolder-&gt;m_Scalar2ndMin[t] = statisticsHolder-&gt;m_ScalarMax[t];</span>
  }
<span style = "background-color:#fdd">  statisticsHolder-&gt;m_LastRecomputeTimeStamp.Modified();
}</span>
/// \endcond SKIP_DOXYGEN
void mitk::ImageStatisticsHolder::ComputeImageStatistics(int t, unsigned int component)
<span style = "background-color:#fdd">{</span>
  // timestep valid?
<span style = "background-color:#fdd">  if (!m_Image-&gt;IsValidTimeStep(t))
    return;</span>

  // image modified?
<span style = "background-color:#fdd">  if (this-&gt;m_Image-&gt;GetMTime() &gt; m_LastRecomputeTimeStamp.GetMTime())
    this-&gt;ResetImageStatistics();</span>

<span style = "background-color:#fdd">  Expand(t + 1);</span>

  // do we have valid information already?
<span style = "background-color:#fdd">  if (m_ScalarMin[t] != itk::NumericTraits&lt;ScalarType&gt;::max() ||</span>
      m_Scalar2ndMin[t] != itk::NumericTraits&lt;ScalarType&gt;::max())
<span style = "background-color:#fdd">    return; // Values already calculated before...</span>

  // used to avoid statistics calculation on Odf images. property will be replaced as soons as bug 17928 is merged and
  // the diffusion image refactoring is complete.
<span style = "background-color:#fdd">  mitk::BoolProperty *isSh = dynamic_cast&lt;mitk::BoolProperty *&gt;(m_Image-&gt;GetProperty("IsShImage").GetPointer());
  mitk::BoolProperty *isOdf = dynamic_cast&lt;mitk::BoolProperty *&gt;(m_Image-&gt;GetProperty("IsOdfImage").GetPointer());
  const mitk::PixelType pType = m_Image-&gt;GetPixelType(0);
  if (pType.GetNumberOfComponents() == 1 &amp;&amp; (pType.GetPixelType() != itk::IOPixelEnum::UNKNOWNPIXELTYPE) &amp;&amp;</span>
      (pType.GetPixelType() != itk::IOPixelEnum::VECTOR))
  {
    // recompute
<span style = "background-color:#fdd">    mitk::ImageTimeSelector::Pointer timeSelector = this-&gt;GetTimeSelector();
    if (timeSelector.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      timeSelector-&gt;SetTimeNr(t);
      timeSelector-&gt;UpdateLargestPossibleRegion();
      const mitk::Image *image = timeSelector-&gt;GetOutput();
      AccessByItk_2(image, _ComputeExtremaInItkImage, this, t);</span>
    }
<span style = "background-color:#fdd">  }</span>
  else if (pType.GetPixelType() == itk::IOPixelEnum::VECTOR &amp;&amp;
<span style = "background-color:#fdd">           (!isOdf || !isOdf-&gt;GetValue()) &amp;&amp; (!isSh || !isSh-&gt;GetValue())) // we have a vector image</span>
  {
    // recompute
<span style = "background-color:#fdd">    mitk::ImageTimeSelector::Pointer timeSelector = this-&gt;GetTimeSelector();
    if (timeSelector.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      timeSelector-&gt;SetTimeNr(t);
      timeSelector-&gt;UpdateLargestPossibleRegion();
      const mitk::Image *image = timeSelector-&gt;GetOutput();
      AccessVectorPixelTypeByItk_n(image, _ComputeExtremaInItkVectorImage, (this, t, component));</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    m_ScalarMin[t] = 0;
    m_ScalarMax[t] = 255;
    m_Scalar2ndMin[t] = 0;
    m_Scalar2ndMax[t] = 255;</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::ScalarType mitk::ImageStatisticsHolder::GetScalarValueMin(int t, unsigned int component)
<span style = "background-color:#fdd">{
  ComputeImageStatistics(t, component);
  return m_ScalarMin[t];
}</span>

mitk::ScalarType mitk::ImageStatisticsHolder::GetScalarValueMax(int t, unsigned int component)
<span style = "background-color:#fdd">{
  ComputeImageStatistics(t, component);
  return m_ScalarMax[t];
}</span>

mitk::ScalarType mitk::ImageStatisticsHolder::GetScalarValue2ndMin(int t, unsigned int component)
<span style = "background-color:#fdd">{
  ComputeImageStatistics(t, component);
  return m_Scalar2ndMin[t];
}</span>

mitk::ScalarType mitk::ImageStatisticsHolder::GetScalarValue2ndMax(int t, unsigned int component)
<span style = "background-color:#fdd">{
  ComputeImageStatistics(t, component);
  return m_Scalar2ndMax[t];
}</span>

mitk::ScalarType mitk::ImageStatisticsHolder::GetCountOfMinValuedVoxels(int t, unsigned int component)
<span style = "background-color:#fdd">{
  ComputeImageStatistics(t, component);
  return m_CountOfMinValuedVoxels[t];
}</span>

mitk::ScalarType mitk::ImageStatisticsHolder::GetCountOfMaxValuedVoxels(int t, unsigned int component)
<span style = "background-color:#fdd">{
  ComputeImageStatistics(t, component);
  return m_CountOfMaxValuedVoxels[t];
}</span></pre>
	</body>
</html>