<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSimpleBarrierConstraintChecker.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkSimpleBarrierConstraintChecker.h"

#include &lt;algorithm&gt;

#include "mitkExceptionMacro.h"

mitk::SimpleBarrierConstraintChecker::PenaltyArrayType
mitk::SimpleBarrierConstraintChecker::GetPenalties(const ParametersType&amp; parameters) const
<span style = "background-color:#fdd">{
  PenaltyArrayType result(m_Constraints.size());</span>

<span style = "background-color:#fdd">  PenaltyArrayType::iterator penaltyPos = result.begin();</span>

<span style = "background-color:#fdd">  for (ConstraintVectorType::const_iterator pos = m_Constraints.begin(); pos != m_Constraints.end();
       ++pos, ++penaltyPos)</span>
  {
<span style = "background-color:#fdd">    *penaltyPos = CalcPenalty(parameters, *pos);
  }</span>

<span style = "background-color:#fdd">  return result;
};</span>

unsigned int mitk::SimpleBarrierConstraintChecker::GetNumberOfConstraints() const
<span style = "background-color:#fdd">{
  return m_Constraints.size();
};</span>

mitk::SimpleBarrierConstraintChecker::PenaltyValueType
mitk::SimpleBarrierConstraintChecker::GetFailedConstraintValue() const
<span style = "background-color:#fdd">{
  return m_MaxConstraintPenalty;
};</span>

void mitk::SimpleBarrierConstraintChecker::SetLowerBarrier(ParameterIndexType parameterID,
    BarrierValueType barrier, BarrierWidthType width)
<span style = "background-color:#fdd">{
  Constraint c;
  ParameterIndexVectorType params;
  params.push_back(parameterID);
  c.parameters = params;
  c.barrier = barrier;
  c.width = width;
  c.upperBarrier = false;</span>

<span style = "background-color:#fdd">  m_Constraints.push_back(c);
};</span>

void mitk::SimpleBarrierConstraintChecker::SetUpperBarrier(ParameterIndexType parameterID,
    BarrierValueType barrier, BarrierWidthType width)
<span style = "background-color:#fdd">{
  Constraint c;
  ParameterIndexVectorType params;
  params.push_back(parameterID);
  c.parameters = params;
  c.barrier = barrier;
  c.width = width;
  c.upperBarrier = true;</span>

<span style = "background-color:#fdd">  m_Constraints.push_back(c);
};</span>

void mitk::SimpleBarrierConstraintChecker::SetLowerSumBarrier(const ParameterIndexVectorType&amp;
    parameterIDs, BarrierValueType barrier, BarrierWidthType width)
<span style = "background-color:#fdd">{
  Constraint c;</span>

<span style = "background-color:#fdd">  c.parameters = parameterIDs;
  c.barrier = barrier;
  c.width = width;
  c.upperBarrier = false;</span>

<span style = "background-color:#fdd">  m_Constraints.push_back(c);
};</span>

void mitk::SimpleBarrierConstraintChecker::SetUpperSumBarrier(const ParameterIndexVectorType&amp;
    parameterIDs, BarrierValueType barrier, BarrierWidthType width)
<span style = "background-color:#fdd">{
  Constraint c;</span>

<span style = "background-color:#fdd">  c.parameters = parameterIDs;
  c.barrier = barrier;
  c.width = width;
  c.upperBarrier = true;</span>

<span style = "background-color:#fdd">  m_Constraints.push_back(c);
};</span>

mitk::SimpleBarrierConstraintChecker::Constraint&amp;
mitk::SimpleBarrierConstraintChecker::GetConstraint(unsigned int index)
<span style = "background-color:#fdd">{
  if (index &gt;= GetNumberOfConstraints())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt;</span>
                "Error. Cannot get constraint. Invalid constraint index passed.Parameter Invalid index:"
                &lt;&lt; index;
  }

<span style = "background-color:#fdd">  return m_Constraints[index];
};</span>

const mitk::SimpleBarrierConstraintChecker::Constraint&amp;
mitk::SimpleBarrierConstraintChecker::GetConstraint(unsigned int index) const
<span style = "background-color:#fdd">{
  if (index &gt;= GetNumberOfConstraints())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt;</span>
                "Error. Cannot get constraint. Invalid constraint index passed.Parameter Invalid index:"
                &lt;&lt; index;
  }

<span style = "background-color:#fdd">  return m_Constraints[index];
};</span>

void mitk::SimpleBarrierConstraintChecker::DeleteConstraint(unsigned int index)
<span style = "background-color:#fdd">{
  if (index &gt;= GetNumberOfConstraints())</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  m_Constraints.erase(m_Constraints.begin() + index);
};</span>


void mitk::SimpleBarrierConstraintChecker::ResetConstraints()
<span style = "background-color:#fdd">{
  m_Constraints.clear();
};</span>

mitk::SimpleBarrierConstraintChecker::PenaltyValueType
mitk::SimpleBarrierConstraintChecker::CalcPenalty(const ParametersType&amp; parameters,
    const Constraint&amp; constraint) const
<span style = "background-color:#fdd">{
  double constrainedValue = 0;</span>

<span style = "background-color:#fdd">  for (ParameterIndexVectorType::const_iterator pos = constraint.parameters.begin();
       pos != constraint.parameters.end(); ++pos)</span>
  {
<span style = "background-color:#fdd">    if (*pos &gt;= parameters.size())</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt;</span>
                  "Error. Parameter specified by constraint is no part of the passed parameter values. Invalid parameter ID:"
                  &lt;&lt; *pos;
    }

<span style = "background-color:#fdd">    constrainedValue += parameters[*pos];
  };</span>

<span style = "background-color:#fdd">  PenaltyValueType result = 0;</span>

  //transform into an inequality against 0.
  //basic form of inequalities are constrainedValue (relation) constraint.barrier
<span style = "background-color:#fdd">  double transformedTermValue = constraint.barrier - constrainedValue;</span>

<span style = "background-color:#fdd">  if (!constraint.upperBarrier)</span>
  {
    // need the form 0 &lt;= term, but right now it would be 0 &gt;= term, so *-1
<span style = "background-color:#fdd">    transformedTermValue *= -1;</span>
  }

<span style = "background-color:#fdd">  double barrierSize = std::abs(static_cast&lt;double&gt;(constraint.width));</span>

  //Check if it would be the maximum penalty anyway.
<span style = "background-color:#fdd">  if (transformedTermValue &lt;= 0)</span>
  {
<span style = "background-color:#fdd">    result = this-&gt;m_MaxConstraintPenalty;
  }
  else if (transformedTermValue &gt; barrierSize)</span>
  {
    //Check if it is outside the barrier region
    //the constrained value is outside the barrier region within a legal valid range.
<span style = "background-color:#fdd">    result = 0;
  }</span>
  else
  {
    // the constrained value seems to violate the constraint or at least is within the
    // barrier region, so compute the penalty

    //calculate the barrier function value
<span style = "background-color:#fdd">    double barrierValue = -1 * log(transformedTermValue / barrierSize);</span>

<span style = "background-color:#fdd">    result = std::min(barrierValue, this-&gt;m_MaxConstraintPenalty);</span>
  }

<span style = "background-color:#fdd">  return result;
};</span></pre>
	</body>
</html>