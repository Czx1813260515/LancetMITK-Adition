<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkFormulaParser.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;boost/math/constants/constants.hpp&gt;
#include &lt;boost/spirit/include/qi.hpp&gt;
#include &lt;boost/spirit/include/phoenix.hpp&gt;
#include &lt;boost/version.hpp&gt;

#include "mitkFormulaParser.h"
#include "mitkFresnel.h"

namespace qi = boost::spirit::qi;
namespace ascii = boost::spirit::ascii;
namespace phx = boost::phoenix;

typedef std::string::const_iterator Iter;
typedef ascii::space_type Skipper;

namespace qi = boost::spirit::qi;

namespace mitk
{
  /*!
   *	@brief			Transforms the given number from degrees to radians and returns it.
   *	@tparam T		The scalar type that represents a value (e.g. double).
   *	@param[in] deg	A scalar value in degrees.
   *	@return			The given value in radians.
   */
  template&lt;typename T&gt;
  inline T deg2rad(const T deg)
<span style = "background-color:#fdd">  {
    return deg * boost::math::constants::pi&lt;T&gt;() / static_cast&lt;T&gt;(180);
  }</span>

  /*!
   *	@brief			Returns the cosine of the given degree scalar.
   *	@tparam T		The scalar type that represents a value (e.g. double).
   *	@param[in] t	A scalar value in degrees whose cosine should be returned.
   *	@return			The cosine of the given degree scalar.
   */
  template&lt;typename T&gt;
  inline T cosd(const T t)
<span style = "background-color:#fdd">  {
    return std::cos(deg2rad(t));
  }</span>

  /*!
   *	@brief			Returns the sine of the given degree scalar.
   *	@tparam T		The scalar type that represents a value (e.g. double).
   *	@param[in] t	A scalar value in degrees whose sine should be returned.
   *	@return			The sine of the given degree scalar.
   */
  template&lt;typename T&gt;
  inline T sind(const T t)
<span style = "background-color:#fdd">  {
    return std::sin(deg2rad(t));
  }</span>

  /*!
   *	@brief			Returns the tangent of the given degree scalar.
   *	@tparam T		The scalar type that represents a value (e.g. double).
   *	@param[in] t	A scalar value in degrees whose tangent should be returned.
   *	@return			The tangent of the given degree scalar.
   */
  template&lt;typename T&gt;
  inline T tand(const T t)
<span style = "background-color:#fdd">  {
    return std::tan(deg2rad(t));
  }</span>

  /*!
   *	@brief			Returns the fresnel integral sine at the given x-coordinate.
   *	@details		Code for "fresnel_s()" (fresnel.cpp and fresnel.h) taken as-is from the GNU
   *					Scientific Library (http://www.gnu.org/software/gsl/), specifically from
   *					http://www.network-theory.co.uk/download/gslextras/Fresnel/.
   *	@tparam T		The scalar type that represents a value (e.g. double).
   *	@param[in] t	The x-coordinate at which the fresnel integral sine should be returned.
   *	@return			The fresnel integral sine at the given x-coordinate.
   */
  template&lt;typename T&gt;
  T fresnelS(const T t)
<span style = "background-color:#fdd">  {
    T x = t / boost::math::constants::root_half_pi&lt;T&gt;();
    return static_cast&lt;T&gt;(fresnel_s(x) / boost::math::constants::root_two_div_pi&lt;T&gt;());
  }</span>

  /*!
   *	@brief			Returns the fresnel integral cosine at the given x-coordinate.
   *	@details		Code for "fresnel_c()" (fresnel.cpp and fresnel.h) taken as-is from the GNU
   *					Scientific Library (http://www.gnu.org/software/gsl/), specifically from
   *					http://www.network-theory.co.uk/download/gslextras/Fresnel/.
   *	@tparam T		The scalar type that represents a value (e.g. double).
   *	@param[in] t	The x-coordinate at which the fresnel integral cosine should be returned.
   *	@return			The fresnel integral cosine at the given x-coordinate.
   */
  template&lt;typename T&gt;
  T fresnelC(const T t)
<span style = "background-color:#fdd">  {
    T x = t / boost::math::constants::root_half_pi&lt;T&gt;();
    return static_cast&lt;T&gt;(fresnel_c(x) / boost::math::constants::root_two_div_pi&lt;T&gt;());
  }</span>

  /*!
   *	@brief		The grammar that defines the language (i.e. what is allowed) for the parser.
   */
  class Grammar : public qi::grammar&lt;Iter, FormulaParser::ValueType(), Skipper&gt;
  {
    /*!
     *	@brief	Helper structure that makes it easier to dynamically call any
     *			one-parameter-function by overloading the @c () operator.
     */
    struct func1_
    {
      // Required for Phoenix 3+
      template&lt;typename Sig&gt;
      struct result;

      /*!
       *	@brief				Helper structure that is needed for compatibility with
       *						@c boost::phoenix.
       *	@tparam Functor		Type of the functor (this struct).
       *	@tparam Function	Type of the function that should be called.
       *	@tparam Arg1		Type of the argument the function should be called with.
       *
       */
      template&lt;typename Functor, typename Function, typename Arg1&gt;
      struct result&lt;Functor(Function, Arg1&amp;)&gt;
      {
        /*! @brief The result structure always needs this typedef */
        typedef Arg1 type;
      };

      /*!
       *	@brief				Calls the function @b f with the argument @b a1 and returns the
       *						result.
       *						The result always has the same type as the argument.
       *	@tparam Function	Type of the function that should be called.
       *	@tparam Arg1			Type of the argument the function should be called with.
       *	@param[in] f		The function that should be called.
       *	@param[in] a1		The argument the function should be called with.
       *	@return				The result of the called function.
       */
      template&lt;typename Function, typename Arg1&gt;
      Arg1 operator()(const Function f, const Arg1 a1) const
<span style = "background-color:#fdd">      {
        return f(a1);
      }</span>
    };

    /*!
     *	@brief	Helper structure that maps strings to function calls so that parsing e.g.
     *			@c "cos(0)" actually calls the @c std::cos function with parameter @c 1 so it
     *			returns @c 0.
     */
    class unaryFunction_ :
      public qi::symbols&lt;typename std::iterator_traits&lt;Iter&gt;::value_type, FormulaParser::ValueType(*)(FormulaParser::ValueType)&gt;
    {
    public:
      /*!
       *	@brief Constructs the structure, this is where the mapping takes place.
       */
<span style = "background-color:#fdd">      unaryFunction_()</span>
      {
<span style = "background-color:#fdd">        this-&gt;add</span>
        ("abs", static_cast&lt;FormulaParser::ValueType(*)(FormulaParser::ValueType)&gt;(&amp;std::abs))
          ("exp", static_cast&lt;FormulaParser::ValueType(*)(FormulaParser::ValueType)&gt;(&amp;std::exp)) // @TODO: exp ignores division by zero
          ("sin", static_cast&lt;FormulaParser::ValueType(*)(FormulaParser::ValueType)&gt;(&amp;std::sin))
          ("cos", static_cast&lt;FormulaParser::ValueType(*)(FormulaParser::ValueType)&gt;(&amp;std::cos))
          ("tan", static_cast&lt;FormulaParser::ValueType(*)(FormulaParser::ValueType)&gt;(&amp;std::tan))
          ("sind", &amp;sind)
          ("cosd", &amp;cosd)
          ("tand", &amp;tand)
          ("fresnelS", &amp;fresnelS)
          ("fresnelC", &amp;fresnelC);
<span style = "background-color:#fdd">      }</span>
    } unaryFunction;

  public:
    /*!
     *	@brief							Constructs the grammar with the given formula parser.
     *	@param[in, out] formulaParser	The formula parser this grammar is for - so it can
     *									access its variable map.
     */
<span style = "background-color:#fdd">    Grammar(FormulaParser&amp; formulaParser) : Grammar::base_type(start)
    {</span>
      using qi::_val;
      using qi::_1;
      using qi::_2;
      using qi::char_;
      using qi::alpha;
      using qi::alnum;
      using qi::double_;
      using qi::as_string;

<span style = "background-color:#fdd">      phx::function&lt;func1_&gt; func1;</span>

<span style = "background-color:#fdd">      start = expression &gt; qi::eoi;</span>

<span style = "background-color:#fdd">      expression = term[_val = _1]</span>
        &gt;&gt; *(('+' &gt;&gt; term[_val += _1])
          | ('-' &gt;&gt; term[_val -= _1]));

<span style = "background-color:#fdd">      term = factor[_val = _1]</span>
        &gt;&gt; *(('*' &gt;&gt; factor[_val *= _1])
          | ('/' &gt;&gt; factor[_val /= _1]));

<span style = "background-color:#fdd">      factor = primary[_val = _1];</span>
      /*!	@TODO:	Repair exponentiation */
      //&gt;&gt; *('^' &gt;&gt; factor[phx::bind&lt;FormulaParser::ValueType, FormulaParser::ValueType, FormulaParser::ValueType&gt;(std::pow, _val, _1)]);

<span style = "background-color:#fdd">      variable = as_string[alpha &gt;&gt; *(alnum | char_('_'))]</span>
        [_val = phx::bind(&amp;FormulaParser::lookupVariable, &amp;formulaParser, _1)];

<span style = "background-color:#fdd">      primary = double_[_val = _1]</span>
        | '(' &gt;&gt; expression[_val = _1] &gt;&gt; ')'
        | ('-' &gt;&gt; primary[_val = -_1])
        | ('+' &gt;&gt; primary[_val = _1])
        | (unaryFunction &gt;&gt; '(' &gt;&gt; expression &gt;&gt; ')')[_val = func1(_1, _2)]
        | variable[_val = _1];
<span style = "background-color:#fdd">    }</span>

    /*! the rules of the grammar. */
    qi::rule&lt;Iter, FormulaParser::ValueType(), Skipper&gt; start;
    qi::rule&lt;Iter, FormulaParser::ValueType(), Skipper&gt; expression;
    qi::rule&lt;Iter, FormulaParser::ValueType(), Skipper&gt; term;
    qi::rule&lt;Iter, FormulaParser::ValueType(), Skipper&gt; factor;
    qi::rule&lt;Iter, FormulaParser::ValueType(), Skipper&gt; variable;
    qi::rule&lt;Iter, FormulaParser::ValueType(), Skipper&gt; primary;
  };


<span style = "background-color:#fdd">  FormulaParser::FormulaParser(const VariableMapType* variables) : m_Variables(variables)
  {}</span>

  FormulaParser::ValueType FormulaParser::parse(const std::string&amp; input)
<span style = "background-color:#fdd">  {
    std::string::const_iterator iter = input.begin();
    std::string::const_iterator end = input.end();
    FormulaParser::ValueType result = static_cast&lt;FormulaParser::ValueType&gt;(0);</span>

    try
    {
<span style = "background-color:#fdd">      if (!qi::phrase_parse(iter, end, Grammar(*this), ascii::space, result))</span>
      {
<span style = "background-color:#fdd">        mitkThrowException(FormulaParserException) &lt;&lt; "Could not parse '" &lt;&lt; input &lt;&lt;</span>
          "': Grammar could not be applied to the input " &lt;&lt; "at all.";
      }
    }
    catch (qi::expectation_failure&lt;Iter&gt;&amp; e)
<span style = "background-color:#fdd">    {
      std::string parsed = "";</span>

<span style = "background-color:#fdd">      for (Iter i = input.begin(); i != e.first; i++)</span>
      {
<span style = "background-color:#fdd">        parsed += *i;
      }
      mitkThrowException(FormulaParserException) &lt;&lt; "Error while parsing '" &lt;&lt; input &lt;&lt;</span>
        "': Unexpected character '" &lt;&lt; *e.first &lt;&lt; "' after '" &lt;&lt; parsed &lt;&lt; "'";
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    return result;
  };</span>

  FormulaParser::ValueType FormulaParser::lookupVariable(const std::string var)
<span style = "background-color:#fdd">  {
    if (m_Variables == nullptr)</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(FormulaParserException) &lt;&lt; "Map of variables is empty";</span>
    }

    try
    {
<span style = "background-color:#fdd">      return m_Variables-&gt;at(var);</span>
    }
    catch (std::out_of_range&amp;)
<span style = "background-color:#fdd">    {
      mitkThrowException(FormulaParserException) &lt;&lt; "No variable '" &lt;&lt; var &lt;&lt; "' defined in lookup";
    }
  };</span>

}</pre>
	</body>
</html>