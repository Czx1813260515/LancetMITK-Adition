<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkTwoCompartmentExchangeModelDifferentialEquations.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKTWOCOMPARTMENTEXCHANGEMODELDIFFERENTIALEQUATIONS_H
#define MITKTWOCOMPARTMENTEXCHANGEMODELDIFFERENTIALEQUATIONS_H

#include "mitkNumericTwoCompartmentExchangeModel.h"

namespace mitk{
/** @class TwoCompartmentExchangeModelDifferentialEquations
 * @brief Helper Class for NumericTwoCompartmentExchangeModel: Defines the differential equations (Mass Balance Equations) in the 2 Compartment Exchange model.
 * The 2 Compartment Exchange model is defined via the mass balance equations
 * vp * dCp(t)/dt =  F * (CA(t) - Cp(t)) - PS * (Cp(t) - Ce(t))
 * ve * dCe(t)/dt = PS * (Cp(t) - Ce(t))
 * Boost ODEINT performs a stepwise numeric integration (e.g. via Runge-Kutta method) of the initial value problem
 * x' = dx/dt = f(x,t)
 * It needs an operator () (a functor) that calculates dx/dt = dxdt for a given x and t.
 * Parameters are F, PS, ve and vp and the time dependent Ca(t) =AIF, that is interpolated to the current step t
*/

class TwoCompartmentExchangeModelDifferentialEquations
{
public:

    typedef std::vector&lt; double &gt; AIFType;

    /** @brief Functor for differential equation of Physiological Pharmacokinetic Brix Model
     * Takes current state x = x(t) and time t and calculates the corresponding dxdt = dx/dt
    */
    void operator() (const mitk::NumericTwoCompartmentExchangeModel::state_type &amp;x, mitk::NumericTwoCompartmentExchangeModel::state_type &amp;dxdt, const double t)
<span style = "background-color:#fdd">    {
        double Ca_t = InterpolateAIFToCurrentTimeStep(t);</span>

//        dxdt[0] = -(this-&gt;FVP + this-&gt;PSVP)*x[0] - this-&gt;PSVP*x[1]+this-&gt;FVP*Ca_t;
<span style = "background-color:#fdd">        dxdt[0] = (1/this-&gt;vp) * ( this-&gt;F*(Ca_t - x[0]) - this-&gt;PS*(x[0] - x[1]) );
        dxdt[1] = (1/this-&gt;ve) * this-&gt;PS * (x[0] - x[1]);</span>

<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    TwoCompartmentExchangeModelDifferentialEquations() : F(0), PS(0), ve(0), vp(0), m_AIF(0), m_AIFTimeGrid(0)
    {
    }</span>

    /** @brief Initialize class with parameters F/Vp, PS/Vp, fi and fp that are free fit parameters*/
    void initialize(double Fp, double ps, double fi, double fp)
<span style = "background-color:#fdd">    {
        this-&gt;F = Fp;
        this-&gt;PS = ps;
        this-&gt;ve = fi;
        this-&gt;vp = fp;
    }</span>


    void setAIF(AIFType &amp;aif)
<span style = "background-color:#fdd">    {
        this-&gt;m_AIF = aif;
    }</span>


    void setAIFTimeGrid(AIFType &amp;grid)
<span style = "background-color:#fdd">    {
        this-&gt;m_AIFTimeGrid = grid;
    }</span>

private:

    double F;
    double PS;
    double ve;
    double vp;

    AIFType m_AIF;
    AIFType m_AIFTimeGrid;


    /** @brief Internal routine to interpolate the AIF to the current time point t used for integration
     * The numerical integration of ODEINT is performed on an adaptive timegrid (adaptive step size dt) different from the time grid of the AIF and model function.
     * Thus, the AIF value Ca(t) has to be interpolated from the set AIF
     */
    double InterpolateAIFToCurrentTimeStep(double t)
<span style = "background-color:#fdd">    {
        double lastValue = m_AIF[0];
        double lastTime = std::numeric_limits&lt;double&gt;::min();</span>

<span style = "background-color:#fdd">        AIFType::const_iterator posITime = m_AIFTimeGrid.begin();
        AIFType::const_iterator posValue = m_AIF.begin();</span>

<span style = "background-color:#fdd">        while(t &gt; *posITime)</span>
        {
<span style = "background-color:#fdd">            lastValue = *posValue;
            lastTime = *posITime;
            ++posValue;
            ++posITime;
        }
        double weightLast = 1 - (t - lastTime)/(*posITime - lastTime);
        double weightNext = 1- (*posITime - t)/(*posITime - lastTime);
        double result = weightLast * lastValue + weightNext * (*posValue);</span>

<span style = "background-color:#fdd">        return result;
    }</span>

};
}

#endif // MITKTWOCOMPARTMENTEXCHANGEMODELDIFFERENTIALEQUATIONS_H</pre>
	</body>
</html>