<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>usWaitCondition_p.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

  Library: CppMicroServices

  Copyright (c) German Cancer Research Center (DKFZ)
  All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

============================================================================*/

#ifndef USWAITCONDITION_P_H
#define USWAITCONDITION_P_H

#include "usCoreConfig.h"
#include "usLog_p.h"
#include "usUtils_p.h"
#include "usThreads_p.h"

#ifdef US_PLATFORM_POSIX
#include &lt;sys/time.h&gt;
#include &lt;cerrno&gt;
#endif

US_BEGIN_NAMESPACE

/**
 * \brief A thread synchronization object used to suspend execution until some
 * condition on shared data is met.
 *
 * A thread calls Wait() to suspend its execution until the condition is
 * met. Each call to Notify() from an executing thread will then cause a single
 * waiting thread to be released.  A call to Notify() means, "signal
 * that the condition is true."  NotifyAll() releases all threads waiting on
 * the condition variable.
 *
 * The WaitCondition implementation is consistent with the standard
 * definition and use of condition variables in pthreads and other common
 * thread libraries.
 *
 * IMPORTANT: A condition variable always requires an associated mutex
 * object. The mutex object is used to avoid a dangerous race condition when
 * Wait() and Notify() are called simultaneously from two different
 * threads.
 *
 * On systems using pthreads, this implementation abstracts the
 * standard calls to the pthread condition variable.  On Win32
 * systems, there is no system provided condition variable.  This
 * class implements a condition variable using a critical section, a
 * semphore, an event and a number of counters.  The implementation is
 * almost an extract translation of the implementation presented by
 * Douglas C Schmidt and Irfan Pyarali in "Strategies for Implementing
 * POSIX Condition Variables on Win32". This article can be found at
 * http://www.cs.wustl.edu/~schmidt/win32-cv-1.html
 *
 */
template&lt;class MutexHost&gt;
class WaitCondition
{
public:

  WaitCondition();
  ~WaitCondition();

  bool Wait(unsigned long time = 0);

  /** Notify that the condition is true and release one waiting thread */
  void Notify();

  /** Notify that the condition is true and release all waiting threads */
  void NotifyAll();

private:

  // purposely not implemented
  WaitCondition(const WaitCondition&amp; other);
  const WaitCondition&amp; operator=(const WaitCondition&amp;);

#ifdef US_ENABLE_THREADING_SUPPORT

  /** Suspend execution of this thread until the condition is signaled. The
   *  argument is a SimpleMutex object that must be locked prior to calling
   *  this method.  */
  bool Wait(Mutex&amp; mutex, unsigned long time = 0);

  bool Wait(Mutex* mutex, unsigned long time = 0);

  #ifdef US_PLATFORM_POSIX
  pthread_cond_t m_WaitCondition;
  #else

  int m_NumberOfWaiters;                   // number of waiting threads
  CRITICAL_SECTION m_NumberOfWaitersLock;  // Serialize access to
  // m_NumberOfWaiters

  HANDLE m_Semaphore;                      // Semaphore to queue threads
  HANDLE m_WaitersAreDone;                 // Auto-reset event used by the
                                           // broadcast/signal thread to
                                           // wait for all the waiting
                                           // threads to wake up and
                                           // release the semaphore

  std::size_t m_WasNotifyAll;              // Keeps track of whether we
                                           // were broadcasting or signaling
  #endif

#endif // US_ENABLE_THREADING_SUPPORT
};

template&lt;class MutexHost&gt;
class NoWaitCondition
{
public:
<span style = "background-color:#dfd">  NoWaitCondition() {}</span>
private:
  // purposely not implemented
  NoWaitCondition(const NoWaitCondition&amp; other);
  const NoWaitCondition&amp; operator=(const NoWaitCondition&amp;);
};

// ------------------------------------------------------------------------
// WaitCondition implementation
// ------------------------------------------------------------------------

#ifdef US_ENABLE_THREADING_SUPPORT
template&lt;class MutexHost&gt;
WaitCondition&lt;MutexHost&gt;::WaitCondition()
<span style = "background-color:#dfd">{</span>
  #ifdef US_PLATFORM_POSIX
    pthread_cond_init(&amp;m_WaitCondition, nullptr);
  #else
<span style = "background-color:#dfd">    m_NumberOfWaiters = 0;
    m_WasNotifyAll = 0;
    m_Semaphore = CreateSemaphore(0,            // no security</span>
                                  0,            // initial value
                                  0x7fffffff,   // max count
                                  0);           // unnamed
<span style = "background-color:#dfd">    InitializeCriticalSection(&amp;m_NumberOfWaitersLock);
    m_WaitersAreDone = CreateEvent(0,           // no security</span>
                                   FALSE,       // auto-reset
                                   FALSE,       // non-signaled initially
                                   0 );         // unnamed
  #endif
<span style = "background-color:#dfd">}</span>

template&lt;class MutexHost&gt;
WaitCondition&lt;MutexHost&gt;::~WaitCondition()
<span style = "background-color:#dfd">{</span>
  #ifdef US_PLATFORM_POSIX
    pthread_cond_destroy(&amp;m_WaitCondition);
  #else
<span style = "background-color:#dfd">    CloseHandle(m_Semaphore);
    CloseHandle(m_WaitersAreDone);
    DeleteCriticalSection(&amp;m_NumberOfWaitersLock);</span>
  #endif
<span style = "background-color:#dfd">}</span>

template&lt;class MutexHost&gt;
bool WaitCondition&lt;MutexHost&gt;::Wait(unsigned long time)
<span style = "background-color:#fdd">{
  return this-&gt;Wait(static_cast&lt;MutexHost*&gt;(this)-&gt;m_Mtx, time);
}</span>

template&lt;class MutexHost&gt;
void WaitCondition&lt;MutexHost&gt;::Notify()
{
  #ifdef US_PLATFORM_POSIX
    pthread_cond_signal(&amp;m_WaitCondition);
  #else
    EnterCriticalSection(&amp;m_NumberOfWaitersLock);
    int haveWaiters = m_NumberOfWaiters &gt; 0;
    LeaveCriticalSection(&amp;m_NumberOfWaitersLock);

    // if there were not any waiters, then this is a no-op
    if (haveWaiters)
    {
      ReleaseSemaphore(m_Semaphore, 1, 0);
    }
  #endif
}

template&lt;class MutexHost&gt;
void WaitCondition&lt;MutexHost&gt;::NotifyAll()
<span style = "background-color:#dfd">{</span>
  #ifdef US_PLATFORM_POSIX
    pthread_cond_broadcast(&amp;m_WaitCondition);
  #else
    // This is needed to ensure that m_NumberOfWaiters and m_WasNotifyAll are
    // consistent
<span style = "background-color:#dfd">    EnterCriticalSection(&amp;m_NumberOfWaitersLock);
    int haveWaiters = 0;</span>

<span style = "background-color:#dfd">    if (m_NumberOfWaiters &gt; 0)</span>
    {
      // We are broadcasting, even if there is just one waiter...
      // Record that we are broadcasting, which helps optimize Notify()
      // for the non-broadcast case
<span style = "background-color:#fdd">      m_WasNotifyAll = 1;
      haveWaiters = 1;</span>
    }

<span style = "background-color:#dfd">    if (haveWaiters)</span>
    {
      // Wake up all waiters atomically
<span style = "background-color:#fdd">      ReleaseSemaphore(m_Semaphore, m_NumberOfWaiters, 0);</span>

<span style = "background-color:#fdd">      LeaveCriticalSection(&amp;m_NumberOfWaitersLock);</span>

      // Wait for all the awakened threads to acquire the counting
      // semaphore
<span style = "background-color:#fdd">      WaitForSingleObject(m_WaitersAreDone, INFINITE);</span>
      // This assignment is ok, even without the m_NumberOfWaitersLock held
      // because no other waiter threads can wake up to access it.
<span style = "background-color:#fdd">      m_WasNotifyAll = 0;
    }</span>
    else
    {
<span style = "background-color:#dfd">      LeaveCriticalSection(&amp;m_NumberOfWaitersLock);</span>
    }
  #endif
<span style = "background-color:#dfd">}</span>

template&lt;class MutexHost&gt;
bool WaitCondition&lt;MutexHost&gt;::Wait(Mutex* mutex, unsigned long timeoutMillis)
{
  return Wait(*mutex, timeoutMillis);
}

template&lt;class MutexHost&gt;
bool WaitCondition&lt;MutexHost&gt;::Wait(Mutex&amp; mutex, unsigned long timeoutMillis)
<span style = "background-color:#fdd">{</span>
  #ifdef US_PLATFORM_POSIX
    struct timespec ts, * pts = nullptr;
    if (timeoutMillis)
    {
      pts = &amp;ts;
      struct timeval tv;
      int error = gettimeofday(&amp;tv, nullptr);
      if (error)
      {
        US_ERROR &lt;&lt; "gettimeofday error: " &lt;&lt; GetLastErrorStr();
        return false;
      }
      ts.tv_sec = tv.tv_sec;
      ts.tv_nsec = tv.tv_usec * 1000;
      ts.tv_sec += timeoutMillis / 1000;
      ts.tv_nsec += (timeoutMillis % 1000) * 1000000;
      ts.tv_sec += ts.tv_nsec / 1000000000;
      ts.tv_nsec = ts.tv_nsec % 1000000000;
    }

    if (pts)
    {
      int error = pthread_cond_timedwait(&amp;m_WaitCondition, &amp;mutex.m_Mtx, pts);
      if (error == 0)
      {
        return true;
      }
      else
      {
        if (error != ETIMEDOUT)
        {
          US_ERROR &lt;&lt; "pthread_cond_timedwait error: " &lt;&lt; GetLastErrorStr();
        }
        return false;
      }
    }
    else
    {
      int error = pthread_cond_wait(&amp;m_WaitCondition, &amp;mutex.m_Mtx);
      if (error)
      {
        US_ERROR &lt;&lt; "pthread_cond_wait error: " &lt;&lt; GetLastErrorStr();
        return false;
      }
      return true;
    }

  #else

    // Avoid race conditions
<span style = "background-color:#fdd">    EnterCriticalSection(&amp;m_NumberOfWaitersLock);
    m_NumberOfWaiters++;
    LeaveCriticalSection(&amp;m_NumberOfWaitersLock);</span>

    DWORD dw;
<span style = "background-color:#fdd">    bool result = true;</span>

    // This call atomically releases the mutex and waits on the
    // semaphore until signaled
<span style = "background-color:#fdd">    dw = SignalObjectAndWait(mutex.m_Mtx, m_Semaphore, timeoutMillis ? timeoutMillis : INFINITE, FALSE);
    if (dw == WAIT_TIMEOUT)</span>
    {
<span style = "background-color:#fdd">      result = false;
    }
    else if (dw == WAIT_FAILED)</span>
    {
<span style = "background-color:#fdd">      result = false;
      US_ERROR &lt;&lt; "SignalObjectAndWait failed: " &lt;&lt; GetLastErrorStr();</span>
    }

    // Reacquire lock to avoid race conditions
<span style = "background-color:#fdd">    EnterCriticalSection(&amp;m_NumberOfWaitersLock);</span>

    // We're no longer waiting....
<span style = "background-color:#fdd">    m_NumberOfWaiters--;</span>

    // Check to see if we're the last waiter after the broadcast
<span style = "background-color:#fdd">    int lastWaiter = m_WasNotifyAll &amp;&amp; m_NumberOfWaiters == 0;</span>

<span style = "background-color:#fdd">    LeaveCriticalSection(&amp;m_NumberOfWaitersLock);</span>

    // If we're the last waiter thread during this particular broadcast
    // then let the other threads proceed
<span style = "background-color:#fdd">    if (lastWaiter)</span>
    {
      // This call atomically signals the m_WaitersAreDone event and waits
      // until it can acquire the external mutex.  This is required to
      // ensure fairness
<span style = "background-color:#fdd">      dw = SignalObjectAndWait(m_WaitersAreDone, mutex.m_Mtx,</span>
                          INFINITE, FALSE);
<span style = "background-color:#fdd">      if (result &amp;&amp; dw == WAIT_FAILED)</span>
      {
<span style = "background-color:#fdd">        result = false;
        US_ERROR &lt;&lt; "SignalObjectAndWait failed: " &lt;&lt; GetLastErrorStr();</span>
      }
<span style = "background-color:#fdd">    }</span>
    else
    {
      // Always regain the external mutex since that's the guarentee we
      // give to our callers
<span style = "background-color:#fdd">      dw = WaitForSingleObject(mutex.m_Mtx, INFINITE);
      if (result &amp;&amp; dw == WAIT_FAILED)</span>
      {
<span style = "background-color:#fdd">        result = false;
        US_ERROR &lt;&lt; "SignalObjectAndWait failed: " &lt;&lt; GetLastErrorStr();</span>
      }
    }

<span style = "background-color:#fdd">    return result;</span>
  #endif
<span style = "background-color:#fdd">}</span>

#else

template&lt;class MutexHost&gt;
WaitCondition&lt;MutexHost&gt;::WaitCondition() {}

template&lt;class MutexHost&gt;
WaitCondition&lt;MutexHost&gt;::~WaitCondition() {}

template&lt;class MutexHost&gt;
bool WaitCondition&lt;MutexHost&gt;::Wait(unsigned long)
{
  return true;
}

template&lt;class MutexHost&gt;
void WaitCondition&lt;MutexHost&gt;::Notify() {}

template&lt;class MutexHost&gt;
void WaitCondition&lt;MutexHost&gt;::NotifyAll() {}

#endif

US_END_NAMESPACE

#endif // USWAITCONDITION_P_H</pre>
	</body>
</html>