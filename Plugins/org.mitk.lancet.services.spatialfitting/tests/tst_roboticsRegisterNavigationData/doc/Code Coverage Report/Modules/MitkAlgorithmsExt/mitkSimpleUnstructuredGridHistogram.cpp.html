<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSimpleUnstructuredGridHistogram.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkSimpleUnstructuredGridHistogram.h"

#include &lt;mitkUnstructuredGrid.h&gt;

#include &lt;itkSampleToHistogramFilter.h&gt;
#include &lt;vtkDataArray.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkUnstructuredGrid.h&gt;

namespace mitk
{
  SimpleUnstructuredGridHistogram::SimpleUnstructuredGridHistogram()
<span style = "background-color:#fdd">    : m_UGHistogram(HistogramType::New()), m_InvMaxFrequency(1)
  {</span>
    // MITK_INFO &lt;&lt; "#######  Created a SimpleUnstructuredGridHistogram";
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  double SimpleUnstructuredGridHistogram::GetMin() const { return m_UGHistogram-&gt;GetBinMin(0, 0); }</span>
  double SimpleUnstructuredGridHistogram::GetMax() const
<span style = "background-color:#fdd">  {
    return m_UGHistogram-&gt;GetBinMax(0, m_UGHistogram-&gt;GetSize(0) - 1);
  }</span>

  void SimpleUnstructuredGridHistogram::ComputeFromBaseData(BaseData *source)
<span style = "background-color:#fdd">  {
    auto *grid = dynamic_cast&lt;UnstructuredGrid *&gt;(source);</span>
    // m_UGHistogram-&gt;Initialize(grid);

<span style = "background-color:#fdd">    vtkUnstructuredGrid *vtkUGrid = grid-&gt;GetVtkUnstructuredGrid();</span>

<span style = "background-color:#fdd">    ListSampleType::Pointer listSample = ListSampleType::New();
    listSample-&gt;SetMeasurementVectorSize(1);</span>

    MeasurementVectorType v;

    MeasurementVectorType lowerBound;
    MeasurementVectorType upperBound;

<span style = "background-color:#fdd">    int numberOfBins = 1;
    HistogramType::SizeType size(1);</span>

    vtkDataArray *data;
<span style = "background-color:#fdd">    /*if (m_UsePointData)*/ data = vtkUGrid-&gt;GetPointData()-&gt;GetScalars();</span>
    // else data = vtkUGrid-&gt;GetCellData()-&gt;GetScalars();

<span style = "background-color:#fdd">    if (data == nullptr)</span>
    {
<span style = "background-color:#fdd">      listSample-&gt;Resize(1);
      v[0] = 0;
      listSample-&gt;PushBack(v);
      lowerBound[0] = 0;
      upperBound[0] = 0;
      size.Fill(numberOfBins);
    }</span>
    else
    {
<span style = "background-color:#fdd">      listSample-&gt;Resize(data-&gt;GetNumberOfTuples());
      for (vtkIdType i = 0; i &lt; data-&gt;GetNumberOfTuples(); ++i)</span>
      {
<span style = "background-color:#fdd">        v[0] = data-&gt;GetComponent(i, 0);</span>
        // if (v[0] != 0) MITK_INFO &lt;&lt; "ug scalar: " &lt;&lt; v[0];
<span style = "background-color:#fdd">        listSample-&gt;PushBack(v);
      }</span>

<span style = "background-color:#fdd">      vtkIdType numberOfTuples = data-&gt;GetNumberOfTuples();</span>

<span style = "background-color:#fdd">      if (numberOfTuples &lt; 1000)
        numberOfBins = 250;
      else if (numberOfTuples &lt; 30000)
        numberOfBins = 100;
      else if (numberOfTuples &lt; 100000)
        numberOfBins = 50;</span>
      else
<span style = "background-color:#fdd">        numberOfBins = 20;</span>

<span style = "background-color:#fdd">      size.Fill(numberOfBins);</span>

      double range[2];
<span style = "background-color:#fdd">      data-&gt;GetRange(range);
      lowerBound[0] = range[0];
      upperBound[0] = range[1];</span>
    }

    typedef itk::Statistics::SampleToHistogramFilter&lt;ListSampleType, HistogramType&gt; FilterType;
<span style = "background-color:#fdd">    FilterType::Pointer histoFilter = FilterType::New();</span>

<span style = "background-color:#fdd">    FilterType::HistogramMeasurementVectorType binMin(1);
    FilterType::HistogramMeasurementVectorType binMax(1);</span>

<span style = "background-color:#fdd">    binMin[0] = lowerBound[0];
    binMax[0] = upperBound[0];</span>

<span style = "background-color:#fdd">    histoFilter-&gt;SetInput(listSample);
    histoFilter-&gt;SetHistogramSize(size);
    histoFilter-&gt;SetHistogramBinMinimum(binMin);
    histoFilter-&gt;SetHistogramBinMaximum(binMax);
    histoFilter-&gt;Update();</span>

<span style = "background-color:#fdd">    m_UGHistogram = histoFilter-&gt;GetOutput();</span>

<span style = "background-color:#fdd">    m_BinSize = (GetMax() - GetMin()) / (double)numberOfBins;</span>

<span style = "background-color:#fdd">    m_Mins = m_UGHistogram-&gt;GetMins();
    m_Maxs = m_UGHistogram-&gt;GetMaxs();</span>

<span style = "background-color:#fdd">    HistogramType::AbsoluteFrequencyType maxFrequency = 0;
    HistogramType::SizeValueType histoSize = m_UGHistogram-&gt;GetSize(0);
    for (HistogramType::SizeValueType i = 0; i &lt; histoSize; ++i)</span>
    {
<span style = "background-color:#fdd">      HistogramType::AbsoluteFrequencyType f = m_UGHistogram-&gt;GetFrequency(i);
      if (f &gt; maxFrequency)</span>
      {
<span style = "background-color:#fdd">        maxFrequency = f;</span>
      }
      // MITK_INFO &lt;&lt; "Bin #" &lt;&lt; i &lt;&lt; ": " &lt;&lt; m_UGHistogram-&gt;GetMeasurement(i,0);
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    if (maxFrequency)</span>
    {
<span style = "background-color:#fdd">      m_InvMaxFrequency = 1.0 / log((double)maxFrequency);</span>
    }

    // MITK_INFO &lt;&lt; "UGHistogramm size: " &lt;&lt; m_UGHistogram-&gt;GetSize(0) &lt;&lt; ", maxF: " &lt;&lt; maxFrequency
    //    &lt;&lt; " min count: " &lt;&lt; m_Mins.size() &lt;&lt; " max count: " &lt;&lt; m_Maxs.size();
<span style = "background-color:#fdd">  }</span>

  float SimpleUnstructuredGridHistogram::GetRelativeBin(double start, double end) const
<span style = "background-color:#fdd">  {</span>
    // MITK_INFO &lt;&lt; "GetRelativeBin start: " &lt;&lt; start &lt;&lt; ", end: " &lt;&lt; end;
<span style = "background-color:#fdd">    HistogramType::AbsoluteFrequencyType maxf = 0;
    for (double pos = start; pos &lt; end; pos += m_BinSize)</span>
    {
<span style = "background-color:#fdd">      HistogramType::AbsoluteFrequencyType f = m_UGHistogram-&gt;GetFrequency(m_UGHistogram-&gt;GetIndex(pos));
      if (f &gt; maxf)
        maxf = f;
    }</span>

<span style = "background-color:#fdd">    return log(static_cast&lt;double&gt;(maxf)) * m_InvMaxFrequency;
  }</span>
}</pre>
	</body>
</html>