<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkMovieGeneratorWin32.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkMovieGeneratorWin32.h"
#include &lt;GL/gl.h&gt;

mitk::MovieGeneratorWin32::MovieGeneratorWin32()
<span style = "background-color:#fdd">{
}</span>

void mitk::MovieGeneratorWin32::SetFileName(const char *fileName)
<span style = "background-color:#fdd">{
  m_sFile = _T(fileName);
  if (_tcsstr((char *)m_sFile, _T("avi")) == nullptr)
    m_sFile += _T( ".avi" );
}</span>

void mitk::MovieGeneratorWin32::InitBitmapHeader()
<span style = "background-color:#fdd">{
  m_width = m_renderer-&gt;GetRenderWindow()-&gt;GetSize()[0];  // changed from glGetIntegerv( GL_VIEWPORT, viewport );
  m_height = m_renderer-&gt;GetRenderWindow()-&gt;GetSize()[1]; // due to sometimes strange dimensions</span>

<span style = "background-color:#fdd">  m_width -= 10; // remove colored boarders around renderwindows
  m_height -= 10;</span>

<span style = "background-color:#fdd">  m_width -= m_width % 4; // some video codecs have prerequisites to the image dimensions
  m_height -= m_height % 4;</span>

  BITMAPINFOHEADER bih;
<span style = "background-color:#fdd">  bih.biSize = sizeof(BITMAPINFOHEADER);
  bih.biWidth = m_width;
  bih.biHeight = m_height;
  bih.biPlanes = 1;
  int imgSize = 3 /* BRG*/ * bih.biWidth * bih.biHeight;
  bih.biBitCount = 24;
  bih.biCompression = BI_RGB;
  bih.biSizeImage = imgSize;
  bih.biClrUsed = 0;
  bih.biClrImportant = 0;</span>

  // ASSERT(bih.biWidth%4==0);
  // ASSERT(bih.biHeight%4==0);

  // copying bitmap info structure.
<span style = "background-color:#fdd">  memcpy(&amp;m_bih, &amp;bih, sizeof(BITMAPINFOHEADER));
}</span>

bool mitk::MovieGeneratorWin32::InitGenerator()
<span style = "background-color:#fdd">{
  InitBitmapHeader();</span>

  AVISTREAMINFO strHdr; // information for a single stream
  AVICOMPRESSOPTIONS opts;
<span style = "background-color:#fdd">  AVICOMPRESSOPTIONS FAR *aopts[1] = {&amp;opts};</span>

  TCHAR szBuffer[1024];
  HRESULT hr;

<span style = "background-color:#fdd">  m_sError = _T("Ok");</span>

  // Step 0 : Let's make sure we are running on 1.1
<span style = "background-color:#fdd">  DWORD wVer = HIWORD(VideoForWindowsVersion());
  if (wVer &lt; 0x010a)</span>
  {
    // oops, we are too old, blow out of here
<span style = "background-color:#fdd">    m_sError = _T("Version of Video for Windows too old. Come on, join the 21th century!");
    return false;</span>
  }

  // Step 1 : initialize AVI engine
<span style = "background-color:#fdd">  AVIFileInit();</span>

  // Step 2 : Open the movie file for writing....
<span style = "background-color:#fdd">  hr = AVIFileOpen(&amp;m_pAVIFile,          // Address to contain the new file interface pointer</span>
                   (LPCTSTR)m_sFile,     // Null-terminated string containing the name of the file to open
                   OF_WRITE | OF_CREATE, // Access mode to use when opening the file.
                   nullptr);                // use handler determined from file extension.
  // Name your file .avi -&gt; very important

<span style = "background-color:#fdd">  if (hr != AVIERR_OK)</span>
  {
<span style = "background-color:#fdd">    _tprintf(szBuffer, _T("AVI Engine failed to initialize. Check filename %s."), m_sFile);
    m_sError = szBuffer;</span>
    // Check it succeded.
<span style = "background-color:#fdd">    switch (hr)</span>
    {
      case AVIERR_BADFORMAT:
<span style = "background-color:#fdd">        m_sError += _T("The file couldn't be read, indicating a corrupt file or an unrecognized format.");
        break;</span>
      case AVIERR_MEMORY:
<span style = "background-color:#fdd">        m_sError += _T("The file could not be opened because of insufficient memory.");
        break;</span>
      case AVIERR_FILEREAD:
<span style = "background-color:#fdd">        m_sError += _T("A disk error occurred while reading the file.");
        break;</span>
      case AVIERR_FILEOPEN:
<span style = "background-color:#fdd">        m_sError += _T("A disk error occurred while opening the file.");
        break;</span>
      case REGDB_E_CLASSNOTREG:
<span style = "background-color:#fdd">        m_sError += _T("According to the registry, the type of file specified in AVIFileOpen does not have a handler ")</span>
                    _T("to process it");
        break;
    }

<span style = "background-color:#fdd">    return false;</span>
  }

  // Fill in the header for the video stream....
<span style = "background-color:#fdd">  memset(&amp;strHdr, 0, sizeof(strHdr));
  strHdr.fccType = streamtypeVIDEO; // video stream type
  strHdr.fccHandler = 0;
  strHdr.dwScale = 1;                               // should be one for video
  strHdr.dwRate = static_cast&lt;DWORD&gt;(m_FrameRate);  // fps
  strHdr.dwSuggestedBufferSize = m_bih.biSizeImage; // Recommended buffer size, in bytes, for the stream.
  SetRect(&amp;strHdr.rcFrame,</span>
          0,
          0, // rectangle for stream
          (int)m_bih.biWidth,
          (int)m_bih.biHeight);

  // Step 3 : Create the stream;
<span style = "background-color:#fdd">  hr = AVIFileCreateStream(m_pAVIFile, // file pointer</span>
                           &amp;m_pStream, // returned stream pointer
                           &amp;strHdr);   // stream header

  // Check it succeded.
<span style = "background-color:#fdd">  if (hr != AVIERR_OK)</span>
  {
<span style = "background-color:#fdd">    m_sError = _T("AVI Stream creation failed. Check Bitmap info.");
    if (hr == AVIERR_READONLY)</span>
    {
<span style = "background-color:#fdd">      m_sError += _T(" Read only file.");</span>
    }
<span style = "background-color:#fdd">    return false;</span>
  }

  // Step 4: Get codec and infos about codec
<span style = "background-color:#fdd">  memset(&amp;opts, 0, sizeof(opts));</span>

  // predefine MS-CRAM as standard codec
<span style = "background-color:#fdd">  opts.fccType = streamtypeVIDEO;</span>
  // creates a video with minor quality! Use different codec (must be installed on local machine) to generate movies
  // with higher quality
<span style = "background-color:#fdd">  opts.fccHandler = mmioFOURCC('M', 'S', 'V', 'C');
  opts.dwQuality = 90000; // means 90% quality; dwQuality goes from [0...10000]</span>

// Poping codec dialog
// GUI Codec selection does not work in a vs 2005 compiled mitk, since we do not pass a hwnd as first parameter
// of AVISaveOptions
#if !(_MSC_VER &gt;= 1400)

  if (!AVISaveOptions(nullptr, 0, 1, &amp;m_pStream, (LPAVICOMPRESSOPTIONS FAR *)&amp;aopts))
  {
    AVISaveOptionsFree(1, (LPAVICOMPRESSOPTIONS FAR *)&amp;aopts);
    // return false;
  }

#endif

  // Step 5:  Create a compressed stream using codec options.
<span style = "background-color:#fdd">  hr = AVIMakeCompressedStream(&amp;m_pStreamCompressed, m_pStream, &amp;opts, nullptr);</span>

<span style = "background-color:#fdd">  if (hr != AVIERR_OK)</span>
  {
<span style = "background-color:#fdd">    m_sError = _T("AVI Compressed Stream creation failed.");</span>

<span style = "background-color:#fdd">    switch (hr)</span>
    {
      case AVIERR_NOCOMPRESSOR:
<span style = "background-color:#fdd">        m_sError += _T(" A suitable compressor cannot be found.");
        break;</span>
      case AVIERR_MEMORY:
<span style = "background-color:#fdd">        m_sError += _T(" There is not enough memory to complete the operation.");
        break;</span>
      case AVIERR_UNSUPPORTED:
<span style = "background-color:#fdd">        m_sError += _T("Compression is not supported for this type of data. This error might be returned if you try ")</span>
                    _T("to compress data that is not audio or video.");
        break;
    }

<span style = "background-color:#fdd">    return false;</span>
  }

  // releasing memory allocated by AVISaveOptionFree
<span style = "background-color:#fdd">  hr = AVISaveOptionsFree(1, (LPAVICOMPRESSOPTIONS FAR *)&amp;aopts);
  if (hr != AVIERR_OK)</span>
  {
<span style = "background-color:#fdd">    m_sError = _T("Error releasing memory");
    return false;</span>
  }

  // Step 6 : sets the format of a stream at the specified position
<span style = "background-color:#fdd">  hr = AVIStreamSetFormat(m_pStreamCompressed,</span>
                          0,             // position
                          &amp;m_bih,        // stream format
                          m_bih.biSize + // format size
                            m_bih.biClrUsed * sizeof(RGBQUAD));

<span style = "background-color:#fdd">  if (hr != AVIERR_OK)</span>
  {
<span style = "background-color:#fdd">    m_sError = _T("AVI Compressed Stream format setting failed.");
    return false;</span>
  }

  // Step 6 : Initialize step counter
<span style = "background-color:#fdd">  m_lFrame = 0;</span>

<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::MovieGeneratorWin32::AddFrame(void *data)
<span style = "background-color:#fdd">{
  HRESULT hr = AVIStreamWrite(m_pStreamCompressed, // stream pointer</span>
                              m_lFrame,            // time of this frame
                              1,                   // number to write
                              (BYTE *)data,        // image buffer
                              m_bih.biSizeImage,   // size of this frame
                              AVIIF_KEYFRAME,      // flags....
                              nullptr,
                              nullptr);
  // updating frame counter
<span style = "background-color:#fdd">  m_lFrame++;</span>

<span style = "background-color:#fdd">  if (hr == AVIERR_OK)
    return true;</span>
  else
<span style = "background-color:#fdd">    return false;
}</span>

bool mitk::MovieGeneratorWin32::TerminateGenerator()
<span style = "background-color:#fdd">{
  if (m_pStream)</span>
  {
<span style = "background-color:#fdd">    AVIStreamRelease(m_pStream);
    m_pStream = nullptr;</span>
  }
<span style = "background-color:#fdd">  if (m_pStreamCompressed)</span>
  {
<span style = "background-color:#fdd">    AVIStreamRelease(m_pStreamCompressed);
    m_pStreamCompressed = nullptr;</span>
  }
<span style = "background-color:#fdd">  if (m_pAVIFile)</span>
  {
<span style = "background-color:#fdd">    AVIFileRelease(m_pAVIFile);
    m_pAVIFile = nullptr;</span>
  }
  // Close engine
<span style = "background-color:#fdd">  AVIFileExit();
  return true;
}</span></pre>
	</body>
</html>