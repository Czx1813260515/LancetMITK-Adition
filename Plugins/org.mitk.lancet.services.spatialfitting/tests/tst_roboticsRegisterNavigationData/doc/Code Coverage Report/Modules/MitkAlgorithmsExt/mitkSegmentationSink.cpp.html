<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSegmentationSink.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkSegmentationSink.h"
#include "mitkDataStorage.h"
#include "mitkRenderingManager.h"

namespace mitk
{
<span style = "background-color:#fdd">  SegmentationSink::SegmentationSink() {}
  SegmentationSink::~SegmentationSink() {}</span>
  void SegmentationSink::Initialize(const NonBlockingAlgorithm *other)
<span style = "background-color:#fdd">  {
    Superclass::Initialize(other);</span>
    // sinks should be called explicitly from the tool, because otherwise the order of setting "Input" and "Group node"
    // would matter
<span style = "background-color:#fdd">    UnDefineTriggerParameter("Input");</span>

    // some basedata output
<span style = "background-color:#fdd">    DataNode::Pointer groupNode;
    bool showResult(true);</span>

<span style = "background-color:#fdd">    if (other)</span>
    {
<span style = "background-color:#fdd">      other-&gt;GetPointerParameter("Group node", groupNode);
      other-&gt;GetParameter("Show result", showResult);</span>
    }

<span style = "background-color:#fdd">    SetPointerParameter("Group node", groupNode);
    SetParameter("Show result", showResult);
  }</span>

  bool SegmentationSink::ReadyToRun()
<span style = "background-color:#fdd">  {
    Image::Pointer image;
    GetPointerParameter("Input", image);</span>

<span style = "background-color:#fdd">    DataNode::Pointer groupNode;
    GetPointerParameter("Group node", groupNode);</span>

<span style = "background-color:#fdd">    return image.IsNotNull() &amp;&amp; groupNode.IsNotNull();
  }</span>

<span style = "background-color:#fdd">  bool SegmentationSink::ThreadedUpdateFunction() { return true; }</span>
  /// to be called by subclasses when they want to insert some resulting object (binary image, surface, ...) into the
  /// data tree
  void SegmentationSink::InsertBelowGroupNode(mitk::DataNode *node)
<span style = "background-color:#fdd">  {
    DataNode *groupNode = GetGroupNode();</span>

<span style = "background-color:#fdd">    if (!m_DataStorage.IsExpired())</span>
    {
<span style = "background-color:#fdd">      if (node)
        node-&gt;GetData()-&gt;DisconnectPipeline();
      m_DataStorage.Lock()-&gt;Add(node, groupNode);</span>
    }

<span style = "background-color:#fdd">    RenderingManager::GetInstance()-&gt;RequestUpdateAll();
  }</span>

  DataNode *SegmentationSink::GetGroupNode()
<span style = "background-color:#fdd">  {
    DataNode::Pointer groupNode;
    GetPointerParameter("Group node", groupNode);</span>

<span style = "background-color:#fdd">    return groupNode.GetPointer();
  }</span>

  DataNode *SegmentationSink::LookForPointerTargetBelowGroupNode(const char *name)
<span style = "background-color:#fdd">  {
    DataNode::Pointer groupNode;
    GetPointerParameter("Group node", groupNode);</span>

<span style = "background-color:#fdd">    if (groupNode.IsNotNull() &amp;&amp; !m_DataStorage.IsExpired())</span>
    {
<span style = "background-color:#fdd">      return m_DataStorage.Lock()-&gt;GetNamedDerivedNode(name, groupNode, true);</span>
    }

<span style = "background-color:#fdd">    return nullptr;
  }</span>

} // namespace</pre>
	</body>
</html>