<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkAnisotropicIterativeClosestPointRegistration.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

// MITK
#include "mitkAnisotropicIterativeClosestPointRegistration.h"
#include "mitkAnisotropicRegistrationCommon.h"
#include "mitkWeightedPointTransform.h"
#include &lt;mitkProgressBar.h&gt;
#include &lt;mitkSurface.h&gt;
// VTK
#include &lt;vtkIdList.h&gt;
#include &lt;vtkKdTree.h&gt;
#include &lt;vtkKdTreePointLocator.h&gt;
#include &lt;vtkPoints.h&gt;
#include &lt;vtkPolyData.h&gt;
// STL pair
#include &lt;utility&gt;

/** \brief Comperator implementation used to sort the CorrespondenceList in the
  *        trimmed version of the AnisotropicIterativeClosestPointRegistration.
  */
struct AICPComperator
{
  typedef std::pair&lt;unsigned int, double&gt; Correspondence;

<span style = "background-color:#fdd">  bool operator()(const Correspondence &amp;a, const Correspondence &amp;b) { return (a.second &lt; b.second); }</span>
} AICPComp;

mitk::AnisotropicIterativeClosestPointRegistration::AnisotropicIterativeClosestPointRegistration()
<span style = "background-color:#fdd">  : m_MaxIterations(1000),
    m_Threshold(0.000001),
    m_FRENormalizationFactor(1.0),
    m_SearchRadius(30.0),
    m_MaxIterationsInWeightedPointTransform(1000),
    m_FRE(0.0),
    m_TrimmFactor(0.0),
    m_NumberOfIterations(0),
    m_MovingSurface(nullptr),
    m_FixedSurface(nullptr),
    m_WeightedPointTransform(mitk::WeightedPointTransform::New())
{
}</span>

mitk::AnisotropicIterativeClosestPointRegistration::~AnisotropicIterativeClosestPointRegistration()
<span style = "background-color:#fdd">{
}</span>

void mitk::AnisotropicIterativeClosestPointRegistration::ComputeCorrespondences(vtkPoints *X,
                                                                                vtkPoints *Z,
                                                                                vtkKdTreePointLocator *Y,
                                                                                const CovarianceMatrixList &amp;sigma_X,
                                                                                const CovarianceMatrixList &amp;sigma_Y,
                                                                                CovarianceMatrixList &amp;sigma_Z,
                                                                                CorrespondenceList &amp;correspondences,
                                                                                const double radius)
<span style = "background-color:#fdd">{</span>
  typedef itk::Matrix&lt;double, 3, 3&gt; WeightMatrix;

<span style = "background-color:#fdd">#pragma omp parallel for
  for (int i = 0; i &lt; X-&gt;GetNumberOfPoints(); ++i)</span>
  {
<span style = "background-color:#fdd">    vtkIdType bestIdx = 0;
    mitk::Vector3D x;
    mitk::Vector3D y;
    double bestDist = std::numeric_limits&lt;double&gt;::max();
    vtkIdList *ids = vtkIdList::New();
    double r = radius;</span>
    double p[3];
    // get point
<span style = "background-color:#fdd">    X-&gt;GetPoint(i, p);</span>
    // fill vector
<span style = "background-color:#fdd">    x[0] = p[0];
    x[1] = p[1];
    x[2] = p[2];</span>

    // double the radius till we find at least one point
<span style = "background-color:#fdd">    while (ids-&gt;GetNumberOfIds() &lt;= 0)</span>
    {
<span style = "background-color:#fdd">      Y-&gt;FindPointsWithinRadius(r, p, ids);
      r *= 2.0;
    }</span>

    // loop over the points in the sphere and find the point with the
    // minimal weighted squared distance
<span style = "background-color:#fdd">    for (vtkIdType j = 0; j &lt; ids-&gt;GetNumberOfIds(); ++j)</span>
    {
      // get id
<span style = "background-color:#fdd">      const vtkIdType id = ids-&gt;GetId(j);</span>
      // compute weightmatrix
<span style = "background-color:#fdd">      WeightMatrix m = mitk::AnisotropicRegistrationCommon::CalculateWeightMatrix(sigma_X[i], sigma_Y[id]);</span>
      // point of the fixed data set
<span style = "background-color:#fdd">      Y-&gt;GetDataSet()-&gt;GetPoint(id, p);</span>

      // fill mitk vector
<span style = "background-color:#fdd">      y[0] = p[0];
      y[1] = p[1];
      y[2] = p[2];</span>

<span style = "background-color:#fdd">      const mitk::Vector3D res = m * (x - y);</span>

<span style = "background-color:#fdd">      const double dist = res[0] * res[0] + res[1] * res[1] + res[2] * res[2];</span>

<span style = "background-color:#fdd">      if (dist &lt; bestDist)</span>
      {
<span style = "background-color:#fdd">        bestDist = dist;
        bestIdx = id;</span>
      }
<span style = "background-color:#fdd">    }</span>

    // save correspondences of the fixed point set
<span style = "background-color:#fdd">    Y-&gt;GetDataSet()-&gt;GetPoint(bestIdx, p);
    Z-&gt;SetPoint(i, p);
    sigma_Z[i] = sigma_Y[bestIdx];</span>

<span style = "background-color:#fdd">    Correspondence _pair(i, bestDist);
    correspondences[i] = _pair;</span>

<span style = "background-color:#fdd">    ids-&gt;Delete();
  }
}</span>

void mitk::AnisotropicIterativeClosestPointRegistration::Update()
<span style = "background-color:#fdd">{
  unsigned int k = 0;
  unsigned int numberOfTrimmedPoints = 0;
  double diff = 0.0;
  double FRE_new = std::numeric_limits&lt;double&gt;::max();</span>
  // Moving pointset
<span style = "background-color:#fdd">  vtkPoints *X = vtkPoints::New();</span>
  // Correspondences
<span style = "background-color:#fdd">  vtkPoints *Z = vtkPoints::New();</span>
  // Covariance matrices of the pointset X
<span style = "background-color:#fdd">  CovarianceMatrixList &amp;Sigma_X = m_CovarianceMatricesMovingSurface;</span>
  // Covariance matrices of the pointset Y
<span style = "background-color:#fdd">  CovarianceMatrixList &amp;Sigma_Y = m_CovarianceMatricesFixedSurface;</span>
  // Covariance matrices of the correspondences
<span style = "background-color:#fdd">  CovarianceMatrixList Sigma_Z;</span>
  // transform of the current iteration
<span style = "background-color:#fdd">  Rotation RotationNew;
  Translation TranslationNew;</span>
  // corresponding indizes with distance
<span style = "background-color:#fdd">  CorrespondenceList distanceList;</span>
  // sorted datasets used if trimming is enabled
<span style = "background-color:#fdd">  vtkPoints *X_sorted = vtkPoints::New();
  vtkPoints *Z_sorted = vtkPoints::New();
  CovarianceMatrixList Sigma_X_sorted;
  CovarianceMatrixList Sigma_Z_sorted;</span>

  // create kdtree for correspondence search
<span style = "background-color:#fdd">  vtkKdTreePointLocator *Y = vtkKdTreePointLocator::New();
  Y-&gt;SetDataSet(m_FixedSurface-&gt;GetVtkPolyData());
  Y-&gt;BuildLocator();</span>

  // initialize local variables
  // copy the moving pointset to prevent to modify it
<span style = "background-color:#fdd">  X-&gt;DeepCopy(m_MovingSurface-&gt;GetVtkPolyData()-&gt;GetPoints());</span>
  // initialize size of the correspondences
<span style = "background-color:#fdd">  Z-&gt;SetNumberOfPoints(X-&gt;GetNumberOfPoints());</span>
  // size of the corresponding matrices
<span style = "background-color:#fdd">  Sigma_Z.resize(X-&gt;GetNumberOfPoints());
  distanceList.resize(X-&gt;GetNumberOfPoints());
  RotationNew.SetIdentity();
  TranslationNew.Fill(0.0);</span>

  // reset members
<span style = "background-color:#fdd">  m_FRE = std::numeric_limits&lt;double&gt;::max();
  m_Rotation.SetIdentity();
  m_Translation.Fill(0.0);</span>

  // compute number of correspondences based
  // on the trimmfactor
<span style = "background-color:#fdd">  if (m_TrimmFactor &gt; 0.0)</span>
  {
<span style = "background-color:#fdd">    numberOfTrimmedPoints = X-&gt;GetNumberOfPoints() * m_TrimmFactor;</span>
  }

  // initialize the sizes of the sorted datasets
  // used in the trimmed version of the algorithm
<span style = "background-color:#fdd">  Sigma_Z_sorted.resize(numberOfTrimmedPoints);
  Sigma_X_sorted.resize(numberOfTrimmedPoints);
  X_sorted-&gt;SetNumberOfPoints(numberOfTrimmedPoints);
  Z_sorted-&gt;SetNumberOfPoints(numberOfTrimmedPoints);</span>

  // initialize the progress bar
<span style = "background-color:#fdd">  unsigned int steps = m_MaxIterations;
  unsigned int stepSize = m_MaxIterations / 10;
  mitk::ProgressBar::GetInstance()-&gt;AddStepsToDo(steps);</span>

  do
  {
    // reset innerloop
<span style = "background-color:#fdd">    double currSearchRadius = m_SearchRadius;
    unsigned int radiusDoubled = 0;</span>

<span style = "background-color:#fdd">    k = k + 1;</span>

<span style = "background-color:#fdd">    MITK_DEBUG &lt;&lt; "iteration: " &lt;&lt; k;</span>

    do
    {
      // search correspondences
<span style = "background-color:#fdd">      ComputeCorrespondences(X, Z, Y, Sigma_X, Sigma_Y, Sigma_Z, distanceList, currSearchRadius);</span>

      // tmp pointers
<span style = "background-color:#fdd">      vtkPoints *X_k = X;
      vtkPoints *Z_k = Z;
      CovarianceMatrixList *Sigma_Z_k = &amp;Sigma_Z;
      CovarianceMatrixList *Sigma_X_k = &amp;Sigma_X;</span>

      // sort the correspondences depending on their
      // distance, if trimming is enabled
<span style = "background-color:#fdd">      if (m_TrimmFactor &gt; 0.0)</span>
      {
<span style = "background-color:#fdd">        std::sort(distanceList.begin(), distanceList.end(), AICPComp);</span>
        // map correspondences to the data arrays
<span style = "background-color:#fdd">        for (unsigned int i = 0; i &lt; numberOfTrimmedPoints; ++i)</span>
        {
<span style = "background-color:#fdd">          const int idx = distanceList[i].first;
          Sigma_Z_sorted[i] = Sigma_Z[idx];
          Sigma_X_sorted[i] = Sigma_X[idx];
          Z_sorted-&gt;SetPoint(i, Z-&gt;GetPoint(idx));
          X_sorted-&gt;SetPoint(i, X-&gt;GetPoint(idx));
        }</span>
        // assign pointers
<span style = "background-color:#fdd">        X_k = X_sorted;
        Z_k = Z_sorted;
        Sigma_X_k = &amp;Sigma_X_sorted;
        Sigma_Z_k = &amp;Sigma_Z_sorted;</span>
      }

      // compute weighted transformation
      // set parameters
<span style = "background-color:#fdd">      m_WeightedPointTransform-&gt;SetMovingPointSet(X_k);
      m_WeightedPointTransform-&gt;SetFixedPointSet(Z_k);
      m_WeightedPointTransform-&gt;SetCovarianceMatricesMoving(*Sigma_X_k);
      m_WeightedPointTransform-&gt;SetCovarianceMatricesFixed(*Sigma_Z_k);
      m_WeightedPointTransform-&gt;SetMaxIterations(m_MaxIterationsInWeightedPointTransform);
      m_WeightedPointTransform-&gt;SetFRENormalizationFactor(m_FRENormalizationFactor);</span>

      // run computation
<span style = "background-color:#fdd">      m_WeightedPointTransform-&gt;ComputeTransformation();</span>
      // retrieve result
<span style = "background-color:#fdd">      RotationNew = m_WeightedPointTransform-&gt;GetTransformR();
      TranslationNew = m_WeightedPointTransform-&gt;GetTransformT();
      FRE_new = m_WeightedPointTransform-&gt;GetFRE();</span>

      // double the radius
<span style = "background-color:#fdd">      radiusDoubled += 1;
      currSearchRadius *= 2.0;</span>

      // sanity check to prevent endless loop
<span style = "background-color:#fdd">      if (radiusDoubled &gt;= 20)</span>
      {
<span style = "background-color:#fdd">        mitkThrow() &lt;&lt; "Radius doubled 20 times, preventing endless loop, check input and search radius";</span>
      }

      // termination constraint
<span style = "background-color:#fdd">      diff = m_FRE - FRE_new;</span>

<span style = "background-color:#fdd">    } while (diff &lt; -1.0e-3); // increase radius as long as the FRE grows</span>

<span style = "background-color:#fdd">    MITK_DEBUG &lt;&lt; "FRE:" &lt;&lt; m_FRE &lt;&lt; ", FRE_new: " &lt;&lt; FRE_new;</span>
    // transform points and propagate matrices
<span style = "background-color:#fdd">    mitk::AnisotropicRegistrationCommon::TransformPoints(X, X, RotationNew, TranslationNew);
    mitk::AnisotropicRegistrationCommon::PropagateMatrices(Sigma_X, Sigma_X, RotationNew);</span>

    // update global transformation
<span style = "background-color:#fdd">    m_Rotation = RotationNew * m_Rotation;
    m_Translation = RotationNew * m_Translation + TranslationNew;</span>

<span style = "background-color:#fdd">    MITK_DEBUG &lt;&lt; "diff:" &lt;&lt; diff;</span>
    // update FRE
<span style = "background-color:#fdd">    m_FRE = FRE_new;</span>

    // update the progressbar. Just use the half every 2nd iteration
    // to use a simulated endless progress bar since we don't have
    // a fixed amount of iterations
<span style = "background-color:#fdd">    stepSize = (k % 2 == 0) ? stepSize / 2 : stepSize;
    stepSize = (stepSize == 0) ? 1 : stepSize;
    mitk::ProgressBar::GetInstance()-&gt;Progress(stepSize);</span>

<span style = "background-color:#fdd">  } while (diff &gt; m_Threshold &amp;&amp; k &lt; m_MaxIterations);</span>

<span style = "background-color:#fdd">  m_NumberOfIterations = k;</span>

  // finish the progress bar if there are more steps
  // left than iterations used
<span style = "background-color:#fdd">  if (k &lt; steps)
    mitk::ProgressBar::GetInstance()-&gt;Progress(steps);</span>

  // free memory
<span style = "background-color:#fdd">  Y-&gt;Delete();
  Z-&gt;Delete();
  X-&gt;Delete();
  X_sorted-&gt;Delete();
  Z_sorted-&gt;Delete();
}</span></pre>
	</body>
</html>