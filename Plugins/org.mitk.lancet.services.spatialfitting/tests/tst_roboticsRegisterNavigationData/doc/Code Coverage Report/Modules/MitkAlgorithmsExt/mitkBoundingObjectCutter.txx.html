<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkBoundingObjectCutter.txx</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKBOUNDINGOBJECTCUTTER_TXX
#define MITKBOUNDINGOBJECTCUTTER_TXX

#include "itkImageRegionIteratorWithIndex.h"
#include "mitkImageToItk.h"
#include "mitkStatusBar.h"

namespace mitk
{
  template &lt;typename TPixel, unsigned int VImageDimension, typename TOutputPixel&gt;
  void CutImageWithOutputTypeSelect(itk::Image&lt;TPixel, VImageDimension&gt; *inputItkImage,
                                    mitk::BoundingObjectCutter *cutter,
                                    int /* boTimeStep */,
                                    TOutputPixel * /* dummy */)
<span style = "background-color:#fdd">  {</span>
    typedef itk::Image&lt;TPixel, VImageDimension&gt; ItkInputImageType;
    typedef itk::Image&lt;TOutputPixel, VImageDimension&gt; ItkOutputImageType;
    typedef typename itk::ImageBase&lt;VImageDimension&gt;::RegionType ItkRegionType;
    typedef itk::ImageRegionIteratorWithIndex&lt;ItkInputImageType&gt; ItkInputImageIteratorType;
    typedef itk::ImageRegionIteratorWithIndex&lt;ItkOutputImageType&gt; ItkOutputImageIteratorType;

<span style = "background-color:#fdd">    if (cutter-&gt;m_BoundingObject.IsNull())
      return;</span>

<span style = "background-color:#fdd">    if (inputItkImage == nullptr)</span>
    {
<span style = "background-color:#fdd">      mitk::StatusBar::GetInstance()-&gt;DisplayErrorText(</span>
        "An internal error occurred. Can't convert Image. Please report to bugs@mitk.org");
<span style = "background-color:#fdd">      std::cout &lt;&lt; " image is NULL...returning" &lt;&lt; std::endl;
      return;</span>
    }

    // PART 1: convert m_InputRequestedReg ion (type mitk::SlicedData::RegionType)
    // into ITK-image-region (ItkImageType::RegionType)
    // unfortunately, we cannot use input-&gt;GetRequestedRegion(), because it
    // has been destroyed by the mitk::CastToItkImage call of PART 1
    // (which sets the m_RequestedRegion to the LargestPossibleRegion).
    // Thus, use our own member m_InputRequestedRegion insead.

    // first convert the index
    typename ItkRegionType::IndexType::IndexValueType tmpIndex[3];
<span style = "background-color:#fdd">    itk2vtk(cutter-&gt;m_InputRequestedRegion.GetIndex(), tmpIndex);</span>
    typename ItkRegionType::IndexType index;
<span style = "background-color:#fdd">    index.SetIndex(tmpIndex);</span>

    // then convert the size
    typename ItkRegionType::SizeType::SizeValueType tmpSize[3];
<span style = "background-color:#fdd">    itk2vtk(cutter-&gt;m_InputRequestedRegion.GetSize(), tmpSize);</span>
    typename ItkRegionType::SizeType size;
<span style = "background-color:#fdd">    size.SetSize(tmpSize);</span>

    // create the ITK-image-region out of index and size
<span style = "background-color:#fdd">    ItkRegionType inputRegionOfInterest(index, size);</span>

    // PART 2: get access to the MITK output image via an ITK image
<span style = "background-color:#fdd">    typename mitk::ImageToItk&lt;ItkOutputImageType&gt;::Pointer outputimagetoitk =</span>
      mitk::ImageToItk&lt;ItkOutputImageType&gt;::New();
<span style = "background-color:#fdd">    outputimagetoitk-&gt;SetInput(cutter-&gt;m_OutputTimeSelector-&gt;GetOutput());
    outputimagetoitk-&gt;Update();
    typename ItkOutputImageType::Pointer outputItkImage = outputimagetoitk-&gt;GetOutput();</span>

    // PART 3: iterate over input and output using ITK iterators

    // create the iterators
<span style = "background-color:#fdd">    ItkInputImageIteratorType inputIt(inputItkImage, inputRegionOfInterest);
    ItkOutputImageIteratorType outputIt(outputItkImage, outputItkImage-&gt;GetLargestPossibleRegion());</span>

    // Cut the boundingbox out of the image by iterating through
    // all pixels and checking if they are inside using IsInside()
<span style = "background-color:#fdd">    cutter-&gt;m_OutsidePixelCount = 0;
    cutter-&gt;m_InsidePixelCount = 0;
    mitk::Point3D p;
    mitk::BaseGeometry *inputGeometry = cutter-&gt;GetInput()-&gt;GetGeometry();</span>

    TOutputPixel outsideValue;
<span style = "background-color:#fdd">    if (cutter-&gt;m_AutoOutsideValue)</span>
    {
<span style = "background-color:#fdd">      outsideValue = itk::NumericTraits&lt;TOutputPixel&gt;::min();
    }</span>
    else
    {
<span style = "background-color:#fdd">      outsideValue = (TOutputPixel)cutter-&gt;m_OutsideValue;</span>
    }
    // shall we use a fixed value for each inside pixel?
<span style = "background-color:#fdd">    if (cutter-&gt;GetUseInsideValue())</span>
    {
<span style = "background-color:#fdd">      TOutputPixel insideValue = (TOutputPixel)cutter-&gt;m_InsideValue;</span>
      // yes, use a fixed value for each inside pixel (create a binary mask of the bounding object)
<span style = "background-color:#fdd">      for (inputIt.GoToBegin(), outputIt.GoToBegin(); !inputIt.IsAtEnd(); ++inputIt, ++outputIt)</span>
      {
<span style = "background-color:#fdd">        vtk2itk(inputIt.GetIndex(), p);
        inputGeometry-&gt;IndexToWorld(p, p);
        if (cutter-&gt;m_BoundingObject-&gt;IsInside(p))</span>
        {
<span style = "background-color:#fdd">          outputIt.Set(insideValue);
          ++cutter-&gt;m_InsidePixelCount;
        }</span>
        else
        {
<span style = "background-color:#fdd">          outputIt.Set(outsideValue);
          ++cutter-&gt;m_OutsidePixelCount;</span>
        }
<span style = "background-color:#fdd">      }
    }</span>
    else
    {
      // no, use the pixel value of the original image (normal cutting)
<span style = "background-color:#fdd">      for (inputIt.GoToBegin(), outputIt.GoToBegin(); !inputIt.IsAtEnd(); ++inputIt, ++outputIt)</span>
      {
<span style = "background-color:#fdd">        vtk2itk(inputIt.GetIndex(), p);
        inputGeometry-&gt;IndexToWorld(p, p);
        if (cutter-&gt;m_BoundingObject-&gt;IsInside(p))</span>
        {
<span style = "background-color:#fdd">          outputIt.Set((TOutputPixel)inputIt.Value());
          ++cutter-&gt;m_InsidePixelCount;
        }</span>
        else
        {
<span style = "background-color:#fdd">          outputIt.Set(outsideValue);
          ++cutter-&gt;m_OutsidePixelCount;</span>
        }
<span style = "background-color:#fdd">      }</span>
    }
<span style = "background-color:#fdd">  }</span>

  template &lt;typename TPixel, unsigned int VImageDimension, typename TOutputPixel&gt;
  void CutImageWithOutputTypeSelect(itk::VectorImage&lt;TPixel, VImageDimension&gt; *inputItkImage,
                                    mitk::BoundingObjectCutter *cutter,
                                    int /* boTimeStep */,
                                    TOutputPixel * /* dummy */)
<span style = "background-color:#fdd">  {</span>
    typedef itk::VectorImage&lt;TPixel, VImageDimension&gt; ItkInputImageType;
    typedef itk::VectorImage&lt;TOutputPixel, VImageDimension&gt; ItkOutputImageType;
    typedef typename itk::ImageBase&lt;VImageDimension&gt;::RegionType ItkRegionType;
    typedef itk::ImageRegionIteratorWithIndex&lt;ItkInputImageType&gt; ItkInputImageIteratorType;
    typedef itk::ImageRegionIteratorWithIndex&lt;ItkOutputImageType&gt; ItkOutputImageIteratorType;

<span style = "background-color:#fdd">    if (cutter-&gt;m_BoundingObject.IsNull())
      return;</span>

<span style = "background-color:#fdd">    if (inputItkImage == nullptr)</span>
    {
<span style = "background-color:#fdd">      mitk::StatusBar::GetInstance()-&gt;DisplayErrorText(</span>
        "An internal error occurred. Can't convert Image. Please report to bugs@mitk.org");
<span style = "background-color:#fdd">      std::cout &lt;&lt; " image is NULL...returning" &lt;&lt; std::endl;
      return;</span>
    }

    // PART 1: convert m_InputRequestedReg ion (type mitk::SlicedData::RegionType)
    // into ITK-image-region (ItkImageType::RegionType)
    // unfortunately, we cannot use input-&gt;GetRequestedRegion(), because it
    // has been destroyed by the mitk::CastToItkImage call of PART 1
    // (which sets the m_RequestedRegion to the LargestPossibleRegion).
    // Thus, use our own member m_InputRequestedRegion insead.

    // first convert the index
    typename ItkRegionType::IndexType::IndexValueType tmpIndex[3];
<span style = "background-color:#fdd">    itk2vtk(cutter-&gt;m_InputRequestedRegion.GetIndex(), tmpIndex);</span>
    typename ItkRegionType::IndexType index;
<span style = "background-color:#fdd">    index.SetIndex(tmpIndex);</span>

    // then convert the size
    typename ItkRegionType::SizeType::SizeValueType tmpSize[3];
<span style = "background-color:#fdd">    itk2vtk(cutter-&gt;m_InputRequestedRegion.GetSize(), tmpSize);</span>
    typename ItkRegionType::SizeType size;
<span style = "background-color:#fdd">    size.SetSize(tmpSize);</span>

    // create the ITK-image-region out of index and size
<span style = "background-color:#fdd">    ItkRegionType inputRegionOfInterest(index, size);</span>

    // PART 2: get access to the MITK output image via an ITK image
<span style = "background-color:#fdd">    typename mitk::ImageToItk&lt;ItkOutputImageType&gt;::Pointer outputimagetoitk =</span>
      mitk::ImageToItk&lt;ItkOutputImageType&gt;::New();
<span style = "background-color:#fdd">    outputimagetoitk-&gt;SetInput(cutter-&gt;m_OutputTimeSelector-&gt;GetOutput());
    outputimagetoitk-&gt;Update();
    typename ItkOutputImageType::Pointer outputItkImage = outputimagetoitk-&gt;GetOutput();</span>

    // PART 3: iterate over input and output using ITK iterators

    // create the iterators
<span style = "background-color:#fdd">    ItkInputImageIteratorType inputIt(inputItkImage, inputRegionOfInterest);
    ItkOutputImageIteratorType outputIt(outputItkImage, outputItkImage-&gt;GetLargestPossibleRegion());</span>

    // Cut the boundingbox out of the image by iterating through
    // all pixels and checking if they are inside using IsInside()
<span style = "background-color:#fdd">    cutter-&gt;m_OutsidePixelCount = 0;
    cutter-&gt;m_InsidePixelCount = 0;
    mitk::Point3D p;
    mitk::BaseGeometry *inputGeometry = cutter-&gt;GetInput()-&gt;GetGeometry();</span>

<span style = "background-color:#fdd">    typename ItkOutputImageType::PixelType outsideValue;
    outsideValue.SetSize(outputItkImage-&gt;GetVectorLength());
    if (cutter-&gt;m_AutoOutsideValue)</span>
    {
<span style = "background-color:#fdd">      outsideValue.Fill(itk::NumericTraits&lt;TOutputPixel&gt;::min());
    }</span>
    else
    {
<span style = "background-color:#fdd">      outsideValue.Fill(cutter-&gt;m_OutsideValue);</span>
    }
    // shall we use a fixed value for each inside pixel?
<span style = "background-color:#fdd">    if (cutter-&gt;GetUseInsideValue())</span>
    {
<span style = "background-color:#fdd">      typename ItkOutputImageType::PixelType insideValue;
      insideValue.Fill(cutter-&gt;m_InsideValue);</span>
      // yes, use a fixed value for each inside pixel (create a binary mask of the bounding object)
<span style = "background-color:#fdd">      for (inputIt.GoToBegin(), outputIt.GoToBegin(); !inputIt.IsAtEnd(); ++inputIt, ++outputIt)</span>
      {
<span style = "background-color:#fdd">        vtk2itk(inputIt.GetIndex(), p);
        inputGeometry-&gt;IndexToWorld(p, p);
        if (cutter-&gt;m_BoundingObject-&gt;IsInside(p))</span>
        {
<span style = "background-color:#fdd">          outputIt.Set(insideValue);
          ++cutter-&gt;m_InsidePixelCount;
        }</span>
        else
        {
<span style = "background-color:#fdd">          outputIt.Set(outsideValue);
          ++cutter-&gt;m_OutsidePixelCount;</span>
        }
<span style = "background-color:#fdd">      }
    }</span>
    else
    {
      // no, use the pixel value of the original image (normal cutting)
<span style = "background-color:#fdd">      for (inputIt.GoToBegin(), outputIt.GoToBegin(); !inputIt.IsAtEnd(); ++inputIt, ++outputIt)</span>
      {
<span style = "background-color:#fdd">        vtk2itk(inputIt.GetIndex(), p);
        inputGeometry-&gt;IndexToWorld(p, p);
        if (cutter-&gt;m_BoundingObject-&gt;IsInside(p))</span>
        {
<span style = "background-color:#fdd">          outputIt.Set(inputIt.Get());
          ++cutter-&gt;m_InsidePixelCount;
        }</span>
        else
        {
<span style = "background-color:#fdd">          outputIt.Set(outsideValue);
          ++cutter-&gt;m_OutsidePixelCount;</span>
        }
<span style = "background-color:#fdd">      }</span>
    }
<span style = "background-color:#fdd">  }</span>

  template &lt;typename TPixel, unsigned int VImageDimension&gt;
  void CutImage(itk::Image&lt;TPixel, VImageDimension&gt; *inputItkImage, mitk::BoundingObjectCutter *cutter, int boTimeStep)
<span style = "background-color:#fdd">  {
    TPixel *dummy = nullptr;
    CutImageWithOutputTypeSelect&lt;TPixel, VImageDimension, TPixel&gt;(inputItkImage, cutter, boTimeStep, dummy);
  }</span>

  template &lt;typename TPixel, unsigned int VImageDimension&gt;
  void CutImage(itk::VectorImage&lt;TPixel, VImageDimension&gt; *inputItkImage,
                mitk::BoundingObjectCutter *cutter,
                int boTimeStep)
<span style = "background-color:#fdd">  {
    TPixel *dummy = nullptr;
    CutImageWithOutputTypeSelect&lt;TPixel, VImageDimension, TPixel&gt;(inputItkImage, cutter, boTimeStep, dummy);
  }</span>

} // of namespace mitk

#include "mitkImageCast.h"

#endif // of MITKBOUNDINGOBJECTCUTTER_TXX</pre>
	</body>
</html>