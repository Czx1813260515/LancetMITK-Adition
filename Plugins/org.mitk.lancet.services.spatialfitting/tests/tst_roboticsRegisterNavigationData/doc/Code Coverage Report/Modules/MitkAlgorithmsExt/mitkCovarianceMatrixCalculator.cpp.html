<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkCovarianceMatrixCalculator.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkCovarianceMatrixCalculator.h"
#include &lt;mitkExceptionMacro.h&gt;
#include &lt;mitkSurface.h&gt;
#include &lt;vtkCell.h&gt;
#include &lt;vtkCellLinks.h&gt;
#include &lt;vtkPlane.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkPolyDataNormals.h&gt;
#include &lt;vtkSmartPointer.h&gt;

// forward declarations of private functions
static vtkIdList *GetNeighboursOfPoint(unsigned int index, vtkPolyData *polydata);

static vtkIdList *CalculatePCAonPointNeighboursForNormalVector(int index,
                                                               double normal[3],
                                                               itk::Matrix&lt;double, 3, 3&gt; &amp;mat,
                                                               double curVertex[3],
                                                               std::vector&lt;mitk::Point3D&gt; &amp;pointList,
                                                               vtkPolyData *polyData);

static itk::Matrix&lt;double, 3, 3&gt; ComputeCovarianceMatrix(itk::Matrix&lt;double, 3, 3&gt; &amp;axes,
                                                         double sigma[3],
                                                         double normalizationValue);
namespace mitk
{
  /** \brief Pimpl to hold the private data in the CovarianceMatrixCalculator.*/
  struct CovarianceMatrixCalculatorData
  {
    vtkPolyDataNormals *m_PolyDataNormals;
    vtkPolyData *m_PolyData;
    Surface *m_Input;
    double m_VoronoiScalingFactor;
    bool m_EnableNormalization;
    double m_MeanVariance;

    CovarianceMatrixCalculatorData()
<span style = "background-color:#fdd">      : m_PolyDataNormals(vtkPolyDataNormals::New()),
        m_PolyData(nullptr),
        m_Input(nullptr),
        m_VoronoiScalingFactor(1.0),
        m_EnableNormalization(false),
        m_MeanVariance(0.0)
    {
      m_PolyDataNormals-&gt;SplittingOff();
    }</span>

    ~CovarianceMatrixCalculatorData()
<span style = "background-color:#fdd">    {
      if (m_PolyDataNormals)
        m_PolyDataNormals-&gt;Delete();
    }</span>
  };
}

<span style = "background-color:#fdd">mitk::CovarianceMatrixCalculator::CovarianceMatrixCalculator() : d(new CovarianceMatrixCalculatorData())
{
}</span>

mitk::CovarianceMatrixCalculator::~CovarianceMatrixCalculator()
<span style = "background-color:#fdd">{
  delete d;
}</span>

void mitk::CovarianceMatrixCalculator::SetVoronoiScalingFator(const double factor)
<span style = "background-color:#fdd">{
  d-&gt;m_VoronoiScalingFactor = factor;
}</span>

void mitk::CovarianceMatrixCalculator::EnableNormalization(bool state)
<span style = "background-color:#fdd">{
  d-&gt;m_EnableNormalization = state;
}</span>

double mitk::CovarianceMatrixCalculator::GetMeanVariance() const
<span style = "background-color:#fdd">{
  return d-&gt;m_MeanVariance;
}</span>

const mitk::CovarianceMatrixCalculator::CovarianceMatrixList &amp;mitk::CovarianceMatrixCalculator::GetCovarianceMatrices()
  const
<span style = "background-color:#fdd">{
  return m_CovarianceMatrixList;
}</span>

void mitk::CovarianceMatrixCalculator::SetInputSurface(Surface *input)
<span style = "background-color:#fdd">{
  d-&gt;m_Input = input;
}</span>

void mitk::CovarianceMatrixCalculator::ComputeCovarianceMatrices()
<span style = "background-color:#fdd">{
  double normalizationValue = -1.0;
  vtkDataArray *normals = nullptr;
  d-&gt;m_MeanVariance = 0.0;</span>

<span style = "background-color:#fdd">  if (!d-&gt;m_Input)
    mitkThrow() &lt;&lt; "No input surface was set in mitk::CovarianceMatrixCalculator";</span>

<span style = "background-color:#fdd">  d-&gt;m_PolyData = d-&gt;m_Input-&gt;GetVtkPolyData();</span>

  // Optional normal calculation can be disabled to use the normals
  // of the surface:
  // normals = d-&gt;m_PolyData-&gt;GetPointData()-&gt;GetNormals();
  //// compute surface normals if the surface has no normals
  // if ( normals == nullptr )
  //{
<span style = "background-color:#fdd">  d-&gt;m_PolyDataNormals-&gt;SetInputData(d-&gt;m_PolyData);
  d-&gt;m_PolyDataNormals-&gt;Update();
  normals = d-&gt;m_PolyDataNormals-&gt;GetOutput()-&gt;GetPointData()-&gt;GetNormals();</span>
  //}

<span style = "background-color:#fdd">  if (d-&gt;m_EnableNormalization)
    normalizationValue = 1.5;</span>

  // clear the matrixlist
<span style = "background-color:#fdd">  m_CovarianceMatrixList.clear();</span>
  // allocate memory if required
<span style = "background-color:#fdd">  if (d-&gt;m_PolyData-&gt;GetNumberOfPoints() &gt; (vtkIdType)m_CovarianceMatrixList.capacity())
    m_CovarianceMatrixList.reserve(d-&gt;m_PolyData-&gt;GetNumberOfPoints());</span>

<span style = "background-color:#fdd">  for (vtkIdType i = 0; i &lt; d-&gt;m_PolyData-&gt;GetNumberOfPoints(); ++i)</span>
  {
    Vertex normal;
    Vertex currentVertex;
<span style = "background-color:#fdd">    Vertex variances = {0.0, 0.0, 0.0};
    CovarianceMatrix mat;
    mat.Fill(0.0);</span>

<span style = "background-color:#fdd">    normals-&gt;GetTuple(i, normal);
    d-&gt;m_PolyData-&gt;GetPoint(i, currentVertex);</span>

<span style = "background-color:#fdd">    ComputeOrthonormalCoordinateSystem(i, normal, mat, variances, currentVertex);</span>

    // use prefactor for sigma along surface
<span style = "background-color:#fdd">    variances[0] = (d-&gt;m_VoronoiScalingFactor * variances[0]);
    variances[1] = (d-&gt;m_VoronoiScalingFactor * variances[1]);
    variances[2] = (d-&gt;m_VoronoiScalingFactor * variances[2]);</span>

<span style = "background-color:#fdd">    d-&gt;m_MeanVariance += (variances[0] + variances[1] + variances[2]);</span>
    // compute the covariance matrix and save it
<span style = "background-color:#fdd">    const CovarianceMatrix covarianceMatrix = ComputeCovarianceMatrix(mat, variances, normalizationValue);
    m_CovarianceMatrixList.push_back(covarianceMatrix);
  }</span>

<span style = "background-color:#fdd">  if (d-&gt;m_EnableNormalization)
    d-&gt;m_MeanVariance = normalizationValue / 3.0;</span>
  else
<span style = "background-color:#fdd">    d-&gt;m_MeanVariance /= (3.0 * (double)d-&gt;m_PolyData-&gt;GetNumberOfPoints());</span>

  // reset input
<span style = "background-color:#fdd">  d-&gt;m_PolyData = nullptr;
  d-&gt;m_Input = nullptr;
}</span>

// Get a list with the id's of all surrounding conected vertices
// to the current vertex at the given index in the polydata
vtkIdList *GetNeighboursOfPoint(unsigned int index, vtkPolyData *polydata)
<span style = "background-color:#fdd">{
  vtkIdList *cellIds = vtkIdList::New();
  vtkIdList *result = vtkIdList::New();
  polydata-&gt;GetPointCells(index, cellIds);</span>

<span style = "background-color:#fdd">  for (vtkIdType j = 0; j &lt; cellIds-&gt;GetNumberOfIds(); j++)</span>
  {
<span style = "background-color:#fdd">    vtkIdList *newPoints = polydata-&gt;GetCell(cellIds-&gt;GetId(j))-&gt;GetPointIds();
    for (vtkIdType k = 0; k &lt; newPoints-&gt;GetNumberOfIds(); k++)</span>
    {
      // if point has not yet been inserted add id
<span style = "background-color:#fdd">      if (result-&gt;IsId(newPoints-&gt;GetId(k)) == -1)</span>
      {
<span style = "background-color:#fdd">        result-&gt;InsertNextId(newPoints-&gt;GetId(k));</span>
      }
<span style = "background-color:#fdd">    }
  }
  cellIds-&gt;Delete();
  return result;
}</span>

// Computes a primary component analysis of the surounding vertices
// of the verex at the current index.
vtkIdList *CalculatePCAonPointNeighboursForNormalVector(int index,
                                                        double normal[3],
                                                        itk::Matrix&lt;double, 3, 3&gt; &amp;mat,
                                                        double curVertex[3],
                                                        std::vector&lt;mitk::Point3D&gt; &amp;pointList,
                                                        vtkPolyData *polyData)
<span style = "background-color:#fdd">{</span>
  typedef std::vector&lt;mitk::Point3D&gt; VectorType;
  typedef VectorType::const_iterator ConstPointIterator;
  typedef double Vertex[3];

<span style = "background-color:#fdd">  Vertex mean = {0.0, 0.0, 0.0};
  Vertex tmp = {0.0, 0.0, 0.0};
  vtkIdList *neighbourPoints = GetNeighboursOfPoint(index, polyData);
  const vtkIdType size = neighbourPoints-&gt;GetNumberOfIds();</span>

  // reserve memory for all neighbours
<span style = "background-color:#fdd">  pointList.reserve(size);</span>

  // project neighbours on plane given by normal
  // and compute mean
<span style = "background-color:#fdd">  for (vtkIdType i = 0; i &lt; size; ++i)</span>
  {
<span style = "background-color:#fdd">    mitk::Point3D p;</span>
    Vertex resultPoint;

<span style = "background-color:#fdd">    polyData-&gt;GetPoint((neighbourPoints-&gt;GetId(i)), tmp);</span>

<span style = "background-color:#fdd">    vtkPlane::GeneralizedProjectPoint(tmp, curVertex, normal, resultPoint);</span>

<span style = "background-color:#fdd">    p[0] = resultPoint[0];
    p[1] = resultPoint[1];
    p[2] = resultPoint[2];</span>

<span style = "background-color:#fdd">    mean[0] += p[0];
    mean[1] += p[1];
    mean[2] += p[2];</span>

<span style = "background-color:#fdd">    pointList.push_back(p);
  }</span>

<span style = "background-color:#fdd">  mean[0] /= (double)size;
  mean[1] /= (double)size;
  mean[2] /= (double)size;</span>

  // compute the covariances with matrix multiplication
<span style = "background-color:#fdd">  for (ConstPointIterator it = pointList.begin(); it != pointList.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    tmp[0] = ((*it)[0] - mean[0]);
    tmp[1] = ((*it)[1] - mean[1]);
    tmp[2] = ((*it)[2] - mean[2]);</span>

    // on diagonal elements
<span style = "background-color:#fdd">    mat[0][0] += tmp[0] * tmp[0];
    mat[1][1] += tmp[1] * tmp[1];
    mat[2][2] += tmp[2] * tmp[2];</span>

    // of diagonal elements
<span style = "background-color:#fdd">    mat[1][0] += tmp[0] * tmp[1];
    mat[2][0] += tmp[0] * tmp[2];
    mat[2][1] += tmp[1] * tmp[2];
  }</span>

  // copy upper triangle to lower triangle,
  // we got a symetric matrix
<span style = "background-color:#fdd">  mat[0][1] = mat[1][0];
  mat[0][2] = mat[2][0];
  mat[1][2] = mat[2][1];</span>

  // variance
<span style = "background-color:#fdd">  mat /= (size - 1);</span>

<span style = "background-color:#fdd">  vnl_svd&lt;double&gt; svd(mat.GetVnlMatrix().as_ref());</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; 3; ++i)
    for (int j = 0; j &lt; 3; ++j)
      mat[i][j] = svd.U()[j][i];</span>

<span style = "background-color:#fdd">  return neighbourPoints;
}</span>

// Computes an orthonormal system for a vertex with it's surrounding neighbours.
void mitk::CovarianceMatrixCalculator::ComputeOrthonormalCoordinateSystem(
  const int index, Vertex normal, CovarianceMatrix &amp;axes, Vertex variances, Vertex curVertex)
<span style = "background-color:#fdd">{</span>
  typedef std::vector&lt;mitk::Point3D&gt; VectorType;
  typedef VectorType::const_iterator ConstPointIterator;
<span style = "background-color:#fdd">  VectorType projectedPoints;</span>

<span style = "background-color:#fdd">  Vertex meanValues = {0.0, 0.0, 0.0};</span>
  // project neighbours to new coordinate system and get principal axes
<span style = "background-color:#fdd">  vtkIdList *neighbourPoints =</span>
    CalculatePCAonPointNeighboursForNormalVector(index, normal, axes, curVertex, projectedPoints, d-&gt;m_PolyData);

  // Set the normal as the third principal axis
<span style = "background-color:#fdd">  axes[2][0] = normal[0];
  axes[2][1] = normal[1];
  axes[2][2] = normal[2];</span>

<span style = "background-color:#fdd">  for (vtkIdType i = 0; i &lt; neighbourPoints-&gt;GetNumberOfIds(); ++i)</span>
  {
<span style = "background-color:#fdd">    mitk::Point3D projectedPoint;</span>
    Vertex curNeighbour;
<span style = "background-color:#fdd">    d-&gt;m_PolyData-&gt;GetPoint(neighbourPoints-&gt;GetId(i), curNeighbour);</span>

<span style = "background-color:#fdd">    curNeighbour[0] = curNeighbour[0] - curVertex[0];
    curNeighbour[1] = curNeighbour[1] - curVertex[1];
    curNeighbour[2] = curNeighbour[2] - curVertex[2];</span>

<span style = "background-color:#fdd">    for (int k = 0; k &lt; 3; ++k)</span>
    {
<span style = "background-color:#fdd">      projectedPoint[k] = axes[k][0] * curNeighbour[0] + axes[k][1] * curNeighbour[1] + axes[k][2] * curNeighbour[2];</span>

<span style = "background-color:#fdd">      meanValues[k] += projectedPoint[k];
    }</span>
    // reuse the allocated vector from the PCA on the point neighbours
<span style = "background-color:#fdd">    projectedPoints[i] = projectedPoint;
  }</span>

<span style = "background-color:#fdd">  meanValues[0] /= (double)projectedPoints.size();
  meanValues[1] /= (double)projectedPoints.size();
  meanValues[2] /= (double)projectedPoints.size();</span>

  // compute variances along new axes
<span style = "background-color:#fdd">  for (ConstPointIterator it = projectedPoints.begin(); it != projectedPoints.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    const mitk::Point3D &amp;p = *it;</span>

<span style = "background-color:#fdd">    variances[0] += (p[0] - meanValues[0]) * (p[0] - meanValues[0]);
    variances[1] += (p[1] - meanValues[1]) * (p[1] - meanValues[1]);
    variances[2] += (p[2] - meanValues[2]) * (p[2] - meanValues[2]);
  }</span>

<span style = "background-color:#fdd">  variances[0] /= (double)(projectedPoints.size() - 1);
  variances[1] /= (double)(projectedPoints.size() - 1);
  variances[2] /= (double)(projectedPoints.size() - 1);</span>

  // clean up
<span style = "background-color:#fdd">  neighbourPoints-&gt;Delete();
}</span>

// Sorts the axes of the computed orthonormal system based on
// the eigenvalues in a descending order
itk::Matrix&lt;double, 3, 3&gt; ComputeCovarianceMatrix(itk::Matrix&lt;double, 3, 3&gt; &amp;axes,
                                                  double sigma[3],
                                                  double normalizationValue)
<span style = "background-color:#fdd">{</span>
  unsigned int idxMax, idxMin, idxBetween;
<span style = "background-color:#fdd">  itk::Matrix&lt;double, 3, 3&gt; returnValue;
  itk::Matrix&lt;double, 3, 3&gt; V;
  itk::Matrix&lt;double, 3, 3&gt; diagMatrix;
  diagMatrix.Fill(0.0);</span>

<span style = "background-color:#fdd">  if (sigma[0] &gt;= sigma[1] &amp;&amp; sigma[0] &gt;= sigma[2])</span>
  {
<span style = "background-color:#fdd">    idxMax = 0;
    if (sigma[1] &gt;= sigma[2])</span>
    {
<span style = "background-color:#fdd">      idxBetween = 1;
      idxMin = 2;
    }</span>
    else
    {
<span style = "background-color:#fdd">      idxBetween = 2;
      idxMin = 1;</span>
    }
<span style = "background-color:#fdd">  }
  else if (sigma[1] &gt;= sigma[0] &amp;&amp; sigma[1] &gt;= sigma[2])</span>
  {
<span style = "background-color:#fdd">    idxMax = 1;
    if (sigma[0] &gt;= sigma[2])</span>
    {
<span style = "background-color:#fdd">      idxBetween = 0;
      idxMin = 2;
    }</span>
    else
    {
<span style = "background-color:#fdd">      idxBetween = 2;
      idxMin = 0;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else // index 2 corresponds to largest sigma
  {
<span style = "background-color:#fdd">    idxMax = 2;
    if (sigma[0] &gt;= sigma[1])</span>
    {
<span style = "background-color:#fdd">      idxBetween = 0;
      idxMin = 1;
    }</span>
    else
    {
<span style = "background-color:#fdd">      idxBetween = 1;
      idxMin = 0;</span>
    }
  }

<span style = "background-color:#fdd">  V[0][0] = axes[idxMax][0];
  V[1][0] = axes[idxMax][1];
  V[2][0] = axes[idxMax][2];
  V[0][1] = axes[idxBetween][0];
  V[1][1] = axes[idxBetween][1];
  V[2][1] = axes[idxBetween][2];
  V[0][2] = axes[idxMin][0];
  V[1][2] = axes[idxMin][1];
  V[2][2] = axes[idxMin][2];</span>

<span style = "background-color:#fdd">  diagMatrix[0][0] = sigma[idxMax];
  diagMatrix[1][1] = sigma[idxBetween];
  diagMatrix[2][2] = sigma[idxMin];</span>

<span style = "background-color:#fdd">  returnValue = V * diagMatrix * V.GetTranspose();</span>

<span style = "background-color:#fdd">  if (normalizationValue &gt; 0.0)</span>
  {
<span style = "background-color:#fdd">    double trace = returnValue[0][0] + returnValue[1][1] + returnValue[2][2];
    returnValue *= (normalizationValue / trace);</span>
  }

<span style = "background-color:#fdd">  return returnValue;
}</span></pre>
	</body>
</html>