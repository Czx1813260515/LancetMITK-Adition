<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlanarFigureVtkMapper3D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlanarFigureVtkMapper3D.h"
#include "mitkAbstractTransformGeometry.h"
#include "mitkImage.h"
#include "mitkPlaneGeometry.h"
#include &lt;mitkPlanarFigure.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkIdList.h&gt;
#include &lt;vtkPoints.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkPolyLine.h&gt;
#include &lt;vtkPolygon.h&gt;

<span style = "background-color:#fdd">mitk::PlanarFigureVtkMapper3D::LocalStorage::LocalStorage() : m_Actor(vtkSmartPointer&lt;vtkActor&gt;::New()), m_LastMTime(0)
{
}</span>

mitk::PlanarFigureVtkMapper3D::LocalStorage::~LocalStorage()
<span style = "background-color:#fdd">{
}</span>

void mitk::PlanarFigureVtkMapper3D::SetDefaultProperties(DataNode *node, BaseRenderer *, bool)
<span style = "background-color:#fdd">{
  node-&gt;AddProperty("planarfigure.3drendering", mitk::BoolProperty::New(false));
  node-&gt;AddProperty("planarfigure.3drendering.fill", mitk::BoolProperty::New(false));
}</span>

<span style = "background-color:#fdd">mitk::PlanarFigureVtkMapper3D::PlanarFigureVtkMapper3D() : m_FillPf(false)
{
}</span>

mitk::PlanarFigureVtkMapper3D::~PlanarFigureVtkMapper3D()
<span style = "background-color:#fdd">{
}</span>

void mitk::PlanarFigureVtkMapper3D::ApplyColorAndOpacityProperties(BaseRenderer *renderer, vtkActor *actor)
<span style = "background-color:#fdd">{
  if (actor == nullptr)
    return;</span>

<span style = "background-color:#fdd">  const mitk::DataNode *dataNode = this-&gt;GetDataNode();</span>

<span style = "background-color:#fdd">  if (dataNode == nullptr)
    return;</span>

<span style = "background-color:#fdd">  bool selected = false;
  dataNode-&gt;GetBoolProperty("selected", selected, renderer);</span>

  float color[3];
<span style = "background-color:#fdd">  dataNode-&gt;GetColor(color, renderer, selected ? "planarfigure.selected.line.color" : "color");</span>

<span style = "background-color:#fdd">  float opacity = 1.0f;
  dataNode-&gt;GetOpacity(opacity, renderer);</span>

<span style = "background-color:#fdd">  vtkProperty *property = actor-&gt;GetProperty();
  property-&gt;SetColor(color[0], color[1], color[2]);
  property-&gt;SetOpacity(opacity);
}</span>

void mitk::PlanarFigureVtkMapper3D::ApplyPlanarFigureProperties(BaseRenderer *renderer, vtkActor *actor)
<span style = "background-color:#fdd">{
  if (actor == nullptr)
    return;</span>

<span style = "background-color:#fdd">  const mitk::DataNode *dataNode = this-&gt;GetDataNode();</span>

<span style = "background-color:#fdd">  if (dataNode == nullptr)
    return;</span>

<span style = "background-color:#fdd">  bool render = false;
  dataNode-&gt;GetBoolProperty("planarfigure.3drendering", render);</span>

<span style = "background-color:#fdd">  actor-&gt;SetVisibility(render);</span>

<span style = "background-color:#fdd">  float lineWidth = 1.0f;
  dataNode-&gt;GetFloatProperty("planarfigure.line.width", lineWidth, renderer);</span>

<span style = "background-color:#fdd">  vtkProperty *property = actor-&gt;GetProperty();
  property-&gt;SetLineWidth(lineWidth);
}</span>

void mitk::PlanarFigureVtkMapper3D::GenerateDataForRenderer(BaseRenderer *renderer)
<span style = "background-color:#fdd">{</span>
  typedef PlanarFigure::PolyLineType PolyLine;

<span style = "background-color:#fdd">  const DataNode *node = this-&gt;GetDataNode();</span>

<span style = "background-color:#fdd">  if (node == nullptr)
    return;</span>

<span style = "background-color:#fdd">  auto *planarFigure = dynamic_cast&lt;PlanarFigure *&gt;(node-&gt;GetData());</span>

<span style = "background-color:#fdd">  if (planarFigure == nullptr || !planarFigure-&gt;IsPlaced())
    return;</span>

<span style = "background-color:#fdd">  LocalStorage *localStorage = m_LocalStorageHandler.GetLocalStorage(renderer);
  unsigned long mTime = planarFigure-&gt;GetMTime();</span>

<span style = "background-color:#fdd">  bool fillPf = false;
  bool refresh = false;
  node-&gt;GetBoolProperty("planarfigure.3drendering.fill", fillPf);
  if (m_FillPf != fillPf)</span>
  {
<span style = "background-color:#fdd">    m_FillPf = fillPf;
    refresh = true;</span>
  }

<span style = "background-color:#fdd">  if (mTime &gt; localStorage-&gt;m_LastMTime || refresh)</span>
  {
<span style = "background-color:#fdd">    localStorage-&gt;m_LastMTime = mTime;</span>

<span style = "background-color:#fdd">    const auto *planeGeometry = dynamic_cast&lt;const PlaneGeometry *&gt;(planarFigure-&gt;GetPlaneGeometry());
    const auto *abstractTransformGeometry =</span>
      dynamic_cast&lt;const AbstractTransformGeometry *&gt;(planarFigure-&gt;GetPlaneGeometry());

<span style = "background-color:#fdd">    if (planeGeometry == nullptr &amp;&amp; abstractTransformGeometry == nullptr)
      return;</span>

<span style = "background-color:#fdd">    const size_t numPolyLines = planarFigure-&gt;GetPolyLinesSize();</span>

<span style = "background-color:#fdd">    if (numPolyLines == 0)
      return;</span>

<span style = "background-color:#fdd">    const vtkSmartPointer&lt;vtkPoints&gt; points = vtkSmartPointer&lt;vtkPoints&gt;::New();
    const vtkSmartPointer&lt;vtkCellArray&gt; cells = vtkSmartPointer&lt;vtkCellArray&gt;::New();
    const vtkSmartPointer&lt;vtkCellArray&gt; polygons = vtkSmartPointer&lt;vtkCellArray&gt;::New();
    vtkIdType baseIndex = 0;</span>

<span style = "background-color:#fdd">    for (size_t i = 0; i &lt; numPolyLines; ++i)</span>
    {
<span style = "background-color:#fdd">      const PolyLine polyLine = planarFigure-&gt;GetPolyLine(i);
      const vtkIdType numPoints = polyLine.size();</span>

<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkPolygon&gt; polygon = vtkSmartPointer&lt;vtkPolygon&gt;::New();</span>

<span style = "background-color:#fdd">      if (numPoints &lt; 2)
        continue;</span>

<span style = "background-color:#fdd">      auto polyLineEnd = polyLine.cend();</span>

<span style = "background-color:#fdd">      for (auto polyLineIt = polyLine.cbegin(); polyLineIt != polyLineEnd; ++polyLineIt)</span>
      {
<span style = "background-color:#fdd">        Point3D point;
        planeGeometry-&gt;Map(*polyLineIt, point);
        points-&gt;InsertNextPoint(point.GetDataPointer());</span>

<span style = "background-color:#fdd">        const vtkIdType id = polygon-&gt;GetPoints()-&gt;InsertNextPoint(point[0], point[1], point[2]);
        polygon-&gt;GetPointIds()-&gt;InsertNextId(id);
      }</span>

<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkPolyLine&gt; line = vtkSmartPointer&lt;vtkPolyLine&gt;::New();</span>

<span style = "background-color:#fdd">      vtkIdList *pointIds = line-&gt;GetPointIds();</span>

<span style = "background-color:#fdd">      if (planarFigure-&gt;IsClosed() &amp;&amp; numPoints &gt; 2)</span>
      {
<span style = "background-color:#fdd">        polygons-&gt;InsertNextCell(polygon);
        pointIds-&gt;SetNumberOfIds(numPoints + 1);
        pointIds-&gt;SetId(numPoints, baseIndex);
      }</span>
      else
      {
<span style = "background-color:#fdd">        pointIds-&gt;SetNumberOfIds(numPoints);</span>
      }

<span style = "background-color:#fdd">      for (vtkIdType j = 0; j &lt; numPoints; ++j)
        pointIds-&gt;SetId(j, baseIndex + j);</span>

<span style = "background-color:#fdd">      cells-&gt;InsertNextCell(line);</span>

<span style = "background-color:#fdd">      baseIndex += points-&gt;GetNumberOfPoints();
    }</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPolyData&gt; polyData = vtkSmartPointer&lt;vtkPolyData&gt;::New();
    polyData-&gt;SetPoints(points);
    polyData-&gt;SetLines(cells);
    if (m_FillPf)
      polyData-&gt;SetPolys(polygons);</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
    mapper-&gt;SetInputData(polyData);</span>

<span style = "background-color:#fdd">    localStorage-&gt;m_Actor-&gt;SetMapper(mapper);
  }</span>

<span style = "background-color:#fdd">  this-&gt;ApplyColorAndOpacityProperties(renderer, localStorage-&gt;m_Actor);
  this-&gt;ApplyPlanarFigureProperties(renderer, localStorage-&gt;m_Actor);
}</span>

vtkProp *mitk::PlanarFigureVtkMapper3D::GetVtkProp(BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  return m_LocalStorageHandler.GetLocalStorage(renderer)-&gt;m_Actor;
}</span>

void mitk::PlanarFigureVtkMapper3D::UpdateVtkTransform(BaseRenderer *)
<span style = "background-color:#fdd">{
}</span></pre>
	</body>
</html>