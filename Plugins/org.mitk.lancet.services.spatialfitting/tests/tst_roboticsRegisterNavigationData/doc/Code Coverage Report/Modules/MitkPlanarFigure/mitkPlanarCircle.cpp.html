<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlanarCircle.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlanarCircle.h"
#include "mitkPlaneGeometry.h"

#include "mitkProperties.h"

mitk::PlanarCircle::PlanarCircle()
<span style = "background-color:#fdd">  : FEATURE_ID_RADIUS(this-&gt;AddFeature("Radius", "mm")),
    FEATURE_ID_DIAMETER(this-&gt;AddFeature("Diameter", "mm")),
    FEATURE_ID_AREA(this-&gt;AddFeature("Area", "mm2")),
    m_MinRadius(0),
    m_MaxRadius(100),
    m_MinMaxRadiusContraintsActive(false),
    m_RadiusFixed(false)
{</span>
  // Circle has two control points
<span style = "background-color:#fdd">  this-&gt;ResetNumberOfControlPoints(2);
  this-&gt;SetNumberOfPolyLines(1);
  this-&gt;SetProperty("closed", mitk::BoolProperty::New(true));
}</span>

mitk::PlanarCircle::PlanarCircle(double fixedRadius)
<span style = "background-color:#fdd">  : FEATURE_ID_RADIUS(this-&gt;AddFeature("Radius", "mm")),
  FEATURE_ID_DIAMETER(this-&gt;AddFeature("Diameter", "mm")),
  FEATURE_ID_AREA(this-&gt;AddFeature("Area", "mm2")),
  m_MinRadius(fixedRadius),
  m_MaxRadius(100),
  m_MinMaxRadiusContraintsActive(false),
  m_RadiusFixed(true)
{</span>
  // Fixed Circle has 1 control points
<span style = "background-color:#fdd">  this-&gt;ResetNumberOfControlPoints(1);
  this-&gt;SetNumberOfPolyLines(1);
  this-&gt;SetProperty("closed", mitk::BoolProperty::New(true));
}</span>

bool mitk::PlanarCircle::SetControlPoint(unsigned int index, const Point2D &amp;point, bool /*createIfDoesNotExist*/)
<span style = "background-color:#fdd">{</span>
  // moving center point
<span style = "background-color:#fdd">  if (index == 0)</span>
  {
<span style = "background-color:#fdd">    const Point2D &amp;centerPoint = GetControlPoint(0);
    if (!m_RadiusFixed)</span>
    {
<span style = "background-color:#fdd">      Point2D boundaryPoint = GetControlPoint(1);
      const vnl_vector&lt;ScalarType&gt; vec = (point.GetVnlVector() - centerPoint.GetVnlVector());</span>

<span style = "background-color:#fdd">      boundaryPoint[0] += vec[0];
      boundaryPoint[1] += vec[1];
      PlanarFigure::SetControlPoint(1, boundaryPoint);
    }
    PlanarFigure::SetControlPoint(0, point);
    return true;
  }
  else if (index == 1)</span>
  {
<span style = "background-color:#fdd">    PlanarFigure::SetControlPoint(index, point);
    return true;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

mitk::Point2D mitk::PlanarCircle::ApplyControlPointConstraints(unsigned int index, const Point2D &amp;point)
<span style = "background-color:#fdd">{
  if (this-&gt;GetPlaneGeometry() == nullptr)</span>
  {
<span style = "background-color:#fdd">    return point;</span>
  }

<span style = "background-color:#fdd">  Point2D indexPoint;
  this-&gt;GetPlaneGeometry()-&gt;WorldToIndex(point, indexPoint);</span>

<span style = "background-color:#fdd">  const BoundingBox::BoundsArrayType bounds = this-&gt;GetPlaneGeometry()-&gt;GetBounds();
  if (indexPoint[0] &lt; bounds[0])</span>
  {
<span style = "background-color:#fdd">    indexPoint[0] = bounds[0];</span>
  }
<span style = "background-color:#fdd">  if (indexPoint[0] &gt; bounds[1])</span>
  {
<span style = "background-color:#fdd">    indexPoint[0] = bounds[1];</span>
  }
<span style = "background-color:#fdd">  if (indexPoint[1] &lt; bounds[2])</span>
  {
<span style = "background-color:#fdd">    indexPoint[1] = bounds[2];</span>
  }
<span style = "background-color:#fdd">  if (indexPoint[1] &gt; bounds[3])</span>
  {
<span style = "background-color:#fdd">    indexPoint[1] = bounds[3];</span>
  }

<span style = "background-color:#fdd">  Point2D constrainedPoint;
  this-&gt;GetPlaneGeometry()-&gt;IndexToWorld(indexPoint, constrainedPoint);</span>

<span style = "background-color:#fdd">  if (m_MinMaxRadiusContraintsActive)</span>
  {
<span style = "background-color:#fdd">    if (index != 0)</span>
    {
<span style = "background-color:#fdd">      const Point2D &amp;centerPoint = this-&gt;GetControlPoint(0);
      const double euclideanDinstanceFromCenterToPoint1 = centerPoint.EuclideanDistanceTo(point);</span>

<span style = "background-color:#fdd">      Vector2D vectorProjectedPoint = point - centerPoint;
      vectorProjectedPoint.Normalize();</span>

<span style = "background-color:#fdd">      if (euclideanDinstanceFromCenterToPoint1 &gt; m_MaxRadius)</span>
      {
<span style = "background-color:#fdd">        vectorProjectedPoint *= m_MaxRadius;
        constrainedPoint = centerPoint;
        constrainedPoint += vectorProjectedPoint;
      }
      else if (euclideanDinstanceFromCenterToPoint1 &lt; m_MinRadius)</span>
      {
<span style = "background-color:#fdd">        vectorProjectedPoint *= m_MinRadius;
        constrainedPoint = centerPoint;
        constrainedPoint += vectorProjectedPoint;</span>
      }
    }
  }

<span style = "background-color:#fdd">  return constrainedPoint;
}</span>

void mitk::PlanarCircle::GeneratePolyLine()
<span style = "background-color:#fdd">{</span>
  // TODO: start circle at specified boundary point...

  // clear the PolyLine-Contrainer, it will be reconstructed soon enough...
<span style = "background-color:#fdd">  this-&gt;ClearPolyLines();</span>

<span style = "background-color:#fdd">  const Point2D &amp;centerPoint = GetControlPoint(0);</span>

<span style = "background-color:#fdd">  double radius = m_MinRadius;</span>
    
<span style = "background-color:#fdd">  if (!m_RadiusFixed)</span>
  {
<span style = "background-color:#fdd">    const Point2D &amp;boundaryPoint = GetControlPoint(1);
    radius = centerPoint.EuclideanDistanceTo(boundaryPoint);</span>
  }

  // Generate poly-line with 64 segments
<span style = "background-color:#fdd">  for (int t = 0; t &lt; 64; ++t)</span>
  {
<span style = "background-color:#fdd">    const double alpha = (double)t * vnl_math::pi / 32.0;</span>

    // construct the new polyline point ...
<span style = "background-color:#fdd">    Point2D polyLinePoint;
    polyLinePoint[0] = centerPoint[0] + radius * cos(alpha);
    polyLinePoint[1] = centerPoint[1] + radius * sin(alpha);</span>

    // ... and append it to the PolyLine.
    // No extending supported here, so we can set the index of the PolyLineElement to '0'
<span style = "background-color:#fdd">    this-&gt;AppendPointToPolyLine(0, polyLinePoint);
  }
}</span>

void mitk::PlanarCircle::GenerateHelperPolyLine(double /*mmPerDisplayUnit*/, unsigned int /*displayHeight*/)
<span style = "background-color:#fdd">{</span>
  // A circle does not require a helper object
<span style = "background-color:#fdd">}</span>

void mitk::PlanarCircle::EvaluateFeaturesInternal()
<span style = "background-color:#fdd">{</span>
  // Calculate circle radius and area
<span style = "background-color:#fdd">  const Point3D &amp;p0 = this-&gt;GetWorldControlPoint(0);
  double radius = m_MinRadius;</span>

<span style = "background-color:#fdd">  if (!m_RadiusFixed)</span>
  {
<span style = "background-color:#fdd">    const Point3D &amp;p1 = this-&gt;GetWorldControlPoint(1);
    radius = p0.EuclideanDistanceTo(p1);</span>
  }

<span style = "background-color:#fdd">  const double area = vnl_math::pi * radius * radius;</span>

<span style = "background-color:#fdd">  this-&gt;SetQuantity(FEATURE_ID_RADIUS, radius);
  this-&gt;SetQuantity(FEATURE_ID_DIAMETER, 2 * radius);
  this-&gt;SetQuantity(FEATURE_ID_AREA, area);
}</span>

void mitk::PlanarCircle::PrintSelf(std::ostream &amp;os, itk::Indent indent) const
<span style = "background-color:#fdd">{
  Superclass::PrintSelf(os, indent);
}</span>

bool mitk::PlanarCircle::SetCurrentControlPoint(const Point2D &amp;point)
<span style = "background-color:#fdd">{
  if (m_SelectedControlPoint &lt; 0)</span>
  {
<span style = "background-color:#fdd">    m_SelectedControlPoint = 1;</span>
  }

<span style = "background-color:#fdd">  return this-&gt;SetControlPoint(m_SelectedControlPoint, point, false);
}</span>

bool mitk::PlanarCircle::Equals(const PlanarFigure &amp;other) const
<span style = "background-color:#fdd">{
  const auto *otherCircle = dynamic_cast&lt;const mitk::PlanarCircle *&gt;(&amp;other);
  if (otherCircle)</span>
  {
<span style = "background-color:#fdd">    return Superclass::Equals(other);
  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>