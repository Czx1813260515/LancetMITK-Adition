<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkLabelSetImage.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkLabelSetImage.h"

#include "mitkImageAccessByItk.h"
#include "mitkImageCast.h"
#include "mitkImagePixelReadAccessor.h"
#include "mitkImagePixelWriteAccessor.h"
#include "mitkInteractionConst.h"
#include "mitkLookupTableProperty.h"
#include "mitkPadImageFilter.h"
#include "mitkRenderingManager.h"
#include "mitkDICOMSegmentationPropertyHelper.h"
#include "mitkDICOMQIPropertyHelper.h"

#include &lt;vtkCell.h&gt;
#include &lt;vtkTransform.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;

#include &lt;itkImageRegionIterator.h&gt;
#include &lt;itkQuadEdgeMesh.h&gt;
#include &lt;itkTriangleMeshToBinaryImageFilter.h&gt;
//#include &lt;itkRelabelComponentImageFilter.h&gt;

#include &lt;itkCommand.h&gt;

template &lt;typename TPixel, unsigned int VDimensions&gt;
void SetToZero(itk::Image&lt;TPixel, VDimensions&gt; *source)
<span style = "background-color:#fdd">{
  source-&gt;FillBuffer(0);
}</span>

template &lt;unsigned int VImageDimension = 3&gt;
void CreateLabelMaskProcessing(mitk::Image *layerImage, mitk::Image *mask, mitk::LabelSet::PixelType index)
<span style = "background-color:#fdd">{
  mitk::ImagePixelReadAccessor&lt;mitk::LabelSet::PixelType, VImageDimension&gt; readAccessor(layerImage);
  mitk::ImagePixelWriteAccessor&lt;mitk::LabelSet::PixelType, VImageDimension&gt; writeAccessor(mask);</span>

<span style = "background-color:#fdd">  std::size_t numberOfPixels = 1;
  for (int dim = 0; dim &lt; static_cast&lt;int&gt;(VImageDimension); ++dim)
    numberOfPixels *= static_cast&lt;std::size_t&gt;(readAccessor.GetDimension(dim));</span>

<span style = "background-color:#fdd">  auto src = readAccessor.GetData();
  auto dest = writeAccessor.GetData();</span>

<span style = "background-color:#fdd">  for (std::size_t i = 0; i &lt; numberOfPixels; ++i)</span>
  {
<span style = "background-color:#fdd">    if (index == *(src + i))
      *(dest + i) = 1;
  }
}</span>

mitk::LabelSetImage::LabelSetImage()
<span style = "background-color:#fdd">  : mitk::Image(), m_ActiveLayer(0), m_activeLayerInvalid(false), m_ExteriorLabel(nullptr)
{</span>
  // Iniitlaize Background Label
<span style = "background-color:#fdd">  mitk::Color color;
  color.Set(0, 0, 0);
  m_ExteriorLabel = mitk::Label::New();
  m_ExteriorLabel-&gt;SetColor(color);
  m_ExteriorLabel-&gt;SetName("Exterior");
  m_ExteriorLabel-&gt;SetOpacity(0.0);
  m_ExteriorLabel-&gt;SetLocked(false);
  m_ExteriorLabel-&gt;SetValue(0);</span>

  // Add some DICOM Tags as properties to segmentation image
<span style = "background-color:#fdd">  DICOMSegmentationPropertyHelper::DeriveDICOMSegmentationProperties(this);
}</span>

mitk::LabelSetImage::LabelSetImage(const mitk::LabelSetImage &amp;other)
<span style = "background-color:#fdd">  : Image(other),
    m_ActiveLayer(other.GetActiveLayer()),
    m_activeLayerInvalid(false),
    m_ExteriorLabel(other.GetExteriorLabel()-&gt;Clone())
{
  for (unsigned int i = 0; i &lt; other.GetNumberOfLayers(); i++)</span>
  {
    // Clone LabelSet data
<span style = "background-color:#fdd">    mitk::LabelSet::Pointer lsClone = other.GetLabelSet(i)-&gt;Clone();</span>
    // add modified event listener to LabelSet (listen to LabelSet changes)
<span style = "background-color:#fdd">    itk::SimpleMemberCommand&lt;Self&gt;::Pointer command = itk::SimpleMemberCommand&lt;Self&gt;::New();
    command-&gt;SetCallbackFunction(this, &amp;mitk::LabelSetImage::OnLabelSetModified);
    lsClone-&gt;AddObserver(itk::ModifiedEvent(), command);
    m_LabelSetContainer.push_back(lsClone);</span>

    // clone layer Image data
<span style = "background-color:#fdd">    mitk::Image::Pointer liClone = other.GetLayerImage(i)-&gt;Clone();
    m_LayerContainer.push_back(liClone);
  }</span>

  // Add some DICOM Tags as properties to segmentation image
<span style = "background-color:#fdd">  DICOMSegmentationPropertyHelper::DeriveDICOMSegmentationProperties(this);
}</span>

void mitk::LabelSetImage::OnLabelSetModified()
<span style = "background-color:#fdd">{
  Superclass::Modified();
}</span>

void mitk::LabelSetImage::SetExteriorLabel(mitk::Label *label)
<span style = "background-color:#fdd">{
  m_ExteriorLabel = label;
}</span>

mitk::Label *mitk::LabelSetImage::GetExteriorLabel()
<span style = "background-color:#fdd">{
  return m_ExteriorLabel;
}</span>

const mitk::Label *mitk::LabelSetImage::GetExteriorLabel() const
<span style = "background-color:#fdd">{
  return m_ExteriorLabel;
}</span>

void mitk::LabelSetImage::Initialize(const mitk::Image *other)
<span style = "background-color:#fdd">{
  mitk::PixelType pixelType(mitk::MakeScalarPixelType&lt;LabelSetImage::PixelType&gt;());
  if (other-&gt;GetDimension() == 2)</span>
  {
<span style = "background-color:#fdd">    const unsigned int dimensions[] = {other-&gt;GetDimension(0), other-&gt;GetDimension(1), 1};
    Superclass::Initialize(pixelType, 3, dimensions);
  }</span>
  else
  {
<span style = "background-color:#fdd">    Superclass::Initialize(pixelType, other-&gt;GetDimension(), other-&gt;GetDimensions());</span>
  }

<span style = "background-color:#fdd">  auto originalGeometry = other-&gt;GetTimeGeometry()-&gt;Clone();
  this-&gt;SetTimeGeometry(originalGeometry);</span>

  // initialize image memory to zero
<span style = "background-color:#fdd">  if (4 == this-&gt;GetDimension())</span>
  {
<span style = "background-color:#fdd">    AccessFixedDimensionByItk(this, SetToZero, 4);
  }</span>
  else
  {
<span style = "background-color:#fdd">    AccessByItk(this, SetToZero);</span>
  }

  // Transfer some general DICOM properties from the source image to derived image (e.g. Patient information,...)
<span style = "background-color:#fdd">  DICOMQIPropertyHelper::DeriveDICOMSourceProperties(other, this);</span>

  // Add a inital LabelSet ans corresponding image data to the stack
<span style = "background-color:#fdd">  AddLayer();
}</span>

mitk::LabelSetImage::~LabelSetImage()
<span style = "background-color:#fdd">{
  m_LabelSetContainer.clear();
}</span>

mitk::Image *mitk::LabelSetImage::GetLayerImage(unsigned int layer)
<span style = "background-color:#fdd">{
  return m_LayerContainer[layer];
}</span>

const mitk::Image *mitk::LabelSetImage::GetLayerImage(unsigned int layer) const
<span style = "background-color:#fdd">{
  return m_LayerContainer[layer];
}</span>

unsigned int mitk::LabelSetImage::GetActiveLayer() const
<span style = "background-color:#fdd">{
  return m_ActiveLayer;
}</span>

unsigned int mitk::LabelSetImage::GetNumberOfLayers() const
<span style = "background-color:#fdd">{
  return m_LabelSetContainer.size();
}</span>

void mitk::LabelSetImage::RemoveLayer()
<span style = "background-color:#fdd">{
  int layerToDelete = GetActiveLayer();</span>
  // remove all observers from active label set
<span style = "background-color:#fdd">  GetLabelSet(layerToDelete)-&gt;RemoveAllObservers();</span>

  // set the active layer to one below, if exists.
<span style = "background-color:#fdd">  if (layerToDelete != 0)</span>
  {
<span style = "background-color:#fdd">    SetActiveLayer(layerToDelete - 1);
  }</span>
  else
  {
    // we are deleting layer zero, it should not be copied back into the vector
<span style = "background-color:#fdd">    m_activeLayerInvalid = true;</span>
  }

  // remove labelset and image data
<span style = "background-color:#fdd">  m_LabelSetContainer.erase(m_LabelSetContainer.begin() + layerToDelete);
  m_LayerContainer.erase(m_LayerContainer.begin() + layerToDelete);</span>

<span style = "background-color:#fdd">  if (layerToDelete == 0)</span>
  {
<span style = "background-color:#fdd">    this-&gt;SetActiveLayer(layerToDelete);</span>
  }

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span>

unsigned int mitk::LabelSetImage::AddLayer(mitk::LabelSet::Pointer lset)
<span style = "background-color:#fdd">{
  mitk::Image::Pointer newImage = mitk::Image::New();
  newImage-&gt;Initialize(this-&gt;GetPixelType(),</span>
                       this-&gt;GetDimension(),
                       this-&gt;GetDimensions(),
                       this-&gt;GetImageDescriptor()-&gt;GetNumberOfChannels());
<span style = "background-color:#fdd">  newImage-&gt;SetTimeGeometry(this-&gt;GetTimeGeometry()-&gt;Clone());</span>

<span style = "background-color:#fdd">  if (newImage-&gt;GetDimension() &lt; 4)</span>
  {
<span style = "background-color:#fdd">    AccessByItk(newImage, SetToZero);
  }</span>
  else
  {
<span style = "background-color:#fdd">    AccessFixedDimensionByItk(newImage, SetToZero, 4);</span>
  }

<span style = "background-color:#fdd">  unsigned int newLabelSetId = this-&gt;AddLayer(newImage, lset);</span>

<span style = "background-color:#fdd">  return newLabelSetId;
}</span>

unsigned int mitk::LabelSetImage::AddLayer(mitk::Image::Pointer layerImage, mitk::LabelSet::Pointer lset)
<span style = "background-color:#fdd">{
  unsigned int newLabelSetId = m_LayerContainer.size();</span>

  // Add labelset to layer
<span style = "background-color:#fdd">  mitk::LabelSet::Pointer ls;
  if (lset.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    ls = lset;
  }</span>
  else
  {
<span style = "background-color:#fdd">    ls = mitk::LabelSet::New();
    ls-&gt;AddLabel(GetExteriorLabel());
    ls-&gt;SetActiveLabel(0 /*Exterior Label*/);</span>
  }

<span style = "background-color:#fdd">  ls-&gt;SetLayer(newLabelSetId);</span>
  // Add exterior Label to label set
  // mitk::Label::Pointer exteriorLabel = CreateExteriorLabel();

  // push a new working image for the new layer
<span style = "background-color:#fdd">  m_LayerContainer.push_back(layerImage);</span>

  // push a new labelset for the new layer
<span style = "background-color:#fdd">  m_LabelSetContainer.push_back(ls);</span>

  // add modified event listener to LabelSet (listen to LabelSet changes)
<span style = "background-color:#fdd">  itk::SimpleMemberCommand&lt;Self&gt;::Pointer command = itk::SimpleMemberCommand&lt;Self&gt;::New();
  command-&gt;SetCallbackFunction(this, &amp;mitk::LabelSetImage::OnLabelSetModified);
  ls-&gt;AddObserver(itk::ModifiedEvent(), command);</span>

<span style = "background-color:#fdd">  SetActiveLayer(newLabelSetId);</span>
  // MITK_INFO &lt;&lt; GetActiveLayer();
<span style = "background-color:#fdd">  this-&gt;Modified();
  return newLabelSetId;
}</span>

void mitk::LabelSetImage::AddLabelSetToLayer(const unsigned int layerIdx, const mitk::LabelSet::Pointer labelSet)
<span style = "background-color:#fdd">{
  if (m_LayerContainer.size() &lt;= layerIdx)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Trying to add labelSet to non-existing layer.";</span>
  }

<span style = "background-color:#fdd">  if (layerIdx &lt; m_LabelSetContainer.size())</span>
  {
<span style = "background-color:#fdd">    m_LabelSetContainer[layerIdx] = labelSet;
  }</span>
  else
  {
<span style = "background-color:#fdd">    while (layerIdx &gt;= m_LabelSetContainer.size())</span>
    {
<span style = "background-color:#fdd">      mitk::LabelSet::Pointer defaultLabelSet = mitk::LabelSet::New();
      defaultLabelSet-&gt;AddLabel(GetExteriorLabel());
      defaultLabelSet-&gt;SetActiveLabel(0 /*Exterior Label*/);
      defaultLabelSet-&gt;SetLayer(m_LabelSetContainer.size());
      m_LabelSetContainer.push_back(defaultLabelSet);
    }
    m_LabelSetContainer.push_back(labelSet);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::LabelSetImage::SetActiveLayer(unsigned int layer)
<span style = "background-color:#fdd">{</span>
  try
  {
<span style = "background-color:#fdd">    if (4 == this-&gt;GetDimension())</span>
    {
<span style = "background-color:#fdd">      if ((layer != GetActiveLayer() || m_activeLayerInvalid) &amp;&amp; (layer &lt; this-&gt;GetNumberOfLayers()))</span>
      {
<span style = "background-color:#fdd">        BeforeChangeLayerEvent.Send();</span>

<span style = "background-color:#fdd">        if (m_activeLayerInvalid)</span>
        {
          // We should not write the invalid layer back to the vector
<span style = "background-color:#fdd">          m_activeLayerInvalid = false;
        }</span>
        else
        {
<span style = "background-color:#fdd">          AccessFixedDimensionByItk_n(this, ImageToLayerContainerProcessing, 4, (GetActiveLayer()));</span>
        }
<span style = "background-color:#fdd">        m_ActiveLayer = layer; // only at this place m_ActiveLayer should be manipulated!!! Use Getter and Setter
        AccessFixedDimensionByItk_n(this, LayerContainerToImageProcessing, 4, (GetActiveLayer()));</span>

<span style = "background-color:#fdd">        AfterChangeLayerEvent.Send();</span>
      }
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">      if ((layer != GetActiveLayer() || m_activeLayerInvalid) &amp;&amp; (layer &lt; this-&gt;GetNumberOfLayers()))</span>
      {
<span style = "background-color:#fdd">        BeforeChangeLayerEvent.Send();</span>

<span style = "background-color:#fdd">        if (m_activeLayerInvalid)</span>
        {
          // We should not write the invalid layer back to the vector
<span style = "background-color:#fdd">          m_activeLayerInvalid = false;
        }</span>
        else
        {
<span style = "background-color:#fdd">          AccessByItk_1(this, ImageToLayerContainerProcessing, GetActiveLayer());</span>
        }
<span style = "background-color:#fdd">        m_ActiveLayer = layer; // only at this place m_ActiveLayer should be manipulated!!! Use Getter and Setter
        AccessByItk_1(this, LayerContainerToImageProcessing, GetActiveLayer());</span>

<span style = "background-color:#fdd">        AfterChangeLayerEvent.Send();</span>
      }
    }
  }
  catch (itk::ExceptionObject &amp;e)
<span style = "background-color:#fdd">  {
    mitkThrow() &lt;&lt; e.GetDescription();
  }
  this-&gt;Modified();
}</span>

void mitk::LabelSetImage::Concatenate(mitk::LabelSetImage *other)
<span style = "background-color:#fdd">{
  const unsigned int *otherDims = other-&gt;GetDimensions();
  const unsigned int *thisDims = this-&gt;GetDimensions();
  if ((otherDims[0] != thisDims[0]) || (otherDims[1] != thisDims[1]) || (otherDims[2] != thisDims[2]))
    mitkThrow() &lt;&lt; "Dimensions do not match.";</span>

  try
  {
<span style = "background-color:#fdd">    int numberOfLayers = other-&gt;GetNumberOfLayers();
    for (int layer = 0; layer &lt; numberOfLayers; ++layer)</span>
    {
<span style = "background-color:#fdd">      this-&gt;SetActiveLayer(layer);
      AccessByItk_1(this, ConcatenateProcessing, other);
      mitk::LabelSet *ls = other-&gt;GetLabelSet(layer);
      auto it = ls-&gt;IteratorConstBegin();
      auto end = ls-&gt;IteratorConstEnd();
      it++; // skip exterior
      while (it != end)</span>
      {
<span style = "background-color:#fdd">        GetLabelSet()-&gt;AddLabel((it-&gt;second));</span>
        // AddLabelEvent.Send();
<span style = "background-color:#fdd">        it++;
      }
    }</span>
  }
  catch (itk::ExceptionObject &amp;e)
<span style = "background-color:#fdd">  {
    mitkThrow() &lt;&lt; e.GetDescription();
  }
  this-&gt;Modified();
}</span>

void mitk::LabelSetImage::ClearBuffer()
<span style = "background-color:#fdd">{</span>
  try
  {
<span style = "background-color:#fdd">    if (this-&gt;GetDimension() == 4)</span>
    { //remark: this extra branch was added, because LabelSetImage instances can be
      //dynamic (4D), but AccessByItk by support only supports 2D and 3D.
      //The option to change the CMake default dimensions for AccessByItk was
      //dropped (for details see discussion in T28756)
<span style = "background-color:#fdd">      AccessFixedDimensionByItk(this, ClearBufferProcessing,4);
    }</span>
    else
    {
<span style = "background-color:#fdd">      AccessByItk(this, ClearBufferProcessing);</span>
    }
<span style = "background-color:#fdd">    this-&gt;Modified();</span>
  }
  catch (itk::ExceptionObject &amp;e)
<span style = "background-color:#fdd">  {
    mitkThrow() &lt;&lt; e.GetDescription();
  }
}</span>

bool mitk::LabelSetImage::ExistLabel(PixelType pixelValue) const
<span style = "background-color:#fdd">{
  bool exist = false;
  for (unsigned int lidx = 0; lidx &lt; GetNumberOfLayers(); lidx++)
    exist |= m_LabelSetContainer[lidx]-&gt;ExistLabel(pixelValue);
  return exist;
}</span>

bool mitk::LabelSetImage::ExistLabel(PixelType pixelValue, unsigned int layer) const
<span style = "background-color:#fdd">{
  bool exist = m_LabelSetContainer[layer]-&gt;ExistLabel(pixelValue);
  return exist;
}</span>

bool mitk::LabelSetImage::ExistLabelSet(unsigned int layer) const
<span style = "background-color:#fdd">{
  return layer &lt; m_LabelSetContainer.size();
}</span>

void mitk::LabelSetImage::MergeLabel(PixelType pixelValue, PixelType sourcePixelValue, unsigned int layer)
<span style = "background-color:#fdd">{</span>
  try
  {
<span style = "background-color:#fdd">    AccessByItk_2(this, MergeLabelProcessing, pixelValue, sourcePixelValue);</span>
  }
  catch (itk::ExceptionObject &amp;e)
<span style = "background-color:#fdd">  {
    mitkThrow() &lt;&lt; e.GetDescription();
  }
  GetLabelSet(layer)-&gt;SetActiveLabel(pixelValue);
  Modified();
}</span>

void mitk::LabelSetImage::MergeLabels(PixelType pixelValue, std::vector&lt;PixelType&gt;&amp; vectorOfSourcePixelValues, unsigned int layer)
<span style = "background-color:#fdd">{</span>
  try
  {
<span style = "background-color:#fdd">    for (unsigned int idx = 0; idx &lt; vectorOfSourcePixelValues.size(); idx++)</span>
    {
<span style = "background-color:#fdd">      AccessByItk_2(this, MergeLabelProcessing, pixelValue, vectorOfSourcePixelValues[idx]);
    }</span>
  }
  catch (itk::ExceptionObject &amp;e)
<span style = "background-color:#fdd">  {
    mitkThrow() &lt;&lt; e.GetDescription();
  }
  GetLabelSet(layer)-&gt;SetActiveLabel(pixelValue);
  Modified();
}</span>

void mitk::LabelSetImage::RemoveLabels(std::vector&lt;PixelType&gt; &amp;VectorOfLabelPixelValues, unsigned int layer)
<span style = "background-color:#fdd">{
  for (unsigned int idx = 0; idx &lt; VectorOfLabelPixelValues.size(); idx++)</span>
  {
<span style = "background-color:#fdd">    GetLabelSet(layer)-&gt;RemoveLabel(VectorOfLabelPixelValues[idx]);
    EraseLabel(VectorOfLabelPixelValues[idx], layer);
  }
}</span>

void mitk::LabelSetImage::EraseLabels(std::vector&lt;PixelType&gt; &amp;VectorOfLabelPixelValues, unsigned int layer)
<span style = "background-color:#fdd">{
  for (unsigned int i = 0; i &lt; VectorOfLabelPixelValues.size(); i++)</span>
  {
<span style = "background-color:#fdd">    this-&gt;EraseLabel(VectorOfLabelPixelValues[i], layer);
  }
}</span>

void mitk::LabelSetImage::EraseLabel(PixelType pixelValue, unsigned int layer)
<span style = "background-color:#fdd">{</span>
  try
  {
<span style = "background-color:#fdd">    if (4 == this-&gt;GetDimension())</span>
    {
<span style = "background-color:#fdd">      AccessFixedDimensionByItk_2(this, EraseLabelProcessing, 4, pixelValue, layer);
    }</span>
    else
    {
<span style = "background-color:#fdd">      AccessByItk_2(this, EraseLabelProcessing, pixelValue, layer);</span>
    }
  }
  catch (const itk::ExceptionObject &amp;e)
<span style = "background-color:#fdd">  {
    mitkThrow() &lt;&lt; e.GetDescription();
  }
  Modified();
}</span>

mitk::Label *mitk::LabelSetImage::GetActiveLabel(unsigned int layer)
<span style = "background-color:#fdd">{
  if (m_LabelSetContainer.size() &lt;= layer)
    return nullptr;</span>
  else
<span style = "background-color:#fdd">    return m_LabelSetContainer[layer]-&gt;GetActiveLabel();
}</span>

const mitk::Label* mitk::LabelSetImage::GetActiveLabel(unsigned int layer) const
<span style = "background-color:#fdd">{
  if (m_LabelSetContainer.size() &lt;= layer)
    return nullptr;</span>
  else
<span style = "background-color:#fdd">    return m_LabelSetContainer[layer]-&gt;GetActiveLabel();
}</span>

mitk::Label *mitk::LabelSetImage::GetLabel(PixelType pixelValue, unsigned int layer) const
<span style = "background-color:#fdd">{
  if (m_LabelSetContainer.size() &lt;= layer)
    return nullptr;</span>
  else
<span style = "background-color:#fdd">    return m_LabelSetContainer[layer]-&gt;GetLabel(pixelValue);
}</span>

mitk::LabelSet *mitk::LabelSetImage::GetLabelSet(unsigned int layer)
<span style = "background-color:#fdd">{
  if (m_LabelSetContainer.size() &lt;= layer)
    return nullptr;</span>
  else
<span style = "background-color:#fdd">    return m_LabelSetContainer[layer].GetPointer();
}</span>

const mitk::LabelSet *mitk::LabelSetImage::GetLabelSet(unsigned int layer) const
<span style = "background-color:#fdd">{
  if (m_LabelSetContainer.size() &lt;= layer)
    return nullptr;</span>
  else
<span style = "background-color:#fdd">    return m_LabelSetContainer[layer].GetPointer();
}</span>

mitk::LabelSet *mitk::LabelSetImage::GetActiveLabelSet()
<span style = "background-color:#fdd">{
  if (m_LabelSetContainer.size() == 0)
    return nullptr;</span>
  else
<span style = "background-color:#fdd">    return m_LabelSetContainer[GetActiveLayer()].GetPointer();
}</span>

const mitk::LabelSet* mitk::LabelSetImage::GetActiveLabelSet() const
<span style = "background-color:#fdd">{
  if (m_LabelSetContainer.size() == 0)
    return nullptr;</span>
  else
<span style = "background-color:#fdd">    return m_LabelSetContainer[GetActiveLayer()].GetPointer();
}</span>

void mitk::LabelSetImage::UpdateCenterOfMass(PixelType pixelValue, unsigned int layer)
<span style = "background-color:#fdd">{
  if (4 == this-&gt;GetDimension())</span>
  {
<span style = "background-color:#fdd">    AccessFixedDimensionByItk_2(this, CalculateCenterOfMassProcessing, 4, pixelValue, layer);
  }</span>
  else
  {
<span style = "background-color:#fdd">    AccessByItk_2(this, CalculateCenterOfMassProcessing, pixelValue, layer);</span>
  }
<span style = "background-color:#fdd">}</span>

unsigned int mitk::LabelSetImage::GetNumberOfLabels(unsigned int layer) const
<span style = "background-color:#fdd">{
  return m_LabelSetContainer[layer]-&gt;GetNumberOfLabels();
}</span>

unsigned int mitk::LabelSetImage::GetTotalNumberOfLabels() const
<span style = "background-color:#fdd">{
  unsigned int totalLabels(0);
  auto layerIter = m_LabelSetContainer.begin();
  for (; layerIter != m_LabelSetContainer.end(); ++layerIter)
    totalLabels += (*layerIter)-&gt;GetNumberOfLabels();
  return totalLabels;
}</span>

void mitk::LabelSetImage::MaskStamp(mitk::Image *mask, bool forceOverwrite)
<span style = "background-color:#fdd">{</span>
  try
  {
<span style = "background-color:#fdd">    mitk::PadImageFilter::Pointer padImageFilter = mitk::PadImageFilter::New();
    padImageFilter-&gt;SetInput(0, mask);
    padImageFilter-&gt;SetInput(1, this);
    padImageFilter-&gt;SetPadConstant(0);
    padImageFilter-&gt;SetBinaryFilter(false);
    padImageFilter-&gt;SetLowerThreshold(0);
    padImageFilter-&gt;SetUpperThreshold(1);</span>

<span style = "background-color:#fdd">    padImageFilter-&gt;Update();</span>

<span style = "background-color:#fdd">    mitk::Image::Pointer paddedMask = padImageFilter-&gt;GetOutput();</span>

<span style = "background-color:#fdd">    if (paddedMask.IsNull())
      return;</span>

<span style = "background-color:#fdd">    AccessByItk_2(this, MaskStampProcessing, paddedMask, forceOverwrite);
  }</span>
  catch (...)
<span style = "background-color:#fdd">  {
    mitkThrow() &lt;&lt; "Could not stamp the provided mask on the selected label.";
  }
}</span>

mitk::Image::Pointer mitk::LabelSetImage::CreateLabelMask(PixelType index, bool useActiveLayer, unsigned int layer)
<span style = "background-color:#fdd">{
  auto previousActiveLayer = this-&gt;GetActiveLayer();
  auto mask = mitk::Image::New();</span>

  try
  {
    // mask-&gt;Initialize(this) does not work here if this label set image has a single slice,
    // since the mask would be automatically flattened to a 2-d image, whereas we expect the
    // original dimension of this label set image. Hence, initialize the mask more explicitly:
<span style = "background-color:#fdd">    mask-&gt;Initialize(this-&gt;GetPixelType(), this-&gt;GetDimension(), this-&gt;GetDimensions());
    mask-&gt;SetTimeGeometry(this-&gt;GetTimeGeometry()-&gt;Clone());</span>

<span style = "background-color:#fdd">    auto byteSize = sizeof(LabelSetImage::PixelType);
    for (unsigned int dim = 0; dim &lt; mask-&gt;GetDimension(); ++dim)
      byteSize *= mask-&gt;GetDimension(dim);</span>

    {
<span style = "background-color:#fdd">      ImageWriteAccessor accessor(mask);
      memset(accessor.GetData(), 0, byteSize);
    }</span>

<span style = "background-color:#fdd">    if (!useActiveLayer)
      this-&gt;SetActiveLayer(layer);</span>

<span style = "background-color:#fdd">    if (4 == this-&gt;GetDimension())</span>
    {
<span style = "background-color:#fdd">      ::CreateLabelMaskProcessing&lt;4&gt;(this, mask, index);
    }
    else if (3 == this-&gt;GetDimension())</span>
    {
<span style = "background-color:#fdd">      ::CreateLabelMaskProcessing(this, mask, index);
    }</span>
    else
    {
<span style = "background-color:#fdd">      mitkThrow();</span>
    }
  }
  catch (...)
<span style = "background-color:#fdd">  {
    if (!useActiveLayer)
      this-&gt;SetActiveLayer(previousActiveLayer);</span>

<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Could not create a mask out of the selected label.";
  }</span>

<span style = "background-color:#fdd">  if (!useActiveLayer)
    this-&gt;SetActiveLayer(previousActiveLayer);</span>

<span style = "background-color:#fdd">  return mask;
}</span>

void mitk::LabelSetImage::InitializeByLabeledImage(mitk::Image::Pointer image)
<span style = "background-color:#fdd">{
  if (image.IsNull() || image-&gt;IsEmpty() || !image-&gt;IsInitialized())
    mitkThrow() &lt;&lt; "Invalid labeled image.";</span>

  try
  {
<span style = "background-color:#fdd">    this-&gt;Initialize(image);</span>

<span style = "background-color:#fdd">    unsigned int byteSize = sizeof(LabelSetImage::PixelType);
    for (unsigned int dim = 0; dim &lt; image-&gt;GetDimension(); ++dim)</span>
    {
<span style = "background-color:#fdd">      byteSize *= image-&gt;GetDimension(dim);
    }</span>

<span style = "background-color:#fdd">    mitk::ImageWriteAccessor *accessor = new mitk::ImageWriteAccessor(static_cast&lt;mitk::Image *&gt;(this));
    memset(accessor-&gt;GetData(), 0, byteSize);
    delete accessor;</span>

<span style = "background-color:#fdd">    auto geometry = image-&gt;GetTimeGeometry()-&gt;Clone();
    this-&gt;SetTimeGeometry(geometry);</span>

<span style = "background-color:#fdd">    if (image-&gt;GetDimension() == 3)</span>
    {
<span style = "background-color:#fdd">      AccessTwoImagesFixedDimensionByItk(this, image, InitializeByLabeledImageProcessing, 3);
    }
    else if (image-&gt;GetDimension() == 4)</span>
    {
<span style = "background-color:#fdd">      AccessTwoImagesFixedDimensionByItk(this, image, InitializeByLabeledImageProcessing, 4);
    }</span>
    else
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; image-&gt;GetDimension() &lt;&lt; "-dimensional label set images not yet supported";</span>
    }
<span style = "background-color:#fdd">  }</span>
  catch (...)
<span style = "background-color:#fdd">  {
    mitkThrow() &lt;&lt; "Could not intialize by provided labeled image.";
  }
  this-&gt;Modified();
}</span>

template &lt;typename LabelSetImageType, typename ImageType&gt;
void mitk::LabelSetImage::InitializeByLabeledImageProcessing(LabelSetImageType *labelSetImage, ImageType *image)
<span style = "background-color:#fdd">{</span>
  typedef itk::ImageRegionConstIteratorWithIndex&lt;ImageType&gt; SourceIteratorType;
  typedef itk::ImageRegionIterator&lt;LabelSetImageType&gt; TargetIteratorType;

<span style = "background-color:#fdd">  TargetIteratorType targetIter(labelSetImage, labelSetImage-&gt;GetRequestedRegion());
  targetIter.GoToBegin();</span>

<span style = "background-color:#fdd">  SourceIteratorType sourceIter(image, image-&gt;GetRequestedRegion());
  sourceIter.GoToBegin();</span>

<span style = "background-color:#fdd">  while (!sourceIter.IsAtEnd())</span>
  {
<span style = "background-color:#fdd">    auto sourceValue = static_cast&lt;PixelType&gt;(sourceIter.Get());
    targetIter.Set(sourceValue);</span>

<span style = "background-color:#fdd">    if (!this-&gt;ExistLabel(sourceValue))</span>
    {
<span style = "background-color:#fdd">      std::stringstream name;
      name &lt;&lt; "object-" &lt;&lt; sourceValue;</span>

      double rgba[4];
<span style = "background-color:#fdd">      m_LabelSetContainer[this-&gt;GetActiveLayer()]-&gt;GetLookupTable()-&gt;GetTableValue(sourceValue, rgba);</span>

<span style = "background-color:#fdd">      mitk::Color color;
      color.SetRed(rgba[0]);
      color.SetGreen(rgba[1]);
      color.SetBlue(rgba[2]);</span>

<span style = "background-color:#fdd">      auto label = mitk::Label::New();
      label-&gt;SetName(name.str().c_str());
      label-&gt;SetColor(color);
      label-&gt;SetOpacity(rgba[3]);
      label-&gt;SetValue(sourceValue);</span>

<span style = "background-color:#fdd">      this-&gt;GetLabelSet()-&gt;AddLabel(label);</span>

<span style = "background-color:#fdd">      if (GetActiveLabelSet()-&gt;GetNumberOfLabels() &gt;= mitk::Label::MAX_LABEL_VALUE ||</span>
          sourceValue &gt;= mitk::Label::MAX_LABEL_VALUE)
<span style = "background-color:#fdd">        this-&gt;AddLayer();
    }</span>

<span style = "background-color:#fdd">    ++sourceIter;
    ++targetIter;
  }
}</span>

template &lt;typename ImageType&gt;
void mitk::LabelSetImage::MaskStampProcessing(ImageType *itkImage, mitk::Image *mask, bool forceOverwrite)
<span style = "background-color:#fdd">{
  typename ImageType::Pointer itkMask;
  mitk::CastToItkImage(mask, itkMask);</span>

  typedef itk::ImageRegionConstIterator&lt;ImageType&gt; SourceIteratorType;
  typedef itk::ImageRegionIterator&lt;ImageType&gt; TargetIteratorType;

<span style = "background-color:#fdd">  SourceIteratorType sourceIter(itkMask, itkMask-&gt;GetLargestPossibleRegion());
  sourceIter.GoToBegin();</span>

<span style = "background-color:#fdd">  TargetIteratorType targetIter(itkImage, itkImage-&gt;GetLargestPossibleRegion());
  targetIter.GoToBegin();</span>

<span style = "background-color:#fdd">  int activeLabel = this-&gt;GetActiveLabel(GetActiveLayer())-&gt;GetValue();</span>

<span style = "background-color:#fdd">  while (!sourceIter.IsAtEnd())</span>
  {
<span style = "background-color:#fdd">    PixelType sourceValue = sourceIter.Get();
    PixelType targetValue = targetIter.Get();</span>

<span style = "background-color:#fdd">    if ((sourceValue != 0) &amp;&amp;</span>
        (forceOverwrite || !this-&gt;GetLabel(targetValue)-&gt;GetLocked())) // skip exterior and locked labels
    {
<span style = "background-color:#fdd">      targetIter.Set(activeLabel);</span>
    }
<span style = "background-color:#fdd">    ++sourceIter;
    ++targetIter;
  }</span>

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span>

template &lt;typename ImageType&gt;
void mitk::LabelSetImage::CalculateCenterOfMassProcessing(ImageType *itkImage, PixelType pixelValue, unsigned int layer)
<span style = "background-color:#fdd">{</span>
  // for now, we just retrieve the voxel in the middle
  typedef itk::ImageRegionConstIterator&lt;ImageType&gt; IteratorType;
<span style = "background-color:#fdd">  IteratorType iter(itkImage, itkImage-&gt;GetLargestPossibleRegion());
  iter.GoToBegin();</span>

<span style = "background-color:#fdd">  std::vector&lt;typename ImageType::IndexType&gt; indexVector;</span>

<span style = "background-color:#fdd">  while (!iter.IsAtEnd())</span>
  {
    // TODO fix comparison warning more effective
<span style = "background-color:#fdd">    if (iter.Get() == pixelValue)</span>
    {
<span style = "background-color:#fdd">      indexVector.push_back(iter.GetIndex());</span>
    }
<span style = "background-color:#fdd">    ++iter;
  }</span>

<span style = "background-color:#fdd">  mitk::Point3D pos;
  pos.Fill(0.0);</span>

<span style = "background-color:#fdd">  if (!indexVector.empty())</span>
  {
    typename itk::ImageRegionConstIteratorWithIndex&lt;ImageType&gt;::IndexType centerIndex;
<span style = "background-color:#fdd">    centerIndex = indexVector.at(indexVector.size() / 2);
    if (centerIndex.GetIndexDimension() == 3)</span>
    {
<span style = "background-color:#fdd">      pos[0] = centerIndex[0];
      pos[1] = centerIndex[1];
      pos[2] = centerIndex[2];
    }</span>
    else
<span style = "background-color:#fdd">      return;</span>
  }

<span style = "background-color:#fdd">  GetLabelSet(layer)-&gt;GetLabel(pixelValue)-&gt;SetCenterOfMassIndex(pos);
  this-&gt;GetSlicedGeometry()-&gt;IndexToWorld(pos, pos); // TODO: TimeGeometry?
  GetLabelSet(layer)-&gt;GetLabel(pixelValue)-&gt;SetCenterOfMassCoordinates(pos);
}</span>

template &lt;typename ImageType&gt;
void mitk::LabelSetImage::ClearBufferProcessing(ImageType *itkImage)
<span style = "background-color:#fdd">{
  itkImage-&gt;FillBuffer(0);
}</span>

// todo: concatenate all layers and not just the active one
template &lt;typename ImageType&gt;
void mitk::LabelSetImage::ConcatenateProcessing(ImageType *itkTarget, mitk::LabelSetImage *other)
<span style = "background-color:#fdd">{
  typename ImageType::Pointer itkSource = ImageType::New();
  mitk::CastToItkImage(other, itkSource);</span>

  typedef itk::ImageRegionConstIterator&lt;ImageType&gt; ConstIteratorType;
  typedef itk::ImageRegionIterator&lt;ImageType&gt; IteratorType;

<span style = "background-color:#fdd">  ConstIteratorType sourceIter(itkSource, itkSource-&gt;GetLargestPossibleRegion());
  IteratorType targetIter(itkTarget, itkTarget-&gt;GetLargestPossibleRegion());</span>

<span style = "background-color:#fdd">  int numberOfTargetLabels = this-&gt;GetNumberOfLabels(GetActiveLayer()) - 1; // skip exterior
  sourceIter.GoToBegin();
  targetIter.GoToBegin();</span>

<span style = "background-color:#fdd">  while (!sourceIter.IsAtEnd())</span>
  {
<span style = "background-color:#fdd">    PixelType sourceValue = sourceIter.Get();
    PixelType targetValue = targetIter.Get();
    if ((sourceValue != 0) &amp;&amp; !this-&gt;GetLabel(targetValue)-&gt;GetLocked()) // skip exterior and locked labels</span>
    {
<span style = "background-color:#fdd">      targetIter.Set(sourceValue + numberOfTargetLabels);</span>
    }
<span style = "background-color:#fdd">    ++sourceIter;
    ++targetIter;
  }
}</span>

template &lt;typename TPixel, unsigned int VImageDimension&gt;
void mitk::LabelSetImage::LayerContainerToImageProcessing(itk::Image&lt;TPixel, VImageDimension&gt; *target,
                                                          unsigned int layer)
<span style = "background-color:#fdd">{</span>
  typedef itk::Image&lt;TPixel, VImageDimension&gt; ImageType;
<span style = "background-color:#fdd">  typename ImageType::Pointer itkSource;</span>
  // mitk::CastToItkImage(m_LayerContainer[layer], itkSource);
<span style = "background-color:#fdd">  itkSource = ImageToItkImage&lt;TPixel, VImageDimension&gt;(m_LayerContainer[layer]);</span>
  typedef itk::ImageRegionConstIterator&lt;ImageType&gt; SourceIteratorType;
  typedef itk::ImageRegionIterator&lt;ImageType&gt; TargetIteratorType;

<span style = "background-color:#fdd">  SourceIteratorType sourceIter(itkSource, itkSource-&gt;GetLargestPossibleRegion());
  sourceIter.GoToBegin();</span>

<span style = "background-color:#fdd">  TargetIteratorType targetIter(target, target-&gt;GetLargestPossibleRegion());
  targetIter.GoToBegin();</span>

<span style = "background-color:#fdd">  while (!sourceIter.IsAtEnd())</span>
  {
<span style = "background-color:#fdd">    targetIter.Set(sourceIter.Get());
    ++sourceIter;
    ++targetIter;
  }
}</span>

template &lt;typename TPixel, unsigned int VImageDimension&gt;
void mitk::LabelSetImage::ImageToLayerContainerProcessing(itk::Image&lt;TPixel, VImageDimension&gt; *source,
                                                          unsigned int layer) const
<span style = "background-color:#fdd">{</span>
  typedef itk::Image&lt;TPixel, VImageDimension&gt; ImageType;
<span style = "background-color:#fdd">  typename ImageType::Pointer itkTarget;</span>
  // mitk::CastToItkImage(m_LayerContainer[layer], itkTarget);
<span style = "background-color:#fdd">  itkTarget = ImageToItkImage&lt;TPixel, VImageDimension&gt;(m_LayerContainer[layer]);</span>

  typedef itk::ImageRegionConstIterator&lt;ImageType&gt; SourceIteratorType;
  typedef itk::ImageRegionIterator&lt;ImageType&gt; TargetIteratorType;

<span style = "background-color:#fdd">  SourceIteratorType sourceIter(source, source-&gt;GetLargestPossibleRegion());
  sourceIter.GoToBegin();</span>

<span style = "background-color:#fdd">  TargetIteratorType targetIter(itkTarget, itkTarget-&gt;GetLargestPossibleRegion());
  targetIter.GoToBegin();</span>

<span style = "background-color:#fdd">  while (!sourceIter.IsAtEnd())</span>
  {
<span style = "background-color:#fdd">    targetIter.Set(sourceIter.Get());
    ++sourceIter;
    ++targetIter;
  }
}</span>

template &lt;typename ImageType&gt;
void mitk::LabelSetImage::EraseLabelProcessing(ImageType *itkImage, PixelType pixelValue, unsigned int /*layer*/)
<span style = "background-color:#fdd">{</span>
  typedef itk::ImageRegionIterator&lt;ImageType&gt; IteratorType;

<span style = "background-color:#fdd">  IteratorType iter(itkImage, itkImage-&gt;GetLargestPossibleRegion());
  iter.GoToBegin();</span>

<span style = "background-color:#fdd">  while (!iter.IsAtEnd())</span>
  {
<span style = "background-color:#fdd">    PixelType value = iter.Get();</span>

<span style = "background-color:#fdd">    if (value == pixelValue)</span>
    {
<span style = "background-color:#fdd">      iter.Set(0);</span>
    }
<span style = "background-color:#fdd">    ++iter;
  }
}</span>

template &lt;typename ImageType&gt;
void mitk::LabelSetImage::MergeLabelProcessing(ImageType *itkImage, PixelType pixelValue, PixelType index)
<span style = "background-color:#fdd">{</span>
  typedef itk::ImageRegionIterator&lt;ImageType&gt; IteratorType;

<span style = "background-color:#fdd">  IteratorType iter(itkImage, itkImage-&gt;GetLargestPossibleRegion());
  iter.GoToBegin();</span>

<span style = "background-color:#fdd">  while (!iter.IsAtEnd())</span>
  {
<span style = "background-color:#fdd">    if (iter.Get() == index)</span>
    {
<span style = "background-color:#fdd">      iter.Set(pixelValue);</span>
    }
<span style = "background-color:#fdd">    ++iter;
  }
}</span>

bool mitk::Equal(const mitk::LabelSetImage &amp;leftHandSide,
                 const mitk::LabelSetImage &amp;rightHandSide,
                 ScalarType eps,
                 bool verbose)
<span style = "background-color:#fdd">{
  bool returnValue = true;</span>

  /* LabelSetImage members */

<span style = "background-color:#fdd">  MITK_INFO(verbose) &lt;&lt; "--- LabelSetImage Equal ---";</span>

  // number layers
<span style = "background-color:#fdd">  returnValue = leftHandSide.GetNumberOfLayers() == rightHandSide.GetNumberOfLayers();
  if (!returnValue)</span>
  {
<span style = "background-color:#fdd">    MITK_INFO(verbose) &lt;&lt; "Number of layers not equal.";
    return false;</span>
  }

  // total number labels
<span style = "background-color:#fdd">  returnValue = leftHandSide.GetTotalNumberOfLabels() == rightHandSide.GetTotalNumberOfLabels();
  if (!returnValue)</span>
  {
<span style = "background-color:#fdd">    MITK_INFO(verbose) &lt;&lt; "Total number of labels not equal.";
    return false;</span>
  }

  // active layer
<span style = "background-color:#fdd">  returnValue = leftHandSide.GetActiveLayer() == rightHandSide.GetActiveLayer();
  if (!returnValue)</span>
  {
<span style = "background-color:#fdd">    MITK_INFO(verbose) &lt;&lt; "Active layer not equal.";
    return false;</span>
  }

<span style = "background-color:#fdd">  if (4 == leftHandSide.GetDimension())</span>
  {
<span style = "background-color:#fdd">    MITK_INFO(verbose) &lt;&lt; "Can not compare image data for 4D images - skipping check.";
  }</span>
  else
  {
    // working image data
<span style = "background-color:#fdd">    returnValue = mitk::Equal((const mitk::Image &amp;)leftHandSide, (const mitk::Image &amp;)rightHandSide, eps, verbose);
    if (!returnValue)</span>
    {
<span style = "background-color:#fdd">      MITK_INFO(verbose) &lt;&lt; "Working image data not equal.";
      return false;</span>
    }
  }

<span style = "background-color:#fdd">  for (unsigned int layerIndex = 0; layerIndex &lt; leftHandSide.GetNumberOfLayers(); layerIndex++)</span>
  {
<span style = "background-color:#fdd">    if (4 == leftHandSide.GetDimension())</span>
    {
<span style = "background-color:#fdd">      MITK_INFO(verbose) &lt;&lt; "Can not compare image data for 4D images - skipping check.";
    }</span>
    else
    {
      // layer image data
<span style = "background-color:#fdd">      returnValue =</span>
        mitk::Equal(*leftHandSide.GetLayerImage(layerIndex), *rightHandSide.GetLayerImage(layerIndex), eps, verbose);
<span style = "background-color:#fdd">      if (!returnValue)</span>
      {
<span style = "background-color:#fdd">        MITK_INFO(verbose) &lt;&lt; "Layer image data not equal.";
        return false;</span>
      }
    }
    // layer labelset data

<span style = "background-color:#fdd">    returnValue =</span>
      mitk::Equal(*leftHandSide.GetLabelSet(layerIndex), *rightHandSide.GetLabelSet(layerIndex), eps, verbose);
<span style = "background-color:#fdd">    if (!returnValue)</span>
    {
<span style = "background-color:#fdd">      MITK_INFO(verbose) &lt;&lt; "Layer labelset data not equal.";
      return false;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return returnValue;
}</span></pre>
	</body>
</html>