<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDICOMReaderConfigurator.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkDICOMReaderConfigurator.h"

#include "mitkDICOMSortByTag.h"
#include "mitkSortByImagePositionPatient.h"

#include &lt;tinyxml2.h&gt;

mitk::DICOMReaderConfigurator
::DICOMReaderConfigurator()
<span style = "background-color:#dfd">{
}</span>

mitk::DICOMReaderConfigurator
::~DICOMReaderConfigurator()
<span style = "background-color:#dfd">{
}</span>

mitk::DICOMFileReader::Pointer
mitk::DICOMReaderConfigurator
::CreateFromConfigFile(const std::string&amp; filename) const
<span style = "background-color:#fdd">{
  tinyxml2::XMLDocument doc;
  if (tinyxml2::XML_SUCCESS == doc.LoadFile(filename.c_str()))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;CreateFromXMLDocument( doc );
  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Unable to load file at '" &lt;&lt; filename &lt;&lt;"'";
    return DICOMFileReader::Pointer();</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::DICOMFileReader::Pointer
mitk::DICOMReaderConfigurator
::CreateFromUTF8ConfigString(const std::string&amp; xmlContents) const
<span style = "background-color:#dfd">{
  tinyxml2::XMLDocument doc;
  doc.Parse(xmlContents.c_str());</span>

<span style = "background-color:#dfd">  return this-&gt;CreateFromXMLDocument( doc );
}</span>

mitk::DICOMFileReader::Pointer
mitk::DICOMReaderConfigurator
::CreateFromXMLDocument(tinyxml2::XMLDocument&amp; doc) const
<span style = "background-color:#dfd">{
  tinyxml2::XMLHandle root(doc.RootElement());</span>

<span style = "background-color:#dfd">  if (auto* rootElement = root.ToElement())</span>
  {
<span style = "background-color:#dfd">    if (strcmp(rootElement-&gt;Value(), "DICOMFileReader")) // :-( no std::string methods</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "File should contain a &lt;DICOMFileReader&gt; tag at top-level! Found '"</span>
                 &lt;&lt; (rootElement-&gt;Value() ? std::string(rootElement-&gt;Value()) : std::string("!nothing!")) &lt;&lt; "' instead";
<span style = "background-color:#fdd">      return nullptr;</span>
    }

<span style = "background-color:#dfd">    const char* classnameC = rootElement-&gt;Attribute("class");
    if (!classnameC)</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "File should name a reader class in the class attribute: &lt;DICOMFileReader class=\"...\"&gt;. Found nothing instead";
      return nullptr;</span>
    }

<span style = "background-color:#dfd">    int version(1);
    if ( rootElement-&gt;QueryIntAttribute("version", &amp;version) == tinyxml2::XML_SUCCESS)</span>
    {
<span style = "background-color:#dfd">      if (version == 1)</span>
      {
<span style = "background-color:#fdd">        MITK_WARN &lt;&lt; "Warning the given configuration is for DICOMFileReaders of version 1. "</span>
                  &lt;&lt; "This old version may be interpreted differently. Reason: "
                  &lt;&lt; "The default values for the following xml settings have been changed: "
                  &lt;&lt; "FixTiltByShearing (false -&gt; true); StrictSorting (true -&gt; false); ExpectDistanceOne (true -&gt; false).";
<span style = "background-color:#fdd">      }</span>
<span style = "background-color:#dfd">      else if (version &gt;2)</span>
      {
<span style = "background-color:#fdd">        MITK_WARN &lt;&lt; "This reader is only capable of creating DICOMFileReaders of version 1 and 2. "</span>
          &lt;&lt; "Will not continue, because given configuration is meant for version " &lt;&lt; version &lt;&lt; ".";
<span style = "background-color:#fdd">        return nullptr;</span>
      }
<span style = "background-color:#dfd">    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "File should name the version of the reader class in the version attribute: &lt;DICOMFileReader class=\"" &lt;&lt; classnameC &lt;&lt; "\" version=\"...\"&gt;."</span>
                 &lt;&lt; " Found nothing instead, assuming version 1!";
<span style = "background-color:#fdd">      version = 1;</span>
    }

<span style = "background-color:#dfd">    std::string classname(classnameC);</span>

<span style = "background-color:#dfd">    double decimalPlacesForOrientation(mitk::DICOMITKSeriesGDCMReader::GetDefaultDecimalPlacesForOrientation());
    bool useDecimalPlacesForOrientation(false);
    useDecimalPlacesForOrientation =</span>
      rootElement-&gt;QueryDoubleAttribute("decimalPlacesForOrientation", &amp;decimalPlacesForOrientation) == tinyxml2::XML_SUCCESS; // attribute present and a double value

<span style = "background-color:#dfd">    if (classname == "ClassicDICOMSeriesReader")</span>
    {
<span style = "background-color:#dfd">      mitk::ClassicDICOMSeriesReader::Pointer reader = mitk::ClassicDICOMSeriesReader::New();
      this-&gt;ConfigureCommonPropertiesOfDICOMITKSeriesGDCMReader(reader.GetPointer(), rootElement);
      this-&gt;ConfigureCommonPropertiesOfThreeDnTDICOMSeriesReader(reader.GetPointer(), rootElement);
      return reader.GetPointer();</span>
    }
<span style = "background-color:#dfd">    if (classname == "ThreeDnTDICOMSeriesReader")</span>
    {
<span style = "background-color:#dfd">      mitk::ThreeDnTDICOMSeriesReader::Pointer reader;
      if (useDecimalPlacesForOrientation)</span>
<span style = "background-color:#fdd">        reader = mitk::ThreeDnTDICOMSeriesReader::New(decimalPlacesForOrientation);</span>
      else
<span style = "background-color:#dfd">        reader = mitk::ThreeDnTDICOMSeriesReader::New();</span>

<span style = "background-color:#dfd">      return ConfigureThreeDnTDICOMSeriesReader(reader, rootElement).GetPointer();</span>
<span style = "background-color:#fdd">    }</span>
    else
<span style = "background-color:#dfd">    if (classname == "DICOMITKSeriesGDCMReader")</span>
    {
<span style = "background-color:#dfd">      bool simpleVolumeImport = QueryBooleanAttribute(rootElement, "simpleVolumeImport", mitk::DICOMITKSeriesGDCMReader::GetDefaultSimpleVolumeImport());</span>

<span style = "background-color:#dfd">      mitk::DICOMITKSeriesGDCMReader::Pointer reader;
      if (useDecimalPlacesForOrientation)</span>
<span style = "background-color:#fdd">        reader = mitk::DICOMITKSeriesGDCMReader::New( decimalPlacesForOrientation, simpleVolumeImport );</span>
      else
<span style = "background-color:#dfd">        reader = mitk::DICOMITKSeriesGDCMReader::New( mitk::DICOMITKSeriesGDCMReader::GetDefaultDecimalPlacesForOrientation(), simpleVolumeImport );</span>

      // simple volume import that ignores number of frames and inter slice distance

<span style = "background-color:#dfd">      return ConfigureDICOMITKSeriesGDCMReader(reader, rootElement).GetPointer();</span>
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "DICOMFileReader tag names unknown class '" &lt;&lt; classname &lt;&lt; "'";
      return nullptr;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Great confusion: no root element in XML document. Expecting a DICOMFileReader tag at top-level.";
    return nullptr;</span>
  }
<span style = "background-color:#dfd">}</span>

#define boolStringTrue(s) \
  (   s == "true" || s == "on" || s == "1" \
   || s == "TRUE" || s == "ON")

bool
mitk::DICOMReaderConfigurator
::QueryBooleanAttribute(const tinyxml2::XMLElement* element, const char* attributeName, bool defaultValue) const
<span style = "background-color:#dfd">{
  bool value(defaultValue);
  const auto* valueC = element-&gt;Attribute(attributeName);</span>

<span style = "background-color:#dfd">  if (nullptr != valueC)</span>
  {
<span style = "background-color:#dfd">    std::string valueS = valueC;
    value = boolStringTrue(valueS);
  }</span>

<span style = "background-color:#dfd">  return value;
}</span>

void
mitk::DICOMReaderConfigurator
::ConfigureCommonPropertiesOfThreeDnTDICOMSeriesReader(ThreeDnTDICOMSeriesReader::Pointer reader, const tinyxml2::XMLElement* element) const
<span style = "background-color:#dfd">{</span>
  // add the "group3DnT" flag
<span style = "background-color:#dfd">  bool group3DnT = QueryBooleanAttribute(element, "group3DnT", ThreeDnTDICOMSeriesReader::GetDefaultGroup3DandT());</span>

<span style = "background-color:#dfd">  reader-&gt;SetGroup3DandT( group3DnT );</span>

  // add the "onlyCondenseSameSeries" flag
<span style = "background-color:#dfd">  bool onlyCondenseSameSeries = QueryBooleanAttribute(element, "onlyCondenseSameSeries", ThreeDnTDICOMSeriesReader::GetDefaultOnlyCondenseSameSeries());</span>

<span style = "background-color:#dfd">  reader-&gt;SetOnlyCondenseSameSeries(onlyCondenseSameSeries);
}</span>

mitk::ThreeDnTDICOMSeriesReader::Pointer
mitk::DICOMReaderConfigurator
::ConfigureThreeDnTDICOMSeriesReader(ThreeDnTDICOMSeriesReader::Pointer reader, const tinyxml2::XMLElement* element) const
<span style = "background-color:#dfd">{
  assert(element);</span>

  // use all the base class configuration
<span style = "background-color:#dfd">  if (this-&gt;ConfigureDICOMITKSeriesGDCMReader( reader.GetPointer(), element ).IsNull())</span>
  {
<span style = "background-color:#fdd">    return nullptr;</span>
  }

<span style = "background-color:#dfd">  this-&gt;ConfigureCommonPropertiesOfThreeDnTDICOMSeriesReader(reader,element);
  return reader;
}</span>

void
mitk::DICOMReaderConfigurator
::ConfigureCommonPropertiesOfDICOMITKSeriesGDCMReader(DICOMITKSeriesGDCMReader::Pointer reader, const tinyxml2::XMLElement* element) const
<span style = "background-color:#dfd">{
  assert(element);</span>

<span style = "background-color:#dfd">  const char* configLabelC = element-&gt;Attribute("label");
  if (configLabelC)</span>
  {
<span style = "background-color:#dfd">    std::string configLabel(configLabelC);
    reader-&gt;SetConfigurationLabel(configLabel);
  }</span>

<span style = "background-color:#dfd">  const char* configDescriptionC = element-&gt;Attribute("description");
  if (configDescriptionC)</span>
  {
<span style = "background-color:#dfd">    reader-&gt;SetConfigurationDescription(configDescriptionC);</span>
  }

  // "fixTiltByShearing" flag
<span style = "background-color:#dfd">  bool fixTiltByShearing = QueryBooleanAttribute(element, "fixTiltByShearing", DICOMITKSeriesGDCMReader::GetDefaultFixTiltByShearing());</span>

<span style = "background-color:#dfd">  reader-&gt;SetFixTiltByShearing( fixTiltByShearing );
}</span>

mitk::DICOMITKSeriesGDCMReader::Pointer
mitk::DICOMReaderConfigurator
::ConfigureDICOMITKSeriesGDCMReader(DICOMITKSeriesGDCMReader::Pointer reader, const tinyxml2::XMLElement* element) const
<span style = "background-color:#dfd">{
  assert(element);</span>

<span style = "background-color:#dfd">  this-&gt;ConfigureCommonPropertiesOfDICOMITKSeriesGDCMReader(reader, element);</span>

  // "acceptTwoSlicesGroups" flag
<span style = "background-color:#dfd">  bool acceptTwoSlicesGroups = QueryBooleanAttribute(element, "acceptTwoSlicesGroups", true);</span>

<span style = "background-color:#dfd">  reader-&gt;SetAcceptTwoSlicesGroups( acceptTwoSlicesGroups );</span>

  // "toleratedOriginError" attribute (double)
<span style = "background-color:#dfd">  bool toleratedOriginErrorIsAbsolute = QueryBooleanAttribute(element, "toleratedOriginErrorIsAbsolute", false);</span>

<span style = "background-color:#dfd">  double toleratedOriginError(0.3);
  if (element-&gt;QueryDoubleAttribute("toleratedOriginError", &amp;toleratedOriginError) == tinyxml2::XML_SUCCESS) // attribute present and a double value</span>
  {
<span style = "background-color:#fdd">    if (toleratedOriginErrorIsAbsolute)</span>
    {
<span style = "background-color:#fdd">      reader-&gt;SetToleratedOriginOffset( toleratedOriginError );
    }</span>
    else
    {
<span style = "background-color:#fdd">      reader-&gt;SetToleratedOriginOffsetToAdaptive( toleratedOriginError );</span>
    }
  }

  // DICOMTagBasedSorters are the only thing we create at this point
  // TODO for-loop over all child elements of type DICOMTagBasedSorter, BUT actually a single sorter of this type is enough.
<span style = "background-color:#dfd">  auto* dElement = element-&gt;FirstChildElement("DICOMDatasetSorter");
  if (dElement)</span>
  {
<span style = "background-color:#dfd">    const char* classnameC = dElement-&gt;Attribute("class");
    if (!classnameC)</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "File should name a DICOMDatasetSorter class in the class attribute of &lt;DICOMDatasetSorter class=\"...\"&gt;. Found nothing instead";
      return nullptr;</span>
    }

<span style = "background-color:#dfd">    std::string classname(classnameC);</span>

<span style = "background-color:#dfd">    if (classname == "DICOMTagBasedSorter")</span>
    {
<span style = "background-color:#dfd">      DICOMTagBasedSorter::Pointer tagSorter = CreateDICOMTagBasedSorter(dElement);
      if (tagSorter.IsNotNull())</span>
      {
<span style = "background-color:#dfd">        reader-&gt;AddSortingElement( tagSorter );</span>
      }
<span style = "background-color:#dfd">    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "DICOMDatasetSorter tag names unknown class '" &lt;&lt; classname &lt;&lt; "'";
      return nullptr;</span>
    }
<span style = "background-color:#dfd">  }</span>

<span style = "background-color:#dfd">  return reader;
}</span>

mitk::DICOMTagBasedSorter::Pointer
mitk::DICOMReaderConfigurator
::CreateDICOMTagBasedSorter(const tinyxml2::XMLElement* element) const
<span style = "background-color:#dfd">{
  mitk::DICOMTagBasedSorter::Pointer tagSorter = mitk::DICOMTagBasedSorter::New();</span>

  // "strictSorting" parameter!
<span style = "background-color:#dfd">  bool strictSorting = QueryBooleanAttribute(element, "strictSorting", mitk::DICOMTagBasedSorter::GetDefaultStrictSorting());
  tagSorter-&gt;SetStrictSorting(strictSorting);</span>

  // "strictSorting" parameter!
<span style = "background-color:#dfd">  bool expectDistanceOne = QueryBooleanAttribute(element, "expectDistanceOne", mitk::DICOMTagBasedSorter::GetDefaultExpectDistanceOne());
  tagSorter-&gt;SetExpectDistanceOne(expectDistanceOne);</span>

<span style = "background-color:#dfd">  auto* dElement = element-&gt;FirstChildElement("Distinguishing");
  if (dElement)</span>
  {
<span style = "background-color:#dfd">    for ( auto* tChild = dElement-&gt;FirstChildElement();
          tChild != nullptr;
          tChild = tChild-&gt;NextSiblingElement() )</span>
    {
      try
      {
<span style = "background-color:#dfd">        mitk::DICOMTag tag = tagFromXMLElement(tChild);
        int i(5);
        if (tChild-&gt;QueryIntAttribute("cutDecimalPlaces", &amp;i) == tinyxml2::XML_SUCCESS)</span>
        {
<span style = "background-color:#fdd">          tagSorter-&gt;AddDistinguishingTag( tag, new mitk::DICOMTagBasedSorter::CutDecimalPlaces(i) );
        }</span>
        else
        {
<span style = "background-color:#dfd">          tagSorter-&gt;AddDistinguishingTag( tag );</span>
        }
      }
      catch(...)
<span style = "background-color:#fdd">      {
        return nullptr;
      }</span>
<span style = "background-color:#dfd">    }</span>
  }

  // "sorting tags"
<span style = "background-color:#dfd">  auto* sElement = element-&gt;FirstChildElement("Sorting");
  if (sElement)</span>
  {
<span style = "background-color:#dfd">    DICOMSortCriterion::Pointer previousCriterion;
    DICOMSortCriterion::Pointer currentCriterion;</span>

<span style = "background-color:#dfd">    for ( auto* tChildNode = sElement-&gt;LastChild();
        tChildNode != nullptr;
        tChildNode = tChildNode-&gt;PreviousSibling() )</span>
    {
<span style = "background-color:#dfd">      auto* tChild = tChildNode-&gt;ToElement();
      if (!tChild) continue;</span>

<span style = "background-color:#dfd">      if (!strcmp(tChild-&gt;Value(), "Tag"))</span>
      {
        try
        {
<span style = "background-color:#dfd">          currentCriterion = this-&gt;CreateDICOMSortByTag(tChild, previousCriterion);</span>
        }
        catch(...)
<span style = "background-color:#fdd">        {
          std::stringstream ss;
          ss &lt;&lt; "Could not parse &lt;Tag&gt; element at input line " &lt;&lt; tChild-&gt;GetLineNum() &lt;&lt; "!";
          MITK_ERROR &lt;&lt; ss.str();
          return nullptr;
        }</span>
<span style = "background-color:#dfd">      }</span>
      else
<span style = "background-color:#dfd">      if (!strcmp(tChild-&gt;Value(), "ImagePositionPatient"))</span>
      {
        try
        {
<span style = "background-color:#dfd">          currentCriterion = this-&gt;CreateSortByImagePositionPatient(tChild, previousCriterion);</span>
        }
        catch(...)
<span style = "background-color:#fdd">        {
          std::stringstream ss;
          ss &lt;&lt; "Could not parse &lt;ImagePositionPatient&gt; element at input line " &lt;&lt; tChild-&gt;GetLineNum() &lt;&lt; "!";
          MITK_ERROR &lt;&lt; ss.str();
          return nullptr;
        }</span>
<span style = "background-color:#dfd">      }</span>
      else
      {
<span style = "background-color:#fdd">        MITK_ERROR &lt;&lt; "File contain unknown tag &lt;" &lt;&lt; tChild-&gt;Value()  &lt;&lt; "&gt; tag as child to &lt;Sorting&gt;! Cannot interpret...";</span>
      }

<span style = "background-color:#dfd">      previousCriterion = currentCriterion;
    }</span>

<span style = "background-color:#dfd">    tagSorter-&gt;SetSortCriterion( currentCriterion.GetPointer() );
  }</span>

<span style = "background-color:#dfd">  return tagSorter;
}</span>

std::string
mitk::DICOMReaderConfigurator
::requiredStringAttribute(const tinyxml2::XMLElement* xmlElement, const std::string&amp; key) const
<span style = "background-color:#dfd">{
  assert(xmlElement);</span>

<span style = "background-color:#dfd">  const char* gC = xmlElement-&gt;Attribute(key.c_str());
  if (gC)</span>
  {
<span style = "background-color:#dfd">    std::string gS(gC);
    return gS;</span>
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    std::stringstream ss;
    ss &lt;&lt; "Expected an attribute '" &lt;&lt; key &lt;&lt; "' at "</span>
          "input line " &lt;&lt; xmlElement-&gt;GetLineNum() &lt;&lt; "!";
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; ss.str();
    throw std::invalid_argument( ss.str() );
  }</span>
<span style = "background-color:#dfd">}</span>

unsigned int
mitk::DICOMReaderConfigurator
::hexStringToUInt(const std::string&amp; s) const
<span style = "background-color:#dfd">{
  std::stringstream converter(s);</span>
  unsigned int ui;
<span style = "background-color:#dfd">  converter &gt;&gt; std::hex &gt;&gt; ui;
  MITK_DEBUG &lt;&lt; "Converted string '" &lt;&lt; s &lt;&lt; "' to unsigned int " &lt;&lt; ui;
  return ui;
}</span>

mitk::DICOMTag
mitk::DICOMReaderConfigurator
::tagFromXMLElement(const tinyxml2::XMLElement* xmlElement) const
<span style = "background-color:#dfd">{
  assert(xmlElement);</span>

<span style = "background-color:#dfd">  if (strcmp(xmlElement-&gt;Value(), "Tag")) // :-( no std::string methods</span>
  {
<span style = "background-color:#fdd">    std::stringstream ss;
    ss &lt;&lt; "Expected a &lt;Tag group=\"..\" element=\"..\"&gt; tag at "</span>
          "input line " &lt;&lt; xmlElement-&gt;GetLineNum() &lt;&lt; "!";
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; ss.str();
    throw std::invalid_argument( ss.str() );
  }</span>

<span style = "background-color:#dfd">  std::string groupS = requiredStringAttribute(xmlElement, "group");
  std::string elementS = requiredStringAttribute(xmlElement, "element");</span>

  try
  {
    // convert string to int (assuming string is in hex format with leading "0x" like "0x0020")
<span style = "background-color:#dfd">    unsigned int group = hexStringToUInt(groupS);
    unsigned int element = hexStringToUInt(elementS);
    return DICOMTag(group, element);</span>
  }
  catch(...)
<span style = "background-color:#fdd">  {
    std::stringstream ss;
    ss &lt;&lt; "Expected group and element values in &lt;Tag group=\"..\" element=\"..\"&gt; to be hexadecimal with leading 0x, e.g. '0x0020'"</span>
          "(input line " &lt;&lt; xmlElement-&gt;GetLineNum() &lt;&lt; ")!";
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; ss.str();
    throw std::invalid_argument( ss.str() );
  }
}</span>

mitk::DICOMSortCriterion::Pointer
mitk::DICOMReaderConfigurator
::CreateDICOMSortByTag(const tinyxml2::XMLElement* xmlElement, DICOMSortCriterion::Pointer secondaryCriterion) const
<span style = "background-color:#dfd">{
  mitk::DICOMTag tag = tagFromXMLElement(xmlElement);
  return DICOMSortByTag::New(tag, secondaryCriterion).GetPointer();
}</span>

mitk::DICOMSortCriterion::Pointer
mitk::DICOMReaderConfigurator
::CreateSortByImagePositionPatient(const tinyxml2::XMLElement*, DICOMSortCriterion::Pointer secondaryCriterion) const
<span style = "background-color:#dfd">{
  return SortByImagePositionPatient::New(secondaryCriterion).GetPointer();
}</span>



std::string
mitk::DICOMReaderConfigurator
::CreateConfigStringFromReader(DICOMFileReader::ConstPointer reader) const
<span style = "background-color:#fdd">{</span>
  // check possible sub-classes from the most-specific one up to the most generic one
<span style = "background-color:#fdd">  const DICOMFileReader* cPointer = reader;
  tinyxml2::XMLDocument document;
  tinyxml2::XMLElement* root = nullptr;
  if (const auto* specificReader = dynamic_cast&lt;const ClassicDICOMSeriesReader*&gt;(cPointer))</span>
  {
<span style = "background-color:#fdd">    root = this-&gt;CreateConfigStringFromReader(document, specificReader);
  }</span>
  else
<span style = "background-color:#fdd">  if (const auto* specificReader = dynamic_cast&lt;const ThreeDnTDICOMSeriesReader*&gt;(cPointer))</span>
  {
<span style = "background-color:#fdd">    root = this-&gt;CreateConfigStringFromReader(document, specificReader);
  }</span>
  else
<span style = "background-color:#fdd">  if (const auto* specificReader = dynamic_cast&lt;const DICOMITKSeriesGDCMReader*&gt;(cPointer))</span>
  {
<span style = "background-color:#fdd">    root = this-&gt;CreateConfigStringFromReader(document, specificReader);
  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Unknown reader class passed to DICOMReaderConfigurator::CreateConfigStringFromReader(). Cannot serialize.";
    return ""; // no serialization, what a pity</span>
  }

<span style = "background-color:#fdd">  if (nullptr != root)</span>
  {
<span style = "background-color:#fdd">    document.InsertEndChild( root );</span>

<span style = "background-color:#fdd">    tinyxml2::XMLPrinter printer;
    document.Print(&amp;printer);</span>

<span style = "background-color:#fdd">    std::string xmltext = printer.CStr();
    return xmltext;
  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "DICOMReaderConfigurator::CreateConfigStringFromReader() created empty serialization. Problem?";
    return "";</span>
  }
<span style = "background-color:#fdd">}</span>

tinyxml2::XMLElement*
mitk::DICOMReaderConfigurator
::CreateConfigStringFromReader(tinyxml2::XMLDocument &amp;doc, const DICOMITKSeriesGDCMReader* reader) const
<span style = "background-color:#fdd">{
  auto* root = this-&gt;CreateDICOMFileReaderTag(doc, reader);
  assert(root);</span>

<span style = "background-color:#fdd">  root-&gt;SetAttribute("fixTiltByShearing", reader-&gt;GetFixTiltByShearing());
  root-&gt;SetAttribute("acceptTwoSlicesGroups", reader-&gt;GetAcceptTwoSlicesGroups());
  root-&gt;SetAttribute("toleratedOriginError", reader-&gt;GetToleratedOriginError());
  root-&gt;SetAttribute("toleratedOriginErrorIsAbsolute", reader-&gt;IsToleratedOriginOffsetAbsolute());
  root-&gt;SetAttribute("decimalPlacesForOrientation", reader-&gt;GetDecimalPlacesForOrientation());</span>

  // iterate DICOMDatasetSorter objects
<span style = "background-color:#fdd">  DICOMITKSeriesGDCMReader::ConstSorterList sorterList = reader-&gt;GetFreelyConfiguredSortingElements();
  for(auto sorterIter = sorterList.begin();
      sorterIter != sorterList.end();
      ++sorterIter)</span>
  {
<span style = "background-color:#fdd">    const DICOMDatasetSorter* sorter = *sorterIter;
    if (const auto* specificSorter = dynamic_cast&lt;const DICOMTagBasedSorter*&gt;(sorter))</span>
    {
<span style = "background-color:#fdd">      auto* sorterTag = this-&gt;CreateConfigStringFromDICOMDatasetSorter(doc, specificSorter);
      root-&gt;InsertEndChild(sorterTag);
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Unknown DICOMDatasetSorter class passed to DICOMReaderConfigurator::CreateConfigStringFromReader(). Cannot serialize.";
      return nullptr;
    }
  }</span>

<span style = "background-color:#fdd">  return root;
}</span>

tinyxml2::XMLElement*
mitk::DICOMReaderConfigurator
::CreateConfigStringFromDICOMDatasetSorter(tinyxml2::XMLDocument &amp;doc, const DICOMTagBasedSorter* sorter) const
<span style = "background-color:#fdd">{
  assert(sorter);</span>

<span style = "background-color:#fdd">  auto *sorterTag = doc.NewElement("DICOMDatasetSorter");
  sorterTag-&gt;SetAttribute("class", sorter-&gt;GetNameOfClass());
  sorterTag-&gt;SetAttribute("strictSorting", sorter-&gt;GetStrictSorting());
  sorterTag-&gt;SetAttribute("expectDistanceOne", sorter-&gt;GetExpectDistanceOne());</span>

<span style = "background-color:#fdd">  auto *distinguishingTagsElement = doc.NewElement("Distinguishing");
  sorterTag-&gt;InsertEndChild(distinguishingTagsElement);
  mitk::DICOMTagList distinguishingTags = sorter-&gt;GetDistinguishingTags();
  for (auto tagIter = distinguishingTags.begin();
       tagIter != distinguishingTags.end();
       ++tagIter)</span>
  {
<span style = "background-color:#fdd">    auto* tag = this-&gt;CreateConfigStringFromDICOMTag(doc, *tagIter);
    distinguishingTagsElement-&gt;InsertEndChild(tag);</span>

<span style = "background-color:#fdd">    const DICOMTagBasedSorter::TagValueProcessor* processor = sorter-&gt;GetTagValueProcessorForDistinguishingTag(*tagIter);
    if (const auto* specificProcessor = dynamic_cast&lt;const DICOMTagBasedSorter::CutDecimalPlaces*&gt;(processor))</span>
    {
<span style = "background-color:#fdd">      tag-&gt;SetAttribute("cutDecimalPlaces", specificProcessor-&gt;GetPrecision());
    }
  }</span>

<span style = "background-color:#fdd">  auto *sortingElement = doc.NewElement("Sorting");
  sorterTag-&gt;InsertEndChild(sortingElement);
  mitk::DICOMSortCriterion::ConstPointer sortCriterion = sorter-&gt;GetSortCriterion();
  while (sortCriterion.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    std::string classname = sortCriterion-&gt;GetNameOfClass();
    if (classname == "SortByImagePositionPatient")</span>
    {
<span style = "background-color:#fdd">      sortingElement-&gt;InsertEndChild( doc.NewElement("ImagePositionPatient") ); // no parameters
    }</span>
    else
<span style = "background-color:#fdd">    if (classname == "DICOMSortByTag")</span>
    {
<span style = "background-color:#fdd">      DICOMTagList pseudoTagList = sortCriterion-&gt;GetTagsOfInterest();
      if (pseudoTagList.size() == 1)</span>
      {
<span style = "background-color:#fdd">        DICOMTag firstTag = pseudoTagList.front();</span>

<span style = "background-color:#fdd">        auto* tagElement = this-&gt;CreateConfigStringFromDICOMTag(doc, firstTag);</span>

<span style = "background-color:#fdd">        sortingElement-&gt;InsertEndChild( tagElement );
      }</span>
      else
      {
<span style = "background-color:#fdd">        MITK_ERROR &lt;&lt; "Encountered SortByTag class with MULTIPLE tag in CreateConfigStringFromDICOMDatasetSorter. Cannot serialize.";
        return nullptr;</span>
      }
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Encountered unknown class '" &lt;&lt; classname &lt;&lt; "' in CreateConfigStringFromDICOMDatasetSorter. Cannot serialize.";
      return nullptr;</span>
    }

<span style = "background-color:#fdd">    sortCriterion = sortCriterion-&gt;GetSecondaryCriterion();
  }</span>

<span style = "background-color:#fdd">  return sorterTag;
}</span>

tinyxml2::XMLElement*
mitk::DICOMReaderConfigurator
::CreateConfigStringFromDICOMTag(tinyxml2::XMLDocument&amp; doc, const DICOMTag&amp; tag) const
<span style = "background-color:#fdd">{
  auto  tagElement = doc.NewElement("Tag"); // name group element
  tagElement-&gt;SetAttribute("name", tag.GetName().c_str());
  tagElement-&gt;SetAttribute("group", toHexString(tag.GetGroup()).c_str());
  tagElement-&gt;SetAttribute("element", toHexString(tag.GetElement()).c_str());
  return tagElement;
}</span>

std::string
mitk::DICOMReaderConfigurator
::toHexString(unsigned int i) const
<span style = "background-color:#fdd">{
  std::stringstream ss;
  ss &lt;&lt; "0x" &lt;&lt; std::setfill ('0') &lt;&lt; std::setw(4) &lt;&lt; std::hex &lt;&lt; i;
  return ss.str();
}</span>


tinyxml2::XMLElement*
mitk::DICOMReaderConfigurator
::CreateConfigStringFromReader(tinyxml2::XMLDocument&amp; doc, const ThreeDnTDICOMSeriesReader* reader) const
<span style = "background-color:#fdd">{
  auto* root = this-&gt;CreateConfigStringFromReader(doc, static_cast&lt;const DICOMITKSeriesGDCMReader*&gt;(reader));
  assert(root);</span>

<span style = "background-color:#fdd">  root-&gt;SetAttribute("group3DnT", reader-&gt;GetGroup3DandT());</span>

<span style = "background-color:#fdd">  return root;
}</span>

tinyxml2::XMLElement*
mitk::DICOMReaderConfigurator
::CreateConfigStringFromReader(tinyxml2::XMLDocument&amp; doc, const ClassicDICOMSeriesReader* reader) const
<span style = "background-color:#fdd">{
  return this-&gt;CreateDICOMFileReaderTag(doc, reader);
}</span>

tinyxml2::XMLElement*
mitk::DICOMReaderConfigurator
::CreateDICOMFileReaderTag(tinyxml2::XMLDocument&amp; doc, const DICOMFileReader* reader) const
<span style = "background-color:#fdd">{
  auto readerTag = doc.NewElement("DICOMFileReader");
  readerTag-&gt;SetAttribute("class", reader-&gt;GetNameOfClass());
  readerTag-&gt;SetAttribute("label", reader-&gt;GetConfigurationLabel().c_str());
  readerTag-&gt;SetAttribute("description", reader-&gt;GetConfigurationDescription().c_str());
  readerTag-&gt;SetAttribute("version", "1");</span>

<span style = "background-color:#fdd">  return readerTag;
}</span></pre>
	</body>
</html>