<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDicomSeriesReader.txx</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKDICOMSERIESREADER_TXX_
#define MITKDICOMSERIESREADER_TXX_

#include &lt;legacy/mitkDicomSeriesReader.h&gt;

#include &lt;itkImageSeriesReader.h&gt;
#include &lt;mitkProperties.h&gt;

#include &lt;itkAffineTransform.h&gt;
#include &lt;itkLinearInterpolateImageFunction.h&gt;
#include &lt;itkResampleImageFilter.h&gt;
#include &lt;itkTimeProbesCollectorBase.h&gt;

#include &lt;limits&gt;

#include &lt;mitkImage.h&gt;

namespace mitk
{
  template &lt;typename PixelType&gt;
  Image::Pointer DicomSeriesReader::LoadDICOMByITK4D(std::list&lt;StringContainer&gt; &amp;imageBlocks,
                                                     ImageBlockDescriptor imageBlockDescriptor,
                                                     bool correctTilt,
                                                     const GantryTiltInformation &amp;tiltInfo,
                                                     DcmIoType::Pointer &amp;io,
                                                     CallbackCommand *command,
                                                     Image::Pointer preLoadedImageBlock)
<span style = "background-color:#fdd">  {
    mitk::Image::Pointer image = mitk::Image::New();</span>

    // It is 3D+t! Read it and store into mitk image
    typedef itk::Image&lt;PixelType, 4&gt; ImageType;
    typedef itk::ImageSeriesReader&lt;ImageType&gt; ReaderType;

<span style = "background-color:#fdd">    typename ReaderType::Pointer reader = ReaderType::New();</span>

<span style = "background-color:#fdd">    reader-&gt;SetImageIO(io);
    reader-&gt;ReverseOrderOff();</span>

<span style = "background-color:#fdd">    if (command)</span>
    {
<span style = "background-color:#fdd">      reader-&gt;AddObserver(itk::ProgressEvent(), command);</span>
    }

<span style = "background-color:#fdd">    if (preLoadedImageBlock.IsNull())</span>
    {
<span style = "background-color:#fdd">      reader-&gt;SetFileNames(imageBlocks.front());</span>

<span style = "background-color:#fdd">      reader-&gt;Update();</span>

<span style = "background-color:#fdd">      typename ImageType::Pointer readVolume = reader-&gt;GetOutput();</span>
      // if we detected that the images are from a tilted gantry acquisition, we need to push some pixels into the right
      // position
<span style = "background-color:#fdd">      if (correctTilt)</span>
      {
<span style = "background-color:#fdd">        readVolume = InPlaceFixUpTiltedGeometry(reader-&gt;GetOutput(), tiltInfo);</span>
      }

<span style = "background-color:#fdd">      unsigned int volume_count = imageBlocks.size();
      image-&gt;InitializeByItk(readVolume.GetPointer(), 1, volume_count);
      image-&gt;SetImportVolume(readVolume-&gt;GetBufferPointer(), 0u);</span>

<span style = "background-color:#fdd">      FixSpacingInformation(image, imageBlockDescriptor);
    }</span>
    else
    {
<span style = "background-color:#fdd">      StringContainer fakeList;
      fakeList.push_back(imageBlocks.front().front());
      reader-&gt;SetFileNames(fakeList); // only ONE first filename to get MetaDataDictionary</span>

<span style = "background-color:#fdd">      image = preLoadedImageBlock;
    }</span>

<span style = "background-color:#fdd">    gdcm::Scanner scanner;
    ScanForSliceInformation(imageBlockDescriptor.GetFilenames(), scanner);
    CopyMetaDataToImageProperties(imageBlocks, scanner.GetMappings(), io, imageBlockDescriptor, image);</span>

<span style = "background-color:#fdd">    MITK_DEBUG &lt;&lt; "Volume dimension: [" &lt;&lt; image-&gt;GetDimension(0) &lt;&lt; ", " &lt;&lt; image-&gt;GetDimension(1) &lt;&lt; ", "</span>
               &lt;&lt; image-&gt;GetDimension(2) &lt;&lt; ", " &lt;&lt; image-&gt;GetDimension(3) &lt;&lt; "]";

<span style = "background-color:#fdd">    MITK_DEBUG &lt;&lt; "Volume spacing: [" &lt;&lt; image-&gt;GetGeometry()-&gt;GetSpacing()[0] &lt;&lt; ", "</span>
               &lt;&lt; image-&gt;GetGeometry()-&gt;GetSpacing()[1] &lt;&lt; ", " &lt;&lt; image-&gt;GetGeometry()-&gt;GetSpacing()[2] &lt;&lt; "]";

<span style = "background-color:#fdd">    if (preLoadedImageBlock.IsNull())</span>
    {
<span style = "background-color:#fdd">      unsigned int act_volume = 1u;
      for (auto df_it = ++imageBlocks.begin(); df_it != imageBlocks.end(); ++df_it)</span>
      {
<span style = "background-color:#fdd">        reader-&gt;SetFileNames(*df_it);
        reader-&gt;Update();
        typename ImageType::Pointer readVolume = reader-&gt;GetOutput();</span>

<span style = "background-color:#fdd">        if (correctTilt)</span>
        {
<span style = "background-color:#fdd">          readVolume = InPlaceFixUpTiltedGeometry(reader-&gt;GetOutput(), tiltInfo);</span>
        }

<span style = "background-color:#fdd">        image-&gt;SetImportVolume(readVolume-&gt;GetBufferPointer(), act_volume++);
      }</span>
    }

<span style = "background-color:#fdd">    return image;
  }</span>

  template &lt;typename PixelType&gt;
  Image::Pointer DicomSeriesReader::LoadDICOMByITK(const StringContainer &amp;filenames,
                                                   bool correctTilt,
                                                   const GantryTiltInformation &amp;tiltInfo,
                                                   DcmIoType::Pointer &amp;io,
                                                   CallbackCommand *command,
                                                   Image::Pointer preLoadedImageBlock)
<span style = "background-color:#fdd">  {</span>
    /******** Normal Case, 3D (also for GDCM &lt; 2 usable) ***************/
<span style = "background-color:#fdd">    mitk::Image::Pointer image = mitk::Image::New();</span>

    typedef itk::Image&lt;PixelType, 3&gt; ImageType;
    typedef itk::ImageSeriesReader&lt;ImageType&gt; ReaderType;

<span style = "background-color:#fdd">    io = DcmIoType::New();
    typename ReaderType::Pointer reader = ReaderType::New();</span>

<span style = "background-color:#fdd">    reader-&gt;SetImageIO(io);
    reader-&gt;ReverseOrderOff();</span>

<span style = "background-color:#fdd">    if (command)</span>
    {
<span style = "background-color:#fdd">      reader-&gt;AddObserver(itk::ProgressEvent(), command);</span>
    }

<span style = "background-color:#fdd">    if (preLoadedImageBlock.IsNull())</span>
    {
<span style = "background-color:#fdd">      reader-&gt;SetFileNames(filenames);
      reader-&gt;Update();
      typename ImageType::Pointer readVolume = reader-&gt;GetOutput();</span>

      // if we detected that the images are from a tilted gantry acquisition, we need to push some pixels into the right
      // position
<span style = "background-color:#fdd">      if (correctTilt)</span>
      {
<span style = "background-color:#fdd">        readVolume = InPlaceFixUpTiltedGeometry(reader-&gt;GetOutput(), tiltInfo);</span>
      }

<span style = "background-color:#fdd">      image-&gt;InitializeByItk(readVolume.GetPointer());
      image-&gt;SetImportVolume(readVolume-&gt;GetBufferPointer());
    }</span>
    else
    {
<span style = "background-color:#fdd">      image = preLoadedImageBlock;
      StringContainer fakeList;
      fakeList.push_back(filenames.front());
      reader-&gt;SetFileNames(fakeList); // we always need to load at least one file to get the MetaDataDictionary
      reader-&gt;Update();
    }</span>

<span style = "background-color:#fdd">    MITK_DEBUG &lt;&lt; "Volume dimension: [" &lt;&lt; image-&gt;GetDimension(0) &lt;&lt; ", " &lt;&lt; image-&gt;GetDimension(1) &lt;&lt; ", "</span>
               &lt;&lt; image-&gt;GetDimension(2) &lt;&lt; "]";

<span style = "background-color:#fdd">    MITK_DEBUG &lt;&lt; "Volume spacing: [" &lt;&lt; image-&gt;GetGeometry()-&gt;GetSpacing()[0] &lt;&lt; ", "</span>
               &lt;&lt; image-&gt;GetGeometry()-&gt;GetSpacing()[1] &lt;&lt; ", " &lt;&lt; image-&gt;GetGeometry()-&gt;GetSpacing()[2] &lt;&lt; "]";

<span style = "background-color:#fdd">    return image;
  }</span>

  template &lt;typename ImageType&gt;
  typename ImageType::Pointer DicomSeriesReader::InPlaceFixUpTiltedGeometry(ImageType *input,
                                                                            const GantryTiltInformation &amp;tiltInfo)
<span style = "background-color:#fdd">  {</span>
    typedef itk::ResampleImageFilter&lt;ImageType, ImageType&gt; ResampleFilterType;
<span style = "background-color:#fdd">    typename ResampleFilterType::Pointer resampler = ResampleFilterType::New();
    resampler-&gt;SetInput(input);</span>

    /*
       Transform for a point is
        - transform from actual position to index coordinates
        - apply a shear that undoes the gantry tilt
        - transform back into world coordinates

       Anybody who does this in a simpler way: don't forget to write up how and why your solution works
    */
    typedef itk::ScalableAffineTransform&lt;double, ImageType::ImageDimension&gt; TransformType;
<span style = "background-color:#fdd">    typename TransformType::Pointer transformShear = TransformType::New();</span>

    /**
      - apply a shear and spacing correction to the image block that corrects the ITK reader's error
        - ITK ignores the shear and loads slices into an orthogonal volume
        - ITK calculates the spacing from the origin distance, which is more than the actual spacing with gantry tilt
      images
      - to undo the effect
        - we have calculated some information in tiltInfo:
          - the shift in Y direction that is added with each additional slice is the most important information
          - the Y-shift is calculated in mm world coordinates
        - we apply a shearing transformation to the ITK-read image volume
          - to do this locally,
            - we transform the image volume back to origin and "normal" orientation by applying the inverse of its
      transform
              (this brings us into the image's "index coordinate" system)
            - we apply a shear with the Y-shift factor put into a unit transform at row 1, col 2
            - we transform the image volume back to its actual position (from index to world coordinates)
        - we lastly apply modify the image spacing in z direction by replacing this number with the correctly calulcated
      inter-slice distance
    */

<span style = "background-color:#fdd">    ScalarType factor = tiltInfo.GetMatrixCoefficientForCorrectionInWorldCoordinates() / input-&gt;GetSpacing()[1];</span>
    // row 1, column 2 corrects shear in parallel to Y axis, proportional to distance in Z direction
<span style = "background-color:#fdd">    transformShear-&gt;Shear(1, 2, factor);</span>

<span style = "background-color:#fdd">    typename TransformType::Pointer imageIndexToWorld = TransformType::New();
    imageIndexToWorld-&gt;SetOffset(input-&gt;GetOrigin().GetVectorFromOrigin());</span>

<span style = "background-color:#fdd">    typename TransformType::MatrixType indexToWorldMatrix;
    indexToWorldMatrix = input-&gt;GetDirection();</span>

<span style = "background-color:#fdd">    typename ImageType::DirectionType scale;
    for (unsigned int i = 0; i &lt; ImageType::ImageDimension; i++)</span>
    {
<span style = "background-color:#fdd">      scale[i][i] = input-&gt;GetSpacing()[i];
    }
    indexToWorldMatrix *= scale;</span>

<span style = "background-color:#fdd">    imageIndexToWorld-&gt;SetMatrix(indexToWorldMatrix);</span>

<span style = "background-color:#fdd">    typename TransformType::Pointer imageWorldToIndex = TransformType::New();
    imageIndexToWorld-&gt;GetInverse(imageWorldToIndex);</span>

<span style = "background-color:#fdd">    typename TransformType::Pointer gantryTiltCorrection = TransformType::New();
    gantryTiltCorrection-&gt;Compose(imageWorldToIndex);
    gantryTiltCorrection-&gt;Compose(transformShear);
    gantryTiltCorrection-&gt;Compose(imageIndexToWorld);</span>

<span style = "background-color:#fdd">    resampler-&gt;SetTransform(gantryTiltCorrection);</span>

    typedef itk::LinearInterpolateImageFunction&lt;ImageType, double&gt; InterpolatorType;
<span style = "background-color:#fdd">    typename InterpolatorType::Pointer interpolator = InterpolatorType::New();
    resampler-&gt;SetInterpolator(interpolator);</span>
    /*
       This would be the right place to invent a meaningful value for positions outside of the image.
       For CT, HU -1000 might be meaningful, but a general solution seems not possible. Even for CT,
       -1000 would only look natural for many not all images.
    */

    // TODO use (0028,0120) Pixel Padding Value if present
<span style = "background-color:#fdd">    resampler-&gt;SetDefaultPixelValue(itk::NumericTraits&lt;typename ImageType::PixelType&gt;::min());</span>

    // adjust size in Y direction! (maybe just transform the outer last pixel to see how much space we would need

<span style = "background-color:#fdd">    resampler-&gt;SetOutputParametersFromImage(input); // we basically need the same image again, just sheared</span>

    // if tilt positive, then we need additional pixels BELOW origin, otherwise we need pixels behind the end of the
    // block

    // in any case we need more size to accomodate shifted slices
<span style = "background-color:#fdd">    typename ImageType::SizeType largerSize =</span>
      resampler-&gt;GetSize(); // now the resampler already holds the input image's size.
<span style = "background-color:#fdd">    largerSize[1] += static_cast&lt;typename ImageType::SizeType::SizeValueType&gt;(</span>
      tiltInfo.GetTiltCorrectedAdditionalSize() / input-&gt;GetSpacing()[1] + 2.0);
<span style = "background-color:#fdd">    resampler-&gt;SetSize(largerSize);</span>

    // in SOME cases this additional size is below/behind origin
<span style = "background-color:#fdd">    if (tiltInfo.GetMatrixCoefficientForCorrectionInWorldCoordinates() &gt; 0.0)</span>
    {
<span style = "background-color:#fdd">      typename ImageType::DirectionType imageDirection = input-&gt;GetDirection();
      Vector3D yDirection;
      yDirection[0] = imageDirection[0][1];
      yDirection[1] = imageDirection[1][1];
      yDirection[2] = imageDirection[2][1];
      yDirection.Normalize();</span>

      typename ImageType::PointType shiftedOrigin;
<span style = "background-color:#fdd">      shiftedOrigin = input-&gt;GetOrigin();</span>

      // add some pixels to make everything fit
<span style = "background-color:#fdd">      shiftedOrigin[0] -= yDirection[0] * (tiltInfo.GetTiltCorrectedAdditionalSize() + 1.0 * input-&gt;GetSpacing()[1]);
      shiftedOrigin[1] -= yDirection[1] * (tiltInfo.GetTiltCorrectedAdditionalSize() + 1.0 * input-&gt;GetSpacing()[1]);
      shiftedOrigin[2] -= yDirection[2] * (tiltInfo.GetTiltCorrectedAdditionalSize() + 1.0 * input-&gt;GetSpacing()[1]);</span>

<span style = "background-color:#fdd">      resampler-&gt;SetOutputOrigin(shiftedOrigin);</span>
    }

<span style = "background-color:#fdd">    resampler-&gt;Update();
    typename ImageType::Pointer result = resampler-&gt;GetOutput();</span>

    // ImageSeriesReader calculates z spacing as the distance between the first two origins.
    // This is not correct in case of gantry tilt, so we set our calculated spacing.
<span style = "background-color:#fdd">    typename ImageType::SpacingType correctedSpacing = result-&gt;GetSpacing();
    correctedSpacing[2] = tiltInfo.GetRealZSpacing();
    result-&gt;SetSpacing(correctedSpacing);</span>

<span style = "background-color:#fdd">    return result;
  }</span>
}

#endif</pre>
	</body>
</html>