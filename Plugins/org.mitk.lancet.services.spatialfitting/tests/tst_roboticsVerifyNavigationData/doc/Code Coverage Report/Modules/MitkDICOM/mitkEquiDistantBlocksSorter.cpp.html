<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkEquiDistantBlocksSorter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

//#define MBILOG_ENABLE_DEBUG

#include "mitkEquiDistantBlocksSorter.h"

mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::SliceGroupingAnalysisResult()
<span style = "background-color:#fdd">{
}</span>

mitk::DICOMDatasetList
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::GetBlockDatasets()
<span style = "background-color:#fdd">{
  return m_GroupedFiles;
}</span>

mitk::DICOMDatasetList
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::GetUnsortedDatasets()
<span style = "background-color:#fdd">{
  return m_UnsortedFiles;
}</span>

bool
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::ContainsGantryTilt()
<span style = "background-color:#fdd">{
  return m_TiltInfo.IsRegularGantryTilt();
}</span>

void
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::AddFileToSortedBlock(DICOMDatasetAccess* dataset)
<span style = "background-color:#fdd">{
  m_GroupedFiles.push_back( dataset );
}</span>

void
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::AddFileToUnsortedBlock(DICOMDatasetAccess* dataset)
<span style = "background-color:#fdd">{
  m_UnsortedFiles.push_back( dataset );
}</span>

void
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::AddFilesToUnsortedBlock(const DICOMDatasetList&amp; datasets)
<span style = "background-color:#fdd">{
  m_UnsortedFiles.insert( m_UnsortedFiles.end(), datasets.begin(), datasets.end() );
}</span>

void
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::SetFirstFilenameOfBlock(const std::string&amp; filename)
<span style = "background-color:#fdd">{
  m_FirstFilenameOfBlock = filename;
}</span>

std::string
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::GetFirstFilenameOfBlock() const
<span style = "background-color:#fdd">{
  return m_FirstFilenameOfBlock;
}</span>

void
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::SetLastFilenameOfBlock(const std::string&amp; filename)
<span style = "background-color:#fdd">{
  m_LastFilenameOfBlock = filename;
}</span>

std::string
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::GetLastFilenameOfBlock() const
<span style = "background-color:#fdd">{
  return m_LastFilenameOfBlock;
}</span>


void
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::FlagGantryTilt(const GantryTiltInformation&amp; tiltInfo)
<span style = "background-color:#fdd">{
  m_TiltInfo = tiltInfo;
}</span>

const mitk::GantryTiltInformation&amp;
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::GetTiltInfo() const
<span style = "background-color:#fdd">{
  return m_TiltInfo;
}</span>

void
mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
::UndoPrematureGrouping()
<span style = "background-color:#fdd">{
  assert( !m_GroupedFiles.empty() );
  m_UnsortedFiles.insert( m_UnsortedFiles.begin(), m_GroupedFiles.back() );
  m_GroupedFiles.pop_back();
  m_TiltInfo = GantryTiltInformation();
}</span>

// ------------------------ end helper class

mitk::EquiDistantBlocksSorter
::EquiDistantBlocksSorter()
<span style = "background-color:#dfd">:DICOMDatasetSorter()
,m_AcceptTilt(false)
,m_ToleratedOriginOffset(0.3)
,m_ToleratedOriginOffsetIsAbsolute(false)
,m_AcceptTwoSlicesGroups(true)
{
}</span>

mitk::EquiDistantBlocksSorter
::EquiDistantBlocksSorter(const EquiDistantBlocksSorter&amp; other )
<span style = "background-color:#fdd">:DICOMDatasetSorter(other)
,m_AcceptTilt(other.m_AcceptTilt)
,m_ToleratedOriginOffset(other.m_ToleratedOriginOffset)
,m_ToleratedOriginOffsetIsAbsolute(other.m_ToleratedOriginOffsetIsAbsolute)
,m_AcceptTwoSlicesGroups(other.m_AcceptTwoSlicesGroups)
{
}</span>

mitk::EquiDistantBlocksSorter
::~EquiDistantBlocksSorter()
<span style = "background-color:#dfd">{
}</span>

bool
mitk::EquiDistantBlocksSorter
::operator==(const DICOMDatasetSorter&amp; other) const
<span style = "background-color:#fdd">{
  if (const auto* otherSelf = dynamic_cast&lt;const EquiDistantBlocksSorter*&gt;(&amp;other))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_AcceptTilt == otherSelf-&gt;m_AcceptTilt</span>
        &amp;&amp; this-&gt;m_ToleratedOriginOffsetIsAbsolute == otherSelf-&gt;m_ToleratedOriginOffsetIsAbsolute
        &amp;&amp; this-&gt;m_AcceptTwoSlicesGroups == otherSelf-&gt;m_AcceptTwoSlicesGroups
        &amp;&amp; (fabs(this-&gt;m_ToleratedOriginOffset - otherSelf-&gt;m_ToleratedOriginOffset) &lt; eps);
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span>

void
mitk::EquiDistantBlocksSorter
::PrintConfiguration(std::ostream&amp; os, const std::string&amp; indent) const
<span style = "background-color:#fdd">{
  std::stringstream ts;
  if (!m_ToleratedOriginOffsetIsAbsolute)</span>
  {
<span style = "background-color:#fdd">    ts &lt;&lt; "adaptive";
  }</span>
  else
  {
<span style = "background-color:#fdd">    ts &lt;&lt; m_ToleratedOriginOffset &lt;&lt; "mm";</span>
  }

<span style = "background-color:#fdd">  os &lt;&lt; indent &lt;&lt; "Sort into blocks of equidistant, well-aligned (tolerance "</span>
     &lt;&lt; ts.str() &lt;&lt; ") slices "
     &lt;&lt; (m_AcceptTilt ? "(accepting a gantry tilt)" : "")
     &lt;&lt; std::endl;
<span style = "background-color:#fdd">}</span>


void
mitk::EquiDistantBlocksSorter
::SetAcceptTilt(bool accept)
<span style = "background-color:#dfd">{
  m_AcceptTilt = accept;
}</span>


bool
mitk::EquiDistantBlocksSorter
::GetAcceptTilt() const
<span style = "background-color:#fdd">{
  return m_AcceptTilt;
}</span>

void
mitk::EquiDistantBlocksSorter
::SetAcceptTwoSlicesGroups(bool accept)
<span style = "background-color:#dfd">{
  m_AcceptTwoSlicesGroups = accept;
}</span>

bool
mitk::EquiDistantBlocksSorter
::GetAcceptTwoSlicesGroups() const
<span style = "background-color:#fdd">{
  return m_AcceptTwoSlicesGroups;
}</span>


mitk::EquiDistantBlocksSorter&amp;
mitk::EquiDistantBlocksSorter
::operator=(const EquiDistantBlocksSorter&amp; other)
<span style = "background-color:#fdd">{
  if (this != &amp;other)</span>
  {
<span style = "background-color:#fdd">    DICOMDatasetSorter::operator=(other);
    m_AcceptTilt = other.m_AcceptTilt;
    m_ToleratedOriginOffset = other.m_ToleratedOriginOffset;
    m_ToleratedOriginOffsetIsAbsolute = other.m_ToleratedOriginOffsetIsAbsolute;
    m_AcceptTwoSlicesGroups = other.m_AcceptTwoSlicesGroups;</span>
  }
<span style = "background-color:#fdd">  return *this;
}</span>

mitk::DICOMTagList
mitk::EquiDistantBlocksSorter
::GetTagsOfInterest()
<span style = "background-color:#fdd">{
  DICOMTagList tags;
  tags.push_back( DICOMTag(0x0020, 0x0032) ); // ImagePositionPatient
  tags.push_back( DICOMTag(0x0020, 0x0037) ); // ImageOrientationPatient
  tags.push_back( DICOMTag(0x0018, 0x1120) ); // GantryDetectorTilt</span>

<span style = "background-color:#fdd">  return tags;
}</span>

void
mitk::EquiDistantBlocksSorter
::Sort()
<span style = "background-color:#fdd">{
  DICOMDatasetList remainingInput = GetInput(); // copy</span>

  typedef std::list&lt;DICOMDatasetList&gt; OutputListType;
<span style = "background-color:#fdd">  OutputListType outputs;</span>

<span style = "background-color:#fdd">  m_SliceGroupingResults.clear();</span>

<span style = "background-color:#fdd">  while (!remainingInput.empty()) // repeat until all files are grouped somehow</span>
  {
<span style = "background-color:#fdd">    SliceGroupingAnalysisResult regularBlock = this-&gt;AnalyzeFileForITKImageSeriesReaderSpacingAssumption( remainingInput, m_AcceptTilt );</span>

#ifdef MBILOG_ENABLE_DEBUG
<span style = "background-color:#fdd">    DICOMDatasetList inBlock = regularBlock.GetBlockDatasets();
    DICOMDatasetList laterBlock = regularBlock.GetUnsortedDatasets();
    MITK_DEBUG &lt;&lt; "Result: sorted 3D group with " &lt;&lt; inBlock.size() &lt;&lt; " files";
    for (DICOMDatasetList::const_iterator diter = inBlock.cbegin(); diter != inBlock.cend(); ++diter)
      MITK_DEBUG &lt;&lt; "  IN  " &lt;&lt; (*diter)-&gt;GetFilenameIfAvailable();
    for (DICOMDatasetList::const_iterator diter = laterBlock.cbegin(); diter != laterBlock.cend(); ++diter)
      MITK_DEBUG &lt;&lt; " OUT  " &lt;&lt; (*diter)-&gt;GetFilenameIfAvailable();</span>
#endif // MBILOG_ENABLE_DEBUG

<span style = "background-color:#fdd">    outputs.push_back( regularBlock.GetBlockDatasets() );
    m_SliceGroupingResults.push_back( regularBlock );
    remainingInput = regularBlock.GetUnsortedDatasets();
  }</span>

<span style = "background-color:#fdd">  unsigned int numberOfOutputs = outputs.size();
  this-&gt;SetNumberOfOutputs(numberOfOutputs);</span>

<span style = "background-color:#fdd">  unsigned int outputIndex(0);
  for (auto oIter = outputs.cbegin();
       oIter != outputs.cend();
       ++outputIndex, ++oIter)</span>
  {
<span style = "background-color:#fdd">    this-&gt;SetOutput(outputIndex, *oIter);
  }
}</span>

void
mitk::EquiDistantBlocksSorter
::SetToleratedOriginOffsetToAdaptive(double fractionOfInterSliceDistance)
<span style = "background-color:#fdd">{
  m_ToleratedOriginOffset = fractionOfInterSliceDistance;
  m_ToleratedOriginOffsetIsAbsolute = false;</span>

<span style = "background-color:#fdd">  if (m_ToleratedOriginOffset &lt; 0.0)</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Call SetToleratedOriginOffsetToAdaptive() only with positive numbers between 0.0 and 1.0, read documentation!";</span>
  }

<span style = "background-color:#fdd">  if (m_ToleratedOriginOffset &gt; 0.5)</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "EquiDistantBlocksSorter is now accepting large errors, take care of measurements, they could appear at unprecise locations!";</span>
  }
<span style = "background-color:#fdd">}</span>

void
mitk::EquiDistantBlocksSorter
::SetToleratedOriginOffset(double millimeters)
<span style = "background-color:#dfd">{
  m_ToleratedOriginOffset = millimeters;
  m_ToleratedOriginOffsetIsAbsolute = true;
  if (m_ToleratedOriginOffset &lt; 0.0)</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Negative tolerance set to SetToleratedOriginOffset()!";</span>
  }
<span style = "background-color:#dfd">}</span>

double
mitk::EquiDistantBlocksSorter
::GetToleratedOriginOffset() const
<span style = "background-color:#fdd">{
  return m_ToleratedOriginOffset;
}</span>

bool
mitk::EquiDistantBlocksSorter
::IsToleratedOriginOffsetAbsolute() const
<span style = "background-color:#fdd">{
  return m_ToleratedOriginOffsetIsAbsolute;
}</span>


std::string
mitk::EquiDistantBlocksSorter
::ConstCharStarToString(const char* s)
<span style = "background-color:#fdd">{
  return s ?  std::string(s) : std::string();
}</span>

mitk::EquiDistantBlocksSorter::SliceGroupingAnalysisResult
mitk::EquiDistantBlocksSorter
::AnalyzeFileForITKImageSeriesReaderSpacingAssumption(
  const DICOMDatasetList&amp; datasets,
  bool groupImagesWithGantryTilt)
<span style = "background-color:#fdd">{</span>
  // result.first = files that fit ITK's assumption
  // result.second = files that do not fit, should be run through AnalyzeFileForITKImageSeriesReaderSpacingAssumption() again
<span style = "background-color:#fdd">  SliceGroupingAnalysisResult result;</span>

<span style = "background-color:#fdd">  const DICOMTag tagImagePositionPatient = DICOMTag(0x0020,0x0032); // Image Position (Patient)
  const DICOMTag    tagImageOrientation = DICOMTag(0x0020, 0x0037); // Image Orientation</span>

<span style = "background-color:#fdd">  Vector3D fromFirstToSecondOrigin; fromFirstToSecondOrigin.Fill(0.0);
  bool fromFirstToSecondOriginInitialized(false);
  Point3D thisOrigin;
  thisOrigin.Fill(0.0f);
  Point3D lastOrigin;
  lastOrigin.Fill(0.0f);
  Point3D lastDifferentOrigin;
  lastDifferentOrigin.Fill(0.0f);</span>

<span style = "background-color:#fdd">  bool lastOriginInitialized(false);</span>

<span style = "background-color:#fdd">  MITK_DEBUG &lt;&lt; "--------------------------------------------------------------------------------";
  MITK_DEBUG &lt;&lt; "Analyzing " &lt;&lt; datasets.size() &lt;&lt; " files for z-spacing assumption of ITK's ImageSeriesReader (group tilted: " &lt;&lt; groupImagesWithGantryTilt &lt;&lt; ")";
  unsigned int fileIndex(0);
  double toleratedOriginError(0.005); // default: max. 1/10mm error when measurement crosses 20 slices in z direction (too strict? we don't know better)
  for (auto dsIter = datasets.cbegin();
       dsIter != datasets.cend();
       ++dsIter, ++fileIndex)</span>
  {
<span style = "background-color:#fdd">    bool fileFitsIntoPattern(false);
    std::string thisOriginString;</span>
    // Read tag value into point3D. PLEASE replace this by appropriate GDCM code if you figure out how to do that
<span style = "background-color:#fdd">    thisOriginString = (*dsIter)-&gt;GetTagValueAsString(tagImagePositionPatient).value;</span>

<span style = "background-color:#fdd">    if (thisOriginString.empty())</span>
    {
      // don't let such files be in a common group. Everything without position information will be loaded as a single slice:
      // with standard DICOM files this can happen to: CR, DX, SC
<span style = "background-color:#fdd">      MITK_DEBUG &lt;&lt; "    ==&gt; Sort away " &lt;&lt; *dsIter &lt;&lt; " for later analysis (no position information)"; // we already have one occupying this position</span>

<span style = "background-color:#fdd">      if ( result.GetBlockDatasets().empty() ) // nothing WITH position information yet</span>
      {
        // ==&gt; this is a group of its own, stop processing, come back later
<span style = "background-color:#fdd">        result.AddFileToSortedBlock( *dsIter );</span>

<span style = "background-color:#fdd">        DICOMDatasetList remainingFiles;
        remainingFiles.insert( remainingFiles.end(), dsIter+1, datasets.end() );
        result.AddFilesToUnsortedBlock( remainingFiles );</span>

<span style = "background-color:#fdd">        fileFitsIntoPattern = false;
        break; // no files anymore
      }</span>
      else
      {
        // ==&gt; this does not match, consider later
<span style = "background-color:#fdd">        result.AddFileToUnsortedBlock( *dsIter ); // sort away for further analysis
        fileFitsIntoPattern = false;
        continue; // next file</span>
      }
    }

<span style = "background-color:#fdd">    bool ignoredConversionError(-42); // hard to get here, no graceful way to react
    thisOrigin = DICOMStringToPoint3D( thisOriginString, ignoredConversionError );</span>

<span style = "background-color:#fdd">    MITK_DEBUG &lt;&lt; "  " &lt;&lt; fileIndex &lt;&lt; " " &lt;&lt; (*dsIter)-&gt;GetFilenameIfAvailable()</span>
                       &lt;&lt; " at "
                       /* &lt;&lt; thisOriginString */ &lt;&lt; "(" &lt;&lt; thisOrigin[0] &lt;&lt; "," &lt;&lt; thisOrigin[1] &lt;&lt; "," &lt;&lt; thisOrigin[2] &lt;&lt; ")";

<span style = "background-color:#fdd">    if ( lastOriginInitialized &amp;&amp; (thisOrigin == lastOrigin) )</span>
    {
<span style = "background-color:#fdd">      MITK_DEBUG &lt;&lt; "    ==&gt; Sort away " &lt;&lt; *dsIter &lt;&lt; " for separate time step"; // we already have one occupying this position
      result.AddFileToUnsortedBlock( *dsIter ); // sort away for further analysis
      fileFitsIntoPattern = false;
    }</span>
    else
    {
<span style = "background-color:#fdd">      if (!fromFirstToSecondOriginInitialized &amp;&amp; lastOriginInitialized) // calculate vector as soon as possible when we get a new position</span>
      {
<span style = "background-color:#fdd">        fromFirstToSecondOrigin = thisOrigin - lastDifferentOrigin;
        fromFirstToSecondOriginInitialized = true;</span>

        // classic mode without tolerance!
<span style = "background-color:#fdd">        if (!m_ToleratedOriginOffsetIsAbsolute)</span>
        {
<span style = "background-color:#fdd">          MITK_DEBUG &lt;&lt; "Distance of two slices: " &lt;&lt; fromFirstToSecondOrigin.GetNorm() &lt;&lt; "mm";
          toleratedOriginError =</span>
            fromFirstToSecondOrigin.GetNorm() * 0.3; // a third of the slice distance
          //  (less than half, which would mean that a slice is displayed where another slice should actually be)
<span style = "background-color:#fdd">        }</span>
        else
        {
<span style = "background-color:#fdd">          toleratedOriginError = m_ToleratedOriginOffset;</span>
        }
<span style = "background-color:#fdd">        MITK_DEBUG &lt;&lt; "Accepting errors in actual versus expected origin up to " &lt;&lt; toleratedOriginError &lt;&lt; "mm";</span>

        // Here we calculate if this slice and the previous one are well aligned,
        // i.e. we test if the previous origin is on a line through the current
        // origin, directed into the normal direction of the current slice.

        // If this is NOT the case, then we have a data set with a TILTED GANTRY geometry,
        // which cannot be simply loaded into a single mitk::Image at the moment.
        // For this case, we flag this finding in the result and DicomSeriesReader
        // can correct for that later.

<span style = "background-color:#fdd">        Vector3D right; right.Fill(0.0);
        Vector3D up; right.Fill(0.0); // might be down as well, but it is just a name at this point
        std::string orientationValue = (*dsIter)-&gt;GetTagValueAsString( tagImageOrientation ).value;
        DICOMStringToOrientationVectors( orientationValue, right, up, ignoredConversionError );</span>

<span style = "background-color:#fdd">        GantryTiltInformation tiltInfo( lastDifferentOrigin, thisOrigin, right, up, 1 );</span>

<span style = "background-color:#fdd">        if ( tiltInfo.IsSheared() )</span>
        {
          /* optimistic approach, accepting gantry tilt: save file for later, check all further files */

          // at this point we have TWO slices analyzed! if they are the only two files, we still split, because there is no third to verify our tilting assumption.
          // later with a third being available, we must check if the initial tilting vector is still valid. if yes, continue.
          // if NO, we need to split the already sorted part (result.first) and the currently analyzed file (*dsIter)

          // tell apart gantry tilt from overall skewedness
          // sort out irregularly sheared slices, that IS NOT tilting

<span style = "background-color:#fdd">          if ( groupImagesWithGantryTilt &amp;&amp; tiltInfo.IsRegularGantryTilt() )</span>
          {
<span style = "background-color:#fdd">            assert(!datasets.empty());</span>

<span style = "background-color:#fdd">            result.FlagGantryTilt(tiltInfo);
            result.AddFileToSortedBlock( *dsIter ); // this file is good for current block
            result.SetFirstFilenameOfBlock( datasets.front()-&gt;GetFilenameIfAvailable() );
            result.SetLastFilenameOfBlock( datasets.back()-&gt;GetFilenameIfAvailable() );
            fileFitsIntoPattern = true;
          }</span>
          else // caller does not want tilt compensation OR shearing is more complicated than tilt
          {
<span style = "background-color:#fdd">            result.AddFileToUnsortedBlock( *dsIter ); // sort away for further analysis
            fileFitsIntoPattern = false;</span>
          }
<span style = "background-color:#fdd">        }</span>
        else // not sheared
        {
<span style = "background-color:#fdd">          result.AddFileToSortedBlock( *dsIter ); // this file is good for current block
          fileFitsIntoPattern = true;</span>
        }
<span style = "background-color:#fdd">      }
      else if (fromFirstToSecondOriginInitialized) // we already know the offset between slices</span>
      {
<span style = "background-color:#fdd">        Point3D assumedOrigin = lastDifferentOrigin + fromFirstToSecondOrigin;</span>

<span style = "background-color:#fdd">        Vector3D originError = assumedOrigin - thisOrigin;
        double norm = originError.GetNorm();</span>

<span style = "background-color:#fdd">        if (norm &gt; toleratedOriginError)</span>
        {
<span style = "background-color:#fdd">          MITK_DEBUG &lt;&lt; "  File does not fit into the inter-slice distance pattern (diff = "</span>
                               &lt;&lt; norm &lt;&lt; ", allowed "
                               &lt;&lt; toleratedOriginError &lt;&lt; ").";
<span style = "background-color:#fdd">          MITK_DEBUG &lt;&lt; "  Expected position (" &lt;&lt; assumedOrigin[0] &lt;&lt; ","</span>
                                            &lt;&lt; assumedOrigin[1] &lt;&lt; ","
                                            &lt;&lt; assumedOrigin[2] &lt;&lt; "), got position ("
                                            &lt;&lt; thisOrigin[0] &lt;&lt; ","
                                            &lt;&lt; thisOrigin[1] &lt;&lt; ","
                                            &lt;&lt; thisOrigin[2] &lt;&lt; ")";
<span style = "background-color:#fdd">          MITK_DEBUG  &lt;&lt; "    ==&gt; Sort away " &lt;&lt; *dsIter &lt;&lt; " for later analysis";</span>

          // At this point we know we deviated from the expectation of ITK's ImageSeriesReader
          // We split the input file list at this point, i.e. all files up to this one (excluding it)
          // are returned as group 1, the remaining files (including the faulty one) are group 2

          /* Optimistic approach: check if any of the remaining slices fits in */
<span style = "background-color:#fdd">          result.AddFileToUnsortedBlock( *dsIter ); // sort away for further analysis
          fileFitsIntoPattern = false;
        }</span>
        else
        {
<span style = "background-color:#fdd">          result.AddFileToSortedBlock( *dsIter ); // this file is good for current block
          fileFitsIntoPattern = true;</span>
        }
<span style = "background-color:#fdd">      }</span>
      else // this should be the very first slice
      {
<span style = "background-color:#fdd">        result.AddFileToSortedBlock( *dsIter ); // this file is good for current block
        fileFitsIntoPattern = true;</span>
      }
    }

    // record current origin for reference in later iterations
<span style = "background-color:#fdd">    if ( !lastOriginInitialized || ( fileFitsIntoPattern &amp;&amp; (thisOrigin != lastOrigin) ) )</span>
    {
<span style = "background-color:#fdd">      lastDifferentOrigin = thisOrigin;</span>
    }

<span style = "background-color:#fdd">    lastOrigin = thisOrigin;
    lastOriginInitialized = true;
  }</span>

<span style = "background-color:#fdd">  if ( result.ContainsGantryTilt() )</span>
  {
    // check here how many files were grouped.
    // IF it was only two files AND we assume tiltedness (e.g. save "distance")
    // THEN we would want to also split the two previous files (simple) because
    // we don't have any reason to assume they belong together

    // Above behavior can be configured via m_AcceptTwoSlicesGroups, the default being "do accept"
<span style = "background-color:#fdd">    if ( result.GetBlockDatasets().size() == 2 &amp;&amp; !m_AcceptTwoSlicesGroups )</span>
    {
<span style = "background-color:#fdd">      result.UndoPrematureGrouping();</span>
    }
  }

  // update tilt info to get maximum precision
  // earlier, tilt was only calculated from first and second slice.
  // now that we know the whole range, we can re-calculate using the very first and last slice
<span style = "background-color:#fdd">  if ( result.ContainsGantryTilt() &amp;&amp; result.GetBlockDatasets().size() &gt; 1 )</span>
  {
    try
    {
<span style = "background-color:#fdd">      DICOMDatasetList datasets = result.GetBlockDatasets();
      DICOMDatasetAccess* firstDataset = datasets.front();
      DICOMDatasetAccess* lastDataset = datasets.back();
      unsigned int numberOfSlicesApart = datasets.size() - 1;</span>

<span style = "background-color:#fdd">      std::string orientationString = firstDataset-&gt;GetTagValueAsString( tagImageOrientation ).value;
      std::string firstOriginString = firstDataset-&gt;GetTagValueAsString( tagImagePositionPatient ).value;
      std::string lastOriginString = lastDataset-&gt;GetTagValueAsString( tagImagePositionPatient ).value;</span>

<span style = "background-color:#fdd">      result.FlagGantryTilt( GantryTiltInformation::MakeFromTagValues( firstOriginString, lastOriginString, orientationString, numberOfSlicesApart ));
    }</span>
    catch (...)
<span style = "background-color:#fdd">    {</span>
      // just do not flag anything, we are ok
<span style = "background-color:#fdd">    }</span>
  }

<span style = "background-color:#fdd">  return result;
}</span></pre>
	</body>
</html>