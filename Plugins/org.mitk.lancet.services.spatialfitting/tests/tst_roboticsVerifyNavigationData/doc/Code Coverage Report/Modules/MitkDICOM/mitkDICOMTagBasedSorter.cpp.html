<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDICOMTagBasedSorter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkDICOMTagBasedSorter.h"

#include &lt;algorithm&gt;
#include &lt;iomanip&gt;

mitk::DICOMTagBasedSorter::CutDecimalPlaces
::CutDecimalPlaces(unsigned int precision)
<span style = "background-color:#dfd">:m_Precision(precision)
{
}</span>

mitk::DICOMTagBasedSorter::CutDecimalPlaces
::CutDecimalPlaces(const CutDecimalPlaces&amp; other)
<span style = "background-color:#fdd">:m_Precision(other.m_Precision)
{
}</span>

std::string
mitk::DICOMTagBasedSorter::CutDecimalPlaces
::operator()(const std::string&amp; input) const
<span style = "background-color:#fdd">{</span>
  // be a bit tolerant for tags such as image orientation orienatation, let only the first few digits matter (http://bugs.mitk.org/show_bug.cgi?id=12263)
  // iterate all fields, convert each to a number, cut this number as configured, then return a concatenated string with all cut-off numbers
<span style = "background-color:#fdd">  std::ostringstream resultString;
  resultString.str(std::string());
  resultString.clear();
  resultString.setf(std::ios::fixed, std::ios::floatfield);
  resultString.precision(m_Precision);</span>

<span style = "background-color:#fdd">  std::stringstream ss(input);
  ss.str(input);
  ss.clear();
  std::string item;
  double number(0);
  std::istringstream converter(item);
  while (std::getline(ss, item, '\\'))</span>
  {
<span style = "background-color:#fdd">    converter.str(item);
    converter.clear();
    if (converter &gt;&gt; number &amp;&amp; converter.eof())</span>
    {
      // converted to double
<span style = "background-color:#fdd">      resultString &lt;&lt; number;
    }</span>
    else
    {
      // did not convert to double
<span style = "background-color:#fdd">      resultString &lt;&lt; item; // just paste the unmodified string</span>
    }

<span style = "background-color:#fdd">    if (!ss.eof())</span>
    {
<span style = "background-color:#fdd">      resultString &lt;&lt; "\\";</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return resultString.str();
}</span>

mitk::DICOMTagBasedSorter::TagValueProcessor*
mitk::DICOMTagBasedSorter::CutDecimalPlaces
::Clone() const
<span style = "background-color:#fdd">{
  return new CutDecimalPlaces(*this);
}</span>


unsigned int
mitk::DICOMTagBasedSorter::CutDecimalPlaces
::GetPrecision() const
<span style = "background-color:#fdd">{
  return m_Precision;
}</span>

mitk::DICOMTagBasedSorter
::DICOMTagBasedSorter()
<span style = "background-color:#dfd">:DICOMDatasetSorter()
,m_StrictSorting(m_DefaultStrictSorting)
,m_ExpectDistanceOne(m_DefaultExpectDistanceOne)
{
}</span>

mitk::DICOMTagBasedSorter
::~DICOMTagBasedSorter()
<span style = "background-color:#dfd">{
  for(auto ti = m_TagValueProcessor.cbegin();
      ti != m_TagValueProcessor.cend();
      ++ti)</span>
  {
<span style = "background-color:#dfd">    delete ti-&gt;second;
  }
}</span>

mitk::DICOMTagBasedSorter
::DICOMTagBasedSorter(const DICOMTagBasedSorter&amp; other )
<span style = "background-color:#fdd">:DICOMDatasetSorter(other)
,m_DistinguishingTags( other.m_DistinguishingTags )
,m_SortCriterion( other.m_SortCriterion )
,m_StrictSorting( other.m_StrictSorting )
,m_ExpectDistanceOne( other.m_ExpectDistanceOne )
{
  for(auto ti = other.m_TagValueProcessor.cbegin();
      ti != other.m_TagValueProcessor.cend();
      ++ti)</span>
  {
<span style = "background-color:#fdd">    m_TagValueProcessor[ti-&gt;first] = ti-&gt;second-&gt;Clone();
  }
}</span>

mitk::DICOMTagBasedSorter&amp;
mitk::DICOMTagBasedSorter
::operator=(const DICOMTagBasedSorter&amp; other)
<span style = "background-color:#fdd">{
  if (this != &amp;other)</span>
  {
<span style = "background-color:#fdd">    DICOMDatasetSorter::operator=(other);
    m_DistinguishingTags = other.m_DistinguishingTags;
    m_SortCriterion = other.m_SortCriterion;
    m_StrictSorting = other.m_StrictSorting;
    m_ExpectDistanceOne = other.m_ExpectDistanceOne;</span>

<span style = "background-color:#fdd">    for(auto ti = other.m_TagValueProcessor.cbegin();
        ti != other.m_TagValueProcessor.cend();
        ++ti)</span>
    {
<span style = "background-color:#fdd">      m_TagValueProcessor[ti-&gt;first] = ti-&gt;second-&gt;Clone();
    }</span>
  }
<span style = "background-color:#fdd">  return *this;
}</span>

bool
mitk::DICOMTagBasedSorter
::operator==(const DICOMDatasetSorter&amp; other) const
<span style = "background-color:#fdd">{
  if (const auto* otherSelf = dynamic_cast&lt;const DICOMTagBasedSorter*&gt;(&amp;other))</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;m_StrictSorting != otherSelf-&gt;m_StrictSorting) return false;
    if (this-&gt;m_ExpectDistanceOne != otherSelf-&gt;m_ExpectDistanceOne) return false;</span>

<span style = "background-color:#fdd">    bool allTagsPresentAndEqual(true);
    if (this-&gt;m_DistinguishingTags.size() != otherSelf-&gt;m_DistinguishingTags.size())
      return false;</span>

<span style = "background-color:#fdd">    for (auto myTag = this-&gt;m_DistinguishingTags.cbegin();
        myTag != this-&gt;m_DistinguishingTags.cend();
        ++myTag)</span>
    {
<span style = "background-color:#fdd">      allTagsPresentAndEqual &amp;= (std::find( otherSelf-&gt;m_DistinguishingTags.cbegin(), otherSelf-&gt;m_DistinguishingTags.cend(), *myTag )</span>
                                 != otherSelf-&gt;m_DistinguishingTags.cend()); // other contains this tags
                                             // since size is equal, we don't need to check the inverse
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    if (!allTagsPresentAndEqual) return false;</span>

<span style = "background-color:#fdd">    if (this-&gt;m_SortCriterion.IsNotNull() &amp;&amp; otherSelf-&gt;m_SortCriterion.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      return *(this-&gt;m_SortCriterion) == *(otherSelf-&gt;m_SortCriterion);
    }</span>
    else
    {
<span style = "background-color:#fdd">      return this-&gt;m_SortCriterion.IsNull() &amp;&amp; otherSelf-&gt;m_SortCriterion.IsNull();</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span>

void
mitk::DICOMTagBasedSorter
::PrintConfiguration(std::ostream&amp; os, const std::string&amp; indent) const
<span style = "background-color:#fdd">{
  os &lt;&lt; indent &lt;&lt; "Tag based sorting "</span>
     &lt;&lt; "(strict=" &lt;&lt; (m_StrictSorting?"true":"false")
     &lt;&lt; ", expectDistanceOne=" &lt;&lt; (m_ExpectDistanceOne?"true":"false") &lt;&lt; "):"
     &lt;&lt; std::endl;

<span style = "background-color:#fdd">  for (auto tagIter = m_DistinguishingTags.begin();
       tagIter != m_DistinguishingTags.end();
       ++tagIter)</span>
  {
<span style = "background-color:#fdd">    os &lt;&lt; indent &lt;&lt; "  Split on ";
    tagIter-&gt;Print(os);
    os &lt;&lt; std::endl;
  }</span>

<span style = "background-color:#fdd">  DICOMSortCriterion::ConstPointer crit = m_SortCriterion.GetPointer();
  while (crit.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    os &lt;&lt; indent &lt;&lt; "   Sort by ";
    crit-&gt;Print(os);
    os &lt;&lt; std::endl;
    crit = crit-&gt;GetSecondaryCriterion();
  }
}</span>

void
mitk::DICOMTagBasedSorter
::SetStrictSorting(bool strict)
<span style = "background-color:#dfd">{
  m_StrictSorting = strict;
}</span>

bool
mitk::DICOMTagBasedSorter
::GetStrictSorting() const
<span style = "background-color:#fdd">{
  return m_StrictSorting;
}</span>

void
mitk::DICOMTagBasedSorter
::SetExpectDistanceOne(bool strict)
<span style = "background-color:#dfd">{
  m_ExpectDistanceOne = strict;
}</span>

bool
mitk::DICOMTagBasedSorter
::GetExpectDistanceOne() const
<span style = "background-color:#fdd">{
  return m_ExpectDistanceOne;
}</span>


mitk::DICOMTagList
mitk::DICOMTagBasedSorter
::GetTagsOfInterest()
<span style = "background-color:#fdd">{
  DICOMTagList allTags = m_DistinguishingTags;</span>

<span style = "background-color:#fdd">  if (m_SortCriterion.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    const DICOMTagList sortingRelevantTags = m_SortCriterion-&gt;GetAllTagsOfInterest();
    allTags.insert( allTags.end(), sortingRelevantTags.cbegin(), sortingRelevantTags.cend() ); // append
  }</span>

<span style = "background-color:#fdd">  return allTags;
}</span>

mitk::DICOMTagList
mitk::DICOMTagBasedSorter
::GetDistinguishingTags() const
<span style = "background-color:#fdd">{
  return m_DistinguishingTags;
}</span>

const mitk::DICOMTagBasedSorter::TagValueProcessor*
mitk::DICOMTagBasedSorter
::GetTagValueProcessorForDistinguishingTag(const DICOMTag&amp; tag) const
<span style = "background-color:#fdd">{
  auto loc = m_TagValueProcessor.find(tag);
  if (loc != m_TagValueProcessor.cend())</span>
  {
<span style = "background-color:#fdd">    return loc-&gt;second;
  }</span>
  else
  {
<span style = "background-color:#fdd">    return nullptr;</span>
  }
<span style = "background-color:#fdd">}</span>

void
mitk::DICOMTagBasedSorter
::AddDistinguishingTag( const DICOMTag&amp; tag, TagValueProcessor* tagValueProcessor )
<span style = "background-color:#dfd">{
  m_DistinguishingTags.push_back(tag);
  m_TagValueProcessor[tag] = tagValueProcessor;
}</span>

void
mitk::DICOMTagBasedSorter
::SetSortCriterion( DICOMSortCriterion::ConstPointer criterion )
<span style = "background-color:#dfd">{
  m_SortCriterion = criterion;
}</span>

mitk::DICOMSortCriterion::ConstPointer
mitk::DICOMTagBasedSorter
::GetSortCriterion() const
<span style = "background-color:#fdd">{
  return m_SortCriterion;
}</span>

void
mitk::DICOMTagBasedSorter
::Sort()
<span style = "background-color:#fdd">{</span>
  // 1. split
  // 2. sort each group
<span style = "background-color:#fdd">  GroupIDToListType groups = this-&gt;SplitInputGroups();
  GroupIDToListType&amp; sortedGroups = this-&gt;SortGroups( groups );</span>

  // 3. define output
<span style = "background-color:#fdd">  this-&gt;SetNumberOfOutputs(sortedGroups.size());
  unsigned int outputIndex(0);
  for (auto groupIter = sortedGroups.cbegin();
       groupIter != sortedGroups.cend();
       ++outputIndex, ++groupIter)</span>
  {
<span style = "background-color:#fdd">    this-&gt;SetOutput(outputIndex, groupIter-&gt;second);
  }
}</span>

std::string
mitk::DICOMTagBasedSorter
::BuildGroupID( DICOMDatasetAccess* dataset )
<span style = "background-color:#fdd">{</span>
  // just concatenate all tag values
<span style = "background-color:#fdd">  assert(dataset);
  std::stringstream groupID;
  groupID &lt;&lt; "g";
  for (auto tagIter = m_DistinguishingTags.cbegin();
       tagIter != m_DistinguishingTags.cend();
       ++tagIter)</span>
  {
<span style = "background-color:#fdd">    groupID &lt;&lt; tagIter-&gt;GetGroup() &lt;&lt; tagIter-&gt;GetElement(); // make group/element part of the id to cover empty tags
    DICOMDatasetFinding rawTagValue = dataset-&gt;GetTagValueAsString(*tagIter);
    std::string processedTagValue;
    if ( m_TagValueProcessor[*tagIter] != nullptr &amp;&amp; rawTagValue.isValid)</span>
    {
<span style = "background-color:#fdd">      processedTagValue = (*m_TagValueProcessor[*tagIter])(rawTagValue.value);
    }</span>
    else
    {
<span style = "background-color:#fdd">      processedTagValue = rawTagValue.value;</span>
    }
<span style = "background-color:#fdd">    groupID &lt;&lt; processedTagValue;
  }</span>
  // shorten ID?
<span style = "background-color:#fdd">  return groupID.str();
}</span>

mitk::DICOMTagBasedSorter::GroupIDToListType
mitk::DICOMTagBasedSorter
::SplitInputGroups()
<span style = "background-color:#fdd">{
  DICOMDatasetList input = GetInput(); // copy</span>

<span style = "background-color:#fdd">  GroupIDToListType listForGroupID;</span>

<span style = "background-color:#fdd">  for (auto dsIter = input.cbegin();
       dsIter != input.cend();
       ++dsIter)</span>
  {
<span style = "background-color:#fdd">    DICOMDatasetAccess* dataset = *dsIter;
    assert(dataset);</span>

<span style = "background-color:#fdd">    std::string groupID = this-&gt;BuildGroupID( dataset );
    MITK_DEBUG &lt;&lt; "Group ID for for " &lt;&lt; dataset-&gt;GetFilenameIfAvailable() &lt;&lt; ": " &lt;&lt; groupID;
    listForGroupID[groupID].push_back(dataset);
  }</span>

<span style = "background-color:#fdd">  MITK_DEBUG &lt;&lt; "After tag based splitting: " &lt;&lt; listForGroupID.size() &lt;&lt; " groups";</span>

<span style = "background-color:#fdd">  return listForGroupID;
}</span>

mitk::DICOMTagBasedSorter::GroupIDToListType&amp;
mitk::DICOMTagBasedSorter
::SortGroups(GroupIDToListType&amp; groups)
<span style = "background-color:#fdd">{
  if (m_SortCriterion.IsNotNull())</span>
  {
    /*
       Three steps here:
        1. sort within each group
           - this may result in orders such as 1 2 3 4 6 7 8 10 12 13 14
        2. create new groups by enforcing consecutive order within each group
           - resorts above example like 1 2 3 4  ;  6 7 8  ;  10  ;  12 13 14
        3. sort all of the groups (not WITHIN each group) by their first frame
           - if earlier "distinguish" steps created groups like 6 7 8  ;  1 2 3 4  ; 10,
             then this step would sort them like 1 2 3 4  ;  6 7 8  ;  10
    */

    // Step 1: sort within the groups
    // for each output
    //   sort by all configured tags, use secondary tags when equal or empty
    //   make configurable:
    //    - sorting order (ascending, descending)
    //    - sort numerically
    //    - ... ?
<span style = "background-color:#fdd">    unsigned int groupIndex(0);
    for (auto gIter = groups.begin();
         gIter != groups.end();
         ++groupIndex, ++gIter)</span>
    {
<span style = "background-color:#fdd">      DICOMDatasetList&amp; dsList = gIter-&gt;second;</span>

#ifdef MBILOG_ENABLE_DEBUG
<span style = "background-color:#fdd">      MITK_DEBUG &lt;&lt; "   --------------------------------------------------------------------------------";
      MITK_DEBUG &lt;&lt; "   DICOMTagBasedSorter before sorting group : " &lt;&lt; groupIndex;
      for (auto oi = dsList.begin();
           oi != dsList.cend();
           ++oi)</span>
      {
<span style = "background-color:#fdd">        MITK_DEBUG &lt;&lt; "     INPUT     : " &lt;&lt; (*oi)-&gt;GetFilenameIfAvailable();
      }</span>
#endif // #ifdef MBILOG_ENABLE_DEBUG


<span style = "background-color:#fdd">      std::sort( dsList.begin(), dsList.end(), ParameterizedDatasetSort( m_SortCriterion ) );</span>

#ifdef MBILOG_ENABLE_DEBUG
<span style = "background-color:#fdd">      MITK_DEBUG &lt;&lt; "   --------------------------------------------------------------------------------";
      MITK_DEBUG &lt;&lt; "   DICOMTagBasedSorter after sorting group : " &lt;&lt; groupIndex;
      for (auto oi = dsList.cbegin();
           oi != dsList.cend();
           ++oi)</span>
      {
<span style = "background-color:#fdd">        MITK_DEBUG &lt;&lt; "     OUTPUT    : " &lt;&lt; (*oi)-&gt;GetFilenameIfAvailable();
      }
      MITK_DEBUG &lt;&lt; "   --------------------------------------------------------------------------------";</span>

#endif // MBILOG_ENABLE_DEBUG

<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    GroupIDToListType consecutiveGroups;
    if (m_StrictSorting)</span>
    {
      // Step 2: create new groups by enforcing consecutive order within each group
<span style = "background-color:#fdd">      unsigned int groupIndex(0);
      for (auto gIter = groups.begin();
           gIter != groups.end();
           ++gIter)</span>
      {
<span style = "background-color:#fdd">        std::stringstream groupKey;
        groupKey &lt;&lt; std::setfill('0') &lt;&lt; std::setw(6) &lt;&lt; groupIndex++;</span>

<span style = "background-color:#fdd">        DICOMDatasetList&amp; dsList = gIter-&gt;second;
        DICOMDatasetAccess* previousDS(nullptr);
        unsigned int dsIndex(0);
        double constantDistance(0.0);
        bool constantDistanceInitialized(false);
        for (auto dataset = dsList.cbegin();
             dataset != dsList.cend();
             ++dsIndex, ++dataset)</span>
        {
<span style = "background-color:#fdd">          if (dsIndex &gt;0) // ignore the first dataset, we cannot check any distances yet..</span>
          {
            // for the second and every following dataset:
            // let the sorting criterion calculate a "distance"
            // if the distance is not 1, split off a new group!
<span style = "background-color:#fdd">            const double currentDistance = m_SortCriterion-&gt;NumericDistance(previousDS, *dataset);
            if (constantDistanceInitialized)</span>
            {
<span style = "background-color:#fdd">              if (fabs(currentDistance - constantDistance) &lt; fabs(constantDistance * 0.01)) // ok, deviation of up to 1% of distance is tolerated</span>
              {
                // nothing to do, just ok
<span style = "background-color:#fdd">                MITK_DEBUG &lt;&lt; "Checking currentDistance==" &lt;&lt; currentDistance &lt;&lt; ": small enough";
              }</span>
              //else if (currentDistance &lt; mitk::eps) // close enough to 0
              else
              {
<span style = "background-color:#fdd">                MITK_DEBUG &lt;&lt; "Split consecutive group at index " &lt;&lt; dsIndex &lt;&lt; " (current distance " &lt;&lt; currentDistance &lt;&lt; ", constant distance " &lt;&lt; constantDistance &lt;&lt; ")";</span>
                // split! this is done by simply creating a new group (key)
<span style = "background-color:#fdd">                groupKey.str(std::string());
                groupKey.clear();
                groupKey &lt;&lt; std::setfill('0') &lt;&lt; std::setw(6) &lt;&lt; groupIndex++;</span>
              }
<span style = "background-color:#fdd">            }</span>
            else
            {
              // second slice: learn about the expected distance!

              // heuristic: if distance is an integer, we check for a special case:
              //            if the distance is integer and not 1/-1, then we assume
              //            a missing slice right after the first slice
              //            ==&gt; split off slices
              // in all other cases: second dataset at this position, no need to split already, we are still learning about the images

              // addition to the above: when sorting by imagepositions, a distance other than 1 between the first two slices is
              // not unusual, actually expected... then we should not split

<span style = "background-color:#fdd">              if (m_ExpectDistanceOne)</span>
              {
<span style = "background-color:#fdd">                if ((currentDistance - (int)currentDistance == 0.0) &amp;&amp; fabs(currentDistance) != 1.0)</span>
                  // exact comparison. An integer should not be expressed as 1.000000000000000000000000001!
                {
<span style = "background-color:#fdd">                  MITK_DEBUG &lt;&lt; "Split consecutive group at index " &lt;&lt; dsIndex &lt;&lt; " (special case: expected distance 1 exactly)";
                  groupKey.str(std::string());
                  groupKey.clear();
                  groupKey &lt;&lt; std::setfill('0') &lt;&lt; std::setw(6) &lt;&lt; groupIndex++;</span>
                }
              }

<span style = "background-color:#fdd">              MITK_DEBUG &lt;&lt; "Initialize strict distance to currentDistance=" &lt;&lt; currentDistance;</span>

<span style = "background-color:#fdd">              constantDistance = currentDistance;
              constantDistanceInitialized = true;</span>
            }
          }
<span style = "background-color:#fdd">          consecutiveGroups[groupKey.str()].push_back(*dataset);
          previousDS = *dataset;
        }
      }
    }</span>
    else
    {
<span style = "background-color:#fdd">      consecutiveGroups = groups;</span>
    }

    // Step 3: sort all of the groups (not WITHIN each group) by their first frame
    /*
      build a list-1 of datasets with the first dataset one of each group
      sort this list-1
      build a new result list-2:
       - iterate list-1, for each dataset
         - find the group that contains this dataset
         - add this group as the next element to list-2
      return list-2 as the sorted output
    */
<span style = "background-color:#fdd">    DICOMDatasetList firstSlices;
    for (auto gIter = consecutiveGroups.cbegin();
         gIter != consecutiveGroups.cend();
         ++gIter)</span>
    {
<span style = "background-color:#fdd">      assert(!gIter-&gt;second.empty());
      firstSlices.push_back(gIter-&gt;second.front());
    }</span>

<span style = "background-color:#fdd">    std::sort( firstSlices.begin(), firstSlices.end(), ParameterizedDatasetSort( m_SortCriterion ) );</span>

<span style = "background-color:#fdd">    GroupIDToListType sortedResultBlocks;
    unsigned int groupKeyValue(0);
    for (auto firstSlice = firstSlices.cbegin();
         firstSlice != firstSlices.cend();
         ++firstSlice)</span>
    {
<span style = "background-color:#fdd">      for (auto gIter = consecutiveGroups.cbegin();
           gIter != consecutiveGroups.cend();
           ++groupKeyValue, ++gIter)</span>
      {
<span style = "background-color:#fdd">        if (gIter-&gt;second.front() == *firstSlice)</span>
        {
<span style = "background-color:#fdd">          std::stringstream groupKey;
          groupKey &lt;&lt; std::setfill('0') &lt;&lt; std::setw(6) &lt;&lt; groupKeyValue; // try more than 999,999 groups and you are doomed (your application already is)
          sortedResultBlocks[groupKey.str()] = gIter-&gt;second;
        }
      }
    }</span>

<span style = "background-color:#fdd">    groups = sortedResultBlocks;
  }</span>

#ifdef MBILOG_ENABLE_DEBUG
<span style = "background-color:#fdd">  unsigned int groupIndex( 0 );
  for ( auto gIter = groups.begin(); gIter != groups.end(); ++groupIndex, ++gIter )</span>
  {
<span style = "background-color:#fdd">    DICOMDatasetList&amp; dsList = gIter-&gt;second;
    MITK_DEBUG &lt;&lt; "   --------------------------------------------------------------------------------";
    MITK_DEBUG &lt;&lt; "   DICOMTagBasedSorter after sorting group : " &lt;&lt; groupIndex;
    for ( auto oi = dsList.begin(); oi != dsList.end(); ++oi )</span>
    {
<span style = "background-color:#fdd">      MITK_DEBUG &lt;&lt; "     OUTPUT    : " &lt;&lt; ( *oi )-&gt;GetFilenameIfAvailable();
    }
    MITK_DEBUG &lt;&lt; "   --------------------------------------------------------------------------------";
  }</span>
#endif // MBILOG_ENABLE_DEBUG



<span style = "background-color:#fdd">  return groups;
}</span>

mitk::DICOMTagBasedSorter::ParameterizedDatasetSort
::ParameterizedDatasetSort(DICOMSortCriterion::ConstPointer criterion)
<span style = "background-color:#fdd">:m_SortCriterion(criterion)
{
}</span>

bool
mitk::DICOMTagBasedSorter::ParameterizedDatasetSort
::operator() (const mitk::DICOMDatasetAccess* left, const mitk::DICOMDatasetAccess* right)
<span style = "background-color:#fdd">{
  assert(left);
  assert(right);
  assert(m_SortCriterion.IsNotNull());</span>

<span style = "background-color:#fdd">  return m_SortCriterion-&gt;IsLeftBeforeRight(left, right);
}</span></pre>
	</body>
</html>