<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDICOMTagsOfInterestAddHelper.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkDICOMTagsOfInterestAddHelper.h"

#include &lt;mitkIDICOMTagsOfInterest.h&gt;

#include "usModuleContext.h"
#include "usGetModuleContext.h"

void mitk::DICOMTagsOfInterestAddHelper::Activate(us::ModuleContext* context, TagsOfInterestVector tags)
<span style = "background-color:#dfd">{
  if (!m_Active &amp;&amp; nullptr != context)</span>
  {
<span style = "background-color:#dfd">    std::lock_guard&lt;std::mutex&gt; lock(m_Mutex);
    m_Active = true;
    m_Context = context;
    m_TagsOfInterest = tags;</span>

    // Listen for events pertaining to dictionary services.
<span style = "background-color:#dfd">    m_Context-&gt;AddServiceListener(this, &amp;DICOMTagsOfInterestAddHelper::DICOMTagsOfInterestServiceChanged,</span>
      std::string("(&amp;(") + us::ServiceConstants::OBJECTCLASS() + "=" +
      us_service_interface_iid&lt;IDICOMTagsOfInterest&gt;() + "))");
    // Query for any service references matching any language.
<span style = "background-color:#dfd">    std::vector&lt;us::ServiceReference&lt;IDICOMTagsOfInterest&gt; &gt; refs =</span>
      m_Context-&gt;GetServiceReferences&lt;IDICOMTagsOfInterest&gt;();
<span style = "background-color:#dfd">    if (!refs.empty())</span>
    {
<span style = "background-color:#dfd">      for (const auto&amp; ref : refs)</span>
      {
<span style = "background-color:#dfd">        this-&gt;RegisterTagsOfInterest(context-&gt;GetService(ref));
        context-&gt;UngetService(ref);
      }</span>
    }
<span style = "background-color:#dfd">  }
}</span>

void mitk::DICOMTagsOfInterestAddHelper::Deactivate()
<span style = "background-color:#dfd">{
  if (m_Active)</span>
  {
<span style = "background-color:#dfd">    std::lock_guard&lt;std::mutex&gt; lock(m_Mutex);
    m_Active = false;
    if (nullptr != m_Context)</span>
    {
      try
      {
<span style = "background-color:#dfd">          m_Context-&gt;RemoveServiceListener(this, &amp;DICOMTagsOfInterestAddHelper::DICOMTagsOfInterestServiceChanged);</span>
      }
      catch (...)
<span style = "background-color:#fdd">      {
        MITK_WARN &lt;&lt; "Was not able to remove service listener from module context.";
      }</span>
    }
<span style = "background-color:#dfd">  }
}</span>

mitk::DICOMTagsOfInterestAddHelper::~DICOMTagsOfInterestAddHelper()
<span style = "background-color:#dfd">{
  if (m_Active)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "DICOMTagsOfInterestAddHelper was not deactivated correctly befor its destructor was called.";
    auto context = us::GetModuleContext();</span>
    //we cannot trust m_Context at this point anymore and have no means to validate it. So try to get the own module context
    //and to remove the listener via this context.
<span style = "background-color:#fdd">    if (nullptr != context)</span>
    {
      try
      {
<span style = "background-color:#fdd">        context-&gt;RemoveServiceListener(this, &amp;DICOMTagsOfInterestAddHelper::DICOMTagsOfInterestServiceChanged);</span>
      }
      catch (...)
<span style = "background-color:#fdd">      {
        MITK_WARN &lt;&lt; "Was not able to remove service listener from module context.";
      }</span>
    }
  }
<span style = "background-color:#dfd">}</span>

void mitk::DICOMTagsOfInterestAddHelper::RegisterTagsOfInterest(IDICOMTagsOfInterest* toiService) const
<span style = "background-color:#dfd">{
  if (nullptr != toiService)</span>
  {
<span style = "background-color:#dfd">    for (const auto&amp; tag : m_TagsOfInterest)</span>
    {
<span style = "background-color:#dfd">      toiService-&gt;AddTagOfInterest(tag);
    }</span>
  }
<span style = "background-color:#dfd">}</span>

void mitk::DICOMTagsOfInterestAddHelper::DICOMTagsOfInterestServiceChanged(const us::ServiceEvent event)
<span style = "background-color:#dfd">{</span>
  // If a DICOMTagsOfInterestService was registered, register all tags of interest.
<span style = "background-color:#dfd">  if (event.GetType() == us::ServiceEvent::REGISTERED)</span>
  {
<span style = "background-color:#dfd">    if (nullptr != m_Context)</span>
    {
<span style = "background-color:#dfd">      std::lock_guard&lt;std::mutex&gt; lock(m_Mutex);</span>
      // Get a reference to the service object.
<span style = "background-color:#dfd">      us::ServiceReference&lt;IDICOMTagsOfInterest&gt; ref = event.GetServiceReference();
      this-&gt;RegisterTagsOfInterest(m_Context-&gt;GetService(ref));
      m_Context-&gt;UngetService(ref);
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "New DICOMTagsOfInterestService was registered, but no module context exists. Thus, no DICOM tags of interest where added.";</span>
    }
  }
<span style = "background-color:#dfd">}</span></pre>
	</body>
</html>