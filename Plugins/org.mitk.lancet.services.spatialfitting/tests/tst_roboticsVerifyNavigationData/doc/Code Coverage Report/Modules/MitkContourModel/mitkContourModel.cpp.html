<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkContourModel.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/
#include &lt;mitkContourModel.h&gt;
#include &lt;mitkPlaneGeometry.h&gt;

namespace mitk
{
<span style = "background-color:#fdd">  itkEventMacroDefinition(ContourModelEvent, itk::AnyEvent);
  itkEventMacroDefinition(ContourModelShiftEvent, ContourModelEvent);
  itkEventMacroDefinition(ContourModelSizeChangeEvent, ContourModelEvent);
  itkEventMacroDefinition(ContourModelAddEvent, ContourModelSizeChangeEvent);
  itkEventMacroDefinition(ContourModelRemoveEvent, ContourModelSizeChangeEvent);
  itkEventMacroDefinition(ContourModelExpandTimeBoundsEvent, ContourModelEvent);
  itkEventMacroDefinition(ContourModelClosedEvent, ContourModelEvent);</span>
}

<span style = "background-color:#fdd">mitk::ContourModel::ContourModel() : m_UpdateBoundingBox(true)
{</span>
  // set to initial state
<span style = "background-color:#fdd">  this-&gt;InitializeEmpty();
}</span>

mitk::ContourModel::ContourModel(const ContourModel &amp;other)
<span style = "background-color:#fdd">  : BaseData(other), m_ContourSeries(other.m_ContourSeries), m_lineInterpolation(other.m_lineInterpolation)
{
  m_SelectedVertex = nullptr;
}</span>

mitk::ContourModel::~ContourModel()
<span style = "background-color:#fdd">{
  m_SelectedVertex = nullptr;
  this-&gt;m_ContourSeries.clear(); // TODO check destruction
}</span>

void mitk::ContourModel::AddVertex(const Point3D &amp;vertex, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    this-&gt;AddVertex(vertex, false, timestep);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::AddVertex(const Point3D &amp;vertex, bool isControlPoint, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_ContourSeries[timestep]-&gt;AddVertex(vertex, isControlPoint);
    this-&gt;InvokeEvent(ContourModelSizeChangeEvent());
    this-&gt;Modified();
    this-&gt;m_UpdateBoundingBox = true;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::AddVertex(const VertexType &amp;vertex, TimeStepType timestep)
<span style = "background-color:#fdd">{
  this-&gt;AddVertex(vertex.Coordinates, vertex.IsControlPoint, timestep);
}</span>

void mitk::ContourModel::AddVertexAtFront(const Point3D &amp;vertex, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    this-&gt;AddVertexAtFront(vertex, false, timestep);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::AddVertexAtFront(const Point3D &amp;vertex, bool isControlPoint, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_ContourSeries[timestep]-&gt;AddVertexAtFront(vertex, isControlPoint);
    this-&gt;InvokeEvent(ContourModelSizeChangeEvent());
    this-&gt;Modified();
    this-&gt;m_UpdateBoundingBox = true;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::AddVertexAtFront(const VertexType &amp;vertex, TimeStepType timestep)
<span style = "background-color:#fdd">{
  this-&gt;AddVertexAtFront(vertex.Coordinates, vertex.IsControlPoint, timestep);
}</span>

bool mitk::ContourModel::SetVertexAt(int pointId, const Point3D &amp;point, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    if (pointId &gt;= 0 &amp;&amp; this-&gt;m_ContourSeries[timestep]-&gt;GetSize() &gt; ContourElement::VertexSizeType(pointId))</span>
    {
<span style = "background-color:#fdd">      this-&gt;m_ContourSeries[timestep]-&gt;SetVertexAt(pointId, point);
      this-&gt;Modified();
      this-&gt;m_UpdateBoundingBox = true;
      return true;</span>
    }
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::ContourModel::SetVertexAt(int pointId, const VertexType *vertex, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (vertex == nullptr)
    return false;</span>

<span style = "background-color:#fdd">  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    if (pointId &gt;= 0 &amp;&amp; this-&gt;m_ContourSeries[timestep]-&gt;GetSize() &gt; ContourElement::VertexSizeType(pointId))</span>
    {
<span style = "background-color:#fdd">      this-&gt;m_ContourSeries[timestep]-&gt;SetVertexAt(pointId, vertex);
      this-&gt;Modified();
      this-&gt;m_UpdateBoundingBox = true;
      return true;</span>
    }
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

void mitk::ContourModel::InsertVertexAtIndex(const Point3D &amp;vertex, int index, bool isControlPoint, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    if (index &gt;= 0 &amp;&amp; this-&gt;m_ContourSeries[timestep]-&gt;GetSize() &gt; ContourElement::VertexSizeType(index))</span>
    {
<span style = "background-color:#fdd">      this-&gt;m_ContourSeries[timestep]-&gt;InsertVertexAtIndex(vertex, isControlPoint, index);
      this-&gt;InvokeEvent(ContourModelSizeChangeEvent());
      this-&gt;Modified();
      this-&gt;m_UpdateBoundingBox = true;</span>
    }
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::UpdateContour(const ContourModel* sourceModel, TimeStepType destinationTimeStep, TimeStepType sourceTimeStep)
<span style = "background-color:#fdd">{
  if (nullptr == sourceModel)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot update contour. Passed source model is invalid.";</span>
  }

<span style = "background-color:#fdd">  if (!sourceModel-&gt;GetTimeGeometry()-&gt;IsValidTimeStep(sourceTimeStep))</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot update contour. Source contour time geometry does not support passed time step. Invalid time step: " &lt;&lt; sourceTimeStep;</span>
  }

<span style = "background-color:#fdd">  if (!this-&gt;GetTimeGeometry()-&gt;IsValidTimeStep(destinationTimeStep))</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Cannot update contour. Contour time geometry does not support passed time step. Invalid time step: " &lt;&lt; destinationTimeStep;
    return;</span>
  }

<span style = "background-color:#fdd">  this-&gt;Clear(destinationTimeStep);</span>

<span style = "background-color:#fdd">  std::for_each(sourceModel-&gt;Begin(sourceTimeStep), sourceModel-&gt;End(sourceTimeStep), [this, destinationTimeStep](ContourElement::VertexType* vertex) {
    this-&gt;m_ContourSeries[destinationTimeStep]-&gt;AddVertex(vertex-&gt;Coordinates, vertex-&gt;IsControlPoint);
  });</span>

<span style = "background-color:#fdd">  this-&gt;InvokeEvent(ContourModelSizeChangeEvent());
  this-&gt;Modified();
  this-&gt;m_UpdateBoundingBox = true;
}</span>

bool mitk::ContourModel::IsEmpty(TimeStepType timestep) const
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_ContourSeries[timestep]-&gt;IsEmpty();</span>
  }
<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::ContourModel::IsEmpty() const
<span style = "background-color:#fdd">{
  return this-&gt;IsEmpty(0);
}</span>

int mitk::ContourModel::GetNumberOfVertices(TimeStepType timestep) const
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_ContourSeries[timestep]-&gt;GetSize();</span>
  }
<span style = "background-color:#fdd">  return -1;
}</span>

const mitk::ContourModel::VertexType *mitk::ContourModel::GetVertexAt(int index, TimeStepType timestep) const
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep) &amp;&amp; this-&gt;m_ContourSeries[timestep]-&gt;GetSize() &gt; mitk::ContourElement::VertexSizeType(index))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_ContourSeries[timestep]-&gt;GetVertexAt(index);</span>
  }
<span style = "background-color:#fdd">  return nullptr;
}</span>

const mitk::ContourModel::VertexType *mitk::ContourModel::GetNextControlVertexAt(mitk::Point3D &amp;point,
                                                                          float eps,
                                                                          TimeStepType timestep) const
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_ContourSeries[timestep]-&gt;GetNextControlVertexAt(point, eps);</span>
  }
<span style = "background-color:#fdd">  return nullptr;
}</span>

const mitk::ContourModel::VertexType *mitk::ContourModel::GetPreviousControlVertexAt(mitk::Point3D &amp;point,
                                                                          float eps,
                                                                          TimeStepType timestep) const
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_ContourSeries[timestep]-&gt;GetPreviousControlVertexAt(point, eps);</span>
  }
<span style = "background-color:#fdd">  return nullptr;
}</span>

int mitk::ContourModel::GetIndex(const VertexType *vertex, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_ContourSeries[timestep]-&gt;GetIndex(vertex);</span>
  }
<span style = "background-color:#fdd">  return -1;
}</span>

void mitk::ContourModel::Close(TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_ContourSeries[timestep]-&gt;Close();
    this-&gt;InvokeEvent(ContourModelClosedEvent());
    this-&gt;Modified();
    this-&gt;m_UpdateBoundingBox = true;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::Open(TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_ContourSeries[timestep]-&gt;Open();
    this-&gt;InvokeEvent(ContourModelClosedEvent());
    this-&gt;Modified();
    this-&gt;m_UpdateBoundingBox = true;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::SetClosed(bool isClosed, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_ContourSeries[timestep]-&gt;SetClosed(isClosed);
    this-&gt;InvokeEvent(ContourModelClosedEvent());
    this-&gt;Modified();
    this-&gt;m_UpdateBoundingBox = true;</span>
  }
<span style = "background-color:#fdd">}</span>

bool mitk::ContourModel::IsEmptyTimeStep(unsigned int t) const
<span style = "background-color:#fdd">{
  return (this-&gt;m_ContourSeries.size() &lt;= t);
}</span>

bool mitk::ContourModel::IsNearContour(Point3D &amp;point, float eps, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_ContourSeries[timestep]-&gt;IsNearContour(point, eps);</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

void mitk::ContourModel::Concatenate(ContourModel *other, TimeStepType timestep, bool check)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    if (!this-&gt;m_ContourSeries[timestep]-&gt;IsClosed())</span>
    {
<span style = "background-color:#fdd">      this-&gt;m_ContourSeries[timestep]-&gt;Concatenate(other-&gt;m_ContourSeries[timestep], check);
      this-&gt;InvokeEvent(ContourModelSizeChangeEvent());
      this-&gt;Modified();
      this-&gt;m_UpdateBoundingBox = true;</span>
    }
  }
<span style = "background-color:#fdd">}</span>

mitk::ContourModel::VertexIterator mitk::ContourModel::Begin(TimeStepType timestep) const
<span style = "background-color:#fdd">{
  return this-&gt;IteratorBegin(timestep);
}</span>

mitk::ContourModel::VertexIterator mitk::ContourModel::IteratorBegin(TimeStepType timestep) const
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_ContourSeries[timestep]-&gt;IteratorBegin();
  }</span>
  else
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "No iterator at invalid timestep " &lt;&lt; timestep &lt;&lt; ". There are only " &lt;&lt; this-&gt;GetTimeSteps()</span>
                &lt;&lt; " timesteps available.";
  }
<span style = "background-color:#fdd">}</span>

mitk::ContourModel::VertexIterator mitk::ContourModel::End(TimeStepType timestep) const
<span style = "background-color:#fdd">{
  return this-&gt;IteratorEnd(timestep);
}</span>

mitk::ContourModel::VertexIterator mitk::ContourModel::IteratorEnd(TimeStepType timestep) const
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_ContourSeries[timestep]-&gt;IteratorEnd();
  }</span>
  else
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "No iterator at invalid timestep " &lt;&lt; timestep &lt;&lt; ". There are only " &lt;&lt; this-&gt;GetTimeSteps()</span>
                &lt;&lt; " timesteps available.";
  }
<span style = "background-color:#fdd">}</span>

bool mitk::ContourModel::IsClosed(int timestep) const
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;m_ContourSeries[timestep]-&gt;IsClosed();</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::ContourModel::SelectControlVertexAt(Point3D &amp;point, float eps, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_SelectedVertex = this-&gt;m_ContourSeries[timestep]-&gt;GetControlVertexAt(point, eps);</span>
  }
<span style = "background-color:#fdd">  return this-&gt;m_SelectedVertex != nullptr;
}</span>

bool mitk::ContourModel::SelectVertexAt(Point3D &amp;point, float eps, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_SelectedVertex = this-&gt;m_ContourSeries[timestep]-&gt;GetVertexAt(point, eps);</span>
  }
<span style = "background-color:#fdd">  return this-&gt;m_SelectedVertex != nullptr;
}</span>

bool mitk::ContourModel::SelectVertexAt(int index, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep) &amp;&amp; index &gt;= 0)</span>
  {
<span style = "background-color:#fdd">    return (this-&gt;m_SelectedVertex = this-&gt;m_ContourSeries[timestep]-&gt;GetVertexAt(index));</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::ContourModel::SetControlVertexAt(Point3D &amp;point, float eps, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    VertexType *vertex = this-&gt;m_ContourSeries[timestep]-&gt;GetVertexAt(point, eps);
    if (vertex != nullptr)</span>
    {
<span style = "background-color:#fdd">      vertex-&gt;IsControlPoint = true;
      return true;</span>
    }
  }
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::ContourModel::SetControlVertexAt(int index, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep) &amp;&amp; index &gt;= 0)</span>
  {
<span style = "background-color:#fdd">    VertexType *vertex = this-&gt;m_ContourSeries[timestep]-&gt;GetVertexAt(index);
    if (vertex != nullptr)</span>
    {
<span style = "background-color:#fdd">      vertex-&gt;IsControlPoint = true;
      return true;</span>
    }
  }
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::ContourModel::RemoveVertex(const VertexType *vertex, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;m_ContourSeries[timestep]-&gt;RemoveVertex(vertex))</span>
    {
<span style = "background-color:#fdd">      this-&gt;Modified();
      this-&gt;m_UpdateBoundingBox = true;
      this-&gt;InvokeEvent(ContourModelSizeChangeEvent());
      return true;</span>
    }
  }
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::ContourModel::RemoveVertexAt(int index, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;m_ContourSeries[timestep]-&gt;RemoveVertexAt(index))</span>
    {
<span style = "background-color:#fdd">      this-&gt;Modified();
      this-&gt;m_UpdateBoundingBox = true;
      this-&gt;InvokeEvent(ContourModelSizeChangeEvent());
      return true;</span>
    }
  }
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::ContourModel::RemoveVertexAt(Point3D &amp;point, float eps, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;m_ContourSeries[timestep]-&gt;RemoveVertexAt(point, eps))</span>
    {
<span style = "background-color:#fdd">      this-&gt;Modified();
      this-&gt;m_UpdateBoundingBox = true;
      this-&gt;InvokeEvent(ContourModelSizeChangeEvent());
      return true;</span>
    }
  }
<span style = "background-color:#fdd">  return false;
}</span>

void mitk::ContourModel::ShiftSelectedVertex(Vector3D &amp;translate)
<span style = "background-color:#fdd">{
  if (this-&gt;m_SelectedVertex)</span>
  {
<span style = "background-color:#fdd">    this-&gt;ShiftVertex(this-&gt;m_SelectedVertex, translate);
    this-&gt;Modified();
    this-&gt;m_UpdateBoundingBox = true;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::ShiftContour(Vector3D &amp;translate, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
    // shift all vertices
<span style = "background-color:#fdd">    for (auto vertex : *(this-&gt;m_ContourSeries[timestep]))</span>
    {
<span style = "background-color:#fdd">      this-&gt;ShiftVertex(vertex, translate);
    }</span>

<span style = "background-color:#fdd">    this-&gt;Modified();
    this-&gt;m_UpdateBoundingBox = true;
    this-&gt;InvokeEvent(ContourModelShiftEvent());</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::ShiftVertex(VertexType *vertex, Vector3D &amp;vector)
<span style = "background-color:#fdd">{
  vertex-&gt;Coordinates[0] += vector[0];
  vertex-&gt;Coordinates[1] += vector[1];
  vertex-&gt;Coordinates[2] += vector[2];
}</span>

void mitk::ContourModel::Clear(TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
    // clear data at timestep
<span style = "background-color:#fdd">    this-&gt;m_ContourSeries[timestep]-&gt;Clear();
    this-&gt;Modified();
    this-&gt;m_UpdateBoundingBox = true;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::Expand(unsigned int timeSteps)
<span style = "background-color:#fdd">{
  std::size_t oldSize = this-&gt;m_ContourSeries.size();</span>

<span style = "background-color:#fdd">  if (static_cast&lt;std::size_t&gt;(timeSteps) &gt; oldSize)</span>
  {
<span style = "background-color:#fdd">    Superclass::Expand(timeSteps);</span>

    // insert contours for each new timestep
<span style = "background-color:#fdd">    for (std::size_t i = oldSize; i &lt; static_cast&lt;std::size_t&gt;(timeSteps); i++)</span>
    {
<span style = "background-color:#fdd">      m_ContourSeries.push_back(ContourElement::New());
    }</span>

<span style = "background-color:#fdd">    this-&gt;InvokeEvent(ContourModelExpandTimeBoundsEvent());</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::SetRequestedRegionToLargestPossibleRegion()
<span style = "background-color:#fdd">{</span>
  // no support for regions
<span style = "background-color:#fdd">}</span>

bool mitk::ContourModel::RequestedRegionIsOutsideOfTheBufferedRegion()
<span style = "background-color:#fdd">{</span>
  // no support for regions
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::ContourModel::VerifyRequestedRegion()
<span style = "background-color:#fdd">{</span>
  // no support for regions
<span style = "background-color:#fdd">  return true;
}</span>

void mitk::ContourModel::SetRequestedRegion(const itk::DataObject * /*data*/)
<span style = "background-color:#fdd">{</span>
  // no support for regions
<span style = "background-color:#fdd">}</span>

void mitk::ContourModel::Clear()
<span style = "background-color:#fdd">{</span>
  // clear data and set to initial state again
<span style = "background-color:#fdd">  this-&gt;ClearData();
  this-&gt;InitializeEmpty();
  this-&gt;Modified();
  this-&gt;m_UpdateBoundingBox = true;
}</span>

void mitk::ContourModel::RedistributeControlVertices(int period, TimeStepType timestep)
<span style = "background-color:#fdd">{
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_ContourSeries[timestep]-&gt;RedistributeControlVertices(this-&gt;GetSelectedVertex(), period);
    this-&gt;InvokeEvent(ContourModelClosedEvent());
    this-&gt;Modified();
    this-&gt;m_UpdateBoundingBox = true;</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::ContourModel::VertexListType mitk::ContourModel::GetControlVertices(TimeStepType timestep)
<span style = "background-color:#fdd">{
  VertexListType controlVertices;
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    controlVertices = this-&gt;m_ContourSeries[timestep]-&gt;GetControlVertices();</span>
  }
<span style = "background-color:#fdd">  return controlVertices;
}</span>

mitk::ContourModel::VertexListType mitk::ContourModel::GetVertexList(TimeStepType timestep)
<span style = "background-color:#fdd">{
  VertexListType controlVertices;
  if (!this-&gt;IsEmptyTimeStep(timestep))</span>
  {
<span style = "background-color:#fdd">    controlVertices = *this-&gt;m_ContourSeries[timestep]-&gt;GetVertexList();</span>
  }
<span style = "background-color:#fdd">  return controlVertices;
}</span>

void mitk::ContourModel::ClearData()
<span style = "background-color:#fdd">{</span>
  // call the superclass, this releases the data of BaseData
<span style = "background-color:#fdd">  Superclass::ClearData();</span>

  // clear out the time resolved contours
<span style = "background-color:#fdd">  this-&gt;m_ContourSeries.clear();
}</span>

void mitk::ContourModel::Initialize()
<span style = "background-color:#fdd">{
  this-&gt;InitializeEmpty();
  this-&gt;Modified();
  this-&gt;m_UpdateBoundingBox = true;
}</span>

void mitk::ContourModel::Initialize(const ContourModel &amp;other)
<span style = "background-color:#fdd">{
  TimeStepType numberOfTimesteps = other.GetTimeGeometry()-&gt;CountTimeSteps();
  this-&gt;InitializeTimeGeometry(numberOfTimesteps);</span>

<span style = "background-color:#fdd">  for (TimeStepType currentTimestep = 0; currentTimestep &lt; numberOfTimesteps; currentTimestep++)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_ContourSeries.push_back(ContourElement::New());
    this-&gt;SetClosed(other.IsClosed(currentTimestep), currentTimestep);
  }</span>

<span style = "background-color:#fdd">  m_SelectedVertex = nullptr;
  this-&gt;m_lineInterpolation = other.m_lineInterpolation;
  this-&gt;Modified();
  this-&gt;m_UpdateBoundingBox = true;
}</span>

void mitk::ContourModel::InitializeEmpty()
<span style = "background-color:#fdd">{</span>
  // clear data at timesteps
<span style = "background-color:#fdd">  this-&gt;m_ContourSeries.resize(0);
  this-&gt;m_ContourSeries.push_back(ContourElement::New());</span>

  // set number of timesteps to one
<span style = "background-color:#fdd">  this-&gt;InitializeTimeGeometry(1);</span>

<span style = "background-color:#fdd">  m_SelectedVertex = nullptr;
  this-&gt;m_lineInterpolation = ContourModel::LINEAR;
}</span>

void mitk::ContourModel::UpdateOutputInformation()
<span style = "background-color:#fdd">{
  if (this-&gt;GetSource())</span>
  {
<span style = "background-color:#fdd">    this-&gt;GetSource()-&gt;UpdateOutputInformation();</span>
  }

<span style = "background-color:#fdd">  if (this-&gt;m_UpdateBoundingBox)</span>
  {
    // update the bounds of the geometry according to the stored vertices
    ScalarType mitkBounds[6];

    // calculate the boundingbox at each timestep
    typedef itk::BoundingBox&lt;unsigned long, 3, ScalarType&gt; BoundingBoxType;
    typedef BoundingBoxType::PointsContainer PointsContainer;

<span style = "background-color:#fdd">    int timesteps = this-&gt;GetTimeSteps();</span>

    // iterate over the timesteps
<span style = "background-color:#fdd">    for (int currenTimeStep = 0; currenTimeStep &lt; timesteps; currenTimeStep++)</span>
    {
<span style = "background-color:#fdd">      if (dynamic_cast&lt;PlaneGeometry *&gt;(this-&gt;GetGeometry(currenTimeStep)))</span>
      {
        // do not update bounds for 2D geometries, as they are unfortunately defined with min bounds 0!
<span style = "background-color:#fdd">        return;
      }</span>
      else
      { // we have a 3D geometry -&gt; let's update bounds
        // only update bounds if the contour was modified
<span style = "background-color:#fdd">        if (this-&gt;GetMTime() &gt; this-&gt;GetGeometry(currenTimeStep)-&gt;GetBoundingBox()-&gt;GetMTime())</span>
        {
<span style = "background-color:#fdd">          mitkBounds[0] = 0.0;
          mitkBounds[1] = 0.0;
          mitkBounds[2] = 0.0;
          mitkBounds[3] = 0.0;
          mitkBounds[4] = 0.0;
          mitkBounds[5] = 0.0;</span>

<span style = "background-color:#fdd">          BoundingBoxType::Pointer boundingBox = BoundingBoxType::New();</span>

<span style = "background-color:#fdd">          PointsContainer::Pointer points = PointsContainer::New();</span>

<span style = "background-color:#fdd">          auto it = this-&gt;IteratorBegin(currenTimeStep);
          auto end = this-&gt;IteratorEnd(currenTimeStep);</span>

          // fill the boundingbox with the points
<span style = "background-color:#fdd">          while (it != end)</span>
          {
<span style = "background-color:#fdd">            Point3D currentP = (*it)-&gt;Coordinates;</span>
            BoundingBoxType::PointType p;
<span style = "background-color:#fdd">            p.CastFrom(currentP);
            points-&gt;InsertElement(points-&gt;Size(), p);</span>

<span style = "background-color:#fdd">            it++;
          }</span>

          // construct the new boundingBox
<span style = "background-color:#fdd">          boundingBox-&gt;SetPoints(points);
          boundingBox-&gt;ComputeBoundingBox();
          BoundingBoxType::BoundsArrayType tmp = boundingBox-&gt;GetBounds();
          mitkBounds[0] = tmp[0];
          mitkBounds[1] = tmp[1];
          mitkBounds[2] = tmp[2];
          mitkBounds[3] = tmp[3];
          mitkBounds[4] = tmp[4];
          mitkBounds[5] = tmp[5];</span>

          // set boundingBox at current timestep
<span style = "background-color:#fdd">          BaseGeometry *geometry3d = this-&gt;GetGeometry(currenTimeStep);
          geometry3d-&gt;SetBounds(mitkBounds);
        }</span>
      }
<span style = "background-color:#fdd">    }
    this-&gt;m_UpdateBoundingBox = false;</span>
  }
<span style = "background-color:#fdd">  GetTimeGeometry()-&gt;Update();
}</span>

void mitk::ContourModel::ExecuteOperation(Operation * /*operation*/)
<span style = "background-color:#fdd">{</span>
  // not supported yet
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>