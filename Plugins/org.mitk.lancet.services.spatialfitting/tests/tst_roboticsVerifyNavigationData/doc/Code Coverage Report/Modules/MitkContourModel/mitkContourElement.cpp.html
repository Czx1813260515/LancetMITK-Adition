<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkContourElement.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/
#include &lt;algorithm&gt;
#include &lt;mitkContourElement.h&gt;
#include &lt;vtkMath.h&gt;

bool mitk::ContourElement::ContourModelVertex::operator==(const ContourModelVertex &amp;other) const
<span style = "background-color:#fdd">{
  return this-&gt;Coordinates == other.Coordinates &amp;&amp; this-&gt;IsControlPoint == other.IsControlPoint;
}</span>

mitk::ContourElement::ConstVertexIterator mitk::ContourElement::ConstIteratorBegin() const
<span style = "background-color:#fdd">{
  return this-&gt;begin();
}</span>

mitk::ContourElement::ConstVertexIterator mitk::ContourElement::ConstIteratorEnd() const
<span style = "background-color:#fdd">{
  return this-&gt;end();
}</span>

mitk::ContourElement::VertexIterator mitk::ContourElement::IteratorBegin()
<span style = "background-color:#fdd">{
  return this-&gt;begin();
}</span>

mitk::ContourElement::VertexIterator mitk::ContourElement::IteratorEnd()
<span style = "background-color:#fdd">{
  return this-&gt;end();
}</span>

mitk::ContourElement::ConstVertexIterator mitk::ContourElement::begin() const
<span style = "background-color:#fdd">{
  return this-&gt;m_Vertices.begin();
}</span>

mitk::ContourElement::ConstVertexIterator mitk::ContourElement::end() const
<span style = "background-color:#fdd">{
  return this-&gt;m_Vertices.end();
}</span>

mitk::ContourElement::VertexIterator mitk::ContourElement::begin()
<span style = "background-color:#fdd">{
  return this-&gt;m_Vertices.begin();
}</span>

mitk::ContourElement::VertexIterator mitk::ContourElement::end()
<span style = "background-color:#fdd">{
  return this-&gt;m_Vertices.end();
}</span>

mitk::ContourElement::ContourElement(const mitk::ContourElement &amp;other)
<span style = "background-color:#fdd">  : itk::LightObject(), m_IsClosed(other.m_IsClosed)
{
  for (const auto &amp;v : other.m_Vertices)</span>
  {
<span style = "background-color:#fdd">    m_Vertices.push_back(new ContourModelVertex(*v));
  }
}</span>

mitk::ContourElement &amp;mitk::ContourElement::operator=(const ContourElement &amp;other)
<span style = "background-color:#fdd">{
  if (this != &amp;other)</span>
  {
<span style = "background-color:#fdd">    this-&gt;Clear();
    for (const auto &amp;v : other.m_Vertices)</span>
    {
<span style = "background-color:#fdd">      m_Vertices.push_back(new ContourModelVertex(*v));
    }</span>
  }

<span style = "background-color:#fdd">  this-&gt;m_IsClosed = other.m_IsClosed;
  return *this;
}</span>

mitk::ContourElement::~ContourElement()
<span style = "background-color:#fdd">{
  this-&gt;Clear();
}</span>

mitk::ContourElement::VertexSizeType mitk::ContourElement::GetSize() const
<span style = "background-color:#fdd">{
  return this-&gt;m_Vertices.size();
}</span>

void mitk::ContourElement::AddVertex(const mitk::Point3D &amp;vertex, bool isControlPoint)
<span style = "background-color:#fdd">{
  this-&gt;m_Vertices.push_back(new VertexType(vertex, isControlPoint));
}</span>

void mitk::ContourElement::AddVertexAtFront(const mitk::Point3D &amp;vertex, bool isControlPoint)
<span style = "background-color:#fdd">{
  this-&gt;m_Vertices.push_front(new VertexType(vertex, isControlPoint));
}</span>

void mitk::ContourElement::InsertVertexAtIndex(const mitk::Point3D &amp;vertex, bool isControlPoint, VertexSizeType index)
<span style = "background-color:#fdd">{
  if (this-&gt;GetSize() &gt; index)</span>
  {
<span style = "background-color:#fdd">    auto _where = this-&gt;m_Vertices.begin();
    _where += index;
    this-&gt;m_Vertices.insert(_where, new VertexType(vertex, isControlPoint));
  }
}</span>

void mitk::ContourElement::SetVertexAt(VertexSizeType pointId, const Point3D &amp;point)
<span style = "background-color:#fdd">{
  if (this-&gt;GetSize() &gt; pointId)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_Vertices[pointId]-&gt;Coordinates = point;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ContourElement::SetVertexAt(VertexSizeType pointId, const VertexType *vertex)
<span style = "background-color:#fdd">{
  if (nullptr == vertex)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot set vertex. Passed vertex instance is invalid. Index to set: " &lt;&lt; pointId;</span>
  }

<span style = "background-color:#fdd">  if (this-&gt;GetSize() &gt; pointId)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_Vertices[pointId]-&gt;Coordinates = vertex-&gt;Coordinates;
    this-&gt;m_Vertices[pointId]-&gt;IsControlPoint = vertex-&gt;IsControlPoint;</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::ContourElement::VertexType *mitk::ContourElement::GetVertexAt(VertexSizeType index)
<span style = "background-color:#fdd">{
  return this-&gt;m_Vertices.at(index);
}</span>

const mitk::ContourElement::VertexType *mitk::ContourElement::GetVertexAt(VertexSizeType index) const
<span style = "background-color:#fdd">{
  return this-&gt;m_Vertices.at(index);
}</span>

bool mitk::ContourElement::IsEmpty() const
<span style = "background-color:#fdd">{
  return this-&gt;m_Vertices.empty();
}</span>

mitk::ContourElement::VertexType *mitk::ContourElement::GetControlVertexAt(const mitk::Point3D &amp;point, float eps)
<span style = "background-color:#fdd">{</span>
  /* current version iterates over the whole deque - should some kind of an octree with spatial query*/

<span style = "background-color:#fdd">  if (eps &gt; 0)</span>
  {
    // currently no method with better performance is available
<span style = "background-color:#fdd">    return BruteForceGetVertexAt(point, eps, true);</span>
  } // if eps &lt; 0
<span style = "background-color:#fdd">  return nullptr;
}</span>

mitk::ContourElement::VertexType *mitk::ContourElement::GetVertexAt(const mitk::Point3D &amp;point, float eps)
<span style = "background-color:#fdd">{</span>
  /* current version iterates over the whole deque - should some kind of an octree with spatial query*/

<span style = "background-color:#fdd">  if (eps &gt; 0)</span>
  {
    // currently no method with better performance is available
<span style = "background-color:#fdd">    return BruteForceGetVertexAt(point, eps);</span>
  } // if eps &lt; 0
<span style = "background-color:#fdd">  return nullptr;
}</span>

mitk::ContourElement::VertexType *mitk::ContourElement::GetNextControlVertexAt(const mitk::Point3D &amp;point, float eps)
<span style = "background-color:#fdd">{</span>
  /* current version iterates over the whole deque - should some kind of an octree with spatial query*/

<span style = "background-color:#fdd">  if (eps &gt; 0)</span>
  {
    // currently no method with better performance is available
<span style = "background-color:#fdd">    return BruteForceGetVertexAt(point, eps, true, 1);</span>
  } // if eps &lt; 0
<span style = "background-color:#fdd">  return nullptr;
}</span>

mitk::ContourElement::VertexType *mitk::ContourElement::GetPreviousControlVertexAt(const mitk::Point3D &amp;point, float eps)
<span style = "background-color:#fdd">{</span>
  /* current version iterates over the whole deque - should some kind of an octree with spatial query*/

<span style = "background-color:#fdd">  if (eps &gt; 0)</span>
  {
    // currently no method with better performance is available
<span style = "background-color:#fdd">    return BruteForceGetVertexAt(point, eps, true, -1);</span>
  } // if eps &lt; 0
<span style = "background-color:#fdd">  return nullptr;
}</span>

mitk::ContourElement::VertexType *mitk::ContourElement::BruteForceGetVertexAt(const mitk::Point3D &amp;point,
                                                                              double eps,
                                                                              bool isControlPoint,
                                                                              int offset)
<span style = "background-color:#fdd">{
  VertexListType verticesList;</span>

<span style = "background-color:#fdd">  if (isControlPoint)</span>
  {
<span style = "background-color:#fdd">    verticesList = this-&gt;GetControlVertices();
  }</span>
  else
  {
<span style = "background-color:#fdd">    verticesList = *this-&gt;GetVertexList();</span>
  }

<span style = "background-color:#fdd">  int vertexIndex = BruteForceGetVertexIndexAt(point, eps, verticesList);</span>

<span style = "background-color:#fdd">  if (vertexIndex!=-1)</span>
  {
<span style = "background-color:#fdd">    vertexIndex += offset;</span>

<span style = "background-color:#fdd">    if (vertexIndex &lt; 0)</span>
    {
      // for negative offset
      // if the offset exceeds the first vertex, we start from the end of the vertex list backwards
<span style = "background-color:#fdd">      vertexIndex = verticesList.size() + offset;
    }
    else if (vertexIndex &gt;= (int) verticesList.size())</span>
    {
      // if the offset exceeds the last vertex, we start from the beginning of the vertex list
<span style = "background-color:#fdd">      vertexIndex = vertexIndex - verticesList.size();</span>
    }

<span style = "background-color:#fdd">    return verticesList[vertexIndex];</span>
  }
<span style = "background-color:#fdd">  return nullptr;
}</span>

int mitk::ContourElement::BruteForceGetVertexIndexAt(const mitk::Point3D &amp;point,
                                                     double eps,
                                                     VertexListType verticesList)
<span style = "background-color:#fdd">{
  if (eps &lt; 0)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Distance cannot be negative";</span>
  }

<span style = "background-color:#fdd">  ConstVertexIterator nearestPointIterator;
  bool nearestPointIsInitialized = false;
  double nearestPointDistance = std::numeric_limits&lt;double&gt;::max();</span>

<span style = "background-color:#fdd">  ConstVertexIterator it = verticesList.begin();
  ConstVertexIterator end = verticesList.end();</span>

<span style = "background-color:#fdd">  while (it != end)</span>
  {
<span style = "background-color:#fdd">    mitk::Point3D currentPoint = (*it)-&gt;Coordinates;</span>

<span style = "background-color:#fdd">    double distance = currentPoint.EuclideanDistanceTo(point);
    if (distance &lt; eps)</span>
    {
<span style = "background-color:#fdd">      if (distance &lt; nearestPointDistance)</span>
      {
<span style = "background-color:#fdd">        nearestPointIterator = it;
        nearestPointIsInitialized = true;
        nearestPointDistance = distance;</span>
      }
    } // if distance &gt; eps

<span style = "background-color:#fdd">    it++;
  } // while</span>

<span style = "background-color:#fdd">  if (nearestPointIsInitialized)</span>
  {
<span style = "background-color:#fdd">    return nearestPointIterator - verticesList.begin();</span>
  }
<span style = "background-color:#fdd">  return -1;
}</span>

const mitk::ContourElement::VertexListType *mitk::ContourElement::GetVertexList() const
<span style = "background-color:#fdd">{
  return &amp;(this-&gt;m_Vertices);
}</span>

bool mitk::ContourElement::IsClosed() const
<span style = "background-color:#fdd">{
  return this-&gt;m_IsClosed;
}</span>

bool mitk::ContourElement::IsNearContour(const mitk::Point3D &amp;point, float eps) const
<span style = "background-color:#fdd">{
  ConstVertexIterator it1 = this-&gt;m_Vertices.begin();
  ConstVertexIterator it2 = this-&gt;m_Vertices.begin();
  it2++; // it2 runs one position ahead</span>

<span style = "background-color:#fdd">  ConstVertexIterator end = this-&gt;m_Vertices.end();</span>

<span style = "background-color:#fdd">  int counter = 0;</span>

<span style = "background-color:#fdd">  for (; it1 != end; it1++, it2++, counter++)</span>
  {
<span style = "background-color:#fdd">    if (it2 == end)
      it2 = this-&gt;m_Vertices.begin();</span>

<span style = "background-color:#fdd">    mitk::Point3D v1 = (*it1)-&gt;Coordinates;
    mitk::Point3D v2 = (*it2)-&gt;Coordinates;</span>

<span style = "background-color:#fdd">    const float l2 = v1.SquaredEuclideanDistanceTo(v2);</span>

<span style = "background-color:#fdd">    mitk::Vector3D p_v1 = point - v1;
    mitk::Vector3D v2_v1 = v2 - v1;</span>

<span style = "background-color:#fdd">    double tc = (p_v1 * v2_v1) / l2;</span>

    // take into account we have line segments and not (infinite) lines
<span style = "background-color:#fdd">    if (tc &lt; 0.0)
      tc = 0.0;
    if (tc &gt; 1.0)
      tc = 1.0;</span>

<span style = "background-color:#fdd">    mitk::Point3D crossPoint = v1 + v2_v1 * tc;</span>

<span style = "background-color:#fdd">    double distance = point.SquaredEuclideanDistanceTo(crossPoint);</span>

<span style = "background-color:#fdd">    if (distance &lt; eps)</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return false;
}</span>

void mitk::ContourElement::Close()
<span style = "background-color:#fdd">{
  this-&gt;m_IsClosed = true;
}</span>

void mitk::ContourElement::Open()
<span style = "background-color:#fdd">{
  this-&gt;m_IsClosed = false;
}</span>

void mitk::ContourElement::SetClosed(bool isClosed)
<span style = "background-color:#fdd">{
  isClosed ? this-&gt;Close() : this-&gt;Open();
}</span>

mitk::ContourElement::VertexListType mitk::ContourElement::GetControlVertices() const
<span style = "background-color:#fdd">{
  VertexListType controlVertices;</span>

<span style = "background-color:#fdd">  std::copy_if(
    this-&gt;m_Vertices.begin(), this-&gt;m_Vertices.end(), std::back_inserter(controlVertices), [](const VertexType *v) {
      return v-&gt;IsControlPoint;
    });</span>

<span style = "background-color:#fdd">  return controlVertices;
}</span>

void mitk::ContourElement::Concatenate(const mitk::ContourElement *other, bool check)
<span style = "background-color:#fdd">{
  if (other-&gt;GetSize() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    for (const auto &amp;sourceVertex : other-&gt;m_Vertices)</span>
    {
<span style = "background-color:#fdd">      if (check)</span>
      {
<span style = "background-color:#fdd">        auto finding =
          std::find_if(this-&gt;m_Vertices.begin(), this-&gt;m_Vertices.end(), [sourceVertex](const VertexType *v) {
            return sourceVertex-&gt;Coordinates == v-&gt;Coordinates;
          });</span>

<span style = "background-color:#fdd">        if (finding == this-&gt;m_Vertices.end())</span>
        {
<span style = "background-color:#fdd">          this-&gt;m_Vertices.push_back(new ContourModelVertex(*sourceVertex));</span>
        }
<span style = "background-color:#fdd">      }</span>
      else
      {
<span style = "background-color:#fdd">        this-&gt;m_Vertices.push_back(new ContourModelVertex(*sourceVertex));</span>
      }
<span style = "background-color:#fdd">    }</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::ContourElement::VertexSizeType mitk::ContourElement::GetIndex(const VertexType *vertex) const
<span style = "background-color:#fdd">{
  VertexSizeType result = NPOS;</span>

<span style = "background-color:#fdd">  auto finding = std::find(this-&gt;m_Vertices.begin(), this-&gt;m_Vertices.end(), vertex);</span>

<span style = "background-color:#fdd">  if (finding != this-&gt;m_Vertices.end())</span>
  {
<span style = "background-color:#fdd">    result = finding - this-&gt;m_Vertices.begin();</span>
  }

<span style = "background-color:#fdd">  return result;
}</span>

bool mitk::ContourElement::RemoveVertex(const VertexType *vertex)
<span style = "background-color:#fdd">{
  auto finding = std::find(this-&gt;m_Vertices.begin(), this-&gt;m_Vertices.end(), vertex);</span>

<span style = "background-color:#fdd">  return RemoveVertexByIterator(finding);
}</span>

bool mitk::ContourElement::RemoveVertexAt(VertexSizeType index)
<span style = "background-color:#fdd">{
  if (index &lt; this-&gt;m_Vertices.size())</span>
  {
<span style = "background-color:#fdd">    auto delIter = this-&gt;m_Vertices.begin() + index;
    return RemoveVertexByIterator(delIter);</span>
  }

<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::ContourElement::RemoveVertexAt(const mitk::Point3D &amp;point, double eps)
<span style = "background-color:#fdd">{
  if (eps &gt; 0)</span>
  {
<span style = "background-color:#fdd">    auto finding = std::find_if(this-&gt;m_Vertices.begin(), this-&gt;m_Vertices.end(), [point, eps](const VertexType *v) {
      return v-&gt;Coordinates.EuclideanDistanceTo(point) &lt; eps;
    });</span>

<span style = "background-color:#fdd">    return RemoveVertexByIterator(finding);</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::ContourElement::RemoveVertexByIterator(VertexListType::iterator &amp;iter)
<span style = "background-color:#fdd">{
  if (iter != this-&gt;m_Vertices.end())</span>
  {
<span style = "background-color:#fdd">    delete *iter;
    this-&gt;m_Vertices.erase(iter);
    return true;</span>
  }

<span style = "background-color:#fdd">  return false;
}</span>

void mitk::ContourElement::Clear()
<span style = "background-color:#fdd">{
  for (auto vertex : m_Vertices)</span>
  {
<span style = "background-color:#fdd">    delete vertex;
  }
  this-&gt;m_Vertices.clear();
}</span>

//----------------------------------------------------------------------
void mitk::ContourElement::RedistributeControlVertices(const VertexType *selected, int period)
<span style = "background-color:#fdd">{
  int counter = 0;
  auto _where = this-&gt;m_Vertices.begin();</span>

<span style = "background-color:#fdd">  if (selected != nullptr)</span>
  {
<span style = "background-color:#fdd">    auto finding = std::find(this-&gt;m_Vertices.begin(), this-&gt;m_Vertices.end(), selected);</span>

<span style = "background-color:#fdd">    if (finding != this-&gt;m_Vertices.end())</span>
    {
<span style = "background-color:#fdd">      _where = finding;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  auto _iter = _where;
  while (_iter != this-&gt;m_Vertices.end())</span>
  {
    div_t divresult;
<span style = "background-color:#fdd">    divresult = div(counter, period);
    (*_iter)-&gt;IsControlPoint = (divresult.rem == 0);
    counter++;
    _iter++;
  }</span>

<span style = "background-color:#fdd">  _iter = _where;
  counter = 0;
  while (_iter != this-&gt;m_Vertices.begin())</span>
  {
    div_t divresult;
<span style = "background-color:#fdd">    divresult = div(counter, period);
    (*_iter)-&gt;IsControlPoint = (divresult.rem == 0);
    counter++;
    _iter--;
  }
}</span></pre>
	</body>
</html>