<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkContourModelMapper3D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/
#include &lt;mitkContourModelMapper3D.h&gt;

#include &lt;vtkCellArray.h&gt;
#include &lt;vtkPoints.h&gt;
#include &lt;vtkProperty.h&gt;

mitk::ContourModelMapper3D::ContourModelMapper3D()
<span style = "background-color:#fdd">{
}</span>

mitk::ContourModelMapper3D::~ContourModelMapper3D()
<span style = "background-color:#fdd">{
}</span>

const mitk::ContourModel *mitk::ContourModelMapper3D::GetInput(void)
<span style = "background-color:#fdd">{</span>
  // convient way to get the data from the dataNode
<span style = "background-color:#fdd">  return static_cast&lt;const mitk::ContourModel *&gt;(GetDataNode()-&gt;GetData());
}</span>

vtkProp *mitk::ContourModelMapper3D::GetVtkProp(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{</span>
  // return the actor corresponding to the renderer
<span style = "background-color:#fdd">  return m_LSH.GetLocalStorage(renderer)-&gt;m_Actor;
}</span>

void mitk::ContourModelMapper3D::GenerateDataForRenderer(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{</span>
  /* First convert the contourModel to vtkPolyData, then tube filter it and
   * set it input for our mapper
   */

<span style = "background-color:#fdd">  LocalStorage *localStorage = m_LSH.GetLocalStorage(renderer);</span>

<span style = "background-color:#fdd">  auto *inputContour = static_cast&lt;mitk::ContourModel *&gt;(GetDataNode()-&gt;GetData());</span>

<span style = "background-color:#fdd">  localStorage-&gt;m_OutlinePolyData = this-&gt;CreateVtkPolyDataFromContour(inputContour);</span>

<span style = "background-color:#fdd">  this-&gt;ApplyContourProperties(renderer);</span>

  // tube filter the polyData
<span style = "background-color:#fdd">  localStorage-&gt;m_TubeFilter-&gt;SetInputData(localStorage-&gt;m_OutlinePolyData);</span>

<span style = "background-color:#fdd">  float lineWidth(1.0);
  if (this-&gt;GetDataNode()-&gt;GetFloatProperty("contour.3D.width", lineWidth, renderer))</span>
  {
<span style = "background-color:#fdd">    localStorage-&gt;m_TubeFilter-&gt;SetRadius(lineWidth);
  }</span>
  else
  {
<span style = "background-color:#fdd">    localStorage-&gt;m_TubeFilter-&gt;SetRadius(0.5);</span>
  }
<span style = "background-color:#fdd">  localStorage-&gt;m_TubeFilter-&gt;CappingOn();
  localStorage-&gt;m_TubeFilter-&gt;SetNumberOfSides(10);
  localStorage-&gt;m_TubeFilter-&gt;Update();
  localStorage-&gt;m_Mapper-&gt;SetInputConnection(localStorage-&gt;m_TubeFilter-&gt;GetOutputPort());
}</span>

void mitk::ContourModelMapper3D::Update(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  bool visible = true;
  GetDataNode()-&gt;GetVisibility(visible, renderer, "visible");</span>

<span style = "background-color:#fdd">  auto *data = static_cast&lt;mitk::ContourModel *&gt;(GetDataNode()-&gt;GetData());
  if (data == nullptr)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // Calculate time step of the input data for the specified renderer (integer value)
<span style = "background-color:#fdd">  this-&gt;CalculateTimeStep(renderer);</span>

<span style = "background-color:#fdd">  LocalStorage *localStorage = m_LSH.GetLocalStorage(renderer);</span>
  // Check if time step is valid
<span style = "background-color:#fdd">  const TimeGeometry *dataTimeGeometry = data-&gt;GetTimeGeometry();</span>
  if ((dataTimeGeometry == nullptr) || (dataTimeGeometry-&gt;CountTimeSteps() == 0) ||
<span style = "background-color:#fdd">      (!dataTimeGeometry-&gt;IsValidTimePoint(renderer-&gt;GetTime())) || (this-&gt;GetTimestep() == -1))</span>
  {
    // clear the rendered polydata
<span style = "background-color:#fdd">    localStorage-&gt;m_Mapper-&gt;SetInputData(vtkSmartPointer&lt;vtkPolyData&gt;::New());
    return;</span>
  }

<span style = "background-color:#fdd">  const DataNode *node = this-&gt;GetDataNode();
  data-&gt;UpdateOutputInformation();</span>

  // check if something important has changed and we need to rerender
  if ((localStorage-&gt;m_LastUpdateTime &lt; node-&gt;GetMTime()) // was the node modified?
      ||
      (localStorage-&gt;m_LastUpdateTime &lt; data-&gt;GetPipelineMTime()) // Was the data modified?
      ||
      (localStorage-&gt;m_LastUpdateTime &lt;
       renderer-&gt;GetCurrentWorldPlaneGeometryUpdateTime()) // was the geometry modified?
      ||
      (localStorage-&gt;m_LastUpdateTime &lt; renderer-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetMTime()) ||
      (localStorage-&gt;m_LastUpdateTime &lt; node-&gt;GetPropertyList()-&gt;GetMTime()) // was a property modified?
<span style = "background-color:#fdd">      ||</span>
      (localStorage-&gt;m_LastUpdateTime &lt; node-&gt;GetPropertyList(renderer)-&gt;GetMTime()))
  {
<span style = "background-color:#fdd">    this-&gt;GenerateDataForRenderer(renderer);</span>
  }

  // since we have checked that nothing important has changed, we can set
  // m_LastUpdateTime to the current time
<span style = "background-color:#fdd">  localStorage-&gt;m_LastUpdateTime.Modified();
}</span>

vtkSmartPointer&lt;vtkPolyData&gt; mitk::ContourModelMapper3D::CreateVtkPolyDataFromContour(mitk::ContourModel *inputContour)
<span style = "background-color:#fdd">{
  const auto timestep = this-&gt;GetTimestep();</span>

  // the points to draw
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPoints&gt; points = vtkSmartPointer&lt;vtkPoints&gt;::New();</span>
  // the lines to connect the points
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkCellArray&gt; lines = vtkSmartPointer&lt;vtkCellArray&gt;::New();</span>
  // Create a polydata to store everything in
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPolyData&gt; polyData = vtkSmartPointer&lt;vtkPolyData&gt;::New();</span>

  // iterate over the control points
<span style = "background-color:#fdd">  auto current = inputContour-&gt;IteratorBegin(timestep);
  auto next = inputContour-&gt;IteratorBegin(timestep);
  if (next != inputContour-&gt;IteratorEnd(timestep))</span>
  {
<span style = "background-color:#fdd">    next++;</span>

<span style = "background-color:#fdd">    auto end = inputContour-&gt;IteratorEnd(timestep);</span>

<span style = "background-color:#fdd">    while (next != end)</span>
    {
<span style = "background-color:#fdd">      mitk::ContourModel::VertexType *currentControlPoint = *current;
      mitk::ContourModel::VertexType *nextControlPoint = *next;</span>

<span style = "background-color:#fdd">      if (!(currentControlPoint-&gt;Coordinates[0] == nextControlPoint-&gt;Coordinates[0] &amp;&amp;</span>
            currentControlPoint-&gt;Coordinates[1] == nextControlPoint-&gt;Coordinates[1] &amp;&amp;
            currentControlPoint-&gt;Coordinates[2] == nextControlPoint-&gt;Coordinates[2]))
      {
<span style = "background-color:#fdd">        vtkIdType p1 = points-&gt;InsertNextPoint(currentControlPoint-&gt;Coordinates[0],</span>
                                               currentControlPoint-&gt;Coordinates[1],
                                               currentControlPoint-&gt;Coordinates[2]);
<span style = "background-color:#fdd">        vtkIdType p2 = points-&gt;InsertNextPoint(</span>
          nextControlPoint-&gt;Coordinates[0], nextControlPoint-&gt;Coordinates[1], nextControlPoint-&gt;Coordinates[2]);
        // add the line between both contorlPoints
<span style = "background-color:#fdd">        lines-&gt;InsertNextCell(2);
        lines-&gt;InsertCellPoint(p1);
        lines-&gt;InsertCellPoint(p2);</span>
      }
<span style = "background-color:#fdd">      current++;
      next++;
    }</span>

<span style = "background-color:#fdd">    if (inputContour-&gt;IsClosed(timestep))</span>
    {
      // If the contour is closed add a line from the last to the first control point
<span style = "background-color:#fdd">      mitk::ContourModel::VertexType *firstControlPoint = *(inputContour-&gt;IteratorBegin(timestep));
      mitk::ContourModel::VertexType *lastControlPoint = *(--(inputContour-&gt;IteratorEnd(timestep)));</span>
      if (lastControlPoint-&gt;Coordinates[0] != firstControlPoint-&gt;Coordinates[0] ||
<span style = "background-color:#fdd">          lastControlPoint-&gt;Coordinates[1] != firstControlPoint-&gt;Coordinates[1] ||</span>
          lastControlPoint-&gt;Coordinates[2] != firstControlPoint-&gt;Coordinates[2])
      {
<span style = "background-color:#fdd">        vtkIdType p2 = points-&gt;InsertNextPoint(</span>
          lastControlPoint-&gt;Coordinates[0], lastControlPoint-&gt;Coordinates[1], lastControlPoint-&gt;Coordinates[2]);
<span style = "background-color:#fdd">        vtkIdType p1 = points-&gt;InsertNextPoint(</span>
          firstControlPoint-&gt;Coordinates[0], firstControlPoint-&gt;Coordinates[1], firstControlPoint-&gt;Coordinates[2]);

        // add the line to the cellArray
<span style = "background-color:#fdd">        lines-&gt;InsertNextCell(2);
        lines-&gt;InsertCellPoint(p1);
        lines-&gt;InsertCellPoint(p2);</span>
      }
    }

    // Add the points to the dataset
<span style = "background-color:#fdd">    polyData-&gt;SetPoints(points);</span>
    // Add the lines to the dataset
<span style = "background-color:#fdd">    polyData-&gt;SetLines(lines);
  }
  return polyData;
}</span>

void mitk::ContourModelMapper3D::ApplyContourProperties(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  LocalStorage *localStorage = m_LSH.GetLocalStorage(renderer);</span>

<span style = "background-color:#fdd">  mitk::ColorProperty::Pointer colorprop =</span>
    dynamic_cast&lt;mitk::ColorProperty *&gt;(GetDataNode()-&gt;GetProperty("contour.color", renderer));
<span style = "background-color:#fdd">  if (colorprop)</span>
  {
    // set the color of the contour
<span style = "background-color:#fdd">    double red = colorprop-&gt;GetColor().GetRed();
    double green = colorprop-&gt;GetColor().GetGreen();
    double blue = colorprop-&gt;GetColor().GetBlue();
    localStorage-&gt;m_Actor-&gt;GetProperty()-&gt;SetColor(red, green, blue);</span>
  }
<span style = "background-color:#fdd">}</span>

/*+++++++++++++++++++ LocalStorage part +++++++++++++++++++++++++*/

mitk::ContourModelMapper3D::LocalStorage *mitk::ContourModelMapper3D::GetLocalStorage(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  return m_LSH.GetLocalStorage(renderer);
}</span>

mitk::ContourModelMapper3D::LocalStorage::LocalStorage()
<span style = "background-color:#fdd">{
  m_Mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
  m_Actor = vtkSmartPointer&lt;vtkActor&gt;::New();
  m_OutlinePolyData = vtkSmartPointer&lt;vtkPolyData&gt;::New();
  m_TubeFilter = vtkSmartPointer&lt;vtkTubeFilter&gt;::New();</span>

  // set the mapper for the actor
<span style = "background-color:#fdd">  m_Actor-&gt;SetMapper(m_Mapper);
}</span>

void mitk::ContourModelMapper3D::SetDefaultProperties(mitk::DataNode *node,
                                                      mitk::BaseRenderer *renderer,
                                                      bool overwrite)
<span style = "background-color:#fdd">{
  node-&gt;AddProperty("color", ColorProperty::New(1.0, 0.0, 0.0), renderer, overwrite);
  node-&gt;AddProperty("contour.3D.width", mitk::FloatProperty::New(0.5), renderer, overwrite);</span>

<span style = "background-color:#fdd">  Superclass::SetDefaultProperties(node, renderer, overwrite);
}</span></pre>
	</body>
</html>