<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNDITrackingDevice.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkNDITrackingDevice.h"
#include "mitkIGTTimeStamp.h"
#include "mitkIGTHardwareException.h"
#include &lt;cstdio&gt;

#include &lt;itksys/SystemTools.hxx&gt;

#include &lt;mitkUnspecifiedTrackingTypeInformation.h&gt;

#include &lt;mitkNDIPolarisTypeInformation.h&gt;
#include &lt;mitkNDIAuroraTypeInformation.h&gt;

// vtk
#include &lt;vtkSphereSource.h&gt;

const unsigned char CR = 0xD; // == '\r' - carriage return
const unsigned char LF = 0xA; // == '\n' - line feed

mitk::NDITrackingDevice::NDITrackingDevice() :
<span style = "background-color:#fdd">TrackingDevice(), m_DeviceName(""), m_PortNumber(mitk::SerialCommunication::COM5), m_BaudRate(mitk::SerialCommunication::BaudRate9600),
m_DataBits(mitk::SerialCommunication::DataBits8), m_Parity(mitk::SerialCommunication::None), m_StopBits(mitk::SerialCommunication::StopBits1),
m_HardwareHandshake(mitk::SerialCommunication::HardwareHandshakeOff),
m_IlluminationActivationRate(Hz20), m_DataTransferMode(TX), m_6DTools(),
m_SerialCommunication(nullptr), m_DeviceProtocol(nullptr),
m_OperationMode(ToolTracking6D), m_MarkerPoints()
{
  m_Data = mitk::UnspecifiedTrackingTypeInformation::GetDeviceDataUnspecified();
  m_6DTools.clear();
  m_DeviceProtocol = NDIProtocol::New();
  m_DeviceProtocol-&gt;SetTrackingDevice(this);
  m_DeviceProtocol-&gt;UseCRCOn();
  m_MarkerPoints.reserve(50);   // a maximum of 50 marker positions can be reported by the tracking device
}</span>

bool mitk::NDITrackingDevice::UpdateTool(mitk::TrackingTool* tool)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)</span>
  {
<span style = "background-color:#fdd">    mitk::NDIPassiveTool* ndiTool = dynamic_cast&lt;mitk::NDIPassiveTool*&gt;(tool);
    if (ndiTool == nullptr)
      return false;</span>

<span style = "background-color:#fdd">    std::string portHandle = ndiTool-&gt;GetPortHandle();</span>

    //return false if the SROM Data has not been set
<span style = "background-color:#fdd">    if (ndiTool-&gt;GetSROMData() == nullptr)
      return false;</span>

    NDIErrorCode returnvalue;
<span style = "background-color:#fdd">    returnvalue = m_DeviceProtocol-&gt;PVWR(&amp;portHandle, ndiTool-&gt;GetSROMData(), ndiTool-&gt;GetSROMDataLength());
    if (returnvalue != NDIOKAY)
      return false;
    returnvalue = m_DeviceProtocol-&gt;PINIT(&amp;portHandle);
    if (returnvalue != NDIOKAY)
      return false;
    returnvalue = m_DeviceProtocol-&gt;PENA(&amp;portHandle, ndiTool-&gt;GetTrackingPriority()); // Enable tool
    if (returnvalue != NDIOKAY)
      return false;</span>

<span style = "background-color:#fdd">    return true;
  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NDITrackingDevice::SetRotationMode(RotationMode r)
<span style = "background-color:#fdd">{
  m_RotationMode = r;
}</span>

mitk::NDITrackingDevice::~NDITrackingDevice()
<span style = "background-color:#fdd">{</span>
  /* stop tracking and disconnect from tracking device */
<span style = "background-color:#fdd">  if (GetState() == Tracking)</span>
  {
<span style = "background-color:#fdd">    this-&gt;StopTracking();</span>
  }
<span style = "background-color:#fdd">  if (GetState() == Ready)</span>
  {
<span style = "background-color:#fdd">    this-&gt;CloseConnection();</span>
  }
  /* cleanup tracking thread */
<span style = "background-color:#fdd">  if (m_Thread.joinable())
    m_Thread.join();</span>

  /* free serial communication interface */
<span style = "background-color:#fdd">  if (m_SerialCommunication.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    m_SerialCommunication-&gt;ClearReceiveBuffer();
    m_SerialCommunication-&gt;ClearSendBuffer();
    m_SerialCommunication-&gt;CloseConnection();
    m_SerialCommunication = nullptr;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NDITrackingDevice::SetPortNumber(const PortNumber _arg)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)
    return;
  itkDebugMacro("setting PortNumber to " &lt;&lt; _arg);
  if (this-&gt;m_PortNumber != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_PortNumber = _arg;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NDITrackingDevice::SetDeviceName(std::string _arg)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)
    return;
  itkDebugMacro("setting eviceName to " &lt;&lt; _arg);
  if (this-&gt;m_DeviceName != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_DeviceName = _arg;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NDITrackingDevice::SetBaudRate(const BaudRate _arg)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)
    return;
  itkDebugMacro("setting BaudRate to " &lt;&lt; _arg);
  if (this-&gt;m_BaudRate != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_BaudRate = _arg;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NDITrackingDevice::SetDataBits(const DataBits _arg)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)
    return;
  itkDebugMacro("setting DataBits to " &lt;&lt; _arg);
  if (this-&gt;m_DataBits != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_DataBits = _arg;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NDITrackingDevice::SetParity(const Parity _arg)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)
    return;
  itkDebugMacro("setting Parity to " &lt;&lt; _arg);
  if (this-&gt;m_Parity != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_Parity = _arg;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NDITrackingDevice::SetStopBits(const StopBits _arg)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)
    return;
  itkDebugMacro("setting StopBits to " &lt;&lt; _arg);
  if (this-&gt;m_StopBits != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_StopBits = _arg;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NDITrackingDevice::SetHardwareHandshake(const HardwareHandshake _arg)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)
    return;
  itkDebugMacro("setting HardwareHandshake to " &lt;&lt; _arg);
  if (this-&gt;m_HardwareHandshake != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_HardwareHandshake = _arg;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NDITrackingDevice::SetIlluminationActivationRate(const IlluminationActivationRate _arg)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() == Tracking)
    return;
  itkDebugMacro("setting IlluminationActivationRate to " &lt;&lt; _arg);
  if (this-&gt;m_IlluminationActivationRate != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_IlluminationActivationRate = _arg;
    this-&gt;Modified();
    if (this-&gt;GetState() == Ready)   // if the connection to the tracking system is established, send the new rate to the tracking device too
      m_DeviceProtocol-&gt;IRATE(this-&gt;m_IlluminationActivationRate);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NDITrackingDevice::SetDataTransferMode(const DataTransferMode _arg)
<span style = "background-color:#fdd">{
  itkDebugMacro("setting DataTransferMode to " &lt;&lt; _arg);
  if (this-&gt;m_DataTransferMode != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_DataTransferMode = _arg;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::NDIErrorCode mitk::NDITrackingDevice::Send(const std::string* input, bool addCRC)
<span style = "background-color:#fdd">{
  if (input == nullptr)
    return SERIALSENDERROR;</span>

<span style = "background-color:#fdd">  std::string message;</span>

<span style = "background-color:#fdd">  if (addCRC == true)
    message = *input + CalcCRC(input) + std::string(1, CR);</span>
  else
<span style = "background-color:#fdd">    message = *input + std::string(1, CR);</span>

  //unsigned int messageLength = message.length() + 1; // +1 for CR

  // Clear send buffer
<span style = "background-color:#fdd">  this-&gt;ClearSendBuffer();</span>
  // Send the date to the device
<span style = "background-color:#fdd">  std::lock_guard&lt;std::mutex&gt; lock(m_SerialCommunicationMutex);
  long returnvalue = m_SerialCommunication-&gt;Send(message);</span>

<span style = "background-color:#fdd">  if (returnvalue == 0)
    return SERIALSENDERROR;</span>
  else
<span style = "background-color:#fdd">    return NDIOKAY;
}</span>

mitk::NDIErrorCode mitk::NDITrackingDevice::Receive(std::string* answer, unsigned int numberOfBytes)
<span style = "background-color:#fdd">{
  if (answer == nullptr)
    return SERIALRECEIVEERROR;</span>

<span style = "background-color:#fdd">  std::lock_guard&lt;std::mutex&gt; lock(m_SerialCommunicationMutex);
  long returnvalue = m_SerialCommunication-&gt;Receive(*answer, numberOfBytes);  // never read more bytes than the device has send, the function will block until enough bytes are send...</span>

<span style = "background-color:#fdd">  if (returnvalue == 0)
    return SERIALRECEIVEERROR;</span>
  else
<span style = "background-color:#fdd">    return NDIOKAY;
}</span>

mitk::NDIErrorCode mitk::NDITrackingDevice::ReceiveByte(char* answer)
<span style = "background-color:#fdd">{
  if (answer == nullptr)
    return SERIALRECEIVEERROR;</span>

<span style = "background-color:#fdd">  std::string m;</span>

<span style = "background-color:#fdd">  std::lock_guard&lt;std::mutex&gt; lock(m_SerialCommunicationMutex);</span>

<span style = "background-color:#fdd">  long returnvalue = m_SerialCommunication-&gt;Receive(m, 1);</span>

<span style = "background-color:#fdd">  if ((returnvalue == 0) || (m.size() != 1))
    return SERIALRECEIVEERROR;</span>

<span style = "background-color:#fdd">  *answer = m.at(0);
  return NDIOKAY;
}</span>

mitk::NDIErrorCode mitk::NDITrackingDevice::ReceiveLine(std::string* answer)
<span style = "background-color:#fdd">{
  if (answer == nullptr)
    return SERIALRECEIVEERROR;</span>

<span style = "background-color:#fdd">  std::string m;</span>

<span style = "background-color:#fdd">  std::lock_guard&lt;std::mutex&gt; lock(m_SerialCommunicationMutex);</span>

  do
  {
<span style = "background-color:#fdd">    long returnvalue = m_SerialCommunication-&gt;Receive(m, 1);
    if ((returnvalue == 0) || (m.size() != 1))
      return SERIALRECEIVEERROR;
    *answer += m;
  } while (m.at(0) != LF);
  return NDIOKAY;
}</span>

void mitk::NDITrackingDevice::ClearSendBuffer()
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_SerialCommunicationMutex);
  m_SerialCommunication-&gt;ClearSendBuffer();
}</span>

void mitk::NDITrackingDevice::ClearReceiveBuffer()
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_SerialCommunicationMutex);
  m_SerialCommunication-&gt;ClearReceiveBuffer();
}</span>

const std::string mitk::NDITrackingDevice::CalcCRC(const std::string* input)
<span style = "background-color:#fdd">{
  if (input == nullptr)
    return "";</span>
  /* the crc16 calculation code is taken from the NDI API guide example code section */
  static int oddparity[16] = { 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0 };
  unsigned int data;  // copy of the input string's current character
<span style = "background-color:#fdd">  unsigned int crcValue = 0;  // the crc value is stored here
  unsigned int* puCRC16 = &amp;crcValue;  // the algorithm uses a pointer to crcValue, so it's easier to provide that than to change the algorithm
  for (unsigned int i = 0; i &lt; input-&gt;length(); i++)</span>
  {
<span style = "background-color:#fdd">    data = (*input)[i];
    data = (data ^ (*(puCRC16)&amp; 0xff)) &amp; 0xff;
    *puCRC16 &gt;&gt;= 8;
    if (oddparity[data &amp; 0x0f] ^ oddparity[data &gt;&gt; 4])</span>
    {
<span style = "background-color:#fdd">      *(puCRC16) ^= 0xc001;</span>
    }
<span style = "background-color:#fdd">    data &lt;&lt;= 6;
    *puCRC16 ^= data;
    data &lt;&lt;= 1;
    *puCRC16 ^= data;
  }</span>
  // crcValue contains now the CRC16 value. Convert it to a string and return it
  char returnvalue[13];
<span style = "background-color:#fdd">  sprintf(returnvalue, "%04X", crcValue);  // 4 hexadecimal digit with uppercase format
  return std::string(returnvalue);
}</span>

bool mitk::NDITrackingDevice::OpenConnection()
<span style = "background-color:#fdd">{</span>
  //this-&gt;m_ModeMutex.lock();
<span style = "background-color:#fdd">  if (this-&gt;GetState() != Setup)</span>
  {
<span style = "background-color:#fdd">    mitkThrowException(mitk::IGTException) &lt;&lt; "Can only try to open the connection if in setup mode";</span>
  }

<span style = "background-color:#fdd">  m_SerialCommunication = mitk::SerialCommunication::New();</span>

  /* init local com port to standard com settings for a NDI tracking device:
  9600 baud, 8 data bits, no parity, 1 stop bit, no hardware handshake */
<span style = "background-color:#fdd">  if (m_DeviceName.empty())
    m_SerialCommunication-&gt;SetPortNumber(m_PortNumber);</span>
  else
<span style = "background-color:#fdd">    m_SerialCommunication-&gt;SetDeviceName(m_DeviceName);
  m_SerialCommunication-&gt;SetBaudRate(mitk::SerialCommunication::BaudRate9600);
  m_SerialCommunication-&gt;SetDataBits(mitk::SerialCommunication::DataBits8);
  m_SerialCommunication-&gt;SetParity(mitk::SerialCommunication::None);
  m_SerialCommunication-&gt;SetStopBits(mitk::SerialCommunication::StopBits1);
  m_SerialCommunication-&gt;SetSendTimeout(5000);
  m_SerialCommunication-&gt;SetReceiveTimeout(5000);
  if (m_SerialCommunication-&gt;OpenConnection() == 0) // 0 == ERROR_VALUE</span>
  {
<span style = "background-color:#fdd">    m_SerialCommunication-&gt;CloseConnection();
    m_SerialCommunication = nullptr;
    mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Can not open serial port";</span>
  }

  /* Reset Tracking device by sending a serial break for 500ms */
<span style = "background-color:#fdd">  m_SerialCommunication-&gt;SendBreak(400);</span>

  /* Read answer from tracking device (RESETBE6F) */
<span style = "background-color:#fdd">  static const std::string reset("RESETBE6F\r");
  std::string answer = "";
  this-&gt;Receive(&amp;answer, reset.length());  // read answer (should be RESETBE6F)
  this-&gt;ClearReceiveBuffer();     // flush the receive buffer of all remaining data (carriage return, strings other than reset
  if (reset.compare(answer) != 0)  // check for RESETBE6F</span>
  {
<span style = "background-color:#fdd">    if (m_SerialCommunication.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      m_SerialCommunication-&gt;CloseConnection();
      m_SerialCommunication = nullptr;</span>
    }
<span style = "background-color:#fdd">    mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Hardware Reset of tracking device did not work";</span>
  }

  /* Now the tracking device isSetData reset, start initialization */
  NDIErrorCode returnvalue;

  /* set device com settings to new values and wait for the device to change them */
<span style = "background-color:#fdd">  returnvalue = m_DeviceProtocol-&gt;COMM(m_BaudRate, m_DataBits, m_Parity, m_StopBits, m_HardwareHandshake);</span>

<span style = "background-color:#fdd">  if (returnvalue != NDIOKAY)</span>
  {
<span style = "background-color:#fdd">    mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not set comm settings in trackingdevice";</span>
  }

  //after changing COMM wait at least 100ms according to NDI Api documentation page 31
<span style = "background-color:#fdd">  itksys::SystemTools::Delay(500);</span>

  /* now change local com settings accordingly */
<span style = "background-color:#fdd">  m_SerialCommunication-&gt;CloseConnection();
  m_SerialCommunication-&gt;SetBaudRate(m_BaudRate);
  m_SerialCommunication-&gt;SetDataBits(m_DataBits);
  m_SerialCommunication-&gt;SetParity(m_Parity);
  m_SerialCommunication-&gt;SetStopBits(m_StopBits);
  m_SerialCommunication-&gt;SetHardwareHandshake(m_HardwareHandshake);
  m_SerialCommunication-&gt;SetSendTimeout(5000);
  m_SerialCommunication-&gt;SetReceiveTimeout(5000);
  m_SerialCommunication-&gt;OpenConnection();</span>

  /* initialize the tracking device */
<span style = "background-color:#fdd">  returnvalue = m_DeviceProtocol-&gt;INIT();
  if (returnvalue != NDIOKAY)</span>
  {
<span style = "background-color:#fdd">    mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not initialize the tracking device";</span>
  }

<span style = "background-color:#fdd">  if (this-&gt;GetType() == mitk::UnspecifiedTrackingTypeInformation::GetTrackingDeviceName())  // if the type of tracking device is not specified, try to query the connected device</span>
  {
<span style = "background-color:#fdd">    mitk::TrackingDeviceType deviceType;
    returnvalue = m_DeviceProtocol-&gt;VER(deviceType);
    if ((returnvalue != NDIOKAY) || (deviceType == mitk::UnspecifiedTrackingTypeInformation::GetTrackingDeviceName()))</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not determine tracking device type. Please set manually and try again.";</span>
    }
<span style = "background-color:#fdd">    this-&gt;SetType(deviceType);
  }</span>

  /****  Optional Polaris specific code, Work in progress
  // start diagnostic mode
  returnvalue = m_DeviceProtocol-&gt;DSTART();
  if (returnvalue != NDIOKAY)
  {
  this-&gt;SetErrorMessage("Could not start diagnostic mode");
  return false;
  }
  else    // we are in diagnostic mode
  {
  // initialize extensive IR checking
  returnvalue = m_DeviceProtocol-&gt;IRINIT();
  if (returnvalue != NDIOKAY)
  {
  this-&gt;SetErrorMessage("Could not initialize intense infrared light checking");
  return false;
  }
  bool intenseIR = false;
  returnvalue = m_DeviceProtocol-&gt;IRCHK(&amp;intenseIR);
  if (returnvalue != NDIOKAY)
  {
  this-&gt;SetErrorMessage("Could not execute intense infrared light checking");
  return false;
  }
  if (intenseIR == true)
  // do something - warn the user, raise exception, write to protocol or similar
  std::cout &lt;&lt; "Warning: Intense infrared light detected. Accurate tracking will probably not be possible.\n";

  // stop diagnictic mode
  returnvalue = m_DeviceProtocol-&gt;DSTOP();
  if (returnvalue != NDIOKAY)
  {
  this-&gt;SetErrorMessage("Could not stop diagnostic mode");
  return false;
  }
  }
  *** end of optional polaris code ***/

  /**
  * now add tools to the tracking system
  **/

  /* First, check if the tracking device has port handles that need to be freed and free them */
<span style = "background-color:#fdd">  returnvalue = FreePortHandles();</span>
  // non-critical, therefore no error handling

  /**
  * POLARIS: initialize the tools that were added manually
  **/
  {
<span style = "background-color:#fdd">    std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex);
    std::string portHandle;
    auto endIt = m_6DTools.end();
    for (auto it = m_6DTools.begin(); it != endIt; ++it)</span>
    {
      /* get a port handle for the tool */
<span style = "background-color:#fdd">      returnvalue = m_DeviceProtocol-&gt;PHRQ(&amp;portHandle);
      if (returnvalue == NDIOKAY)</span>
      {
<span style = "background-color:#fdd">        (*it)-&gt;SetPortHandle(portHandle.c_str());</span>
        /* now write the SROM file of the tool to the tracking system using PVWR */
<span style = "background-color:#fdd">        if (this-&gt;m_Data.Line == mitk::NDIPolarisTypeInformation::GetTrackingDeviceName())</span>
        {
<span style = "background-color:#fdd">          returnvalue = m_DeviceProtocol-&gt;PVWR(&amp;portHandle, (*it)-&gt;GetSROMData(), (*it)-&gt;GetSROMDataLength());
          if (returnvalue != NDIOKAY)</span>
          {
<span style = "background-color:#fdd">            mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not write SROM file for tool '") + (*it)-&gt;GetToolName() + std::string("' to tracking device")).c_str();</span>
          }

<span style = "background-color:#fdd">          returnvalue = m_DeviceProtocol-&gt;PINIT(&amp;portHandle);
          if (returnvalue != NDIOKAY)</span>
          {
<span style = "background-color:#fdd">            mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not initialize tool '") + (*it)-&gt;GetToolName()).c_str();</span>
          }

<span style = "background-color:#fdd">          if ((*it)-&gt;IsEnabled() == true)</span>
          {
<span style = "background-color:#fdd">            returnvalue = m_DeviceProtocol-&gt;PENA(&amp;portHandle, (*it)-&gt;GetTrackingPriority()); // Enable tool
            if (returnvalue != NDIOKAY)</span>
            {
<span style = "background-color:#fdd">              mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not enable port '") + portHandle +</span>
                std::string("' for tool '") + (*it)-&gt;GetToolName() + std::string("'")).c_str();
            }
          }
        }
<span style = "background-color:#fdd">      }
    }
  } // end of toolsmutexlockholder scope</span>

  /* check for wired tools and add them too */
<span style = "background-color:#fdd">  if (this-&gt;DiscoverWiredTools() == false)  // query the tracking device for wired tools and add them to our tool list
    return false; // \TODO: could we continue anyways?</span>

  /*POLARIS: set the illuminator activation rate */
<span style = "background-color:#fdd">  if (this-&gt;m_Data.Line == mitk::NDIPolarisTypeInformation::GetTrackingDeviceName())</span>
  {
<span style = "background-color:#fdd">    returnvalue = m_DeviceProtocol-&gt;IRATE(this-&gt;m_IlluminationActivationRate);
    if (returnvalue != NDIOKAY)</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not set the illuminator activation rate";</span>
    }
  }
  /* finish  - now all tools should be added, initialized and enabled, so that tracking can be started */
<span style = "background-color:#fdd">  this-&gt;SetState(Ready);</span>
  try
  {
<span style = "background-color:#fdd">    SetVolume(this-&gt;m_Data);</span>
  }
  catch (const mitk::IGTHardwareException&amp; e)
<span style = "background-color:#fdd">  {
    MITK_WARN &lt;&lt; e.GetDescription();
  }</span>

<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::NDITrackingDevice::InitializeWiredTools()
<span style = "background-color:#fdd">{</span>
  NDIErrorCode returnvalue;
<span style = "background-color:#fdd">  std::string portHandle;
  returnvalue = m_DeviceProtocol-&gt;PHSR(OCCUPIED, &amp;portHandle);</span>

<span style = "background-color:#fdd">  if (returnvalue != NDIOKAY)</span>
  {
<span style = "background-color:#fdd">    mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not obtain a list of port handles that are connected";</span>
  }

  /* if there are port handles that need to be initialized, initialize them. Furthermore instantiate tools for each handle that has no tool yet. */
<span style = "background-color:#fdd">  std::string ph;</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; portHandle.size(); i += 2)</span>
  {
<span style = "background-color:#fdd">    ph = portHandle.substr(i, 2);
    mitk::NDIPassiveTool* pt = this-&gt;GetInternalTool(ph);
    if (pt == nullptr) // if we don't have a tool, something is wrong. Tools should be discovered first by calling DiscoverWiredTools()
      continue;</span>

<span style = "background-color:#fdd">    if (pt-&gt;GetSROMData() == nullptr)
      continue;</span>

<span style = "background-color:#fdd">    returnvalue = m_DeviceProtocol-&gt;PVWR(&amp;ph, pt-&gt;GetSROMData(), pt-&gt;GetSROMDataLength());
    if (returnvalue != NDIOKAY)</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not write SROM file for tool '") + pt-&gt;GetToolName() + std::string("' to tracking device")).c_str();</span>
    }

<span style = "background-color:#fdd">    returnvalue = m_DeviceProtocol-&gt;PINIT(&amp;ph);
    if (returnvalue != NDIOKAY)</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not initialize tool '") + pt-&gt;GetToolName()).c_str();</span>
    }

<span style = "background-color:#fdd">    if (pt-&gt;IsEnabled() == true)</span>
    {
<span style = "background-color:#fdd">      returnvalue = m_DeviceProtocol-&gt;PENA(&amp;ph, pt-&gt;GetTrackingPriority()); // Enable tool
      if (returnvalue != NDIOKAY)</span>
      {
<span style = "background-color:#fdd">        mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not enable port '") + portHandle +</span>
          std::string("' for tool '") + pt-&gt;GetToolName() + std::string("'")).c_str();
      }
    }
<span style = "background-color:#fdd">  }
  return true;
}</span>

mitk::TrackingDeviceType mitk::NDITrackingDevice::TestConnection()
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)</span>
  {
<span style = "background-color:#fdd">    return mitk::UnspecifiedTrackingTypeInformation::GetTrackingDeviceName();</span>
  }

<span style = "background-color:#fdd">  m_SerialCommunication = mitk::SerialCommunication::New();</span>
  //m_DeviceProtocol =  mitk::NDIProtocol::New();
  //m_DeviceProtocol-&gt;SetTrackingDevice(this);
  //m_DeviceProtocol-&gt;UseCRCOn();
  /* init local com port to standard com settings for a NDI tracking device:
  9600 baud, 8 data bits, no parity, 1 stop bit, no hardware handshake
  */
<span style = "background-color:#fdd">  if (m_DeviceName.empty())
    m_SerialCommunication-&gt;SetPortNumber(m_PortNumber);</span>
  else
<span style = "background-color:#fdd">    m_SerialCommunication-&gt;SetDeviceName(m_DeviceName);</span>

<span style = "background-color:#fdd">  m_SerialCommunication-&gt;SetBaudRate(mitk::SerialCommunication::BaudRate9600);
  m_SerialCommunication-&gt;SetDataBits(mitk::SerialCommunication::DataBits8);
  m_SerialCommunication-&gt;SetParity(mitk::SerialCommunication::None);
  m_SerialCommunication-&gt;SetStopBits(mitk::SerialCommunication::StopBits1);
  m_SerialCommunication-&gt;SetSendTimeout(5000);
  m_SerialCommunication-&gt;SetReceiveTimeout(5000);
  if (m_SerialCommunication-&gt;OpenConnection() == 0) // error</span>
  {
<span style = "background-color:#fdd">    m_SerialCommunication = nullptr;
    return mitk::UnspecifiedTrackingTypeInformation::GetTrackingDeviceName();</span>
  }

  /* Reset Tracking device by sending a serial break for 500ms */
<span style = "background-color:#fdd">  m_SerialCommunication-&gt;SendBreak(400);</span>

  /* Read answer from tracking device (RESETBE6F) */
<span style = "background-color:#fdd">  static const std::string reset("RESETBE6F\r");
  std::string answer = "";
  this-&gt;Receive(&amp;answer, reset.length());  // read answer (should be RESETBE6F)
  this-&gt;ClearReceiveBuffer();     // flush the receive buffer of all remaining data (carriage return, strings other than reset
  if (reset.compare(answer) != 0)  // check for RESETBE6F</span>
  {
<span style = "background-color:#fdd">    m_SerialCommunication-&gt;CloseConnection();
    m_SerialCommunication = nullptr;
    mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Hardware Reset of tracking device did not work";</span>
  }

  /* Now the tracking device is reset, start initialization */
  NDIErrorCode returnvalue;

  /* initialize the tracking device */
  //returnvalue = m_DeviceProtocol-&gt;INIT();
  //if (returnvalue != NDIOKAY)
  //{
  //  this-&gt;SetErrorMessage("Could not initialize the tracking device");
  //  return mitk::TrackingSystemNotSpecified;
  //}

<span style = "background-color:#fdd">  mitk::TrackingDeviceType deviceType;
  returnvalue = m_DeviceProtocol-&gt;VER(deviceType);
  if ((returnvalue != NDIOKAY) || (deviceType == mitk::UnspecifiedTrackingTypeInformation::GetTrackingDeviceName()))</span>
  {
<span style = "background-color:#fdd">    m_SerialCommunication = nullptr;
    return mitk::UnspecifiedTrackingTypeInformation::GetTrackingDeviceName();</span>
  }
<span style = "background-color:#fdd">  m_SerialCommunication = nullptr;
  return deviceType;
}</span>

bool mitk::NDITrackingDevice::CloseConnection()
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)</span>
  {
    //init before closing to force the field generator from aurora to switch itself off
<span style = "background-color:#fdd">    m_DeviceProtocol-&gt;INIT();</span>
    /* close the serial connection */
<span style = "background-color:#fdd">    m_SerialCommunication-&gt;CloseConnection();</span>
    /* invalidate all tools */
<span style = "background-color:#fdd">    this-&gt;InvalidateAll();</span>
    /* return to setup mode */
<span style = "background-color:#fdd">    this-&gt;SetState(Setup);
    m_SerialCommunication = nullptr;</span>
  }
<span style = "background-color:#fdd">  return true;
}</span>

void mitk::NDITrackingDevice::ThreadStartTracking()
<span style = "background-color:#fdd">{
  if (this-&gt;GetOperationMode() == ToolTracking6D)
    this-&gt;TrackTools();             // call TrackTools() from the original object
  else if (this-&gt;GetOperationMode() == MarkerTracking3D)
    this-&gt;TrackMarkerPositions();   // call TrackMarkerPositions() from the original object
  else if (this-&gt;GetOperationMode() == ToolTracking5D)
    this-&gt;TrackMarkerPositions(); // call TrackMarkerPositions() from the original object
  else if (this-&gt;GetOperationMode() == HybridTracking)</span>
  {
<span style = "background-color:#fdd">    this-&gt;TrackToolsAndMarkers();</span>
  }
<span style = "background-color:#fdd">}</span>

bool mitk::NDITrackingDevice::StartTracking()
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Ready)
    return false;</span>

<span style = "background-color:#fdd">  this-&gt;SetState(Tracking);      // go to mode Tracking
  this-&gt;m_StopTrackingMutex.lock();  // update the local copy of m_StopTracking
  this-&gt;m_StopTracking = false;
  this-&gt;m_StopTrackingMutex.unlock();</span>

<span style = "background-color:#fdd">  m_Thread = std::thread(&amp;NDITrackingDevice::ThreadStartTracking, this);    // start a new thread that executes the TrackTools() method
  mitk::IGTTimeStamp::GetInstance()-&gt;Start(this);
  return true;
}</span>

void mitk::NDITrackingDevice::TrackTools()
<span style = "background-color:#fdd">{</span>
  /* lock the TrackingFinishedMutex to signal that the execution rights are now transfered to the tracking thread */
<span style = "background-color:#fdd">  std::lock_guard&lt;std::mutex&gt; lock(m_TrackingFinishedMutex);</span>

<span style = "background-color:#fdd">  if (this-&gt;GetState() != Tracking)
    return;</span>

  NDIErrorCode returnvalue;
<span style = "background-color:#fdd">  returnvalue = m_DeviceProtocol-&gt;TSTART();
  if (returnvalue != NDIOKAY)
    return;</span>

  bool localStopTracking;       // Because m_StopTracking is used by two threads, access has to be guarded by a mutex. To minimize thread locking, a local copy is used here
<span style = "background-color:#fdd">  this-&gt;m_StopTrackingMutex.lock();  // update the local copy of m_StopTracking
  localStopTracking = this-&gt;m_StopTracking;
  this-&gt;m_StopTrackingMutex.unlock();
  while ((this-&gt;GetState() == Tracking) &amp;&amp; (localStopTracking == false))</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;m_DataTransferMode == TX)</span>
    {
<span style = "background-color:#fdd">      returnvalue = this-&gt;m_DeviceProtocol-&gt;TX();
      if (!((returnvalue == NDIOKAY) || (returnvalue == NDICRCERROR) || (returnvalue == NDICRCDOESNOTMATCH))) // right now, do not stop on crc errors
        break;
    }</span>
    else
    {
<span style = "background-color:#fdd">      returnvalue = this-&gt;m_DeviceProtocol-&gt;BX();
      if (returnvalue != NDIOKAY)
        break;</span>
    }
    /* Update the local copy of m_StopTracking */
<span style = "background-color:#fdd">    this-&gt;m_StopTrackingMutex.lock();
    localStopTracking = m_StopTracking;
    this-&gt;m_StopTrackingMutex.unlock();
  }</span>
  /* StopTracking was called, thus the mode should be changed back to Ready now that the tracking loop has ended. */

<span style = "background-color:#fdd">  returnvalue = m_DeviceProtocol-&gt;TSTOP();
  if (returnvalue != NDIOKAY)</span>
  {
<span style = "background-color:#fdd">    mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "An error occured while tracking tools.";</span>
  }

<span style = "background-color:#fdd">  return;       // returning from this function (and ThreadStartTracking()) this will end the thread and transfer control back to main thread by releasing trackingFinishedLockHolder
}</span>

void mitk::NDITrackingDevice::TrackMarkerPositions()
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_TrackingFinishedMutex);</span>

<span style = "background-color:#fdd">  if (m_OperationMode == ToolTracking6D)
    return;</span>

<span style = "background-color:#fdd">  if (this-&gt;GetState() != Tracking)
    return;</span>

  NDIErrorCode returnvalue;

<span style = "background-color:#fdd">  returnvalue = m_DeviceProtocol-&gt;DSTART();   // Start Diagnostic Mode
  if (returnvalue != NDIOKAY)
    return;</span>

  bool localStopTracking;       // Because m_StopTracking is used by two threads, access has to be guarded by a mutex. To minimize thread locking, a local copy is used here
<span style = "background-color:#fdd">  this-&gt;m_StopTrackingMutex.lock();  // update the local copy of m_StopTracking
  localStopTracking = this-&gt;m_StopTracking;
  this-&gt;m_StopTrackingMutex.unlock();
  while ((this-&gt;GetState() == Tracking) &amp;&amp; (localStopTracking == false))</span>
  {
<span style = "background-color:#fdd">    m_MarkerPointsMutex.lock();                                    // lock points data structure
    returnvalue = this-&gt;m_DeviceProtocol-&gt;POS3D(&amp;m_MarkerPoints); // update points data structure with new position data from tracking device
    m_MarkerPointsMutex.unlock();
    if (!((returnvalue == NDIOKAY) || (returnvalue == NDICRCERROR) || (returnvalue == NDICRCDOESNOTMATCH))) // right now, do not stop on crc errors</span>
    {
<span style = "background-color:#fdd">      std::cout &lt;&lt; "Error in POS3D: could not read data. Possibly no markers present." &lt;&lt; std::endl;</span>
    }
    /* Update the local copy of m_StopTracking */
<span style = "background-color:#fdd">    this-&gt;m_StopTrackingMutex.lock();
    localStopTracking = m_StopTracking;
    this-&gt;m_StopTrackingMutex.unlock();</span>

<span style = "background-color:#fdd">    itksys::SystemTools::Delay(1);
  }</span>
  /* StopTracking was called, thus the mode should be changed back to Ready now that the tracking loop has ended. */
<span style = "background-color:#fdd">  returnvalue = m_DeviceProtocol-&gt;DSTOP();
  if (returnvalue != NDIOKAY)
    return;     // how can this thread tell the application, that an error has occured?</span>

<span style = "background-color:#fdd">  this-&gt;SetState(Ready);
  return;       // returning from this function (and ThreadStartTracking()) this will end the thread
}</span>

void mitk::NDITrackingDevice::TrackToolsAndMarkers()
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_TrackingFinishedMutex);
  if (m_OperationMode != HybridTracking)
    return;</span>

  NDIErrorCode returnvalue;

<span style = "background-color:#fdd">  returnvalue = m_DeviceProtocol-&gt;TSTART();   // Start Diagnostic Mode
  if (returnvalue != NDIOKAY)
    return;</span>

  bool localStopTracking;       // Because m_StopTracking is used by two threads, access has to be guarded by a mutex. To minimize thread locking, a local copy is used here
<span style = "background-color:#fdd">  this-&gt;m_StopTrackingMutex.lock();  // update the local copy of m_StopTracking
  localStopTracking = this-&gt;m_StopTracking;
  this-&gt;m_StopTrackingMutex.unlock();
  while ((this-&gt;GetState() == Tracking) &amp;&amp; (localStopTracking == false))</span>
  {
<span style = "background-color:#fdd">    m_MarkerPointsMutex.lock();                                     // lock points data structure
    returnvalue = this-&gt;m_DeviceProtocol-&gt;TX(true, &amp;m_MarkerPoints); // update points data structure with new position data from tracking device
    m_MarkerPointsMutex.unlock();
    if (!((returnvalue == NDIOKAY) || (returnvalue == NDICRCERROR) || (returnvalue == NDICRCDOESNOTMATCH))) // right now, do not stop on crc errors</span>
    {
<span style = "background-color:#fdd">      std::cout &lt;&lt; "Error in TX: could not read data. Possibly no markers present." &lt;&lt; std::endl;</span>
    }
    /* Update the local copy of m_StopTracking */
<span style = "background-color:#fdd">    this-&gt;m_StopTrackingMutex.lock();
    localStopTracking = m_StopTracking;
    this-&gt;m_StopTrackingMutex.unlock();
  }</span>
  /* StopTracking was called, thus the mode should be changed back to Ready now that the tracking loop has ended. */

<span style = "background-color:#fdd">  returnvalue = m_DeviceProtocol-&gt;TSTOP();
  if (returnvalue != NDIOKAY)
    return;     // how can this thread tell the application, that an error has occurred?</span>

<span style = "background-color:#fdd">  this-&gt;SetState(Ready);
  return;       // returning from this function (and ThreadStartTracking()) this will end the thread
}</span>

mitk::TrackingTool* mitk::NDITrackingDevice::GetTool(unsigned int toolNumber) const
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex);
  if (toolNumber &lt; m_6DTools.size())
    return m_6DTools.at(toolNumber);
  return nullptr;
}</span>

mitk::TrackingTool* mitk::NDITrackingDevice::GetToolByName(std::string name) const
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex);
  auto end = m_6DTools.end();
  for (auto iterator = m_6DTools.begin(); iterator != end; ++iterator)
    if (name.compare((*iterator)-&gt;GetToolName()) == 0)
      return *iterator;
  return nullptr;
}</span>

mitk::NDIPassiveTool* mitk::NDITrackingDevice::GetInternalTool(std::string portHandle)
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex);
  auto end = m_6DTools.end();
  for (auto iterator = m_6DTools.begin(); iterator != end; ++iterator)
    if (portHandle.compare((*iterator)-&gt;GetPortHandle()) == 0)
      return *iterator;
  return nullptr;
}</span>

unsigned int mitk::NDITrackingDevice::GetToolCount() const
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex);
  return m_6DTools.size();
}</span>

bool mitk::NDITrackingDevice::Beep(unsigned char count)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Setup)</span>
  {
<span style = "background-color:#fdd">    return (m_DeviceProtocol-&gt;BEEP(count) == NDIOKAY);
  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::TrackingTool* mitk::NDITrackingDevice::AddTool(const char* toolName, const char* fileName, TrackingPriority p /*= NDIPassiveTool::Dynamic*/)
<span style = "background-color:#fdd">{
  mitk::NDIPassiveTool::Pointer t = mitk::NDIPassiveTool::New();
  if (t-&gt;LoadSROMFile(fileName) == false)
    return nullptr;
  t-&gt;SetToolName(toolName);
  t-&gt;SetTrackingPriority(p);
  if (this-&gt;InternalAddTool(t) == false)
    return nullptr;
  return t.GetPointer();
}</span>

bool mitk::NDITrackingDevice::InternalAddTool(mitk::NDIPassiveTool* tool)
<span style = "background-color:#fdd">{
  if (tool == nullptr)
    return false;
  NDIPassiveTool::Pointer p = tool;</span>
  /* if the connection to the tracking device is already established, add the new tool to the device now */
<span style = "background-color:#fdd">  if (this-&gt;GetState() == Ready)</span>
  {
    /* get a port handle for the tool */
<span style = "background-color:#fdd">    std::string newPortHandle;</span>
    NDIErrorCode returnvalue;
<span style = "background-color:#fdd">    returnvalue = m_DeviceProtocol-&gt;PHRQ(&amp;newPortHandle);
    if (returnvalue == NDIOKAY)</span>
    {
<span style = "background-color:#fdd">      p-&gt;SetPortHandle(newPortHandle.c_str());</span>
      /* now write the SROM file of the tool to the tracking system using PVWR */
<span style = "background-color:#fdd">      returnvalue = m_DeviceProtocol-&gt;PVWR(&amp;newPortHandle, p-&gt;GetSROMData(), p-&gt;GetSROMDataLength());
      if (returnvalue != NDIOKAY)</span>
      {
<span style = "background-color:#fdd">        mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not write SROM file for tool '") + p-&gt;GetToolName() + std::string("' to tracking device")).c_str();</span>
      }
      /* initialize the port handle */
<span style = "background-color:#fdd">      returnvalue = m_DeviceProtocol-&gt;PINIT(&amp;newPortHandle);
      if (returnvalue != NDIOKAY)</span>
      {
<span style = "background-color:#fdd">        mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not initialize port '") + newPortHandle +</span>
          std::string("' for tool '") + p-&gt;GetToolName() + std::string("'")).c_str();
      }
      /* enable the port handle */
<span style = "background-color:#fdd">      if (p-&gt;IsEnabled() == true)</span>
      {
<span style = "background-color:#fdd">        returnvalue = m_DeviceProtocol-&gt;PENA(&amp;newPortHandle, p-&gt;GetTrackingPriority()); // Enable tool
        if (returnvalue != NDIOKAY)</span>
        {
<span style = "background-color:#fdd">          mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not enable port '") + newPortHandle +</span>
            std::string("' for tool '") + p-&gt;GetToolName() + std::string("'")).c_str();
        }
      }
    }
    /* now that the tool is added to the device, add it to list too */
<span style = "background-color:#fdd">    m_ToolsMutex.lock();
    this-&gt;m_6DTools.push_back(p);
    m_ToolsMutex.unlock();
    this-&gt;Modified();
    return true;
  }
  else if (this-&gt;GetState() == Setup)</span>
  {
    /* In Setup mode, we only add it to the list, so that OpenConnection() can add it later */
<span style = "background-color:#fdd">    m_ToolsMutex.lock();
    this-&gt;m_6DTools.push_back(p);
    m_ToolsMutex.unlock();
    this-&gt;Modified();
    return true;
  }</span>
  else  // in Tracking mode, no tools can be added
<span style = "background-color:#fdd">    return false;
}</span>

bool mitk::NDITrackingDevice::RemoveTool(mitk::TrackingTool* tool)
<span style = "background-color:#fdd">{
  mitk::NDIPassiveTool* ndiTool = dynamic_cast&lt;mitk::NDIPassiveTool*&gt;(tool);
  if (ndiTool == nullptr)
    return false;</span>

<span style = "background-color:#fdd">  std::string portHandle = ndiTool-&gt;GetPortHandle();</span>
  /* a valid portHandle has length 2. If a valid handle exists, the tool is already added to the tracking device, so we have to remove it there
  if the connection to the tracking device has already been established.
  */
<span style = "background-color:#fdd">  if ((portHandle.length() == 2) &amp;&amp; (this-&gt;GetState() == Ready))  // do not remove a tool in tracking mode</span>
  {
    NDIErrorCode returnvalue;
<span style = "background-color:#fdd">    returnvalue = m_DeviceProtocol-&gt;PHF(&amp;portHandle);
    if (returnvalue != NDIOKAY)
      return false;</span>
    /* Now that the tool is removed from the tracking device, remove it from our tool list too */
<span style = "background-color:#fdd">    std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex);
    auto end = m_6DTools.end();
    for (auto iterator = m_6DTools.begin(); iterator != end; ++iterator)</span>
    {
<span style = "background-color:#fdd">      if (iterator-&gt;GetPointer() == ndiTool)</span>
      {
<span style = "background-color:#fdd">        m_6DTools.erase(iterator);
        this-&gt;Modified();
        return true;
      }
    }
    return false;
  }
  else if (this-&gt;GetState() == Setup)  // in Setup Mode, we are not connected to the tracking device, so we can just remove the tool from the tool list</span>
  {
<span style = "background-color:#fdd">    std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex);
    auto end = m_6DTools.end();
    for (auto iterator = m_6DTools.begin(); iterator != end; ++iterator)</span>
    {
<span style = "background-color:#fdd">      if ((*iterator).GetPointer() == ndiTool)</span>
      {
<span style = "background-color:#fdd">        m_6DTools.erase(iterator);
        this-&gt;Modified();
        return true;
      }
    }
    return false;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

void mitk::NDITrackingDevice::InvalidateAll()
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_ToolsMutex);
  auto end = m_6DTools.end();
  for (auto iterator = m_6DTools.begin(); iterator != end; ++iterator)
    (*iterator)-&gt;SetDataValid(false);
}</span>

bool mitk::NDITrackingDevice::SetOperationMode(OperationMode mode)
<span style = "background-color:#fdd">{
  if (GetState() == Tracking)
    return false;</span>

<span style = "background-color:#fdd">  m_OperationMode = mode;
  return true;
}</span>

mitk::OperationMode mitk::NDITrackingDevice::GetOperationMode()
<span style = "background-color:#fdd">{
  return m_OperationMode;
}</span>

bool mitk::NDITrackingDevice::GetMarkerPositions(MarkerPointContainerType* markerpositions)
<span style = "background-color:#fdd">{
  m_MarkerPointsMutex.lock();
  *markerpositions = m_MarkerPoints;  // copy the internal vector to the one provided
  m_MarkerPointsMutex.unlock();
  return (markerpositions-&gt;size() != 0);
}</span>

bool mitk::NDITrackingDevice::DiscoverWiredTools()
<span style = "background-color:#fdd">{</span>
  /* First, check for disconnected tools and remove them */
<span style = "background-color:#fdd">  this-&gt;FreePortHandles();</span>

  //NDI handling (PHSR 02, PINIT, PHSR 02, PHSR 00) =&gt; all initialized and all handles available
  //creation of MITK tools
  //NDI enable all tools (PENA)
  //NDI get all serial numbers (PHINF)

  /**
  NDI handling (PHSR 02, PINIT, PHSR 02, PHSR 00) =&gt; all initialized and all handles available
  **/

  /* check for occupied port handles on channel 0 */
<span style = "background-color:#fdd">  std::string portHandle;
  NDIErrorCode returnvalue = m_DeviceProtocol-&gt;PHSR(OCCUPIED, &amp;portHandle);</span>

<span style = "background-color:#fdd">  if (returnvalue != NDIOKAY)</span>
  {
<span style = "background-color:#fdd">	  mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not obtain a list of port handles that are connected on channel 0.";</span>
  }

  /* Initialize all port handles on channel 0 */
<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; portHandle.size(); i += 2)</span>
  {
<span style = "background-color:#fdd">     std::string ph = portHandle.substr(i, 2);
     returnvalue = m_DeviceProtocol-&gt;PINIT(&amp;ph);</span>

<span style = "background-color:#fdd">     if (returnvalue != NDIOKAY)</span>
     {
<span style = "background-color:#fdd">        mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not initialize port '") + ph + std::string("."));</span>
     }
<span style = "background-color:#fdd">  }</span>

  /* check for occupied port handles on channel 1 (initialize automatically, portHandle is empty although additional tools were detected) */
  //For a split port on a dual 5DOF tool, the first PHSR sent will report only one port handle. After the port handle is
  //initialized, it is assigned to channel 0. You must then use PHSR again to assign a port handle to channel 1. The
  //port handle for channel 1 is initialized automatically.
<span style = "background-color:#fdd">  returnvalue = m_DeviceProtocol-&gt;PHSR(OCCUPIED, &amp;portHandle);</span>

<span style = "background-color:#fdd">  if (returnvalue != NDIOKAY)</span>
  {
<span style = "background-color:#fdd">     mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not obtain a list of port handles that are connected on channel 1.";</span>
  }

  /* read all port handles */
<span style = "background-color:#fdd">  returnvalue = m_DeviceProtocol-&gt;PHSR(ALL, &amp;portHandle);</span>

<span style = "background-color:#fdd">  if (returnvalue != NDIOKAY)</span>
  {
<span style = "background-color:#fdd">     mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not obtain a list of port handles that are connected on all channels.";</span>
  }

  /**
  1. Create MITK tracking tool representations of NDI tools
  2. NDI enable all tools (PENA)
  **/

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; portHandle.size(); i += 2)</span>
  {
<span style = "background-color:#fdd">     std::string ph = portHandle.substr(i, 2);
     if (this-&gt;GetInternalTool(ph) != nullptr) // if we already have a tool with this handle
        continue;                              // then skip the initialization</span>

     //define tracking priority
<span style = "background-color:#fdd">     auto trackingPriority = mitk::NDIPassiveTool::Dynamic;</span>

     //instantiate an object for each tool that is connected
<span style = "background-color:#fdd">     mitk::NDIPassiveTool::Pointer newTool = mitk::NDIPassiveTool::New();
     newTool-&gt;SetPortHandle(ph.c_str());
     newTool-&gt;SetTrackingPriority(trackingPriority);</span>

     //set a name for identification
<span style = "background-color:#fdd">     newTool-&gt;SetToolName((std::string("Port ") + ph).c_str());</span>

     /* enable the port handle */
<span style = "background-color:#fdd">     returnvalue = m_DeviceProtocol-&gt;PENA(&amp;ph, trackingPriority); // Enable tool</span>

<span style = "background-color:#fdd">     if (returnvalue != NDIOKAY)</span>
     {
<span style = "background-color:#fdd">        mitkThrowException(mitk::IGTHardwareException) &lt;&lt; (std::string("Could not enable port '") + ph +</span>
           std::string("' for tool '") + newTool-&gt;GetToolName() + std::string("'")).c_str();
     }

     //we have to temporarily unlock m_ModeMutex here to avoid a deadlock with another lock inside InternalAddTool()
<span style = "background-color:#fdd">     if (this-&gt;InternalAddTool(newTool) == false)</span>
     {
<span style = "background-color:#fdd">        mitkThrowException(mitk::IGTException) &lt;&lt; "Error while adding new tool";</span>
     }
<span style = "background-color:#fdd">  }</span>

  /**
  NDI get all serial numbers (PHINF)
  **/

  // after initialization readout serial numbers of automatically detected tools
<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; portHandle.size(); i += 2)</span>
  {
<span style = "background-color:#fdd">     std::string ph = portHandle.substr(i, 2);</span>

<span style = "background-color:#fdd">     std::string portInfo;
     NDIErrorCode returnvaluePort = m_DeviceProtocol-&gt;PHINF(ph, &amp;portInfo);
     if ((returnvaluePort == NDIOKAY) &amp;&amp; (portInfo.size() &gt; 31))
        dynamic_cast&lt;mitk::NDIPassiveTool*&gt;(this-&gt;GetInternalTool(ph))-&gt;SetSerialNumber(portInfo.substr(23, 8));
     MITK_INFO &lt;&lt; "portInfo: " &lt;&lt; portInfo;
     itksys::SystemTools::Delay(10);
  }</span>

<span style = "background-color:#fdd">  return true;
}</span>

mitk::NDIErrorCode mitk::NDITrackingDevice::FreePortHandles()
<span style = "background-color:#fdd">{</span>
  /*  first search for port handles that need to be freed: e.g. because of a reset of the tracking system */
<span style = "background-color:#fdd">  NDIErrorCode returnvalue = NDIOKAY;
  std::string portHandle;
  returnvalue = m_DeviceProtocol-&gt;PHSR(FREED, &amp;portHandle);
  if (returnvalue != NDIOKAY)</span>
  {
<span style = "background-color:#fdd">    mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not obtain a list of port handles that need to be freed";</span>
  }

  /* if there are port handles that need to be freed, free them */
<span style = "background-color:#fdd">  if (portHandle.empty() == true)
    return returnvalue;</span>

<span style = "background-color:#fdd">  std::string ph;
  for (unsigned int i = 0; i &lt; portHandle.size(); i += 2)</span>
  {
<span style = "background-color:#fdd">    ph = portHandle.substr(i, 2);</span>

<span style = "background-color:#fdd">    mitk::NDIPassiveTool* t = this-&gt;GetInternalTool(ph);
    if (t != nullptr)  // if we have a tool for the port handle that needs to be freed</span>
    {
<span style = "background-color:#fdd">      if (this-&gt;RemoveTool(t) == false)  // remove it (this will free the port too)
        returnvalue = NDIERROR;
    }</span>
    else  // we don't have a tool, the port handle exists only in the tracking device
    {
<span style = "background-color:#fdd">      returnvalue = m_DeviceProtocol-&gt;PHF(&amp;ph);  // free it there</span>
      // What to do if port handle could not be freed? This seems to be a non critical error
<span style = "background-color:#fdd">      if (returnvalue != NDIOKAY)</span>
      {
<span style = "background-color:#fdd">        mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not free all port handles";</span>
      }
    }
<span style = "background-color:#fdd">  }
  return returnvalue;
}</span>

int mitk::NDITrackingDevice::GetMajorFirmwareRevisionNumber()
<span style = "background-color:#fdd">{
  std::string revision;
  if (m_DeviceProtocol-&gt;APIREV(&amp;revision) != mitk::NDIOKAY || revision.empty() || (revision.size() != 9))</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Could not receive firmware revision number!";
    return 0;</span>
  }

<span style = "background-color:#fdd">  const std::string majrevno = revision.substr(2, 3); //cut out "004" from "D.004.001"</span>

<span style = "background-color:#fdd">  return std::atoi(majrevno.c_str());
}</span>

const char* mitk::NDITrackingDevice::GetFirmwareRevisionNumber()
<span style = "background-color:#fdd">{
  static std::string revision;
  if (m_DeviceProtocol-&gt;APIREV(&amp;revision) != mitk::NDIOKAY || revision.empty() || (revision.size() != 9))</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Could not receive firmware revision number!";
    revision = "";
    return revision.c_str();</span>
  }
<span style = "background-color:#fdd">  return revision.c_str();
}</span>

bool mitk::NDITrackingDevice::AutoDetectToolsAvailable()
<span style = "background-color:#fdd">{
  if (this-&gt;GetType() == mitk::NDIAuroraTypeInformation::GetTrackingDeviceName()) { return true; }
  else { return false; }
}</span>

bool mitk::NDITrackingDevice::AddSingleToolIsAvailable()
<span style = "background-color:#fdd">{</span>
  //For Aurora, only AutoDetecion or loading of toolStorage should be used. It is not possible to add a single tool.
<span style = "background-color:#fdd">  if (this-&gt;GetType() == mitk::NDIAuroraTypeInformation::GetTrackingDeviceName()) { return false; }</span>
  //For Polaris, a single tool can be added, there is no autoDetection.
<span style = "background-color:#fdd">  else { return true; }
}</span>

mitk::NavigationToolStorage::Pointer mitk::NDITrackingDevice::AutoDetectTools()
<span style = "background-color:#fdd">{
  mitk::NavigationToolStorage::Pointer autoDetectedStorage = mitk::NavigationToolStorage::New();
  if (this-&gt;GetType() == mitk::NDIAuroraTypeInformation::GetTrackingDeviceName())</span>
  {
    try
    {
<span style = "background-color:#fdd">      this-&gt;OpenConnection();
      this-&gt;StartTracking();</span>
    }
    catch (mitk::Exception&amp; e)
<span style = "background-color:#fdd">    {
      MITK_WARN &lt;&lt; "Warning, can not auto-detect tools! (" &lt;&lt; e.GetDescription() &lt;&lt; ")";
      return autoDetectedStorage;
    }</span>

<span style = "background-color:#fdd">    for (unsigned int i = 0; i &lt; this-&gt;GetToolCount(); i++)</span>
    {
      //create a navigation tool with sphere as surface
<span style = "background-color:#fdd">      std::stringstream toolname;
      toolname &lt;&lt; "AutoDetectedTool" &lt;&lt; i;
      mitk::NavigationTool::Pointer newTool = mitk::NavigationTool::New();
      newTool-&gt;SetSerialNumber(dynamic_cast&lt;mitk::NDIPassiveTool*&gt;(this-&gt;GetTool(i))-&gt;GetSerialNumber());
      newTool-&gt;SetIdentifier(toolname.str());
      newTool-&gt;SetTrackingDeviceType(mitk::NDIAuroraTypeInformation::GetTrackingDeviceName());
      newTool-&gt;GetDataNode()-&gt;SetName(toolname.str());
      autoDetectedStorage-&gt;AddTool(newTool);
    }
    this-&gt;StopTracking();
    this-&gt;CloseConnection();</span>
  }
<span style = "background-color:#fdd">  return autoDetectedStorage;
}</span>

bool mitk::NDITrackingDevice::GetSupportedVolumes(unsigned int* numberOfVolumes, mitk::NDITrackingDevice::NDITrackingVolumeContainerType* volumes, mitk::NDITrackingDevice::TrackingVolumeDimensionType* volumesDimensions)
<span style = "background-color:#fdd">{
  if (numberOfVolumes == nullptr || volumes == nullptr || volumesDimensions == nullptr)
    return false;</span>

<span style = "background-color:#fdd">  static std::string info;
  if (m_DeviceProtocol-&gt;SFLIST(&amp;info) != mitk::NDIOKAY || info.empty())</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Could not receive tracking volume information of tracking system!";
    return false;</span>
  }

  /*info contains the following:
  &lt;HEX:number of volumes&gt; (+n times:) &lt;HEX:shape type&gt; &lt;shape parameters D1-D10&gt; &lt;HEX:reserved / number of wavelength supported&gt; &lt;metal resistant / supported wavelength&gt;
  */
<span style = "background-color:#fdd">  (*numberOfVolumes) = (unsigned int)std::atoi(info.substr(0, 1).c_str());</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; (*numberOfVolumes); i++)</span>
  {
    //e.g. for cube:  "9-025000+025000-025000+025000-055000-005000+000000+000000+000000+00000011"
    //for dome:       "A+005000+048000+005000+066000+000000+000000+000000+000000+000000+00000011"

    std::string::size_type offset, end;
<span style = "background-color:#fdd">    offset = (i * 73) + 1;
    end = 73 + (i * 73);
    std::string currentVolume = info.substr(offset, end);//i=0: from 1 to 73 characters; i=1: from 75 to 148 char;</span>
    // if i&gt;0 then we have a return statement &lt;LF&gt; infront
<span style = "background-color:#fdd">    if (i &gt; 0)
      currentVolume = currentVolume.substr(1, currentVolume.size());
    if (currentVolume.compare(0, 1, NDIPolarisTypeInformation::GetDeviceDataPolarisOldModel().HardwareCode) == 0)
      volumes-&gt;push_back(NDIPolarisTypeInformation::GetDeviceDataPolarisOldModel().Model);
    if (currentVolume.compare(0, 3, NDIPolarisTypeInformation::GetDeviceDataPolarisSpectra().HardwareCode) == 0)
      volumes-&gt;push_back(NDIPolarisTypeInformation::GetDeviceDataPolarisSpectra().Model);
    if (currentVolume.compare(1, 3, NDIPolarisTypeInformation::GetDeviceDataSpectraExtendedPyramid().HardwareCode) == 0)</span>
    {
<span style = "background-color:#fdd">      currentVolume = currentVolume.substr(1, currentVolume.size());
      volumes-&gt;push_back(NDIPolarisTypeInformation::GetDeviceDataSpectraExtendedPyramid().Model);</span>
    }
<span style = "background-color:#fdd">    if (currentVolume.compare(0, 1, NDIPolarisTypeInformation::GetDeviceDataPolarisVicra().HardwareCode) == 0)
      volumes-&gt;push_back(NDIPolarisTypeInformation::GetDeviceDataPolarisVicra().Model);
    else if (currentVolume.compare(0, 1, mitk::NDIAuroraTypeInformation::GetDeviceDataAuroraPlanarCube().HardwareCode) == 0)
      volumes-&gt;push_back(mitk::NDIAuroraTypeInformation::GetDeviceDataAuroraPlanarCube().Model);//alias cube
    else if (currentVolume.compare(0, 1, mitk::NDIAuroraTypeInformation::GetDeviceDataAuroraPlanarDome().HardwareCode) == 0)
      volumes-&gt;push_back(mitk::NDIAuroraTypeInformation::GetDeviceDataAuroraPlanarDome().Model);</span>

    //fill volumesDimensions
<span style = "background-color:#fdd">    for (unsigned int index = 0; index &lt; 10; index++)</span>
    {
      std::string::size_type offD, endD;
<span style = "background-color:#fdd">      offD = 1 + (index * 7); //7 digits per dimension and the first is the type of volume
      endD = offD + 7;
      int dimension = std::atoi(currentVolume.substr(offD, endD).c_str());
      dimension /= 100; //given in mm. 7 digits are xxxx.xx according to NDI //strange, the last two digits (11) also for the metal flag get read also...
      volumesDimensions-&gt;push_back(dimension);
    }
  }</span>

<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::NDITrackingDevice::SetVolume(mitk::TrackingDeviceData volume)
<span style = "background-color:#fdd">{
  if (m_DeviceProtocol-&gt;VSEL(volume) != mitk::NDIOKAY)</span>
  {
<span style = "background-color:#fdd">    mitkThrowException(mitk::IGTHardwareException) &lt;&lt; "Could not set volume!";</span>
  }
<span style = "background-color:#fdd">  return true;
}</span></pre>
	</body>
</html>