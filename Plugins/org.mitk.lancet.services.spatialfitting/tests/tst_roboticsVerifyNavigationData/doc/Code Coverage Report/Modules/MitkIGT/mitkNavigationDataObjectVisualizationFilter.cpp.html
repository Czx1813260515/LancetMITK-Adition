<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNavigationDataObjectVisualizationFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/
#include "mitkNavigationDataObjectVisualizationFilter.h"

#include "mitkDataStorage.h"
#include &lt;vector&gt;

mitk::NavigationDataObjectVisualizationFilter::NavigationDataObjectVisualizationFilter()
<span style = "background-color:#fdd">  : NavigationDataToNavigationDataFilter(),
    m_RepresentationVectorMap(),
    m_TransformPosition(),
    m_TransformOrientation(),
    m_RotationMode(RotationStandard)
{
}</span>

mitk::NavigationDataObjectVisualizationFilter::~NavigationDataObjectVisualizationFilter()
<span style = "background-color:#fdd">{
  m_RepresentationVectorMap.clear();
  m_OffsetList.clear();
}</span>

mitk::BaseData::Pointer mitk::NavigationDataObjectVisualizationFilter::GetRepresentationObject(unsigned int idx) const
<span style = "background-color:#fdd">{  
  auto iter = m_RepresentationVectorMap.find(idx);
  if (iter != m_RepresentationVectorMap.end())
    return iter-&gt;second.at(0);</span>

<span style = "background-color:#fdd">  return nullptr;
}</span>

std::vector&lt;mitk::BaseData::Pointer&gt; mitk::NavigationDataObjectVisualizationFilter::GetAllRepresentationObjects(unsigned int idx) const
<span style = "background-color:#fdd">{
  RepresentationVectorPointerMap::const_iterator iter = m_RepresentationVectorMap.find(idx);
  if (iter != m_RepresentationVectorMap.end())
    return iter-&gt;second;</span>

<span style = "background-color:#fdd">  std::vector&lt;mitk::NavigationDataObjectVisualizationFilter::RepresentationPointer&gt; empty;
  return empty;
}</span>

mitk::AffineTransform3D::Pointer mitk::NavigationDataObjectVisualizationFilter::GetOffset(int index)
<span style = "background-color:#fdd">{
  OffsetPointerMap::const_iterator iter = m_OffsetList.find(index);
  if (iter != m_OffsetList.end())
    return iter-&gt;second;
  return nullptr;
}</span>

void mitk::NavigationDataObjectVisualizationFilter::SetRepresentationObject(unsigned int idx, BaseData::Pointer data)
<span style = "background-color:#fdd">{
  std::vector&lt;BaseData::Pointer&gt; dataVector;
  dataVector.push_back(data);
  SetRepresentationObjects(idx, dataVector);
}</span>

void mitk::NavigationDataObjectVisualizationFilter::SetRepresentationObjects(unsigned int idx, const std::vector&lt;BaseData::Pointer&gt; &amp;data)
<span style = "background-color:#fdd">{
  m_RepresentationVectorMap[idx] = data;
}</span>

void mitk::NavigationDataObjectVisualizationFilter::SetOffset(int index, mitk::AffineTransform3D::Pointer offset)
<span style = "background-color:#fdd">{
  m_OffsetList[index] = offset;
}</span>

void mitk::NavigationDataObjectVisualizationFilter::SetRotationMode(RotationMode r)
<span style = "background-color:#fdd">{
  m_RotationMode = r;
}</span>

void mitk::NavigationDataObjectVisualizationFilter::GenerateData()
<span style = "background-color:#fdd">{</span>
  /*get each input, lookup the associated BaseData and transfer the data*/
<span style = "background-color:#fdd">  DataObjectPointerArray inputs = this-&gt;GetInputs(); // get all inputs
  for (unsigned int index = 0; index &lt; inputs.size(); index++)</span>
  {
    // get the needed variables
<span style = "background-color:#fdd">    const mitk::NavigationData *nd = this-&gt;GetInput(index);
    assert(nd);</span>

<span style = "background-color:#fdd">    mitk::NavigationData *output = this-&gt;GetOutput(index);
    assert(output);</span>

    // check if the data is valid
<span style = "background-color:#fdd">    if (!nd-&gt;IsDataValid())</span>
    {
<span style = "background-color:#fdd">      output-&gt;SetDataValid(false);
      continue;</span>
    }
<span style = "background-color:#fdd">    output-&gt;Graft(nd); // copy all information from input to output</span>

<span style = "background-color:#fdd">    const std::vector&lt;mitk::NavigationDataObjectVisualizationFilter::RepresentationPointer&gt; data =</span>
      this-&gt;GetAllRepresentationObjects(index);

<span style = "background-color:#fdd">    for (unsigned int dataIdx = 0; dataIdx &lt; data.size(); dataIdx++)</span>
    {
<span style = "background-color:#fdd">      if (data.at(dataIdx) == nullptr)</span>
      {
<span style = "background-color:#fdd">        MITK_WARN &lt;&lt; "No BaseData associated with input " &lt;&lt; index;
        continue;</span>
      }

      // get the transform from data
<span style = "background-color:#fdd">      mitk::AffineTransform3D::Pointer affineTransform = data.at(dataIdx)-&gt;GetGeometry()-&gt;GetIndexToWorldTransform();
      if (affineTransform.IsNull())</span>
      {
<span style = "background-color:#fdd">        MITK_WARN &lt;&lt; "AffineTransform IndexToWorldTransform not initialized!";
        continue;</span>
      }

      // check for offset
<span style = "background-color:#fdd">      mitk::AffineTransform3D::Pointer offset = this-&gt;GetOffset(index);</span>

      // store the current scaling to set it after transformation
<span style = "background-color:#fdd">      mitk::Vector3D spacing = data.at(dataIdx)-&gt;GetGeometry()-&gt;GetSpacing();</span>
      // clear spacing of data to be able to set it again afterwards
<span style = "background-color:#fdd">      ScalarType scale[] = {1.0, 1.0, 1.0};
      data.at(dataIdx)-&gt;GetGeometry()-&gt;SetSpacing(scale);</span>

      /*now bring quaternion to affineTransform by using vnl_Quaternion*/
<span style = "background-color:#fdd">      affineTransform-&gt;SetIdentity();</span>

<span style = "background-color:#fdd">      if (this-&gt;GetTransformOrientation(index) == true)</span>
      {
<span style = "background-color:#fdd">        mitk::NavigationData::OrientationType orientation = nd-&gt;GetOrientation();</span>

        /* because of an itk bug, the transform can not be calculated with float data type.
        To use it in the mitk geometry classes, it has to be transfered to mitk::ScalarType which is float */
        static AffineTransform3D::MatrixType m;

        // convert quaternion to rotation matrix depending on the rotation mode
<span style = "background-color:#fdd">        if (m_RotationMode == RotationStandard)</span>
        {
          // calculate the transform from the quaternions
<span style = "background-color:#fdd">          static itk::QuaternionRigidTransform&lt;double&gt;::Pointer quatTransform =
            itk::QuaternionRigidTransform&lt;double&gt;::New();</span>
          // convert mitk::ScalarType quaternion to double quaternion because of itk bug
<span style = "background-color:#fdd">          vnl_quaternion&lt;double&gt; doubleQuaternion(orientation.x(), orientation.y(), orientation.z(), orientation.r());
          quatTransform-&gt;SetIdentity();
          quatTransform-&gt;SetRotation(doubleQuaternion);
          quatTransform-&gt;Modified();
          mitk::TransferMatrix(quatTransform-&gt;GetMatrix(), m);
        }</span>

<span style = "background-color:#fdd">        else if (m_RotationMode == RotationTransposed)</span>
        {
<span style = "background-color:#fdd">          vnl_matrix_fixed&lt;mitk::ScalarType, 3, 3&gt; rot = orientation.rotation_matrix_transpose();
          for (int i = 0; i &lt; 3; i++)
            for (int j = 0; j &lt; 3; j++)
              m[i][j] = rot[i][j];</span>
        }
<span style = "background-color:#fdd">        affineTransform-&gt;SetMatrix(m);</span>
      }
<span style = "background-color:#fdd">      if (this-&gt;GetTransformPosition(index) == true)</span>
      {
        ///*set the offset by convert from itkPoint to itkVector and setting offset of transform*/
<span style = "background-color:#fdd">        mitk::Vector3D pos;
        pos.SetVnlVector(nd-&gt;GetPosition().GetVnlVector());
        affineTransform-&gt;SetOffset(pos);</span>
      }
<span style = "background-color:#fdd">      affineTransform-&gt;Modified();</span>

      // set the transform to data
<span style = "background-color:#fdd">      if (offset.IsNotNull()) // first use offset if there is one.</span>
      {
<span style = "background-color:#fdd">        mitk::AffineTransform3D::Pointer overallTransform = mitk::AffineTransform3D::New();
        overallTransform-&gt;SetIdentity();
        overallTransform-&gt;Compose(offset);
        overallTransform-&gt;Compose(affineTransform);
        data.at(dataIdx)-&gt;GetGeometry()-&gt;SetIndexToWorldTransform(overallTransform);
      }</span>
      else
      {
<span style = "background-color:#fdd">        data.at(dataIdx)-&gt;GetGeometry()-&gt;SetIndexToWorldTransform(affineTransform);</span>
      }

      // set the original spacing to keep scaling of the geometrical object
<span style = "background-color:#fdd">      data.at(dataIdx)-&gt;GetGeometry()-&gt;SetSpacing(spacing);
      data.at(dataIdx)-&gt;GetGeometry()-&gt;Modified();
      data.at(dataIdx)-&gt;Modified();
      output-&gt;SetDataValid(true); // operation was successful, therefore data of output is valid.
    }
  }
}</span>

void mitk::NavigationDataObjectVisualizationFilter::SetTransformPosition(unsigned int index, bool applyTransform)
<span style = "background-color:#fdd">{
  itkDebugMacro("setting TransformPosition for index " &lt;&lt; index &lt;&lt; " to " &lt;&lt; applyTransform);
  BooleanInputMap::const_iterator it = this-&gt;m_TransformPosition.find(index);
  if ((it != this-&gt;m_TransformPosition.end()) &amp;&amp; (it-&gt;second == applyTransform))
    return;</span>

<span style = "background-color:#fdd">  this-&gt;m_TransformPosition[index] = applyTransform;
  this-&gt;Modified();
}</span>

bool mitk::NavigationDataObjectVisualizationFilter::GetTransformPosition(unsigned int index) const
<span style = "background-color:#fdd">{
  itkDebugMacro("returning TransformPosition for index " &lt;&lt; index);
  BooleanInputMap::const_iterator it = this-&gt;m_TransformPosition.find(index);
  if (it != this-&gt;m_TransformPosition.end())
    return it-&gt;second;</span>
  else
<span style = "background-color:#fdd">    return true; // default to true
}</span>

void mitk::NavigationDataObjectVisualizationFilter::TransformPositionOn(unsigned int index)
<span style = "background-color:#fdd">{
  this-&gt;SetTransformPosition(index, true);
}</span>

void mitk::NavigationDataObjectVisualizationFilter::TransformPositionOff(unsigned int index)
<span style = "background-color:#fdd">{
  this-&gt;SetTransformPosition(index, false);
}</span>

void mitk::NavigationDataObjectVisualizationFilter::SetTransformOrientation(unsigned int index, bool applyTransform)
<span style = "background-color:#fdd">{
  itkDebugMacro("setting TransformOrientation for index " &lt;&lt; index &lt;&lt; " to " &lt;&lt; applyTransform);
  BooleanInputMap::const_iterator it = this-&gt;m_TransformOrientation.find(index);
  if ((it != this-&gt;m_TransformOrientation.end()) &amp;&amp; (it-&gt;second == applyTransform))
    return;</span>

<span style = "background-color:#fdd">  this-&gt;m_TransformOrientation[index] = applyTransform;
  this-&gt;Modified();
}</span>

bool mitk::NavigationDataObjectVisualizationFilter::GetTransformOrientation(unsigned int index) const
<span style = "background-color:#fdd">{
  itkDebugMacro("returning TransformOrientation for index " &lt;&lt; index);
  BooleanInputMap::const_iterator it = this-&gt;m_TransformOrientation.find(index);
  if (it != this-&gt;m_TransformOrientation.end())
    return it-&gt;second;</span>
  else
<span style = "background-color:#fdd">    return true; // default to true
}</span>

void mitk::NavigationDataObjectVisualizationFilter::TransformOrientationOn(unsigned int index)
<span style = "background-color:#fdd">{
  this-&gt;SetTransformOrientation(index, true);
}</span>

void mitk::NavigationDataObjectVisualizationFilter::TransformOrientationOff(unsigned int index)
<span style = "background-color:#fdd">{
  this-&gt;SetTransformOrientation(index, false);
}</span></pre>
	</body>
</html>