<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlanarFigureMapper2D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlanarFigureMapper2D.h"

#include "mitkBaseRenderer.h"
#include "mitkColorProperty.h"
#include "vtkContext2D.h"
#include "vtkContextDevice2D.h"
#include "vtkOpenGLContextDevice2D.h"
#include "mitkPlaneGeometry.h"
#include "mitkProperties.h"
#include "vtkTextProperty.h"

#define _USE_MATH_DEFINES
#include &lt;cmath&gt;

#include &lt;array&gt;
#include &lt;vector&gt;

mitk::PlanarFigureMapper2D::PlanarFigureMapper2D()
<span style = "background-color:#fdd">  : m_NodeModified(true), m_NodeModifiedObserverTag(0), m_NodeModifiedObserverAdded(false), m_Initialized(false)
{</span>

<span style = "background-color:#fdd">  this-&gt;InitializeDefaultPlanarFigureProperties();
}</span>

mitk::PlanarFigureMapper2D::~PlanarFigureMapper2D()
<span style = "background-color:#fdd">{
  if (m_NodeModifiedObserverAdded &amp;&amp; GetDataNode() != nullptr)</span>
  {
<span style = "background-color:#fdd">    GetDataNode()-&gt;RemoveObserver(m_NodeModifiedObserverTag);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::PlanarFigureMapper2D::ApplyColorAndOpacityProperties(mitk::BaseRenderer *renderer, vtkActor * /*actor*/)
<span style = "background-color:#fdd">{
  float rgba[4] = { 1.0f, 1.0f, 1.0f, 1.0f };</span>
  // check for color prop and use it for rendering if it exists
<span style = "background-color:#fdd">  GetDataNode()-&gt;GetColor(rgba, renderer, "color");</span>
  // check for opacity prop and use it for rendering if it exists
<span style = "background-color:#fdd">  GetDataNode()-&gt;GetOpacity(rgba[3], renderer, "opacity");</span>

<span style = "background-color:#fdd">  this-&gt;m_Pen-&gt;SetColorF((double)rgba[0], (double)rgba[1], (double)rgba[2], (double)rgba[3]);
}</span>

void mitk::PlanarFigureMapper2D::Initialize(mitk::BaseRenderer *)
<span style = "background-color:#fdd">{
  this-&gt;m_Pen = vtkSmartPointer&lt;vtkPen&gt;::New();
  vtkOpenGLContextDevice2D *device = nullptr;
    device = vtkOpenGLContextDevice2D::New();
  if (device)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_Context-&gt;Begin(device);
    device-&gt;Delete();
    this-&gt;m_Initialized = true;
    this-&gt;m_Context-&gt;ApplyPen(this-&gt;m_Pen);</span>
  }
  else
  {
  }
<span style = "background-color:#fdd">}</span>

void mitk::PlanarFigureMapper2D::MitkRender(mitk::BaseRenderer *renderer, mitk::VtkPropRenderer::RenderType type)
<span style = "background-color:#fdd">{
  if (type != mitk::VtkPropRenderer::Overlay) return;
  if (!this-&gt;m_Initialized)</span>
  {
<span style = "background-color:#fdd">    this-&gt;Initialize(renderer);</span>
  }
<span style = "background-color:#fdd">  vtkOpenGLContextDevice2D::SafeDownCast(</span>
    this-&gt;m_Context-&gt;GetDevice())-&gt;Begin(renderer-&gt;GetVtkRenderer());

<span style = "background-color:#fdd">  bool visible = true;</span>

<span style = "background-color:#fdd">  GetDataNode()-&gt;GetVisibility(visible, renderer, "visible");
  if (!visible)
    return;</span>

  // Get PlanarFigure from input
<span style = "background-color:#fdd">  auto *planarFigure =</span>
    const_cast&lt;mitk::PlanarFigure *&gt;(static_cast&lt;const mitk::PlanarFigure *&gt;(GetDataNode()-&gt;GetData()));

  // Check if PlanarFigure has already been placed; otherwise, do nothing
<span style = "background-color:#fdd">  if (!planarFigure-&gt;IsPlaced())</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // Get 2D geometry frame of PlanarFigure
<span style = "background-color:#fdd">  const mitk::PlaneGeometry *planarFigurePlaneGeometry = planarFigure-&gt;GetPlaneGeometry();
  if (planarFigurePlaneGeometry == nullptr)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "PlanarFigure does not have valid PlaneGeometry!";
    return;</span>
  }

  // Get current world 2D geometry from renderer
<span style = "background-color:#fdd">  const mitk::PlaneGeometry *rendererPlaneGeometry = renderer-&gt;GetCurrentWorldPlaneGeometry();</span>

  // If the PlanarFigure geometry is a plane geometry, check if current
  // world plane is parallel to and within the planar figure geometry bounds
  // (otherwise, display nothing)

<span style = "background-color:#fdd">  if ((planarFigurePlaneGeometry != nullptr) &amp;&amp; (rendererPlaneGeometry != nullptr))</span>
  {
<span style = "background-color:#fdd">    double planeThickness = planarFigurePlaneGeometry-&gt;GetExtentInMM(2);
    if (!planarFigurePlaneGeometry-&gt;IsParallel(rendererPlaneGeometry) ||</span>
        !(planarFigurePlaneGeometry-&gt;DistanceFromPlane(rendererPlaneGeometry) &lt; planeThickness / 3.0))
    {
      // Planes are not parallel or renderer plane is not within PlanarFigure
      // geometry bounds --&gt; exit
<span style = "background-color:#fdd">      return;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
    // Plane is not valid (curved reformations are not possible yet)
<span style = "background-color:#fdd">    return;</span>
  }

  // Apply visual appearance properties from the PropertyList
<span style = "background-color:#fdd">  ApplyColorAndOpacityProperties(renderer);</span>

  // Get properties from node (if present)
<span style = "background-color:#fdd">  const mitk::DataNode *node = this-&gt;GetDataNode();
  this-&gt;InitializePlanarFigurePropertiesFromDataNode(node);</span>

<span style = "background-color:#fdd">  PlanarFigureDisplayMode lineDisplayMode = PF_DEFAULT;</span>

<span style = "background-color:#fdd">  if (m_IsSelected)</span>
  {
<span style = "background-color:#fdd">    lineDisplayMode = PF_SELECTED;
  }
  else if (m_IsHovering)</span>
  {
<span style = "background-color:#fdd">    lineDisplayMode = PF_HOVER;</span>
  }

<span style = "background-color:#fdd">  mitk::Point2D anchorPoint;
  anchorPoint[0] = 0;
  anchorPoint[1] = 1;</span>

  // render the actual lines of the PlanarFigure
<span style = "background-color:#fdd">  RenderLines(lineDisplayMode, planarFigure, anchorPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);</span>

  // position-offset of the annotations, is set in RenderAnnotations() and
  // used in RenderQuantities()
<span style = "background-color:#fdd">  double annotationOffset = 0.0;</span>

  // Get Global Opacity
<span style = "background-color:#fdd">  float globalOpacity = 1.0;
  node-&gt;GetFloatProperty("opacity", globalOpacity);</span>

<span style = "background-color:#fdd">  if (m_DrawControlPoints)</span>
  {
    // draw the control-points
<span style = "background-color:#fdd">    RenderControlPoints(planarFigure, lineDisplayMode, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);</span>
  }

  // draw name near the anchor point (point located on the right)
<span style = "background-color:#fdd">  const std::string name = node-&gt;GetName();
  if (m_DrawName &amp;&amp; !name.empty())</span>
  {
<span style = "background-color:#fdd">    RenderAnnotations(renderer, name, anchorPoint, globalOpacity, lineDisplayMode, annotationOffset);</span>
  }

  // draw feature quantities (if requested) next to the anchor point,
  // but under the name (that is where 'annotationOffset' is used)
<span style = "background-color:#fdd">  if (m_DrawQuantities)</span>
  {
<span style = "background-color:#fdd">    RenderQuantities(planarFigure, renderer, anchorPoint, annotationOffset, globalOpacity, lineDisplayMode);</span>
  }

<span style = "background-color:#fdd">  this-&gt;m_Context-&gt;GetDevice()-&gt;End();
}</span>

void mitk::PlanarFigureMapper2D::PaintPolyLine(const mitk::PlanarFigure::PolyLineType vertices,
                                               bool closed,
                                               Point2D &amp;anchorPoint,
                                               const PlaneGeometry *planarFigurePlaneGeometry,
                                               const PlaneGeometry *rendererPlaneGeometry,
                                               const mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  mitk::Point2D rightMostPoint;
  rightMostPoint.Fill(itk::NumericTraits&lt;float&gt;::min());</span>

  // transform all vertices into Point2Ds in display-Coordinates and store them in vector
<span style = "background-color:#fdd">  std::vector&lt;mitk::Point2D&gt; pointlist;
  for (auto iter = vertices.cbegin(); iter != vertices.cend(); ++iter)</span>
  {
    // Draw this 2D point as OpenGL vertex
<span style = "background-color:#fdd">    mitk::Point2D displayPoint;
    this-&gt;TransformObjectToDisplay(*iter, displayPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);</span>

<span style = "background-color:#fdd">    pointlist.push_back(displayPoint);</span>

<span style = "background-color:#fdd">    if (displayPoint[0] &gt; rightMostPoint[0])
      rightMostPoint = displayPoint;
  }</span>

  // If the planarfigure is closed, we add the first control point again.
  // Thus we can always use 'GL_LINE_STRIP' and get rid of strange flickering
  // effect when using the MESA OpenGL library.
<span style = "background-color:#fdd">  if (closed)</span>
  {
<span style = "background-color:#fdd">    mitk::Point2D displayPoint;
    this-&gt;TransformObjectToDisplay(</span>
      vertices.cbegin()[0], displayPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);

<span style = "background-color:#fdd">    pointlist.push_back(displayPoint);</span>
  }

  // now paint all the points in one run

<span style = "background-color:#fdd">  std::vector&lt;float&gt; points;
  points.reserve(pointlist.size() * 2);</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0 ; i &lt; pointlist.size() ; ++i)</span>
  {
<span style = "background-color:#fdd">    points.push_back(pointlist[i][0]);
    points.push_back(pointlist[i][1]);
  }</span>

<span style = "background-color:#fdd">  if (2 &lt;= pointlist.size())
    m_Context-&gt;DrawPoly(points.data(), pointlist.size());</span>

<span style = "background-color:#fdd">  anchorPoint = rightMostPoint;
}</span>

void mitk::PlanarFigureMapper2D::DrawMainLines(mitk::PlanarFigure *figure,
                                               Point2D &amp;anchorPoint,
                                               const PlaneGeometry *planarFigurePlaneGeometry,
                                               const PlaneGeometry *rendererPlaneGeometry,
                                               const mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  const auto numberOfPolyLines = figure-&gt;GetPolyLinesSize();
  for (auto loop = 0; loop &lt; numberOfPolyLines; ++loop)</span>
  {
<span style = "background-color:#fdd">    const auto polyline = figure-&gt;GetPolyLine(loop);</span>

<span style = "background-color:#fdd">    this-&gt;PaintPolyLine(</span>
      polyline, figure-&gt;IsClosed(), anchorPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);
<span style = "background-color:#fdd">  }
}</span>

void mitk::PlanarFigureMapper2D::DrawHelperLines(mitk::PlanarFigure *figure,
                                                 Point2D &amp;anchorPoint,
                                                 const PlaneGeometry *planarFigurePlaneGeometry,
                                                 const PlaneGeometry *rendererPlaneGeometry,
                                                 const mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  const auto numberOfHelperPolyLines = figure-&gt;GetHelperPolyLinesSize();</span>

  // Draw helper objects
<span style = "background-color:#fdd">  for (unsigned int loop = 0; loop &lt; numberOfHelperPolyLines; ++loop)</span>
  {
<span style = "background-color:#fdd">    const auto helperPolyLine =</span>
      figure-&gt;GetHelperPolyLine(loop, renderer-&gt;GetScaleFactorMMPerDisplayUnit(), renderer-&gt;GetViewportSize()[1]);

    // Check if the current helper objects is to be painted
<span style = "background-color:#fdd">    if (!figure-&gt;IsHelperToBePainted(loop))</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

    // ... and once normally above the shadow.
<span style = "background-color:#fdd">    this-&gt;PaintPolyLine(helperPolyLine, false, anchorPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);
  }
}</span>

void mitk::PlanarFigureMapper2D::TransformObjectToDisplay(const mitk::Point2D &amp;point2D,
                                                          mitk::Point2D &amp;displayPoint,
                                                          const mitk::PlaneGeometry *objectGeometry,
                                                          const mitk::PlaneGeometry * /*rendererGeometry*/,
                                                          const mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  mitk::Point3D point3D;</span>

  // Map circle point from local 2D geometry into 3D world space
<span style = "background-color:#fdd">  objectGeometry-&gt;Map(point2D, point3D);</span>

  // Project 3D world point onto display geometry
<span style = "background-color:#fdd">  renderer-&gt;WorldToView(point3D, displayPoint);
}</span>

void mitk::PlanarFigureMapper2D::DrawMarker(const mitk::Point2D &amp;point,
                                            float *lineColor,
                                            float lineOpacity,
                                            float *markerColor,
                                            float markerOpacity,
                                            float lineWidth,
                                            PlanarFigureControlPointStyleProperty::Shape shape,
                                            const mitk::PlaneGeometry *objectGeometry,
                                            const mitk::PlaneGeometry *rendererGeometry,
                                            const mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  if (this-&gt;GetDataNode() != nullptr &amp;&amp; this-&gt;GetDataNode()-&gt;GetDataInteractor().IsNull())
    return;</span>

<span style = "background-color:#fdd">  if (markerOpacity == 0 &amp;&amp; lineOpacity == 0)
    return;</span>

<span style = "background-color:#fdd">  mitk::Point2D displayPoint;</span>

<span style = "background-color:#fdd">  this-&gt;TransformObjectToDisplay(point, displayPoint, objectGeometry, rendererGeometry, renderer);</span>

<span style = "background-color:#fdd">  this-&gt;m_Context-&gt;GetPen()-&gt;SetColorF((double)markerColor[0], (double)markerColor[1], (double)markerColor[2], markerOpacity);
  this-&gt;m_Context-&gt;GetPen()-&gt;SetWidth(lineWidth);</span>

<span style = "background-color:#fdd">  switch (shape)</span>
  {
    case PlanarFigureControlPointStyleProperty::Square:
    default:
    {
      // Paint filled square

<span style = "background-color:#fdd">      if (markerOpacity &gt; 0)</span>
      {
<span style = "background-color:#fdd">        m_Context-&gt;DrawRect(displayPoint[0] - 4, displayPoint[1] - 4, 8, 8);</span>
      }

      // Paint outline
<span style = "background-color:#fdd">      this-&gt;m_Context-&gt;GetPen()-&gt;SetColorF((double)lineColor[0], (double)lineColor[1], (double)lineColor[2], (double)lineOpacity);</span>

      std::array&lt;float, 8&gt; outline = {{
<span style = "background-color:#fdd">        static_cast&lt;float&gt;(displayPoint[0] - 4),
        static_cast&lt;float&gt;(displayPoint[1] - 4),
        static_cast&lt;float&gt;(displayPoint[0] - 4),
        static_cast&lt;float&gt;(displayPoint[1] + 4),
        static_cast&lt;float&gt;(displayPoint[0] + 4),
        static_cast&lt;float&gt;(displayPoint[1] + 4),
        static_cast&lt;float&gt;(displayPoint[0] + 4),
        static_cast&lt;float&gt;(displayPoint[1] - 4)</span>
      }};

<span style = "background-color:#fdd">      m_Context-&gt;DrawLines(outline.data(), 4);</span>
      break;
    }

    case PlanarFigureControlPointStyleProperty::Circle:
    {
      // TODO: This code can not be reached using the properties provided in the GUI

      /*float radius = 4.0;

      if (markerOpacity &gt; 0)
      {
        // Paint filled circle
        glBegin(GL_POLYGON);
        for (int angle = 0; angle &lt; 8; ++angle)
        {
          float angleRad = angle * (float)3.14159 / 4.0;
          float x = displayPoint[0] + radius * (float)cos(angleRad);
          float y = displayPoint[1] + radius * (float)sin(angleRad);
          glVertex3f(x, y, PLANAR_OFFSET);
        }
        glEnd();
      }

      // Paint outline
      glColor4f(lineColor[0], lineColor[1], lineColor[2], lineOpacity);
      glBegin(GL_LINE_LOOP);
      for (int angle = 0; angle &lt; 8; ++angle)
      {
        float angleRad = angle * (float)3.14159 / 4.0;
        float x = displayPoint[0] + radius * (float)cos(angleRad);
        float y = displayPoint[1] + radius * (float)sin(angleRad);
        glVertex3f(x, y, PLANAR_OFFSET);
      }
      glEnd();*/
      break;
    }

  } // end switch
<span style = "background-color:#fdd">}</span>

void mitk::PlanarFigureMapper2D::InitializeDefaultPlanarFigureProperties()
<span style = "background-color:#fdd">{
  m_IsSelected = false;
  m_IsHovering = false;
  m_DrawOutline = false;
  m_DrawQuantities = false;
  m_DrawShadow = false;
  m_DrawControlPoints = false;
  m_DrawName = true;
  m_DrawDashed = false;
  m_DrawHelperDashed = false;
  m_AnnotationsShadow = false;</span>

<span style = "background-color:#fdd">  m_ShadowWidthFactor = 1.2;
  m_LineWidth = 1.0;
  m_OutlineWidth = 4.0;
  m_HelperlineWidth = 2.0;</span>

<span style = "background-color:#fdd">  m_DevicePixelRatio = 1.0;</span>

<span style = "background-color:#fdd">  m_ControlPointShape = PlanarFigureControlPointStyleProperty::Square;</span>

<span style = "background-color:#fdd">  this-&gt;SetColorProperty(m_LineColor, PF_DEFAULT, 1.0, 1.0, 1.0);
  this-&gt;SetFloatProperty(m_LineOpacity, PF_DEFAULT, 1.0);
  this-&gt;SetColorProperty(m_OutlineColor, PF_DEFAULT, 0.0, 0.0, 1.0);
  this-&gt;SetFloatProperty(m_OutlineOpacity, PF_DEFAULT, 1.0);
  this-&gt;SetColorProperty(m_HelperlineColor, PF_DEFAULT, 0.4, 0.8, 0.2);
  this-&gt;SetFloatProperty(m_HelperlineOpacity, PF_DEFAULT, 0.4);
  this-&gt;SetColorProperty(m_MarkerlineColor, PF_DEFAULT, 1.0, 1.0, 1.0);
  this-&gt;SetFloatProperty(m_MarkerlineOpacity, PF_DEFAULT, 1.0);
  this-&gt;SetColorProperty(m_MarkerColor, PF_DEFAULT, 1.0, 1.0, 1.0);
  this-&gt;SetFloatProperty(m_MarkerOpacity, PF_DEFAULT, 0.0);
  this-&gt;SetColorProperty(m_AnnotationColor, PF_DEFAULT, 1.0, 1.0, 1.0);</span>

<span style = "background-color:#fdd">  this-&gt;SetColorProperty(m_LineColor, PF_HOVER, 1.0, 0.7, 0.0);
  this-&gt;SetFloatProperty(m_LineOpacity, PF_HOVER, 1.0);
  this-&gt;SetColorProperty(m_OutlineColor, PF_HOVER, 0.0, 0.0, 1.0);
  this-&gt;SetFloatProperty(m_OutlineOpacity, PF_HOVER, 1.0);
  this-&gt;SetColorProperty(m_HelperlineColor, PF_HOVER, 0.4, 0.8, 0.2);
  this-&gt;SetFloatProperty(m_HelperlineOpacity, PF_HOVER, 0.4);
  this-&gt;SetColorProperty(m_MarkerlineColor, PF_HOVER, 1.0, 1.0, 1.0);
  this-&gt;SetFloatProperty(m_MarkerlineOpacity, PF_HOVER, 1.0);
  this-&gt;SetColorProperty(m_MarkerColor, PF_HOVER, 1.0, 0.6, 0.0);
  this-&gt;SetFloatProperty(m_MarkerOpacity, PF_HOVER, 0.2);
  this-&gt;SetColorProperty(m_AnnotationColor, PF_HOVER, 1.0, 0.7, 0.0);</span>

<span style = "background-color:#fdd">  this-&gt;SetColorProperty(m_LineColor, PF_SELECTED, 1.0, 0.0, 0.0);
  this-&gt;SetFloatProperty(m_LineOpacity, PF_SELECTED, 1.0);
  this-&gt;SetColorProperty(m_OutlineColor, PF_SELECTED, 0.0, 0.0, 1.0);
  this-&gt;SetFloatProperty(m_OutlineOpacity, PF_SELECTED, 1.0);
  this-&gt;SetColorProperty(m_HelperlineColor, PF_SELECTED, 0.4, 0.8, 0.2);
  this-&gt;SetFloatProperty(m_HelperlineOpacity, PF_SELECTED, 0.4);
  this-&gt;SetColorProperty(m_MarkerlineColor, PF_SELECTED, 1.0, 1.0, 1.0);
  this-&gt;SetFloatProperty(m_MarkerlineOpacity, PF_SELECTED, 1.0);
  this-&gt;SetColorProperty(m_MarkerColor, PF_SELECTED, 1.0, 0.6, 0.0);
  this-&gt;SetFloatProperty(m_MarkerOpacity, PF_SELECTED, 1.0);
  this-&gt;SetColorProperty(m_AnnotationColor, PF_SELECTED, 1.0, 0.0, 0.0);
}</span>

void mitk::PlanarFigureMapper2D::InitializePlanarFigurePropertiesFromDataNode(const mitk::DataNode *node)
<span style = "background-color:#fdd">{
  if (node == nullptr)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // if we have not added an observer for ModifiedEvents on the DataNode,
  // we add one now.
<span style = "background-color:#fdd">  if (!m_NodeModifiedObserverAdded)</span>
  {
<span style = "background-color:#fdd">    itk::SimpleMemberCommand&lt;mitk::PlanarFigureMapper2D&gt;::Pointer nodeModifiedCommand =</span>
      itk::SimpleMemberCommand&lt;mitk::PlanarFigureMapper2D&gt;::New();
<span style = "background-color:#fdd">    nodeModifiedCommand-&gt;SetCallbackFunction(this, &amp;mitk::PlanarFigureMapper2D::OnNodeModified);
    m_NodeModifiedObserverTag = node-&gt;AddObserver(itk::ModifiedEvent(), nodeModifiedCommand);
    m_NodeModifiedObserverAdded = true;
  }</span>

  // If the DataNode has not been modified since the last execution of
  // this method, we do not run it now.
<span style = "background-color:#fdd">  if (!m_NodeModified)
    return;</span>

  // Mark the current properties as unmodified
<span style = "background-color:#fdd">  m_NodeModified = false;</span>

  // Get Global Opacity
<span style = "background-color:#fdd">  float globalOpacity = 1.0;
  node-&gt;GetFloatProperty("opacity", globalOpacity);</span>

<span style = "background-color:#fdd">  node-&gt;GetBoolProperty("selected", m_IsSelected);
  node-&gt;GetBoolProperty("planarfigure.ishovering", m_IsHovering);
  node-&gt;GetBoolProperty("planarfigure.drawoutline", m_DrawOutline);
  node-&gt;GetBoolProperty("planarfigure.drawshadow", m_DrawShadow);
  node-&gt;GetBoolProperty("planarfigure.drawquantities", m_DrawQuantities);
  node-&gt;GetBoolProperty("planarfigure.drawcontrolpoints", m_DrawControlPoints);
  node-&gt;GetBoolProperty("planarfigure.drawname", m_DrawName);</span>

<span style = "background-color:#fdd">  node-&gt;GetBoolProperty("planarfigure.drawdashed", m_DrawDashed);
  node-&gt;GetBoolProperty("planarfigure.helperline.drawdashed", m_DrawHelperDashed);</span>

<span style = "background-color:#fdd">  node-&gt;GetFloatProperty("planarfigure.line.width", m_LineWidth);
  node-&gt;GetFloatProperty("planarfigure.shadow.widthmodifier", m_ShadowWidthFactor);
  node-&gt;GetFloatProperty("planarfigure.outline.width", m_OutlineWidth);
  node-&gt;GetFloatProperty("planarfigure.helperline.width", m_HelperlineWidth);</span>

<span style = "background-color:#fdd">  node-&gt;GetFloatProperty("planarfigure.devicepixelratio", m_DevicePixelRatio);
  node-&gt;GetStringProperty("planarfigure.annotations.font.family", m_AnnotationFontFamily);
  node-&gt;GetBoolProperty("planarfigure.annotations.font.bold", m_DrawAnnotationBold);
  node-&gt;GetBoolProperty("planarfigure.annotations.font.italic", m_DrawAnnotationItalic);
  node-&gt;GetIntProperty("planarfigure.annotations.font.size", m_AnnotationSize);
  if (!node-&gt;GetBoolProperty("planarfigure.annotations.shadow", m_AnnotationsShadow))</span>
  {
<span style = "background-color:#fdd">    node-&gt;GetBoolProperty("planarfigure.drawshadow", m_AnnotationsShadow);</span>
  }

<span style = "background-color:#fdd">  PlanarFigureControlPointStyleProperty::Pointer styleProperty =</span>
    dynamic_cast&lt;PlanarFigureControlPointStyleProperty *&gt;(node-&gt;GetProperty("planarfigure.controlpointshape"));
<span style = "background-color:#fdd">  if (styleProperty.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    m_ControlPointShape = styleProperty-&gt;GetShape();</span>
  }

  // Set default color and opacity
  // If property "planarfigure.default.*.color" exists, then use that color. Otherwise global "color" property is used.
<span style = "background-color:#fdd">  if (!node-&gt;GetColor(m_LineColor[PF_DEFAULT], nullptr, "planarfigure.default.line.color"))</span>
  {
<span style = "background-color:#fdd">    node-&gt;GetColor(m_LineColor[PF_DEFAULT], nullptr, "color");</span>
  }
<span style = "background-color:#fdd">  node-&gt;GetFloatProperty("planarfigure.default.line.opacity", m_LineOpacity[PF_DEFAULT]);</span>

<span style = "background-color:#fdd">  if (!node-&gt;GetColor(m_OutlineColor[PF_DEFAULT], nullptr, "planarfigure.default.outline.color"))</span>
  {
<span style = "background-color:#fdd">    node-&gt;GetColor(m_OutlineColor[PF_DEFAULT], nullptr, "color");</span>
  }
<span style = "background-color:#fdd">  node-&gt;GetFloatProperty("planarfigure.default.outline.opacity", m_OutlineOpacity[PF_DEFAULT]);</span>

<span style = "background-color:#fdd">  if (!node-&gt;GetColor(m_HelperlineColor[PF_DEFAULT], nullptr, "planarfigure.default.helperline.color"))</span>
  {
<span style = "background-color:#fdd">    node-&gt;GetColor(m_HelperlineColor[PF_DEFAULT], nullptr, "color");</span>
  }
<span style = "background-color:#fdd">  node-&gt;GetFloatProperty("planarfigure.default.helperline.opacity", m_HelperlineOpacity[PF_DEFAULT]);</span>

<span style = "background-color:#fdd">  node-&gt;GetColor(m_MarkerlineColor[PF_DEFAULT], nullptr, "planarfigure.default.markerline.color");
  node-&gt;GetFloatProperty("planarfigure.default.markerline.opacity", m_MarkerlineOpacity[PF_DEFAULT]);
  node-&gt;GetColor(m_MarkerColor[PF_DEFAULT], nullptr, "planarfigure.default.marker.color");
  node-&gt;GetFloatProperty("planarfigure.default.marker.opacity", m_MarkerOpacity[PF_DEFAULT]);
  if (!node-&gt;GetColor(m_AnnotationColor[PF_DEFAULT], nullptr, "planarfigure.default.annotation.color"))</span>
  {
<span style = "background-color:#fdd">    if (!node-&gt;GetColor(m_AnnotationColor[PF_DEFAULT], nullptr, "planarfigure.default.line.color"))</span>
    {
<span style = "background-color:#fdd">      node-&gt;GetColor(m_AnnotationColor[PF_DEFAULT], nullptr, "color");</span>
    }
  }

  // Set hover color and opacity
<span style = "background-color:#fdd">  node-&gt;GetColor(m_LineColor[PF_HOVER], nullptr, "planarfigure.hover.line.color");
  node-&gt;GetFloatProperty("planarfigure.hover.line.opacity", m_LineOpacity[PF_HOVER]);
  node-&gt;GetColor(m_OutlineColor[PF_HOVER], nullptr, "planarfigure.hover.outline.color");
  node-&gt;GetFloatProperty("planarfigure.hover.outline.opacity", m_OutlineOpacity[PF_HOVER]);
  node-&gt;GetColor(m_HelperlineColor[PF_HOVER], nullptr, "planarfigure.hover.helperline.color");
  node-&gt;GetFloatProperty("planarfigure.hover.helperline.opacity", m_HelperlineOpacity[PF_HOVER]);
  node-&gt;GetColor(m_MarkerlineColor[PF_HOVER], nullptr, "planarfigure.hover.markerline.color");
  node-&gt;GetFloatProperty("planarfigure.hover.markerline.opacity", m_MarkerlineOpacity[PF_HOVER]);
  node-&gt;GetColor(m_MarkerColor[PF_HOVER], nullptr, "planarfigure.hover.marker.color");
  node-&gt;GetFloatProperty("planarfigure.hover.marker.opacity", m_MarkerOpacity[PF_HOVER]);
  if (!node-&gt;GetColor(m_AnnotationColor[PF_HOVER], nullptr, "planarfigure.hover.annotation.color"))</span>
  {
<span style = "background-color:#fdd">    if (!node-&gt;GetColor(m_AnnotationColor[PF_HOVER], nullptr, "planarfigure.hover.line.color"))</span>
    {
<span style = "background-color:#fdd">      node-&gt;GetColor(m_AnnotationColor[PF_HOVER], nullptr, "color");</span>
    }
  }

  // Set selected color and opacity
<span style = "background-color:#fdd">  node-&gt;GetColor(m_LineColor[PF_SELECTED], nullptr, "planarfigure.selected.line.color");
  node-&gt;GetFloatProperty("planarfigure.selected.line.opacity", m_LineOpacity[PF_SELECTED]);
  node-&gt;GetColor(m_OutlineColor[PF_SELECTED], nullptr, "planarfigure.selected.outline.color");
  node-&gt;GetFloatProperty("planarfigure.selected.outline.opacity", m_OutlineOpacity[PF_SELECTED]);
  node-&gt;GetColor(m_HelperlineColor[PF_SELECTED], nullptr, "planarfigure.selected.helperline.color");
  node-&gt;GetFloatProperty("planarfigure.selected.helperline.opacity", m_HelperlineOpacity[PF_SELECTED]);
  node-&gt;GetColor(m_MarkerlineColor[PF_SELECTED], nullptr, "planarfigure.selected.markerline.color");
  node-&gt;GetFloatProperty("planarfigure.selected.markerline.opacity", m_MarkerlineOpacity[PF_SELECTED]);
  node-&gt;GetColor(m_MarkerColor[PF_SELECTED], nullptr, "planarfigure.selected.marker.color");
  node-&gt;GetFloatProperty("planarfigure.selected.marker.opacity", m_MarkerOpacity[PF_SELECTED]);
  if (!node-&gt;GetColor(m_AnnotationColor[PF_SELECTED], nullptr, "planarfigure.selected.annotation.color"))</span>
  {
<span style = "background-color:#fdd">    if (!node-&gt;GetColor(m_AnnotationColor[PF_SELECTED], nullptr, "planarfigure.selected.line.color"))</span>
    {
<span style = "background-color:#fdd">      node-&gt;GetColor(m_AnnotationColor[PF_SELECTED], nullptr, "color");</span>
    }
  }

  // adapt opacity values to global "opacity" property
<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; PF_COUNT; ++i)</span>
  {
<span style = "background-color:#fdd">    m_LineOpacity[i] *= globalOpacity;
    m_OutlineOpacity[i] *= globalOpacity;
    m_HelperlineOpacity[i] *= globalOpacity;
    m_MarkerlineOpacity[i] *= globalOpacity;
    m_MarkerOpacity[i] *= globalOpacity;
  }
}</span>

void mitk::PlanarFigureMapper2D::OnNodeModified()
<span style = "background-color:#fdd">{
  m_NodeModified = true;
}</span>

void mitk::PlanarFigureMapper2D::SetDefaultProperties(mitk::DataNode *node,
                                                      mitk::BaseRenderer *renderer,
                                                      bool overwrite)
<span style = "background-color:#fdd">{
  node-&gt;AddProperty("visible", mitk::BoolProperty::New(true), renderer, overwrite);</span>

  // node-&gt;SetProperty("planarfigure.iseditable",mitk::BoolProperty::New(true));
<span style = "background-color:#fdd">  node-&gt;AddProperty("planarfigure.isextendable", mitk::BoolProperty::New(false));</span>
  // node-&gt;AddProperty( "planarfigure.ishovering", mitk::BoolProperty::New(true) );
<span style = "background-color:#fdd">  node-&gt;AddProperty("planarfigure.drawoutline", mitk::BoolProperty::New(false));</span>
  // node-&gt;AddProperty( "planarfigure.drawquantities", mitk::BoolProperty::New(true) );
<span style = "background-color:#fdd">  node-&gt;AddProperty("planarfigure.drawshadow", mitk::BoolProperty::New(true));
  node-&gt;AddProperty("planarfigure.drawcontrolpoints", mitk::BoolProperty::New(true));
  node-&gt;AddProperty("planarfigure.drawname", mitk::BoolProperty::New(true));
  node-&gt;AddProperty("planarfigure.drawdashed", mitk::BoolProperty::New(false));
  node-&gt;AddProperty("planarfigure.helperline.drawdashed", mitk::BoolProperty::New(false));</span>

<span style = "background-color:#fdd">  node-&gt;AddProperty("planarfigure.annotations.font.family", mitk::StringProperty::New("Arial"));
  node-&gt;AddProperty("planarfigure.annotations.font.bold", mitk::BoolProperty::New(false));
  node-&gt;AddProperty("planarfigure.annotations.font.italic", mitk::BoolProperty::New(false));
  node-&gt;AddProperty("planarfigure.annotations.font.size", mitk::IntProperty::New(12));</span>

<span style = "background-color:#fdd">  node-&gt;AddProperty("planarfigure.line.width", mitk::FloatProperty::New(2.0));
  node-&gt;AddProperty("planarfigure.shadow.widthmodifier", mitk::FloatProperty::New(2.0));
  node-&gt;AddProperty("planarfigure.outline.width", mitk::FloatProperty::New(2.0));
  node-&gt;AddProperty("planarfigure.helperline.width", mitk::FloatProperty::New(1.0));</span>

<span style = "background-color:#fdd">  node-&gt;AddProperty("planarfigure.default.line.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.default.outline.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.default.helperline.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.default.markerline.color", mitk::ColorProperty::New(1.0, 1.0, 1.0));
  node-&gt;AddProperty("planarfigure.default.markerline.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.default.marker.color", mitk::ColorProperty::New(1.0, 1.0, 1.0));
  node-&gt;AddProperty("planarfigure.default.marker.opacity", mitk::FloatProperty::New(1.0));</span>

<span style = "background-color:#fdd">  node-&gt;AddProperty("planarfigure.hover.line.color", mitk::ColorProperty::New(0.0, 1.0, 0.0));
  node-&gt;AddProperty("planarfigure.hover.line.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.hover.outline.color", mitk::ColorProperty::New(0.0, 1.0, 0.0));
  node-&gt;AddProperty("planarfigure.hover.outline.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.hover.helperline.color", mitk::ColorProperty::New(0.0, 1.0, 0.0));
  node-&gt;AddProperty("planarfigure.hover.helperline.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.hover.markerline.color", mitk::ColorProperty::New(0.0, 1.0, 0.0));
  node-&gt;AddProperty("planarfigure.hover.markerline.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.hover.marker.color", mitk::ColorProperty::New(0.0, 1.0, 0.0));
  node-&gt;AddProperty("planarfigure.hover.marker.opacity", mitk::FloatProperty::New(1.0));</span>

<span style = "background-color:#fdd">  node-&gt;AddProperty("planarfigure.selected.line.color", mitk::ColorProperty::New(1.0, 0.0, 0.0));
  node-&gt;AddProperty("planarfigure.selected.line.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.selected.outline.color", mitk::ColorProperty::New(1.0, 0.0, 0.0));
  node-&gt;AddProperty("planarfigure.selected.outline.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.selected.helperline.color", mitk::ColorProperty::New(1.0, 0.0, 0.0));
  node-&gt;AddProperty("planarfigure.selected.helperline.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.selected.markerline.color", mitk::ColorProperty::New(1.0, 0.0, 0.0));
  node-&gt;AddProperty("planarfigure.selected.markerline.opacity", mitk::FloatProperty::New(1.0));
  node-&gt;AddProperty("planarfigure.selected.marker.color", mitk::ColorProperty::New(1.0, 0.0, 0.0));
  node-&gt;AddProperty("planarfigure.selected.marker.opacity", mitk::FloatProperty::New(1.0));
}</span>

void mitk::PlanarFigureMapper2D::RenderControlPoints(const mitk::PlanarFigure *planarFigure,
                                                     const PlanarFigureDisplayMode lineDisplayMode,
                                                     const mitk::PlaneGeometry *planarFigurePlaneGeometry,
                                                     const mitk::PlaneGeometry *rendererPlaneGeometry,
                                                     mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  bool isEditable = true;
  m_DataNode-&gt;GetBoolProperty("planarfigure.iseditable", isEditable);</span>

<span style = "background-color:#fdd">  PlanarFigureDisplayMode pointDisplayMode = PF_DEFAULT;</span>

<span style = "background-color:#fdd">  const auto selectedControlPointsIdx = (unsigned int)planarFigure-&gt;GetSelectedControlPoint();
  const unsigned int numberOfControlPoints = planarFigure-&gt;GetNumberOfControlPoints();</span>
  // Draw markers at control points (selected control point will be colored)
<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; numberOfControlPoints; ++i)</span>
  {
    // Only if planar figure is marked as editable: display markers (control points) in a
    // different style if mouse is over them or they are selected
<span style = "background-color:#fdd">    if (isEditable)</span>
    {
<span style = "background-color:#fdd">      if (i == selectedControlPointsIdx)</span>
      {
<span style = "background-color:#fdd">        pointDisplayMode = PF_SELECTED;
      }
      else if (m_IsHovering &amp;&amp; isEditable)</span>
      {
<span style = "background-color:#fdd">        pointDisplayMode = PF_HOVER;</span>
      }
    }

<span style = "background-color:#fdd">    if (m_MarkerOpacity[pointDisplayMode] == 0 &amp;&amp; m_MarkerlineOpacity[pointDisplayMode] == 0)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    if (m_DrawOutline)</span>
    {
      // draw outlines for markers as well
      // linewidth for the contour is only half, as full width looks
      // much too thick!
<span style = "background-color:#fdd">      this-&gt;DrawMarker(planarFigure-&gt;GetControlPoint(i),</span>
                       m_OutlineColor[lineDisplayMode],
                       m_MarkerlineOpacity[pointDisplayMode],
                       m_OutlineColor[lineDisplayMode],
                       m_MarkerOpacity[pointDisplayMode],
                       m_OutlineWidth / 2,
                       m_ControlPointShape,
                       planarFigurePlaneGeometry,
                       rendererPlaneGeometry,
                       renderer);
    }

<span style = "background-color:#fdd">    this-&gt;DrawMarker(planarFigure-&gt;GetControlPoint(i),</span>
                     m_MarkerlineColor[pointDisplayMode],
                     m_MarkerlineOpacity[pointDisplayMode],
                     m_MarkerColor[pointDisplayMode],
                     m_MarkerOpacity[pointDisplayMode],
                     m_LineWidth,
                     m_ControlPointShape,
                     planarFigurePlaneGeometry,
                     rendererPlaneGeometry,
                     renderer);
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  if (planarFigure-&gt;IsPreviewControlPointVisible())</span>
  {
<span style = "background-color:#fdd">    this-&gt;DrawMarker(planarFigure-&gt;GetPreviewControlPoint(),</span>
                     m_MarkerlineColor[PF_HOVER],
                     m_MarkerlineOpacity[PF_HOVER],
                     m_MarkerColor[PF_HOVER],
                     m_MarkerOpacity[PF_HOVER],
                     m_LineWidth,
                     m_ControlPointShape,
                     planarFigurePlaneGeometry,
                     rendererPlaneGeometry,
                     renderer);
  }
<span style = "background-color:#fdd">}</span>

void mitk::PlanarFigureMapper2D::RenderAnnotations(mitk::BaseRenderer *,
                                                   const std::string name,
                                                   const mitk::Point2D anchorPoint,
                                                   float globalOpacity,
                                                   const PlanarFigureDisplayMode lineDisplayMode,
                                                   double &amp;annotationOffset)
<span style = "background-color:#fdd">{
  if (anchorPoint[0] &lt; mitk::eps || anchorPoint[1] &lt; mitk::eps)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  vtkTextProperty* textProp = vtkTextProperty::New();
  textProp-&gt;SetFontSize(m_AnnotationSize);
  textProp-&gt;SetFontFamilyAsString(m_AnnotationFontFamily.c_str());
  textProp-&gt;SetJustificationToLeft();
  textProp-&gt;SetOpacity(globalOpacity);
  textProp-&gt;SetShadow(0);
  textProp-&gt;SetBold(m_DrawAnnotationBold);
  textProp-&gt;SetItalic(m_DrawAnnotationItalic);</span>

<span style = "background-color:#fdd">  mitk::Point2D offset;
  offset.Fill(5);</span>

<span style = "background-color:#fdd">  mitk::Point2D scaledAnchorPoint;
  scaledAnchorPoint[0] = anchorPoint[0] * m_DevicePixelRatio;
  scaledAnchorPoint[1] = anchorPoint[1] * m_DevicePixelRatio;</span>

<span style = "background-color:#fdd">  offset[0] = offset[0] * m_DevicePixelRatio;
  offset[1] = offset[1] * m_DevicePixelRatio;</span>


<span style = "background-color:#fdd">  if(m_DrawShadow)</span>
  {
<span style = "background-color:#fdd">    textProp-&gt;SetColor(0.0,0.0,0.0);
    this-&gt;m_Context-&gt;ApplyTextProp(textProp);
    this-&gt;m_Context-&gt;DrawString(scaledAnchorPoint[0]+offset[0]+1, scaledAnchorPoint[1]+offset[1]-1, name.c_str());</span>
  }
<span style = "background-color:#fdd">  textProp-&gt;SetColor(m_AnnotationColor[lineDisplayMode][0],</span>
          m_AnnotationColor[lineDisplayMode][1],
          m_AnnotationColor[lineDisplayMode][2]);
<span style = "background-color:#fdd">  this-&gt;m_Context-&gt;ApplyTextProp(textProp);
  this-&gt;m_Context-&gt;DrawString(scaledAnchorPoint[0]+offset[0], scaledAnchorPoint[1]+offset[1], name.c_str());</span>

<span style = "background-color:#fdd">  annotationOffset -= 15.0;</span>
  //  annotationOffset -= m_AnnotationAnnotation-&gt;GetBoundsOnDisplay( renderer ).Size[1];
<span style = "background-color:#fdd">  textProp-&gt;Delete();
}</span>

void mitk::PlanarFigureMapper2D::RenderQuantities(const mitk::PlanarFigure *planarFigure,
                                                  mitk::BaseRenderer *,
                                                  const mitk::Point2D anchorPoint,
                                                  double &amp;annotationOffset,
                                                  float globalOpacity,
                                                  const PlanarFigureDisplayMode lineDisplayMode)
<span style = "background-color:#fdd">{
  if (anchorPoint[0] &lt; mitk::eps || anchorPoint[1] &lt; mitk::eps)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  std::stringstream quantityString;
  quantityString.setf(ios::fixed, ios::floatfield);
  quantityString.precision(1);</span>

<span style = "background-color:#fdd">  bool firstActiveFeature = true;
  for (unsigned int i = 0; i &lt; planarFigure-&gt;GetNumberOfFeatures(); ++i)</span>
  {
<span style = "background-color:#fdd">    if (planarFigure-&gt;IsFeatureActive(i) &amp;&amp; planarFigure-&gt;IsFeatureVisible(i))</span>
    {
<span style = "background-color:#fdd">      if (!firstActiveFeature)</span>
      {
<span style = "background-color:#fdd">        quantityString &lt;&lt; " x ";</span>
      }
<span style = "background-color:#fdd">      quantityString &lt;&lt; planarFigure-&gt;GetQuantity(i) &lt;&lt; " ";
      quantityString &lt;&lt; planarFigure-&gt;GetFeatureUnit(i);
      firstActiveFeature = false;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  vtkTextProperty* textProp = vtkTextProperty::New();
  textProp-&gt;SetFontSize(m_AnnotationSize);
  textProp-&gt;SetFontFamilyAsString(m_AnnotationFontFamily.c_str());
  textProp-&gt;SetJustificationToLeft();
  textProp-&gt;SetOpacity(globalOpacity);
  textProp-&gt;SetShadow(0);
  textProp-&gt;SetBold(m_DrawAnnotationBold);
  textProp-&gt;SetItalic(m_DrawAnnotationItalic);</span>

<span style = "background-color:#fdd">  mitk::Point2D offset;
  offset.Fill(5);</span>

<span style = "background-color:#fdd">  mitk::Point2D scaledAnchorPoint;
  scaledAnchorPoint[0] = anchorPoint[0] * m_DevicePixelRatio;
  scaledAnchorPoint[1] = anchorPoint[1] * m_DevicePixelRatio;</span>

<span style = "background-color:#fdd">  offset[0] = offset[0] * m_DevicePixelRatio;
  offset[1] = offset[1] * m_DevicePixelRatio;</span>


<span style = "background-color:#fdd">  if(m_DrawShadow)</span>
  {
<span style = "background-color:#fdd">    textProp-&gt;SetColor(0,0,0);
    this-&gt;m_Context-&gt;ApplyTextProp(textProp);
    this-&gt;m_Context-&gt;DrawString(scaledAnchorPoint[0]+offset[0]+1, scaledAnchorPoint[1]+offset[1]-1, quantityString.str().c_str());</span>
  }
<span style = "background-color:#fdd">  textProp-&gt;SetColor(m_AnnotationColor[lineDisplayMode][0],</span>
          m_AnnotationColor[lineDisplayMode][1],
          m_AnnotationColor[lineDisplayMode][2]);
<span style = "background-color:#fdd">  this-&gt;m_Context-&gt;ApplyTextProp(textProp);
  this-&gt;m_Context-&gt;DrawString(scaledAnchorPoint[0]+offset[0], scaledAnchorPoint[1]+offset[1], quantityString.str().c_str());</span>

<span style = "background-color:#fdd">  annotationOffset -= 15.0;</span>
  //  annotationOffset -= m_AnnotationAnnotation-&gt;GetBoundsOnDisplay( renderer ).Size[1];
<span style = "background-color:#fdd">  textProp-&gt;Delete();
}</span>

void mitk::PlanarFigureMapper2D::RenderLines(const PlanarFigureDisplayMode lineDisplayMode,
                                             mitk::PlanarFigure *planarFigure,
                                             mitk::Point2D &amp;anchorPoint,
                                             const mitk::PlaneGeometry *planarFigurePlaneGeometry,
                                             const mitk::PlaneGeometry *rendererPlaneGeometry,
                                             const mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{</span>
  // If we want to draw an outline, we do it here
<span style = "background-color:#fdd">  if (m_DrawOutline)</span>
  {
<span style = "background-color:#fdd">    const float *color = m_OutlineColor[lineDisplayMode];
    const float opacity = m_OutlineOpacity[lineDisplayMode];</span>

    // set the color and opacity here as it is common for all outlines

<span style = "background-color:#fdd">    this-&gt;m_Context-&gt;GetPen()-&gt;SetColorF((double)color[0], (double)color[1], (double)color[2], opacity);
    this-&gt;m_Context-&gt;GetPen()-&gt;SetWidth(m_OutlineWidth);</span>

<span style = "background-color:#fdd">    if (m_DrawDashed)
      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::DASH_LINE);</span>
    else
<span style = "background-color:#fdd">      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::SOLID_LINE);</span>

    // Draw the outline for all polylines if requested
<span style = "background-color:#fdd">    this-&gt;DrawMainLines(planarFigure, anchorPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);</span>

<span style = "background-color:#fdd">    this-&gt;m_Context-&gt;GetPen()-&gt;SetWidth(m_HelperlineWidth);</span>

<span style = "background-color:#fdd">    if (m_DrawHelperDashed)
      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::DASH_LINE);</span>
    else
<span style = "background-color:#fdd">      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::SOLID_LINE);</span>

    // Draw the outline for all helper objects if requested
<span style = "background-color:#fdd">    this-&gt;DrawHelperLines(planarFigure, anchorPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);</span>
  }

  // If we want to draw a shadow, we do it here
<span style = "background-color:#fdd">  if (m_DrawShadow)</span>
  {
    // determine the shadow opacity
<span style = "background-color:#fdd">    const float opacity = m_OutlineOpacity[lineDisplayMode];
    float shadowOpacity = 0.0f;
    if (opacity &gt; 0.2f)
      shadowOpacity = opacity - 0.2f;</span>

    // set the color and opacity here as it is common for all shadows
<span style = "background-color:#fdd">    this-&gt;m_Context-&gt;GetPen()-&gt;SetColorF(0, 0, 0, shadowOpacity);
    this-&gt;m_Context-&gt;GetPen()-&gt;SetWidth(m_OutlineWidth * m_ShadowWidthFactor);</span>

<span style = "background-color:#fdd">    if (m_DrawDashed)
      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::DASH_LINE);</span>
    else
<span style = "background-color:#fdd">      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::SOLID_LINE);</span>

    // Draw the outline for all polylines if requested
<span style = "background-color:#fdd">    this-&gt;DrawMainLines(planarFigure, anchorPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);</span>

<span style = "background-color:#fdd">    this-&gt;m_Context-&gt;GetPen()-&gt;SetWidth(m_HelperlineWidth);</span>

<span style = "background-color:#fdd">    if (m_DrawHelperDashed)
      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::DASH_LINE);</span>
    else
<span style = "background-color:#fdd">      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::SOLID_LINE);</span>

    // Draw the outline for all helper objects if requested
<span style = "background-color:#fdd">    this-&gt;DrawHelperLines(planarFigure, anchorPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);</span>
  }

  // set this in brackets to avoid duplicate variables in the same scope
  {
<span style = "background-color:#fdd">    const float *color = m_LineColor[lineDisplayMode];
    const float opacity = m_LineOpacity[lineDisplayMode];</span>

    // set the color and opacity here as it is common for all mainlines

<span style = "background-color:#fdd">    this-&gt;m_Context-&gt;GetPen()-&gt;SetColorF((double)color[0], (double)color[1], (double)color[2], (double)opacity);
    this-&gt;m_Context-&gt;GetPen()-&gt;SetWidth(m_LineWidth);</span>

<span style = "background-color:#fdd">    if (m_DrawDashed)
      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::DASH_LINE);</span>
    else
<span style = "background-color:#fdd">      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::SOLID_LINE);</span>

    // Draw the main line for all polylines
<span style = "background-color:#fdd">    this-&gt;DrawMainLines(planarFigure, anchorPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);</span>

<span style = "background-color:#fdd">    const float *helperColor = m_HelperlineColor[lineDisplayMode];
    const float helperOpacity = m_HelperlineOpacity[lineDisplayMode];</span>

    // we only set the color for the helperlines as the linewidth is unchanged
<span style = "background-color:#fdd">    this-&gt;m_Context-&gt;GetPen()-&gt;SetColorF((double)helperColor[0], (double)helperColor[1], (double)helperColor[2], (double)helperOpacity);
    this-&gt;m_Context-&gt;GetPen()-&gt;SetWidth(m_HelperlineWidth);</span>

<span style = "background-color:#fdd">    if (m_DrawHelperDashed)
      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::DASH_LINE);</span>
    else
<span style = "background-color:#fdd">      this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::SOLID_LINE);</span>


    // Draw helper objects
<span style = "background-color:#fdd">    this-&gt;DrawHelperLines(planarFigure, anchorPoint, planarFigurePlaneGeometry, rendererPlaneGeometry, renderer);</span>
  }

<span style = "background-color:#fdd">  if (m_DrawDashed || m_DrawHelperDashed)
    this-&gt;m_Context-&gt;GetPen()-&gt;SetLineType(vtkPen::SOLID_LINE);
}</span></pre>
	</body>
</html>