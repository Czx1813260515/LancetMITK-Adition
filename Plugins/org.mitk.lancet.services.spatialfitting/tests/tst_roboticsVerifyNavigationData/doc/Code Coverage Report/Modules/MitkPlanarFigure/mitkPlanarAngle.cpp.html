<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlanarAngle.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlanarAngle.h"
#include "mitkPlaneGeometry.h"

<span style = "background-color:#fdd">mitk::PlanarAngle::PlanarAngle() : FEATURE_ID_ANGLE(this-&gt;AddFeature("Angle", "deg"))
{</span>
  // Start with two control points
<span style = "background-color:#fdd">  this-&gt;ResetNumberOfControlPoints(2);</span>

<span style = "background-color:#fdd">  this-&gt;SetNumberOfPolyLines(1);
  this-&gt;SetNumberOfHelperPolyLines(1);</span>

<span style = "background-color:#fdd">  m_HelperPolyLinesToBePainted-&gt;InsertElement(0, false);
}</span>

void mitk::PlanarAngle::GeneratePolyLine()
<span style = "background-color:#fdd">{
  this-&gt;ClearPolyLines();</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; this-&gt;GetNumberOfControlPoints(); i++)
    this-&gt;AppendPointToPolyLine(0, this-&gt;GetControlPoint(i));
}</span>

void mitk::PlanarAngle::GenerateHelperPolyLine(double mmPerDisplayUnit, unsigned int displayHeight)
<span style = "background-color:#fdd">{</span>
  // Generate helper-poly-line for angle
<span style = "background-color:#fdd">  if (this-&gt;GetNumberOfControlPoints() &lt; 3)</span>
  {
<span style = "background-color:#fdd">    m_HelperPolyLinesToBePainted-&gt;SetElement(0, false);
    return; // We do not need to draw an angle as there are no two arms yet</span>
  }

<span style = "background-color:#fdd">  this-&gt;ClearHelperPolyLines();</span>

<span style = "background-color:#fdd">  const Point2D centerPoint = this-&gt;GetControlPoint(1);
  const Point2D boundaryPointOne = this-&gt;GetControlPoint(0);
  const Point2D boundaryPointTwo = this-&gt;GetControlPoint(2);</span>

<span style = "background-color:#fdd">  double radius = centerPoint.EuclideanDistanceTo(boundaryPointOne);
  if (radius &gt; centerPoint.EuclideanDistanceTo(boundaryPointTwo))</span>
  {
<span style = "background-color:#fdd">    radius = centerPoint.EuclideanDistanceTo(boundaryPointTwo);</span>
  }

  // Fixed size radius depending on screen size for the angle
<span style = "background-color:#fdd">  double nonScalingRadius = displayHeight * mmPerDisplayUnit * 0.05;</span>

<span style = "background-color:#fdd">  if (nonScalingRadius &gt; radius)</span>
  {
<span style = "background-color:#fdd">    m_HelperPolyLinesToBePainted-&gt;SetElement(0, false);
    return; // if the arc has a radius that is longer than the shortest arm it should not be painted</span>
  }

<span style = "background-color:#fdd">  m_HelperPolyLinesToBePainted-&gt;SetElement(0, true);
  radius = nonScalingRadius;</span>

<span style = "background-color:#fdd">  double angle = this-&gt;GetQuantity(FEATURE_ID_ANGLE);</span>

  // Determine from which arm the angle should be drawn

<span style = "background-color:#fdd">  Vector2D v0 = boundaryPointOne - centerPoint;
  Vector2D v1 = boundaryPointTwo - centerPoint;
  Vector2D v2;
  v2[0] = 1.0;
  v2[1] = 0.0;</span>

<span style = "background-color:#fdd">  v0[0] = v0[0] * cos(0.001) - v0[1] * sin(0.001); // rotate one arm a bit
  v0[1] = v0[0] * sin(0.001) + v0[1] * cos(0.001);
  v0.Normalize();
  v1.Normalize();
  double testAngle = acos(v0 * v1);</span>
  // if the rotated arm is closer to the other arm than before it is the one from which we start drawing
  // else we start drawing from the other arm (we want to draw in the mathematically positive direction)
<span style = "background-color:#fdd">  if (angle &gt; testAngle)</span>
  {
<span style = "background-color:#fdd">    v1[0] = v0[0] * cos(-0.001) - v0[1] * sin(-0.001);
    v1[1] = v0[0] * sin(-0.001) + v0[1] * cos(-0.001);</span>

    // We determine if the arm is mathematically forward or backward
    // assuming we rotate between -pi and pi
<span style = "background-color:#fdd">    if (acos(v0 * v2) &gt; acos(v1 * v2))</span>
    {
<span style = "background-color:#fdd">      testAngle = acos(v1 * v2);
    }</span>
    else
    {
<span style = "background-color:#fdd">      testAngle = -acos(v1 * v2);</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    v0[0] = v1[0] * cos(-0.001) - v1[1] * sin(-0.001);
    v0[1] = v1[0] * sin(-0.001) + v1[1] * cos(-0.001);</span>
    // We determine if the arm is mathematically forward or backward
    // assuming we rotate between -pi and pi
<span style = "background-color:#fdd">    if (acos(v0 * v2) &lt; acos(v1 * v2))</span>
    {
<span style = "background-color:#fdd">      testAngle = acos(v1 * v2);
    }</span>
    else
    {
<span style = "background-color:#fdd">      testAngle = -acos(v1 * v2);</span>
    }
  }
  // Generate poly-line with 16 segments
<span style = "background-color:#fdd">  for (int t = 0; t &lt; 16; ++t)</span>
  {
<span style = "background-color:#fdd">    double alpha = (double)t * angle / 15.0 + testAngle;</span>

<span style = "background-color:#fdd">    Point2D polyLinePoint;
    polyLinePoint[0] = centerPoint[0] + radius * cos(alpha);
    polyLinePoint[1] = centerPoint[1] + radius * sin(alpha);</span>

<span style = "background-color:#fdd">    this-&gt;AppendPointToHelperPolyLine(0, polyLinePoint);
  }
}</span>

void mitk::PlanarAngle::EvaluateFeaturesInternal()
<span style = "background-color:#fdd">{
  if (this-&gt;GetNumberOfControlPoints() &lt; 3)</span>
  {
    // Angle not yet complete.
<span style = "background-color:#fdd">    return;</span>
  }

  // Calculate angle between lines
<span style = "background-color:#fdd">  const Point2D &amp;p0 = this-&gt;GetControlPoint(0);
  const Point2D &amp;p1 = this-&gt;GetControlPoint(1);
  const Point2D &amp;p2 = this-&gt;GetControlPoint(2);</span>

<span style = "background-color:#fdd">  Vector2D v0 = p1 - p0;
  Vector2D v1 = p1 - p2;</span>

<span style = "background-color:#fdd">  v0.Normalize();
  v1.Normalize();
  double angle = acos(v0 * v1);</span>

<span style = "background-color:#fdd">  this-&gt;SetQuantity(FEATURE_ID_ANGLE, angle);
}</span>

void mitk::PlanarAngle::PrintSelf(std::ostream &amp;os, itk::Indent indent) const
<span style = "background-color:#fdd">{
  Superclass::PrintSelf(os, indent);
}</span>

bool mitk::PlanarAngle::Equals(const PlanarFigure &amp;other) const
<span style = "background-color:#fdd">{
  const auto *otherAngle = dynamic_cast&lt;const mitk::PlanarAngle *&gt;(&amp;other);
  if (otherAngle)</span>
  {
<span style = "background-color:#fdd">    return Superclass::Equals(other);
  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>