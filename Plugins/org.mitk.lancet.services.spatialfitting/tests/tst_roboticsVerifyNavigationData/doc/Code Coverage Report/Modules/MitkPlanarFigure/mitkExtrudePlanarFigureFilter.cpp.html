<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkExtrudePlanarFigureFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlanarFigure.h"
#include &lt;mitkExtrudePlanarFigureFilter.h&gt;
#include &lt;mitkPlaneGeometry.h&gt;
#include &lt;mitkSurface.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkPoints.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkPolyDataNormals.h&gt;
#include &lt;vtkSmartPointer.h&gt;

static mitk::Point2D GetCenterPoint(const mitk::PlanarFigure::PolyLineType &amp;polyLine)
<span style = "background-color:#fdd">{
  mitk::Point2D centerPoint;</span>

<span style = "background-color:#fdd">  centerPoint[0] = 0;
  centerPoint[1] = 0;</span>

<span style = "background-color:#fdd">  auto polyLineEnd = polyLine.cend();</span>

<span style = "background-color:#fdd">  for (auto polyLineIter = polyLine.cbegin(); polyLineIter != polyLineEnd; ++polyLineIter)</span>
  {
<span style = "background-color:#fdd">    centerPoint[0] += static_cast&lt;mitk::Point2D&gt;(*polyLineIter)[0];
    centerPoint[1] += static_cast&lt;mitk::Point2D&gt;(*polyLineIter)[1];
  }</span>

<span style = "background-color:#fdd">  const size_t numPoints = polyLine.size();</span>

<span style = "background-color:#fdd">  centerPoint[0] /= numPoints;
  centerPoint[1] /= numPoints;</span>

<span style = "background-color:#fdd">  return centerPoint;
}</span>

static mitk::Point2D GetCenterPoint(mitk::PlanarFigure *planarFigure)
<span style = "background-color:#fdd">{
  mitk::Point2D centerPoint;</span>

<span style = "background-color:#fdd">  centerPoint[0] = 0;
  centerPoint[1] = 0;</span>

<span style = "background-color:#fdd">  const size_t numPolyLines = planarFigure-&gt;GetPolyLinesSize();</span>

<span style = "background-color:#fdd">  for (size_t i = 0; i &lt; numPolyLines; ++i)</span>
  {
<span style = "background-color:#fdd">    const mitk::Point2D polyLineCenterPoint = GetCenterPoint(planarFigure-&gt;GetPolyLine(i));</span>

<span style = "background-color:#fdd">    centerPoint[0] += polyLineCenterPoint[0];
    centerPoint[1] += polyLineCenterPoint[1];
  }</span>

<span style = "background-color:#fdd">  centerPoint[0] /= numPolyLines;
  centerPoint[1] /= numPolyLines;</span>

<span style = "background-color:#fdd">  return centerPoint;
}</span>

static mitk::Vector3D GetBendDirection(const mitk::PlaneGeometry *planeGeometry,
                                       const mitk::Point2D &amp;centerPoint2d,
                                       const mitk::Vector2D &amp;bendDirection2d)
<span style = "background-color:#fdd">{
  const mitk::Point2D point2d = centerPoint2d + bendDirection2d;</span>

<span style = "background-color:#fdd">  mitk::Point3D point3d;
  planeGeometry-&gt;Map(point2d, point3d);</span>

<span style = "background-color:#fdd">  mitk::Point3D centerPoint3d;
  planeGeometry-&gt;Map(centerPoint2d, centerPoint3d);</span>

<span style = "background-color:#fdd">  mitk::Vector3D bendDirection3d = point3d - centerPoint3d;
  bendDirection3d.Normalize();</span>

<span style = "background-color:#fdd">  return bendDirection3d;
}</span>

mitk::ExtrudePlanarFigureFilter::ExtrudePlanarFigureFilter()
<span style = "background-color:#fdd">  : m_Length(1), m_NumberOfSegments(1), m_TwistAngle(0), m_BendAngle(0), m_FlipDirection(false), m_FlipNormals(false)
{
  m_BendDirection[0] = 0;
  m_BendDirection[1] = 0;</span>

<span style = "background-color:#fdd">  this-&gt;SetNumberOfRequiredInputs(1);
  this-&gt;SetNumberOfRequiredOutputs(1);</span>

<span style = "background-color:#fdd">  this-&gt;SetNthOutput(0, this-&gt;MakeOutput(0));
}</span>

mitk::ExtrudePlanarFigureFilter::~ExtrudePlanarFigureFilter()
<span style = "background-color:#fdd">{
}</span>

void mitk::ExtrudePlanarFigureFilter::GenerateData()
<span style = "background-color:#fdd">{</span>
  typedef PlanarFigure::PolyLineType PolyLine;

<span style = "background-color:#fdd">  if (m_Length &lt;= 0)
    mitkThrow() &lt;&lt; "Length is not positive!";</span>

<span style = "background-color:#fdd">  if (m_NumberOfSegments == 0)
    mitkThrow() &lt;&lt; "Number of segments is zero!";</span>

<span style = "background-color:#fdd">  if (m_BendAngle != 0 &amp;&amp; m_BendDirection[0] == 0 &amp;&amp; m_BendDirection[1] == 0)
    mitkThrow() &lt;&lt; "Bend direction is zero-length vector!";</span>

<span style = "background-color:#fdd">  auto *input = dynamic_cast&lt;PlanarFigure *&gt;(this-&gt;GetPrimaryInput());</span>

<span style = "background-color:#fdd">  if (input == nullptr)
    mitkThrow() &lt;&lt; "Primary input is not a planar figure!";</span>

<span style = "background-color:#fdd">  size_t numPolyLines = input-&gt;GetPolyLinesSize();</span>

<span style = "background-color:#fdd">  if (numPolyLines == 0)
    mitkThrow() &lt;&lt; "Primary input does not contain any poly lines!";</span>

<span style = "background-color:#fdd">  const auto *planeGeometry = dynamic_cast&lt;const PlaneGeometry *&gt;(input-&gt;GetPlaneGeometry());</span>

<span style = "background-color:#fdd">  if (planeGeometry == nullptr)
    mitkThrow() &lt;&lt; "Could not get plane geometry from primary input!";</span>

<span style = "background-color:#fdd">  Vector3D planeNormal = planeGeometry-&gt;GetNormal();
  planeNormal.Normalize();</span>

<span style = "background-color:#fdd">  const Point2D centerPoint2d = GetCenterPoint(input);</span>

<span style = "background-color:#fdd">  Point3D centerPoint3d;
  planeGeometry-&gt;Map(centerPoint2d, centerPoint3d);</span>

<span style = "background-color:#fdd">  const Vector3D bendDirection3d =</span>
    m_BendAngle != 0 ? ::GetBendDirection(planeGeometry, centerPoint2d, m_BendDirection) : Vector3D();

<span style = "background-color:#fdd">  const ScalarType radius = m_Length * (360 / m_BendAngle) / (2 * vnl_math::pi);
  const Vector3D scaledBendDirection3d = bendDirection3d * radius;</span>

<span style = "background-color:#fdd">  Vector3D bendAxis = itk::CrossProduct(planeNormal, bendDirection3d);
  bendAxis.Normalize();</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPoints&gt; points = vtkSmartPointer&lt;vtkPoints&gt;::New();
  vtkSmartPointer&lt;vtkCellArray&gt; cells = vtkSmartPointer&lt;vtkCellArray&gt;::New();
  vtkIdType baseIndex = 0;</span>

<span style = "background-color:#fdd">  for (size_t i = 0; i &lt; numPolyLines; ++i)</span>
  {
<span style = "background-color:#fdd">    const PolyLine polyLine = input-&gt;GetPolyLine(i);
    const size_t numPoints = polyLine.size();</span>

<span style = "background-color:#fdd">    if (numPoints &lt; 2)
      mitkThrow() &lt;&lt; "Poly line " &lt;&lt; i &lt;&lt; " of primary input consists of less than two points!";</span>

<span style = "background-color:#fdd">    std::vector&lt;mitk::Point3D&gt; crossSection;</span>

<span style = "background-color:#fdd">    auto polyLineEnd = polyLine.end();</span>

<span style = "background-color:#fdd">    for (auto polyLineIter = polyLine.begin(); polyLineIter != polyLineEnd; ++polyLineIter)</span>
    {
<span style = "background-color:#fdd">      Point3D point;
      planeGeometry-&gt;Map(*polyLineIter, point);
      crossSection.push_back(point);
    }</span>

<span style = "background-color:#fdd">    const ScalarType segmentLength = m_Length / m_NumberOfSegments;
    Vector3D translation = planeNormal * segmentLength;</span>

<span style = "background-color:#fdd">    const bool bend = std::abs(m_BendAngle) &gt; mitk::eps;
    const bool twist = std::abs(m_TwistAngle) &gt; mitk::eps;</span>

<span style = "background-color:#fdd">    const ScalarType twistAngle = twist ? m_TwistAngle / m_NumberOfSegments * vnl_math::pi / 180 : 0;</span>

<span style = "background-color:#fdd">    ScalarType bendAngle = bend ? m_BendAngle / m_NumberOfSegments * vnl_math::pi / 180 : 0;</span>

<span style = "background-color:#fdd">    if (m_FlipDirection)</span>
    {
<span style = "background-color:#fdd">      translation *= -1;
      bendAngle *= -1;</span>
    }

<span style = "background-color:#fdd">    for (size_t k = 0; k &lt; numPoints; ++k)
      points-&gt;InsertNextPoint(crossSection[k].GetDataPointer());</span>

<span style = "background-color:#fdd">    for (size_t j = 1; j &lt;= m_NumberOfSegments; ++j)</span>
    {
<span style = "background-color:#fdd">      mitk::AffineTransform3D::Pointer transform = mitk::AffineTransform3D::New();</span>

<span style = "background-color:#fdd">      if (bend || twist)
        transform-&gt;Translate(centerPoint3d.GetVectorFromOrigin(), true);</span>

<span style = "background-color:#fdd">      if (bend)</span>
      {
<span style = "background-color:#fdd">        transform-&gt;Translate(scaledBendDirection3d, true);
        transform-&gt;Rotate3D(bendAxis, bendAngle * j, true);
        transform-&gt;Translate(-scaledBendDirection3d, true);
      }</span>
      else
      {
<span style = "background-color:#fdd">        transform-&gt;Translate(translation * j, true);</span>
      }

<span style = "background-color:#fdd">      if (twist)
        transform-&gt;Rotate3D(planeNormal, twistAngle * j, true);</span>

<span style = "background-color:#fdd">      if (bend || twist)
        transform-&gt;Translate(-centerPoint3d.GetVectorFromOrigin(), true);</span>

<span style = "background-color:#fdd">      for (size_t k = 0; k &lt; numPoints; ++k)</span>
      {
<span style = "background-color:#fdd">        const mitk::Point3D transformedPoint = transform-&gt;TransformPoint(crossSection[k]);
        points-&gt;InsertNextPoint(transformedPoint.GetDataPointer());
      }
    }</span>

<span style = "background-color:#fdd">    for (size_t j = 0; j &lt; m_NumberOfSegments; ++j)</span>
    {
<span style = "background-color:#fdd">      for (size_t k = 1; k &lt; numPoints; ++k)</span>
      {
        vtkIdType cell[3];
<span style = "background-color:#fdd">        cell[0] = baseIndex + j * numPoints + (k - 1);
        cell[1] = baseIndex + (j + 1) * numPoints + (k - 1);
        cell[2] = baseIndex + j * numPoints + k;</span>

<span style = "background-color:#fdd">        cells-&gt;InsertNextCell(3, cell);</span>

<span style = "background-color:#fdd">        cell[0] = cell[1];
        cell[1] = baseIndex + (j + 1) * numPoints + k;</span>

<span style = "background-color:#fdd">        cells-&gt;InsertNextCell(3, cell);
      }</span>

<span style = "background-color:#fdd">      if (input-&gt;IsClosed() &amp;&amp; numPoints &gt; 2)</span>
      {
        vtkIdType cell[3];
<span style = "background-color:#fdd">        cell[0] = baseIndex + j * numPoints + (numPoints - 1);
        cell[1] = baseIndex + (j + 1) * numPoints + (numPoints - 1);
        cell[2] = baseIndex + j * numPoints;</span>

<span style = "background-color:#fdd">        cells-&gt;InsertNextCell(3, cell);</span>

<span style = "background-color:#fdd">        cell[0] = cell[1];
        cell[1] = baseIndex + (j + 1) * numPoints;</span>

<span style = "background-color:#fdd">        cells-&gt;InsertNextCell(3, cell);</span>
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    baseIndex += points-&gt;GetNumberOfPoints();
  }</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPolyData&gt; polyData = vtkSmartPointer&lt;vtkPolyData&gt;::New();
  polyData-&gt;SetPoints(points);
  polyData-&gt;SetPolys(cells);</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPolyDataNormals&gt; polyDataNormals = vtkSmartPointer&lt;vtkPolyDataNormals&gt;::New();
  polyDataNormals-&gt;SetFlipNormals(m_FlipNormals);
  polyDataNormals-&gt;SetInputData(polyData);
  polyDataNormals-&gt;SplittingOff();</span>

<span style = "background-color:#fdd">  polyDataNormals-&gt;Update();</span>

<span style = "background-color:#fdd">  auto *output = static_cast&lt;Surface *&gt;(this-&gt;GetPrimaryOutput());
  output-&gt;SetVtkPolyData(polyDataNormals-&gt;GetOutput());
}</span>

void mitk::ExtrudePlanarFigureFilter::GenerateOutputInformation()
<span style = "background-color:#fdd">{
}</span>

itk::ProcessObject::DataObjectPointer mitk::ExtrudePlanarFigureFilter::MakeOutput(DataObjectPointerArraySizeType idx)
<span style = "background-color:#fdd">{
  return idx == 0 ? Surface::New().GetPointer() : nullptr;
}</span>

itk::ProcessObject::DataObjectPointer mitk::ExtrudePlanarFigureFilter::MakeOutput(const DataObjectIdentifierType &amp;name)
<span style = "background-color:#fdd">{
  return this-&gt;IsIndexedOutputName(name) ? this-&gt;MakeOutput(this-&gt;MakeIndexFromOutputName(name)) : nullptr;
}</span>

void mitk::ExtrudePlanarFigureFilter::PrintSelf(std::ostream &amp;os, itk::Indent indent) const
<span style = "background-color:#fdd">{
  Superclass::PrintSelf(os, indent);</span>

<span style = "background-color:#fdd">  os &lt;&lt; indent &lt;&lt; "Length: " &lt;&lt; m_Length &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; "Number of Segments: " &lt;&lt; m_NumberOfSegments &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; "Twist Angle: " &lt;&lt; m_TwistAngle &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; "Bend Angle: " &lt;&lt; m_BendAngle &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; "Bend Direction: " &lt;&lt; m_BendDirection &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; "Flip Normals: " &lt;&lt; m_FlipNormals &lt;&lt; std::endl;
}</span>

void mitk::ExtrudePlanarFigureFilter::SetInput(PlanarFigure *planarFigure)
<span style = "background-color:#fdd">{
  this-&gt;SetPrimaryInput(planarFigure);
}</span>

mitk::Surface *mitk::ExtrudePlanarFigureFilter::GetOutput()
<span style = "background-color:#fdd">{
  return static_cast&lt;Surface *&gt;(this-&gt;GetPrimaryOutput());
}</span></pre>
	</body>
</html>