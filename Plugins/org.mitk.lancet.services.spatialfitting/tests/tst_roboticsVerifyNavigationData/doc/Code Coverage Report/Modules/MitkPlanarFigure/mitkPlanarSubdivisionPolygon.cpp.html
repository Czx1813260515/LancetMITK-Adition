<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlanarSubdivisionPolygon.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlanarSubdivisionPolygon.h"
#include "mitkPlaneGeometry.h"
#include "mitkProperties.h"

// stl related includes
#include &lt;algorithm&gt;

<span style = "background-color:#fdd">mitk::PlanarSubdivisionPolygon::PlanarSubdivisionPolygon() : m_TensionParameter(0.0625), m_SubdivisionRounds(5)
{</span>
  // Polygon is subdivision (in contrast to parent class PlanarPolygon
<span style = "background-color:#fdd">  this-&gt;SetProperty("closed", mitk::BoolProperty::New(true));
  this-&gt;SetProperty("subdivision", mitk::BoolProperty::New(true));</span>

  // Other properties are inherited / already initialized by parent class PlanarPolygon
<span style = "background-color:#fdd">}</span>

void mitk::PlanarSubdivisionPolygon::GeneratePolyLine()
<span style = "background-color:#fdd">{
  this-&gt;ClearPolyLines();
  ControlPointListType subdivisionPoints;
  ControlPointListType newSubdivisionPoints;
  subdivisionPoints.clear();
  subdivisionPoints = m_ControlPoints;</span>

<span style = "background-color:#fdd">  if (m_ControlPoints.size() &gt;= GetMinimumNumberOfControlPoints())</span>
  {
<span style = "background-color:#fdd">    for (unsigned int i = 0; i &lt; GetSubdivisionRounds(); i++)</span>
    {
      // Indices
      unsigned int index, indexPrev, indexNext, indexNextNext;

<span style = "background-color:#fdd">      const unsigned int numberOfPoints = subdivisionPoints.size();</span>

<span style = "background-color:#fdd">      Point2D newPoint;</span>

      // Keep cycling our array indices forward until they wrap around at the end
<span style = "background-color:#fdd">      for (index = 0; index &lt; numberOfPoints; ++index)</span>
      {
        // Create new subdivision point according to formula
        // p_new = (0.5 + tension) * (p_here + p_next) - tension * (p_prev + p_nextnext)
<span style = "background-color:#fdd">        indexPrev = (numberOfPoints + index - 1) % numberOfPoints;
        indexNext = (index + 1) % numberOfPoints;
        indexNextNext = (index + 2) % numberOfPoints;</span>

<span style = "background-color:#fdd">        newPoint[0] =</span>
          (0.5 + GetTensionParameter()) * (double)(subdivisionPoints[index][0] + subdivisionPoints[indexNext][0]) -
          GetTensionParameter() * (double)(subdivisionPoints[indexPrev][0] + subdivisionPoints[indexNextNext][0]);
<span style = "background-color:#fdd">        newPoint[1] =</span>
          (0.5 + GetTensionParameter()) * (double)(subdivisionPoints[index][1] + subdivisionPoints[indexNext][1]) -
          GetTensionParameter() * (double)(subdivisionPoints[indexPrev][1] + subdivisionPoints[indexNextNext][1]);

<span style = "background-color:#fdd">        newSubdivisionPoints.push_back(newPoint);
      }</span>

<span style = "background-color:#fdd">      ControlPointListType mergedSubdivisionPoints;
      ControlPointListType::const_iterator it, itNew;</span>

<span style = "background-color:#fdd">      for (it = subdivisionPoints.cbegin(), itNew = newSubdivisionPoints.cbegin(); it != subdivisionPoints.cend();
           ++it, ++itNew)</span>
      {
<span style = "background-color:#fdd">        mergedSubdivisionPoints.push_back(*it);
        mergedSubdivisionPoints.push_back(*itNew);
      }</span>

<span style = "background-color:#fdd">      subdivisionPoints = mergedSubdivisionPoints;</span>

<span style = "background-color:#fdd">      newSubdivisionPoints.clear();
    }</span>
  }

<span style = "background-color:#fdd">  const bool isInitiallyPlaced = this-&gt;GetProperty("initiallyplaced");</span>

  unsigned int i;
<span style = "background-color:#fdd">  ControlPointListType::const_iterator it;
  for (it = subdivisionPoints.cbegin(), i = 0; it != subdivisionPoints.cend(); ++it, ++i)</span>
  {
    // Determine the index of the control point FOLLOWING this poly-line element
    // (this is needed by PlanarFigureInteractor to insert new points at the correct position,
    // namely BEFORE the next control point)
    unsigned int nextIndex;
<span style = "background-color:#fdd">    if (i == 0)</span>
    {
      // For the FIRST polyline point, use the index of the LAST control point
      // (it will used to check if the mouse is near the very last polyline element)
<span style = "background-color:#fdd">      nextIndex = m_ControlPoints.size() - 1;
    }</span>
    else
    {
      // For all other polyline points, use the index of the control point succeeding it
      // (for polyline points lying on control points, the index of the previous control point
      // is used)
<span style = "background-color:#fdd">      nextIndex = (((i - 1) &gt;&gt; this-&gt;GetSubdivisionRounds()) + 1) % m_ControlPoints.size();
      if (!isInitiallyPlaced &amp;&amp; nextIndex &gt; m_ControlPoints.size() - 2)</span>
      {
<span style = "background-color:#fdd">        this-&gt;AppendPointToPolyLine(0, m_ControlPoints[m_ControlPoints.size() - 1]);
        break;</span>
      }
    }

<span style = "background-color:#fdd">    this-&gt;AppendPointToPolyLine(0, *it);
  }
  subdivisionPoints.clear();
}</span>

bool mitk::PlanarSubdivisionPolygon::Equals(const mitk::PlanarFigure &amp;other) const
<span style = "background-color:#fdd">{
  const auto *otherSubDivPoly = dynamic_cast&lt;const mitk::PlanarSubdivisionPolygon *&gt;(&amp;other);
  if (otherSubDivPoly)</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;m_SubdivisionRounds != otherSubDivPoly-&gt;m_SubdivisionRounds)
      return false;
    if (std::abs(this-&gt;m_TensionParameter - otherSubDivPoly-&gt;m_TensionParameter) &gt; mitk::eps)
      return false;
    return Superclass::Equals(other);
  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span>

int mitk::PlanarSubdivisionPolygon::GetControlPointForPolylinePoint(int indexOfPolylinePoint, int polyLineIndex) const
<span style = "background-color:#fdd">{
  const mitk::PlanarFigure::PolyLineType polyLine = GetPolyLine(polyLineIndex);</span>

<span style = "background-color:#fdd">  if (indexOfPolylinePoint &lt; 0 || indexOfPolylinePoint &gt; static_cast&lt;int&gt;(polyLine.size()))
    return -1;</span>

<span style = "background-color:#fdd">  mitk::PlanarFigure::ControlPointListType::const_iterator elem;
  auto first = m_ControlPoints.cbegin();
  auto end = m_ControlPoints.cend();</span>

<span style = "background-color:#fdd">  mitk::PlanarFigure::PolyLineType::const_iterator polyLineIter;
  auto polyLineEnd = polyLine.cend();
  auto polyLineStart = polyLine.cbegin();
  polyLineStart += indexOfPolylinePoint;</span>

<span style = "background-color:#fdd">  for (polyLineIter = polyLineStart; polyLineIter != polyLineEnd; ++polyLineIter)</span>
  {
<span style = "background-color:#fdd">    elem = std::find(first, end, *polyLineIter);</span>

<span style = "background-color:#fdd">    if (elem != end)
      return std::distance(first, elem);
  }</span>

<span style = "background-color:#fdd">  return GetNumberOfControlPoints();
}</span></pre>
	</body>
</html>