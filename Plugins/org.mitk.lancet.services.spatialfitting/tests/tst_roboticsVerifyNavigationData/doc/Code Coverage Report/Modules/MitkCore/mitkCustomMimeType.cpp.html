<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkCustomMimeType.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkCustomMimeType.h"

#include "mitkMimeType.h"

#include &lt;mitkUtf8Util.h&gt;

#include &lt;algorithm&gt;

#include &lt;itksys/SystemTools.hxx&gt;

namespace mitk
{
  class FindCaseInsensitive
  {
  public:
<span style = "background-color:#dfd">    FindCaseInsensitive(std::string value)</span>
    {
<span style = "background-color:#dfd">      lcValue.resize(value.size());
      std::transform(value.begin(), value.end(), lcValue.begin(), ::tolower);
    }</span>

    bool operator()(std::string elem)
<span style = "background-color:#dfd">    {
      std::transform(elem.begin(), elem.end(), elem.begin(), ::tolower);
      return elem == lcValue;
    }</span>

  private:
    std::string lcValue;
  };

  struct CustomMimeType::Impl
  {
    std::string m_Name;
    std::string m_Category;
    std::vector&lt;std::string&gt; m_Extensions;
    std::string m_Comment;
  };

<span style = "background-color:#dfd">  CustomMimeType::~CustomMimeType() { delete d; }
  CustomMimeType::CustomMimeType() : d(new Impl) {}
  CustomMimeType::CustomMimeType(const std::string &amp;name) : d(new Impl) { d-&gt;m_Name = name; }
  CustomMimeType::CustomMimeType(const CustomMimeType &amp;other) : d(new Impl(*other.d)) {}</span>
<span style = "background-color:#fdd">  CustomMimeType::CustomMimeType(const MimeType &amp;other) : d(new Impl)
  {
    d-&gt;m_Name = other.GetName();
    d-&gt;m_Category = other.GetCategory();
    d-&gt;m_Extensions = other.GetExtensions();
    d-&gt;m_Comment = other.GetComment();
  }</span>

  CustomMimeType &amp;CustomMimeType::operator=(const CustomMimeType &amp;other)
<span style = "background-color:#fdd">  {
    CustomMimeType tmp(other);
    Swap(tmp);
    return *this;
  }</span>

  CustomMimeType &amp;CustomMimeType::operator=(const MimeType &amp;other)
<span style = "background-color:#fdd">  {
    CustomMimeType tmp(other);
    Swap(tmp);
    return *this;
  }</span>

<span style = "background-color:#dfd">  std::string CustomMimeType::GetName() const { return d-&gt;m_Name; }</span>
<span style = "background-color:#fdd">  std::string CustomMimeType::GetCategory() const { return d-&gt;m_Category; }</span>
<span style = "background-color:#dfd">  std::vector&lt;std::string&gt; CustomMimeType::GetExtensions() const { return d-&gt;m_Extensions; }</span>
  std::string CustomMimeType::GetComment() const
<span style = "background-color:#fdd">  {
    if (!d-&gt;m_Comment.empty())
      return d-&gt;m_Comment;
    if (!d-&gt;m_Extensions.empty())</span>
    {
<span style = "background-color:#fdd">      return d-&gt;m_Extensions.front() + " File";</span>
    }
<span style = "background-color:#fdd">    return "Unknown";
  }</span>

<span style = "background-color:#fdd">  bool CustomMimeType::AppliesTo(const std::string &amp;path) const { return MatchesExtension(path); }</span>
  bool CustomMimeType::MatchesExtension(const std::string &amp;path) const
<span style = "background-color:#fdd">  {
    std::string extension, filename;
    return ParsePathForExtension(path, extension, filename);
  }</span>

  std::string CustomMimeType::GetExtension(const std::string &amp;path) const
<span style = "background-color:#fdd">  {
    std::string extension, filename;
    ParsePathForExtension(path, extension, filename);
    return extension;
  }</span>

  std::string CustomMimeType::GetFilenameWithoutExtension(const std::string &amp;path) const
<span style = "background-color:#fdd">  {
    std::string extension, filename;
    ParsePathForExtension(path, extension, filename);
    return filename;
  }</span>

  bool CustomMimeType::ParsePathForExtension(const std::string &amp;path,
                                             std::string &amp;extension,
                                             std::string &amp;filename) const
<span style = "background-color:#fdd">  {
    for (std::vector&lt;std::string&gt;::const_iterator iter = d-&gt;m_Extensions.begin(), iterEnd = d-&gt;m_Extensions.end();
         iter != iterEnd;
         ++iter)</span>
    {
<span style = "background-color:#fdd">      if (!iter-&gt;empty() &amp;&amp; path.size() &gt;= iter-&gt;size())</span>
      {
<span style = "background-color:#fdd">        FindCaseInsensitive cmp(*iter);
        if (cmp(path.substr(path.size() - iter-&gt;size())))</span>
        {
<span style = "background-color:#fdd">          extension = "." + *iter;
          std::string filenameWithExtension = Utf8Util::Utf8ToLocal8Bit(itksys::SystemTools::GetFilenameName(Utf8Util::Local8BitToUtf8(path)));
          filename = filenameWithExtension.substr(0, filenameWithExtension.size() - extension.size());
          return true;</span>
        }
<span style = "background-color:#fdd">      }
    }
    return false;
  }</span>

<span style = "background-color:#dfd">  void CustomMimeType::SetName(const std::string &amp;name) { d-&gt;m_Name = name; }
  void CustomMimeType::SetCategory(const std::string &amp;category) { d-&gt;m_Category = category; }</span>
  void CustomMimeType::SetExtension(const std::string &amp;extension)
<span style = "background-color:#fdd">  {
    d-&gt;m_Extensions.clear();
    d-&gt;m_Extensions.push_back(extension);
  }</span>

  void CustomMimeType::AddExtension(const std::string &amp;extension)
<span style = "background-color:#dfd">  {
    if (std::find_if(d-&gt;m_Extensions.begin(), d-&gt;m_Extensions.end(), FindCaseInsensitive(extension)) ==</span>
        d-&gt;m_Extensions.end())
    {
<span style = "background-color:#dfd">      d-&gt;m_Extensions.push_back(extension);</span>
    }
<span style = "background-color:#dfd">  }</span>

<span style = "background-color:#dfd">  void CustomMimeType::SetComment(const std::string &amp;comment) { d-&gt;m_Comment = comment; }</span>
  void CustomMimeType::Swap(CustomMimeType &amp;r)
<span style = "background-color:#fdd">  {
    Impl *d1 = d;
    d = r.d;
    r.d = d1;
  }</span>

<span style = "background-color:#dfd">  CustomMimeType *CustomMimeType::Clone() const { return new CustomMimeType(*this); }</span>
<span style = "background-color:#fdd">  void swap(CustomMimeType &amp;l, CustomMimeType &amp;r) { l.Swap(r); }</span>
}</pre>
	</body>
</html>