<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkStateMachineContainer.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkStateMachineContainer.h"
#include &lt;algorithm&gt;
#include &lt;mitkStandardFileLocations.h&gt;
#include &lt;vtkObjectFactory.h&gt;
#include &lt;vtkXMLDataElement.h&gt;

// us
#include "usGetModuleContext.h"
#include "usModule.h"
#include "usModuleResource.h"
#include "usModuleResourceStream.h"

/**
 * @brief This class builds up all the necessary structures for a statemachine.
 * and stores one start-state for all built statemachines.
 **/
// XML StateMachine Tags
<span style = "background-color:#dfd">const std::string NAME = "name";
const std::string CONFIG = "statemachine";
const std::string STATE = "state";
const std::string STATEMODE = "state_mode";
const std::string TRANSITION = "transition";
const std::string EVENTCLASS = "event_class";
const std::string EVENTVARIANT = "event_variant";
const std::string STARTSTATE = "startstate";
const std::string TARGET = "target";
const std::string ACTION = "action";
const std::string CONDITION = "condition";
const std::string INVERTED = "inverted";</span>

namespace mitk
{
<span style = "background-color:#fdd">  vtkStandardNewMacro(StateMachineContainer);</span>
}

<span style = "background-color:#fdd">mitk::StateMachineContainer::StateMachineContainer() : m_StartStateFound(false), m_errors(false)
{
}</span>

mitk::StateMachineContainer::~StateMachineContainer()
<span style = "background-color:#fdd">{
}</span>

/**
 * @brief Loads the xml file filename and generates the necessary instances.
 **/
bool mitk::StateMachineContainer::LoadBehavior(const std::string &amp;fileName, const us::Module *module)
<span style = "background-color:#fdd">{
  if (module == nullptr)</span>
  {
<span style = "background-color:#fdd">    module = us::GetModuleContext()-&gt;GetModule();</span>
  }
<span style = "background-color:#fdd">  us::ModuleResource resource = module-&gt;GetResource("Interactions/" + fileName);
  if (!resource.IsValid())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; ("Resource not valid. State machine pattern not found:" + fileName);</span>
  }
<span style = "background-color:#fdd">  us::ModuleResourceStream stream(resource);
  this-&gt;SetStream(&amp;stream);
  m_Filename = fileName;
  return this-&gt;Parse() &amp;&amp; !m_errors;
}</span>

mitk::StateMachineState::Pointer mitk::StateMachineContainer::GetStartState() const
<span style = "background-color:#fdd">{
  return m_StartState;
}</span>

/**
 * @brief sets the pointers in Transition (setNextState(..)) according to the extracted xml-file content
 **/
void mitk::StateMachineContainer::ConnectStates()
<span style = "background-color:#fdd">{
  for (auto it = m_States.begin(); it != m_States.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    if ((*it)-&gt;ConnectTransitions(&amp;m_States) == false)
      m_errors = true;
  }
}</span>

void mitk::StateMachineContainer::StartElement(const char *elementName, const char **atts)
<span style = "background-color:#fdd">{
  std::string name(elementName);</span>

<span style = "background-color:#fdd">  if (name == CONFIG)</span>
  {
    //
<span style = "background-color:#fdd">  }
  else if (name == STATE)</span>
  {
<span style = "background-color:#fdd">    std::string stateName = ReadXMLStringAttribut(NAME, atts);
    std::transform(stateName.begin(), stateName.end(), stateName.begin(), ::toupper);
    std::string stateMode = ReadXMLStringAttribut(STATEMODE, atts);
    std::transform(stateMode.begin(), stateMode.end(), stateMode.begin(), ::toupper);
    bool isStartState = ReadXMLBooleanAttribut(STARTSTATE, atts);</span>

<span style = "background-color:#fdd">    if (isStartState)</span>
    {
<span style = "background-color:#fdd">      m_StartStateFound = true;</span>
    }

    // sanitize state modes
<span style = "background-color:#fdd">    if (stateMode == "" || stateMode == "REGULAR")</span>
    {
<span style = "background-color:#fdd">      stateMode = "REGULAR";
    }
    else if (stateMode != "GRAB_INPUT" &amp;&amp; stateMode != "PREFER_INPUT")</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Invalid State Modus " &lt;&lt; stateMode &lt;&lt; ". Mode assumed to be REGULAR";
      stateMode = "REGULAR";</span>
    }
<span style = "background-color:#fdd">    m_CurrState = mitk::StateMachineState::New(stateName, stateMode);</span>

<span style = "background-color:#fdd">    if (isStartState)
      m_StartState = m_CurrState;
  }
  else if (name == TRANSITION)</span>
  {
<span style = "background-color:#fdd">    std::string eventClass = ReadXMLStringAttribut(EVENTCLASS, atts);
    std::string eventVariant = ReadXMLStringAttribut(EVENTVARIANT, atts);
    std::string target = ReadXMLStringAttribut(TARGET, atts);
    std::transform(target.begin(), target.end(), target.begin(), ::toupper);</span>

<span style = "background-color:#fdd">    mitk::StateMachineTransition::Pointer transition =</span>
      mitk::StateMachineTransition::New(target, eventClass, eventVariant);
<span style = "background-color:#fdd">    if (m_CurrState)</span>
    {
<span style = "background-color:#fdd">      m_CurrState-&gt;AddTransition(transition);
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Malformed Statemachine Pattern. Transition has no origin. \n Will be ignored.";
      MITK_WARN &lt;&lt; "Malformed Transition details: target=" &lt;&lt; target &lt;&lt; ", event class:" &lt;&lt; eventClass</span>
                &lt;&lt; ", event variant:" &lt;&lt; eventVariant;
    }
<span style = "background-color:#fdd">    m_CurrTransition = transition;
  }</span>

<span style = "background-color:#fdd">  else if (name == ACTION)</span>
  {
<span style = "background-color:#fdd">    std::string actionName = ReadXMLStringAttribut(NAME, atts);
    mitk::StateMachineAction::Pointer action = mitk::StateMachineAction::New(actionName);
    if (m_CurrTransition)
      m_CurrTransition-&gt;AddAction(action);</span>
    else
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Malformed state machine Pattern. Action without transition. \n Will be ignored.";
  }</span>

<span style = "background-color:#fdd">  else if (name == CONDITION)</span>
  {
<span style = "background-color:#fdd">    if (!m_CurrTransition)
      MITK_WARN &lt;&lt; "Malformed state machine Pattern. Condition without transition. \n Will be ignored.";</span>

<span style = "background-color:#fdd">    std::string conditionName = ReadXMLStringAttribut(NAME, atts);
    std::string inverted = ReadXMLStringAttribut(INVERTED, atts);
    if (inverted == "" || inverted == "false")</span>
    {
<span style = "background-color:#fdd">      m_CurrTransition-&gt;AddCondition(mitk::StateMachineCondition(conditionName, false));
    }</span>
    else
    {
<span style = "background-color:#fdd">      m_CurrTransition-&gt;AddCondition(mitk::StateMachineCondition(conditionName, true));</span>
    }
<span style = "background-color:#fdd">  }
}</span>

void mitk::StateMachineContainer::EndElement(const char *elementName)
<span style = "background-color:#fdd">{
  std::string name(elementName);</span>

<span style = "background-color:#fdd">  if (name == CONFIG)</span>
  {
<span style = "background-color:#fdd">    if (m_StartState.IsNull())</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "State machine pattern has no start state and cannot be used: " &lt;&lt; m_Filename;</span>
    }
<span style = "background-color:#fdd">    ConnectStates();
  }
  else if (name == TRANSITION)</span>
  {
<span style = "background-color:#fdd">    m_CurrTransition = nullptr;
  }
  else if (name == ACTION)</span>
  {
    //
<span style = "background-color:#fdd">  }
  else if (name == CONDITION)</span>
  {
    //
<span style = "background-color:#fdd">  }
  else if (name == STATE)</span>
  {
<span style = "background-color:#fdd">    m_States.push_back(m_CurrState);
    m_CurrState = nullptr;</span>
  }
<span style = "background-color:#fdd">}</span>

std::string mitk::StateMachineContainer::ReadXMLStringAttribut(std::string name, const char **atts)
<span style = "background-color:#fdd">{
  if (atts)</span>
  {
<span style = "background-color:#fdd">    const char **attsIter = atts;</span>

<span style = "background-color:#fdd">    while (*attsIter)</span>
    {
<span style = "background-color:#fdd">      if (name == *attsIter)</span>
      {
<span style = "background-color:#fdd">        attsIter++;
        return *attsIter;</span>
      }
<span style = "background-color:#fdd">      attsIter++;
      attsIter++;
    }</span>
  }

<span style = "background-color:#fdd">  return std::string();
}</span>

bool mitk::StateMachineContainer::ReadXMLBooleanAttribut(std::string name, const char **atts)
<span style = "background-color:#fdd">{
  std::string s = ReadXMLStringAttribut(name, atts);
  std::transform(s.begin(), s.end(), s.begin(), ::toupper);
  if (s == "TRUE")
    return true;</span>
  else
<span style = "background-color:#fdd">    return false;
}</span></pre>
	</body>
</html>