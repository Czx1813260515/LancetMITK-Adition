<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlaneGeometry.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlaneGeometry.h"
#include "mitkInteractionConst.h"
#include "mitkLine.h"
#include "mitkPlaneOperation.h"

#include &lt;itkSpatialOrientationAdapter.h&gt;

#include &lt;vtkTransform.h&gt;

#include &lt;vnl/vnl_cross.h&gt;

namespace mitk
{
<span style = "background-color:#fdd">  PlaneGeometry::PlaneGeometry() : Superclass(), m_ReferenceGeometry(nullptr) { Initialize(); }
  PlaneGeometry::~PlaneGeometry() {}</span>
  PlaneGeometry::PlaneGeometry(const PlaneGeometry &amp;other)
<span style = "background-color:#fdd">    : Superclass(other), m_ReferenceGeometry(other.m_ReferenceGeometry)
  {
  }</span>

  bool PlaneGeometry::CheckRotationMatrix(mitk::AffineTransform3D *transform, double epsilon)
<span style = "background-color:#fdd">  {
    bool rotation = true;</span>

<span style = "background-color:#fdd">    auto matrix = transform-&gt;GetMatrix().GetVnlMatrix();
    matrix.normalize_columns();</span>

<span style = "background-color:#fdd">    auto det = vnl_determinant(matrix);
    if (fabs(det-1.0) &gt; epsilon)</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Invalid rotation matrix! Determinant != 1 (" &lt;&lt; det &lt;&lt; ")";
      rotation = false;</span>
    }

<span style = "background-color:#fdd">    vnl_matrix_fixed&lt;double, 3, 3&gt; id; id.set_identity();
    auto should_be_id = matrix*matrix.transpose();
    should_be_id -= id;
    auto max = should_be_id.absolute_value_max();
    if (max &gt; epsilon)</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Invalid rotation matrix! R*R^T != ID. Max value: " &lt;&lt; max &lt;&lt; " (should be 0)";
      rotation = false;</span>
    }

<span style = "background-color:#fdd">    return rotation;
  }</span>

  void PlaneGeometry::CheckIndexToWorldTransform(mitk::AffineTransform3D *transform)
<span style = "background-color:#fdd">  {
    this-&gt;CheckRotationMatrix(transform);
  }</span>

  void PlaneGeometry::CheckBounds(const BoundingBox::BoundsArrayType &amp;bounds)
<span style = "background-color:#fdd">  {</span>
    // error: unused parameter 'bounds'
    // this happens in release mode, where the assert macro is defined empty
    // hence we "use" the parameter:
    (void)bounds;

    // currently the unit rectangle must be starting at the origin [0,0]
<span style = "background-color:#fdd">    assert(bounds[0] == 0);
    assert(bounds[2] == 0);</span>
    // the unit rectangle must be two-dimensional
<span style = "background-color:#fdd">    assert(bounds[1] &gt; 0);
    assert(bounds[3] &gt; 0);
  }</span>

  void PlaneGeometry::IndexToWorld(const Point2D &amp;pt_units, Point2D &amp;pt_mm) const
<span style = "background-color:#fdd">  {
    pt_mm[0] = GetExtentInMM(0) / GetExtent(0) * pt_units[0];
    pt_mm[1] = GetExtentInMM(1) / GetExtent(1) * pt_units[1];
  }</span>

  void PlaneGeometry::WorldToIndex(const Point2D &amp;pt_mm, Point2D &amp;pt_units) const
<span style = "background-color:#fdd">  {
    pt_units[0] = pt_mm[0] * (1.0 / (GetExtentInMM(0) / GetExtent(0)));
    pt_units[1] = pt_mm[1] * (1.0 / (GetExtentInMM(1) / GetExtent(1)));
  }</span>

  void PlaneGeometry::IndexToWorld(const Point2D &amp; /*atPt2d_units*/, const Vector2D &amp;vec_units, Vector2D &amp;vec_mm) const
<span style = "background-color:#fdd">  {
    MITK_WARN &lt;&lt; "Warning! Call of the deprecated function PlaneGeometry::IndexToWorld(point, vec, vec). Use "</span>
                 "PlaneGeometry::IndexToWorld(vec, vec) instead!";
<span style = "background-color:#fdd">    this-&gt;IndexToWorld(vec_units, vec_mm);
  }</span>

  void PlaneGeometry::IndexToWorld(const Vector2D &amp;vec_units, Vector2D &amp;vec_mm) const
<span style = "background-color:#fdd">  {
    vec_mm[0] = (GetExtentInMM(0) / GetExtent(0)) * vec_units[0];
    vec_mm[1] = (GetExtentInMM(1) / GetExtent(1)) * vec_units[1];
  }</span>

  void PlaneGeometry::WorldToIndex(const Point2D &amp; /*atPt2d_mm*/, const Vector2D &amp;vec_mm, Vector2D &amp;vec_units) const
<span style = "background-color:#fdd">  {
    MITK_WARN &lt;&lt; "Warning! Call of the deprecated function PlaneGeometry::WorldToIndex(point, vec, vec). Use "</span>
                 "PlaneGeometry::WorldToIndex(vec, vec) instead!";
<span style = "background-color:#fdd">    this-&gt;WorldToIndex(vec_mm, vec_units);
  }</span>

  void PlaneGeometry::WorldToIndex(const Vector2D &amp;vec_mm, Vector2D &amp;vec_units) const
<span style = "background-color:#fdd">  {
    vec_units[0] = vec_mm[0] * (1.0 / (GetExtentInMM(0) / GetExtent(0)));
    vec_units[1] = vec_mm[1] * (1.0 / (GetExtentInMM(1) / GetExtent(1)));
  }</span>

  void PlaneGeometry::InitializeStandardPlane(mitk::ScalarType width,
                                              ScalarType height,
                                              const Vector3D &amp;spacing,
                                              PlaneGeometry::PlaneOrientation planeorientation,
                                              ScalarType zPosition,
                                              bool frontside,
                                              bool rotated,
                                              bool top)
<span style = "background-color:#fdd">  {
    AffineTransform3D::Pointer transform;</span>

<span style = "background-color:#fdd">    transform = AffineTransform3D::New();
    AffineTransform3D::MatrixType matrix;
    AffineTransform3D::MatrixType::InternalMatrixType &amp;vnlmatrix = matrix.GetVnlMatrix();</span>

<span style = "background-color:#fdd">    vnlmatrix.set_identity();
    vnlmatrix(0, 0) = spacing[0];
    vnlmatrix(1, 1) = spacing[1];
    vnlmatrix(2, 2) = spacing[2];
    transform-&gt;SetIdentity();
    transform-&gt;SetMatrix(matrix);</span>

<span style = "background-color:#fdd">    InitializeStandardPlane(width, height, transform.GetPointer(), planeorientation, zPosition, frontside, rotated, top);
  }</span>

  void PlaneGeometry::InitializeStandardPlane(mitk::ScalarType width,
                                              mitk::ScalarType height,
                                              const AffineTransform3D *transform /* = nullptr */,
                                              PlaneGeometry::PlaneOrientation planeorientation /* = Axial */,
                                              mitk::ScalarType zPosition /* = 0 */,
                                              bool frontside /* = true */,
                                              bool rotated /* = false */,
                                              bool top /* = true */)
<span style = "background-color:#fdd">  {
    Superclass::Initialize();</span>

    /// construct standard view.

    // We define at the moment "frontside" as: axial from above,
    // coronal from front (nose), saggital from right.
    // TODO: Double check with medicals doctors or radiologists [ ].

    // We define the orientation in patient's view, e.g. LAI is in a axial cut
    // (parallel to the triangle ear-ear-nose):
    // first axis: To the left ear of the patient
    // seecond axis: To the nose of the patient
    // third axis: To the legs of the patient.

    // Options are: L/R left/right; A/P anterior/posterior; I/S inferior/superior
    // (AKA caudal/cranial).
    // We note on all cases in the following switch block r.h. for right handed
    // or l.h. for left handed to describe the different cases.
    // However, which system is chosen is defined at the end of the switch block.

    // CAVE / be careful: the vectors right and bottom are relative to the plane
    // and do NOT describe e.g. the right side of the patient.

<span style = "background-color:#fdd">    Point3D origin;</span>
    /** Bottom means downwards, DV means Direction Vector. Both relative to the image! */
<span style = "background-color:#fdd">    VnlVector rightDV(3), bottomDV(3);</span>
    /** Origin of this plane is by default a zero vector and implicitly in the top-left corner: */
<span style = "background-color:#fdd">    origin.Fill(0);</span>
    /** This is different to all definitions in MITK, except the QT mouse clicks.
    *   But it is like this here and we don't want to change a running system.
    *   Just be aware, that IN THIS FUNCTION we define the origin at the top left (e.g. your screen). */

    /** NormalDirection defines which axis (i.e. column index in the transform matrix)
    * is perpendicular to the plane: */
    int normalDirection;

<span style = "background-color:#fdd">    switch (planeorientation) // Switch through our limited choice of standard planes:</span>
    {
      case None:
      /** Orientation 'None' shall be done like the axial plane orientation,
       *  for whatever reasons. */
      case Axial:
<span style = "background-color:#fdd">        if (frontside) // Radiologist's view from below. A cut along the triangle ear-ear-nose.</span>
        {
<span style = "background-color:#fdd">          if (rotated == false)</span>
          /** Origin in the top-left corner, x=[1; 0; 0], y=[0; 1; 0], z=[0; 0; 1],
          *   origin=[0,0,zpos]: LAI (r.h.)
          *
          *  0---rightDV----&gt;                            |
          *  |                                           |
          *  |  Picture of a finite, rectangular plane   |
          *  |  ( insert LOLCAT-scan here ^_^ )          |
          *  |                                           |
          *  v  _________________________________________|
          *
          */
          {
<span style = "background-color:#fdd">            FillVector3D(origin, 0, 0, zPosition);
            FillVector3D(rightDV, 1, 0, 0);
            FillVector3D(bottomDV, 0, 1, 0);
          }</span>
          else // Origin rotated to the bottom-right corner, x=[-1; 0; 0], y=[0; -1; 0], z=[0; 0; 1],
               // origin=[w,h,zpos]: RPI (r.h.)
          {    // Caveat emptor:  Still  using  top-left  as  origin  of  index  coordinate  system!
<span style = "background-color:#fdd">            FillVector3D(origin, width, height, zPosition);
            FillVector3D(rightDV, -1, 0, 0);
            FillVector3D(bottomDV, 0, -1, 0);</span>
          }
<span style = "background-color:#fdd">        }</span>
        else // 'Backside, not frontside.' Neuro-Surgeons's view from above patient.
        {
<span style = "background-color:#fdd">          if (rotated == false) // x=[-1; 0; 0], y=[0; 1; 0], z=[0; 0; 1], origin=[w,0,zpos]:  RAS (r.h.)</span>
          {
<span style = "background-color:#fdd">            FillVector3D(origin, width, 0, zPosition);
            FillVector3D(rightDV, -1, 0, 0);
            FillVector3D(bottomDV, 0, 1, 0);
          }</span>
          else // Origin in the bottom-left corner, x=[1; 0; 0], y=[0; -1; 0], z=[0; 0; 1],
               // origin=[0,h,zpos]:  LPS (r.h.)
          {
<span style = "background-color:#fdd">            FillVector3D(origin, 0, height, zPosition);
            FillVector3D(rightDV, 1, 0, 0);
            FillVector3D(bottomDV, 0, -1, 0);</span>
          }
        }
<span style = "background-color:#fdd">        normalDirection = 2; // That is S=Superior=z=third_axis=middlefinger in righthanded LPS-system.
        break;</span>

      // Frontal is known as Coronal in mitk. Plane cuts through patient's ear-ear-heel-heel:
      case Frontal:
<span style = "background-color:#fdd">        if (frontside)</span>
        {
<span style = "background-color:#fdd">          if (rotated == false) // x=[1; 0; 0], y=[0; 0; 1], z=[0; 1; 0], origin=[0,zpos,0]: LAI (r.h.)</span>
          {
<span style = "background-color:#fdd">            FillVector3D(origin, 0, zPosition, 0);
            FillVector3D(rightDV, 1, 0, 0);
            FillVector3D(bottomDV, 0, 0, 1);
          }</span>
          else // x=[-1;0;0], y=[0;0;-1], z=[0;1;0], origin=[w,zpos,h]:  RAS  (r.h.)
          {
<span style = "background-color:#fdd">            FillVector3D(origin, width, zPosition, height);
            FillVector3D(rightDV, -1, 0, 0);
            FillVector3D(bottomDV, 0, 0, -1);</span>
          }
<span style = "background-color:#fdd">        }</span>
        else
        {
<span style = "background-color:#fdd">          if (rotated == false) //  x=[-1;0;0], y=[0;0;1], z=[0;1;0], origin=[w,zpos,0]: RPI (r.h.)</span>
          {
<span style = "background-color:#fdd">            FillVector3D(origin, width, zPosition, 0);
            FillVector3D(rightDV, -1, 0, 0);
            FillVector3D(bottomDV, 0, 0, 1);
          }</span>
          else //  x=[1;0;0], y=[0;1;0], z=[0;0;-1], origin=[0,zpos,h]: LPS (r.h.)
          {
<span style = "background-color:#fdd">            FillVector3D(origin, 0, zPosition, height);
            FillVector3D(rightDV, 1, 0, 0);
            FillVector3D(bottomDV, 0, 0, -1);</span>
          }
        }
<span style = "background-color:#fdd">        normalDirection = 1; // Normal vector = posterior direction.
        break;</span>

      case Sagittal: // Sagittal=Medial plane, the symmetry-plane mirroring your face.
<span style = "background-color:#fdd">        if (frontside)</span>
        {
<span style = "background-color:#fdd">          if (rotated == false) //  x=[0;1;0], y=[0;0;1], z=[1;0;0], origin=[zpos,0,0]:  LAI (r.h.)</span>
          {
<span style = "background-color:#fdd">            FillVector3D(origin, zPosition, 0, 0);
            FillVector3D(rightDV, 0, 1, 0);
            FillVector3D(bottomDV, 0, 0, 1);
          }</span>
          else //  x=[0;-1;0], y=[0;0;-1], z=[1;0;0], origin=[zpos,w,h]:  LPS (r.h.)
          {
<span style = "background-color:#fdd">            FillVector3D(origin, zPosition, width, height);
            FillVector3D(rightDV, 0, -1, 0);
            FillVector3D(bottomDV, 0, 0, -1);</span>
          }
<span style = "background-color:#fdd">        }</span>
        else
        {
<span style = "background-color:#fdd">          if (rotated == false) //  x=[0;-1;0], y=[0;0;1], z=[1;0;0], origin=[zpos,w,0]:  RPI (r.h.)</span>
          {
<span style = "background-color:#fdd">            FillVector3D(origin, zPosition, width, 0);
            FillVector3D(rightDV, 0, -1, 0);
            FillVector3D(bottomDV, 0, 0, 1);
          }</span>
          else //  x=[0;1;0], y=[0;0;-1], z=[1;0;0], origin=[zpos,0,h]:  RAS (r.h.)
          {
<span style = "background-color:#fdd">            FillVector3D(origin, zPosition, 0, height);
            FillVector3D(rightDV, 0, 1, 0);
            FillVector3D(bottomDV, 0, 0, -1);</span>
          }
        }
<span style = "background-color:#fdd">        normalDirection = 0; // Normal vector = Lateral direction: Left in a LPS-system.
        break;</span>

      default:
<span style = "background-color:#fdd">        itkExceptionMacro("unknown PlaneOrientation");</span>
    }

<span style = "background-color:#fdd">    VnlVector normal(3);
    FillVector3D(normal, 0, 0, 0);
    normal[normalDirection] = top ? 1 : -1;</span>

<span style = "background-color:#fdd">    if ( transform != nullptr )</span>
    {
<span style = "background-color:#fdd">      origin = transform-&gt;TransformPoint( origin );
      rightDV = transform-&gt;TransformVector( rightDV ).as_ref();
      bottomDV = transform-&gt;TransformVector( bottomDV ).as_ref();
      normal = transform-&gt;TransformVector( normal ).as_ref();</span>
    }

<span style = "background-color:#fdd">    ScalarType bounds[6] = {0, width, 0, height, 0, 1};
    this-&gt;SetBounds(bounds);</span>

<span style = "background-color:#fdd">    AffineTransform3D::Pointer planeTransform = AffineTransform3D::New();
    Matrix3D matrix;
    matrix.GetVnlMatrix().set_column(0, rightDV.as_ref());
    matrix.GetVnlMatrix().set_column(1, bottomDV.as_ref());
    matrix.GetVnlMatrix().set_column(2, normal.as_ref());
    planeTransform-&gt;SetMatrix(matrix);
    planeTransform-&gt;SetOffset(this-&gt;GetIndexToWorldTransform()-&gt;GetOffset());
    this-&gt;SetIndexToWorldTransform(planeTransform);</span>

<span style = "background-color:#fdd">    this-&gt;SetOrigin(origin);
  }</span>

  std::vector&lt; int &gt; PlaneGeometry::CalculateDominantAxes(mitk::AffineTransform3D::MatrixType::InternalMatrixType&amp; rotation_matrix)
<span style = "background-color:#fdd">  {
    std::vector&lt; int &gt; axes;</span>

<span style = "background-color:#fdd">    bool dominant_axis_error = false;
    for (int i = 0; i &lt; 3; ++i)</span>
    {
<span style = "background-color:#fdd">      int dominantAxis = itk::Function::Max3(</span>
          rotation_matrix[0][i],
          rotation_matrix[1][i],
          rotation_matrix[2][i]
      );

<span style = "background-color:#fdd">      for (int j=0; j&lt;i; ++j)
        if (axes[j] == dominantAxis)</span>
        {
<span style = "background-color:#fdd">          dominant_axis_error = true;
          break;
        }
      if (dominant_axis_error)
        break;</span>

<span style = "background-color:#fdd">      axes.push_back(dominantAxis);
    }</span>

<span style = "background-color:#fdd">    if (dominant_axis_error)</span>
    {
<span style = "background-color:#fdd">      MITK_DEBUG &lt;&lt; "Error during dominant axis calculation. Using default.";
      MITK_DEBUG &lt;&lt; "This is either caused by an imperfect rotation matrix or if the rotation is axactly 45Â° around one or more axis.";
      axes.clear();
      for (int i = 0; i &lt; 3; ++i)
        axes.push_back(i);</span>
    }

<span style = "background-color:#fdd">    return axes;
  }</span>

  void PlaneGeometry::InitializeStandardPlane(const BaseGeometry *geometry3D,
                                              PlaneOrientation planeorientation,
                                              ScalarType zPosition,
                                              bool frontside,
                                              bool rotated,
                                              bool top)
<span style = "background-color:#fdd">  {
    this-&gt;SetReferenceGeometry(geometry3D);</span>

    ScalarType width, height;

    // Inspired by:
    // http://www.na-mic.org/Wiki/index.php/Coordinate_System_Conversion_Between_ITK_and_Slicer3

<span style = "background-color:#fdd">    mitk::AffineTransform3D::MatrixType matrix = geometry3D-&gt;GetIndexToWorldTransform()-&gt;GetMatrix();</span>

<span style = "background-color:#fdd">    matrix.GetVnlMatrix().normalize_columns();
    mitk::AffineTransform3D::MatrixType::InternalMatrixType inverseMatrix = matrix.GetTranspose();</span>

    /// The index of the sagittal, coronal and axial axes in the reference geometry.
<span style = "background-color:#fdd">    auto axes = CalculateDominantAxes(inverseMatrix);</span>
    /// The direction of the sagittal, coronal and axial axes in the reference geometry.
    /// +1 means that the direction is straight, i.e. greater index translates to greater
    /// world coordinate. -1 means that the direction is inverted.
    int directions[3];
    ScalarType extents[3];
    ScalarType spacings[3];
<span style = "background-color:#fdd">    for (int i=0; i&lt;3; ++i)</span>
    {
<span style = "background-color:#fdd">      int dominantAxis = axes.at(i);
      directions[i] = itk::Function::Sign(inverseMatrix[dominantAxis][i]);
      extents[i] = geometry3D-&gt;GetExtent(dominantAxis);
      spacings[i] = geometry3D-&gt;GetSpacing()[dominantAxis];
    }</span>

    // matrix(column) = inverseTransformMatrix(row) * flippedAxes * spacing
<span style = "background-color:#fdd">    matrix[0][0] = inverseMatrix[axes[0]][0] * directions[0] * spacings[0];
    matrix[1][0] = inverseMatrix[axes[0]][1] * directions[0] * spacings[0];
    matrix[2][0] = inverseMatrix[axes[0]][2] * directions[0] * spacings[0];
    matrix[0][1] = inverseMatrix[axes[1]][0] * directions[1] * spacings[1];
    matrix[1][1] = inverseMatrix[axes[1]][1] * directions[1] * spacings[1];
    matrix[2][1] = inverseMatrix[axes[1]][2] * directions[1] * spacings[1];
    matrix[0][2] = inverseMatrix[axes[2]][0] * directions[2] * spacings[2];
    matrix[1][2] = inverseMatrix[axes[2]][1] * directions[2] * spacings[2];
    matrix[2][2] = inverseMatrix[axes[2]][2] * directions[2] * spacings[2];</span>

    /// The "world origin" is the corner with the lowest physical coordinates.
    /// We use it as a reference point so that we get the correct anatomical
    /// orientations.
<span style = "background-color:#fdd">    Point3D worldOrigin = geometry3D-&gt;GetOrigin();
    for (int i = 0; i &lt; 3; ++i)</span>
    {
      /// The distance of the plane origin from the world origin in voxels.
<span style = "background-color:#fdd">      double offset = directions[i] &gt; 0 ? 0.0 : extents[i];</span>

<span style = "background-color:#fdd">      if (geometry3D-&gt;GetImageGeometry())</span>
      {
<span style = "background-color:#fdd">        offset += directions[i] * 0.5;</span>
      }

<span style = "background-color:#fdd">      for (int j = 0; j &lt; 3; ++j)</span>
      {
<span style = "background-color:#fdd">        worldOrigin[j] -= offset * matrix[j][i];
      }
    }</span>

<span style = "background-color:#fdd">    switch(planeorientation)</span>
    {
    case None:
    /** Orientation 'None' shall be done like the axial plane orientation,
     *  for whatever reasons. */
    case Axial:
<span style = "background-color:#fdd">      width  = extents[0];
      height = extents[1];
      break;</span>
    case Frontal:
<span style = "background-color:#fdd">      width  = extents[0];
      height = extents[2];
      break;</span>
    case Sagittal:
<span style = "background-color:#fdd">      width  = extents[1];
      height = extents[2];
      break;</span>
    default:
<span style = "background-color:#fdd">      itkExceptionMacro("unknown PlaneOrientation");</span>
    }

<span style = "background-color:#fdd">    ScalarType bounds[6]= { 0, width, 0, height, 0, 1 };
    this-&gt;SetBounds( bounds );</span>

<span style = "background-color:#fdd">    AffineTransform3D::Pointer transform = AffineTransform3D::New();
    transform-&gt;SetMatrix(matrix);
    transform-&gt;SetOffset(worldOrigin.GetVectorFromOrigin());</span>

<span style = "background-color:#fdd">    InitializeStandardPlane(</span>
      width, height, transform, planeorientation, zPosition, frontside, rotated, top);
<span style = "background-color:#fdd">  }</span>

  void PlaneGeometry::InitializeStandardPlane(
    const BaseGeometry *geometry3D, bool top, PlaneOrientation planeorientation, bool frontside, bool rotated)
<span style = "background-color:#fdd">  {</span>
    /// The index of the sagittal, coronal and axial axes in world coordinate system.
    int worldAxis;
<span style = "background-color:#fdd">    switch(planeorientation)</span>
    {
    case None:
    /** Orientation 'None' shall be done like the axial plane orientation,
     *  for whatever reasons. */
    case Axial:
<span style = "background-color:#fdd">      worldAxis = 2;
      break;</span>
    case Frontal:
<span style = "background-color:#fdd">      worldAxis = 1;
      break;</span>
    case Sagittal:
<span style = "background-color:#fdd">      worldAxis = 0;
      break;</span>
    default:
<span style = "background-color:#fdd">      itkExceptionMacro("unknown PlaneOrientation");</span>
    }

    // Inspired by:
    // http://www.na-mic.org/Wiki/index.php/Coordinate_System_Conversion_Between_ITK_and_Slicer3

<span style = "background-color:#fdd">    mitk::AffineTransform3D::ConstPointer affineTransform = geometry3D-&gt;GetIndexToWorldTransform();
    mitk::AffineTransform3D::MatrixType matrix = affineTransform-&gt;GetMatrix();
    matrix.GetVnlMatrix().normalize_columns();
    mitk::AffineTransform3D::MatrixType::InternalMatrixType inverseMatrix = matrix.GetInverse();</span>

    /// The index of the sagittal, coronal and axial axes in the reference geometry.
<span style = "background-color:#fdd">    int dominantAxis = CalculateDominantAxes(inverseMatrix).at(worldAxis);</span>

<span style = "background-color:#fdd">    ScalarType zPosition = top ? 0.5 : geometry3D-&gt;GetExtent(dominantAxis) - 0.5;</span>

<span style = "background-color:#fdd">    InitializeStandardPlane(geometry3D, planeorientation, zPosition, frontside, rotated, top);
  }</span>

  void PlaneGeometry::InitializeStandardPlane(const Vector3D &amp;rightVector,
                                              const Vector3D &amp;downVector,
                                              const Vector3D *spacing)
<span style = "background-color:#fdd">  {
    InitializeStandardPlane(rightVector.GetVnlVector(), downVector.GetVnlVector(), spacing);
  }</span>

  void PlaneGeometry::InitializeStandardPlane(const VnlVector &amp;rightVector,
                                              const VnlVector &amp;downVector,
                                              const Vector3D *spacing)
<span style = "background-color:#fdd">  {
    ScalarType width = rightVector.two_norm();
    ScalarType height = downVector.two_norm();</span>

<span style = "background-color:#fdd">    InitializeStandardPlane(width, height, rightVector, downVector, spacing);
  }</span>

  void PlaneGeometry::InitializeStandardPlane(mitk::ScalarType width,
                                              ScalarType height,
                                              const Vector3D &amp;rightVector,
                                              const Vector3D &amp;downVector,
                                              const Vector3D *spacing)
<span style = "background-color:#fdd">  {
    InitializeStandardPlane(width, height, rightVector.GetVnlVector(), downVector.GetVnlVector(), spacing);
  }</span>

  void PlaneGeometry::InitializeStandardPlane(mitk::ScalarType width,
                                              ScalarType height,
                                              const VnlVector &amp;rightVector,
                                              const VnlVector &amp;downVector,
                                              const Vector3D *spacing)
<span style = "background-color:#fdd">  {
    assert(width &gt; 0);
    assert(height &gt; 0);</span>

<span style = "background-color:#fdd">    VnlVector rightDV = rightVector;
    rightDV.normalize();
    VnlVector downDV = downVector;
    downDV.normalize();
    VnlVector normal = vnl_cross_3d(rightVector, downVector);
    normal.normalize();</span>
    // Crossproduct vnl_cross_3d is always righthanded, but that is okay here
    // because in this method we create a new IndexToWorldTransform and
    // spacing with 1 or 3 negative components could still make it lefthanded.

<span style = "background-color:#fdd">    if (spacing != nullptr)</span>
    {
<span style = "background-color:#fdd">      rightDV *= (*spacing)[0];
      downDV *= (*spacing)[1];
      normal *= (*spacing)[2];</span>
    }

<span style = "background-color:#fdd">    AffineTransform3D::Pointer transform = AffineTransform3D::New();
    Matrix3D matrix;
    matrix.GetVnlMatrix().set_column(0, rightDV);
    matrix.GetVnlMatrix().set_column(1, downDV);
    matrix.GetVnlMatrix().set_column(2, normal);
    transform-&gt;SetMatrix(matrix);
    transform-&gt;SetOffset(this-&gt;GetIndexToWorldTransform()-&gt;GetOffset());</span>

<span style = "background-color:#fdd">    ScalarType bounds[6] = {0, width, 0, height, 0, 1};
    this-&gt;SetBounds(bounds);</span>

<span style = "background-color:#fdd">    this-&gt;SetIndexToWorldTransform(transform);
  }</span>

  void PlaneGeometry::InitializePlane(const Point3D &amp;origin, const Vector3D &amp;normal)
<span style = "background-color:#fdd">  {
    VnlVector rightVectorVnl(3), downVectorVnl;</span>

<span style = "background-color:#fdd">    if (Equal(normal[1], 0.0f) == false)</span>
    {
<span style = "background-color:#fdd">      FillVector3D(rightVectorVnl, 1.0f, -normal[0] / normal[1], 0.0f);
      rightVectorVnl.normalize();
    }</span>
    else
    {
<span style = "background-color:#fdd">      FillVector3D(rightVectorVnl, 0.0f, 1.0f, 0.0f);</span>
    }
<span style = "background-color:#fdd">    downVectorVnl = vnl_cross_3d(normal.GetVnlVector(), rightVectorVnl);
    downVectorVnl.normalize();</span>
    // Crossproduct vnl_cross_3d is always righthanded.

<span style = "background-color:#fdd">    InitializeStandardPlane(rightVectorVnl, downVectorVnl);</span>

<span style = "background-color:#fdd">    SetOrigin(origin);
  }</span>

  void PlaneGeometry::SetMatrixByVectors(const VnlVector &amp;rightVector,
                                         const VnlVector &amp;downVector,
                                         ScalarType thickness /* = 1.0 */)
<span style = "background-color:#fdd">  {
    VnlVector normal = vnl_cross_3d(rightVector, downVector);
    normal.normalize();
    normal *= thickness;</span>
    // Crossproduct vnl_cross_3d is always righthanded, but that is okay here
    // because in this method we create a new IndexToWorldTransform and
    // a negative thickness could still make it lefthanded.

<span style = "background-color:#fdd">    AffineTransform3D::Pointer transform = AffineTransform3D::New();
    Matrix3D matrix;
    matrix.GetVnlMatrix().set_column(0, rightVector);
    matrix.GetVnlMatrix().set_column(1, downVector);
    matrix.GetVnlMatrix().set_column(2, normal);
    transform-&gt;SetMatrix(matrix);
    transform-&gt;SetOffset(this-&gt;GetIndexToWorldTransform()-&gt;GetOffset());
    SetIndexToWorldTransform(transform);
  }</span>

  Vector3D PlaneGeometry::GetNormal() const
<span style = "background-color:#fdd">  {
    Vector3D frontToBack;
    frontToBack.SetVnlVector(this-&gt;GetIndexToWorldTransform()-&gt;GetMatrix().GetVnlMatrix().get_column(2).as_ref());</span>

<span style = "background-color:#fdd">    return frontToBack;
  }</span>

  VnlVector PlaneGeometry::GetNormalVnl() const
<span style = "background-color:#fdd">  {
    return this-&gt;GetIndexToWorldTransform()-&gt;GetMatrix().GetVnlMatrix().get_column(2).as_ref();
  }</span>

<span style = "background-color:#fdd">  ScalarType PlaneGeometry::DistanceFromPlane(const Point3D &amp;pt3d_mm) const { return fabs(SignedDistance(pt3d_mm)); }
  ScalarType PlaneGeometry::SignedDistance(const Point3D &amp;pt3d_mm) const { return SignedDistanceFromPlane(pt3d_mm); }</span>
  bool PlaneGeometry::IsAbove(const Point3D &amp;pt3d_mm, bool considerBoundingBox) const
<span style = "background-color:#fdd">  {
    if (considerBoundingBox)</span>
    {
<span style = "background-color:#fdd">      Point3D pt3d_units;
      BaseGeometry::WorldToIndex(pt3d_mm, pt3d_units);
      return (pt3d_units[2] &gt; this-&gt;GetBoundingBox()-&gt;GetBounds()[4]);
    }</span>
    else
<span style = "background-color:#fdd">      return SignedDistanceFromPlane(pt3d_mm) &gt; 0;
  }</span>

  bool PlaneGeometry::IntersectionLine(const PlaneGeometry* plane, Line3D&amp; crossline) const
<span style = "background-color:#fdd">  {
    Vector3D normal = this-&gt;GetNormal();
    normal.Normalize();</span>

<span style = "background-color:#fdd">    Vector3D planeNormal = plane-&gt;GetNormal();
    planeNormal.Normalize();</span>

<span style = "background-color:#fdd">    Vector3D direction = itk::CrossProduct(normal, planeNormal);</span>

<span style = "background-color:#fdd">    if (direction.GetSquaredNorm() &lt; eps)
      return false;</span>

<span style = "background-color:#fdd">    crossline.SetDirection(direction);</span>

<span style = "background-color:#fdd">    double N1dN2 = normal * planeNormal;
    double determinant = 1.0 - N1dN2 * N1dN2;</span>

<span style = "background-color:#fdd">    Vector3D origin = this-&gt;GetOrigin().GetVectorFromOrigin();
    Vector3D planeOrigin = plane-&gt;GetOrigin().GetVectorFromOrigin();</span>

<span style = "background-color:#fdd">    double d1 = normal * origin;
    double d2 = planeNormal * planeOrigin;</span>

<span style = "background-color:#fdd">    double c1 = (d1 - d2 * N1dN2) / determinant;
    double c2 = (d2 - d1 * N1dN2) / determinant;</span>

<span style = "background-color:#fdd">    Vector3D p = normal * c1 + planeNormal * c2;
    crossline.GetPoint()[0] = p.GetVnlVector()[0];
    crossline.GetPoint()[1] = p.GetVnlVector()[1];
    crossline.GetPoint()[2] = p.GetVnlVector()[2];</span>

<span style = "background-color:#fdd">    return true;
  }</span>

  unsigned int PlaneGeometry::IntersectWithPlane2D(const PlaneGeometry *plane, Point2D &amp;lineFrom, Point2D &amp;lineTo) const
<span style = "background-color:#fdd">  {
    Line3D crossline;
    if (this-&gt;IntersectionLine(plane, crossline) == false)
      return 0;</span>

<span style = "background-color:#fdd">    Point2D point2;
    Vector2D direction2;</span>

<span style = "background-color:#fdd">    this-&gt;Map(crossline.GetPoint(), point2);
    this-&gt;Map(crossline.GetPoint(), crossline.GetDirection(), direction2);</span>

<span style = "background-color:#fdd">    return Line3D::RectangleLineIntersection(</span>
      0, 0, GetExtentInMM(0), GetExtentInMM(1), point2, direction2, lineFrom, lineTo);
<span style = "background-color:#fdd">  }</span>

  double PlaneGeometry::Angle(const PlaneGeometry *plane) const
<span style = "background-color:#fdd">  {
    return angle(plane-&gt;GetMatrixColumn(2), GetMatrixColumn(2));
  }</span>

  double PlaneGeometry::Angle(const Line3D &amp;line) const
<span style = "background-color:#fdd">  {
    return vnl_math::pi_over_2 - angle(line.GetDirection().GetVnlVector(), GetMatrixColumn(2));
  }</span>

  bool PlaneGeometry::IntersectionPoint(const Line3D &amp;line, Point3D &amp;intersectionPoint) const
<span style = "background-color:#fdd">  {
    Vector3D planeNormal = this-&gt;GetNormal();
    planeNormal.Normalize();</span>

<span style = "background-color:#fdd">    Vector3D lineDirection = line.GetDirection();
    lineDirection.Normalize();</span>

<span style = "background-color:#fdd">    double t = planeNormal * lineDirection;
    if (fabs(t) &lt; eps)</span>
    {
<span style = "background-color:#fdd">      return false;</span>
    }

<span style = "background-color:#fdd">    Vector3D diff;
    diff = this-&gt;GetOrigin() - line.GetPoint();
    t = (planeNormal * diff) / t;</span>

<span style = "background-color:#fdd">    intersectionPoint = line.GetPoint() + lineDirection * t;
    return true;
  }</span>

  bool PlaneGeometry::IntersectionPointParam(const Line3D &amp;line, double &amp;t) const
<span style = "background-color:#fdd">  {
    Vector3D planeNormal = this-&gt;GetNormal();</span>

<span style = "background-color:#fdd">    Vector3D lineDirection = line.GetDirection();</span>

<span style = "background-color:#fdd">    t = planeNormal * lineDirection;</span>

<span style = "background-color:#fdd">    if (fabs(t) &lt; eps)</span>
    {
<span style = "background-color:#fdd">      return false;</span>
    }

<span style = "background-color:#fdd">    Vector3D diff;
    diff = this-&gt;GetOrigin() - line.GetPoint();
    t = (planeNormal * diff) / t;
    return true;
  }</span>

  bool PlaneGeometry::IsParallel(const PlaneGeometry *plane) const
<span style = "background-color:#fdd">  {
    return ((Angle(plane) &lt; 10.0 * mitk::sqrteps) || (Angle(plane) &gt; (vnl_math::pi - 10.0 * sqrteps)));
  }</span>

<span style = "background-color:#fdd">  bool PlaneGeometry::IsOnPlane(const Point3D &amp;point) const { return Distance(point) &lt; eps; }</span>
  bool PlaneGeometry::IsOnPlane(const Line3D &amp;line) const
<span style = "background-color:#fdd">  {
    return ((Distance(line.GetPoint()) &lt; eps) &amp;&amp; (Distance(line.GetPoint2()) &lt; eps));
  }</span>

  bool PlaneGeometry::IsOnPlane(const PlaneGeometry *plane) const
<span style = "background-color:#fdd">  {
    return (IsParallel(plane) &amp;&amp; (Distance(plane-&gt;GetOrigin()) &lt; eps));
  }</span>

  Point3D PlaneGeometry::ProjectPointOntoPlane(const Point3D &amp;pt) const
<span style = "background-color:#fdd">  {
    ScalarType len = this-&gt;GetNormalVnl().two_norm();
    return pt - this-&gt;GetNormal() * this-&gt;SignedDistanceFromPlane(pt) / len;
  }</span>

  itk::LightObject::Pointer PlaneGeometry::InternalClone() const
<span style = "background-color:#fdd">  {
    Self::Pointer newGeometry = new PlaneGeometry(*this);
    newGeometry-&gt;UnRegister();
    return newGeometry.GetPointer();
  }</span>

  void PlaneGeometry::ExecuteOperation(Operation *operation)
<span style = "background-color:#fdd">  {
    vtkTransform *transform = vtkTransform::New();
    transform-&gt;SetMatrix(this-&gt;GetVtkMatrix());</span>

<span style = "background-color:#fdd">    switch (operation-&gt;GetOperationType())</span>
    {
      case OpORIENT:
      {
<span style = "background-color:#fdd">        auto *planeOp = dynamic_cast&lt;mitk::PlaneOperation *&gt;(operation);
        if (planeOp == nullptr)</span>
        {
<span style = "background-color:#fdd">          return;</span>
        }

<span style = "background-color:#fdd">        Point3D center = planeOp-&gt;GetPoint();</span>

<span style = "background-color:#fdd">        Vector3D orientationVector = planeOp-&gt;GetNormal();
        Vector3D defaultVector;
        FillVector3D(defaultVector, 0.0, 0.0, 1.0);</span>

<span style = "background-color:#fdd">        Vector3D rotationAxis = itk::CrossProduct(orientationVector, defaultVector);</span>
        // double rotationAngle = acos( orientationVector[2] / orientationVector.GetNorm() );

<span style = "background-color:#fdd">        double rotationAngle = atan2((double)rotationAxis.GetNorm(), (double)(orientationVector * defaultVector));
        rotationAngle *= 180.0 / vnl_math::pi;</span>

<span style = "background-color:#fdd">        transform-&gt;PostMultiply();
        transform-&gt;Identity();
        transform-&gt;Translate(center[0], center[1], center[2]);
        transform-&gt;RotateWXYZ(rotationAngle, rotationAxis[0], rotationAxis[1], rotationAxis[2]);
        transform-&gt;Translate(-center[0], -center[1], -center[2]);
        break;</span>
      }
      case OpRESTOREPLANEPOSITION:
      {
<span style = "background-color:#fdd">        auto *op = dynamic_cast&lt;mitk::RestorePlanePositionOperation *&gt;(operation);
        if (op == nullptr)</span>
        {
<span style = "background-color:#fdd">          return;</span>
        }

<span style = "background-color:#fdd">        AffineTransform3D::Pointer transform2 = AffineTransform3D::New();
        Matrix3D matrix;
        matrix.GetVnlMatrix().set_column(0, op-&gt;GetTransform()-&gt;GetMatrix().GetVnlMatrix().get_column(0));
        matrix.GetVnlMatrix().set_column(1, op-&gt;GetTransform()-&gt;GetMatrix().GetVnlMatrix().get_column(1));
        matrix.GetVnlMatrix().set_column(2, op-&gt;GetTransform()-&gt;GetMatrix().GetVnlMatrix().get_column(2));
        transform2-&gt;SetMatrix(matrix);
        Vector3D offset = op-&gt;GetTransform()-&gt;GetOffset();
        transform2-&gt;SetOffset(offset);</span>

<span style = "background-color:#fdd">        this-&gt;SetIndexToWorldTransform(transform2);
        ScalarType bounds[6] = {0, op-&gt;GetWidth(), 0, op-&gt;GetHeight(), 0, 1};
        this-&gt;SetBounds(bounds);
        this-&gt;Modified();
        transform-&gt;Delete();
        return;</span>
      }
      default:
<span style = "background-color:#fdd">        Superclass::ExecuteOperation(operation);
        transform-&gt;Delete();
        return;</span>
    }

<span style = "background-color:#fdd">    this-&gt;SetVtkMatrixDeepCopy(transform);
    this-&gt;Modified();
    transform-&gt;Delete();
  }</span>

  void PlaneGeometry::PrintSelf(std::ostream &amp;os, itk::Indent indent) const
<span style = "background-color:#fdd">  {
    Superclass::PrintSelf(os, indent);
    os &lt;&lt; indent &lt;&lt; " ScaleFactorMMPerUnitX: " &lt;&lt; GetExtentInMM(0) / GetExtent(0) &lt;&lt; std::endl;
    os &lt;&lt; indent &lt;&lt; " ScaleFactorMMPerUnitY: " &lt;&lt; GetExtentInMM(1) / GetExtent(1) &lt;&lt; std::endl;
    os &lt;&lt; indent &lt;&lt; " Normal: " &lt;&lt; GetNormal() &lt;&lt; std::endl;
  }</span>

  bool PlaneGeometry::Map(const mitk::Point3D &amp;pt3d_mm, mitk::Point2D &amp;pt2d_mm) const
<span style = "background-color:#fdd">  {
    assert(this-&gt;IsBoundingBoxNull() == false);</span>

<span style = "background-color:#fdd">    Point3D pt3d_units;
    Superclass::WorldToIndex(pt3d_mm, pt3d_units);
    pt2d_mm[0] = pt3d_units[0] * GetExtentInMM(0) / GetExtent(0);
    pt2d_mm[1] = pt3d_units[1] * GetExtentInMM(1) / GetExtent(1);
    pt3d_units[2] = 0;
    return this-&gt;GetBoundingBox()-&gt;IsInside(pt3d_units);
  }</span>

  void PlaneGeometry::Map(const mitk::Point2D &amp;pt2d_mm, mitk::Point3D &amp;pt3d_mm) const
<span style = "background-color:#fdd">  {</span>
    // pt2d_mm is measured from the origin of the world geometry (at leats it called form BaseRendere::Mouse...Event)
<span style = "background-color:#fdd">    Point3D pt3d_units;
    pt3d_units[0] = pt2d_mm[0] / (GetExtentInMM(0) / GetExtent(0));
    pt3d_units[1] = pt2d_mm[1] / (GetExtentInMM(1) / GetExtent(1));
    pt3d_units[2] = 0;</span>
    // pt3d_units is a continuos index. We divided it with the Scale Factor (= spacing in x and y) to convert it from mm
    // to index units.
    //
<span style = "background-color:#fdd">    pt3d_mm = GetIndexToWorldTransform()-&gt;TransformPoint(pt3d_units);</span>
    // now we convert the 3d index to a 3D world point in mm. We could have used IndexToWorld as well as
    // GetITW-&gt;Transform...
<span style = "background-color:#fdd">  }</span>

  void PlaneGeometry::SetSizeInUnits(mitk::ScalarType width, mitk::ScalarType height)
<span style = "background-color:#fdd">  {
    ScalarType bounds[6] = {0, width, 0, height, 0, 1};</span>
    ScalarType extent, newextentInMM;
<span style = "background-color:#fdd">    if (GetExtent(0) &gt; 0)</span>
    {
<span style = "background-color:#fdd">      extent = GetExtent(0);
      if (width &gt; extent)
        newextentInMM = GetExtentInMM(0) / width * extent;</span>
      else
<span style = "background-color:#fdd">        newextentInMM = GetExtentInMM(0) * extent / width;
      SetExtentInMM(0, newextentInMM);</span>
    }
<span style = "background-color:#fdd">    if (GetExtent(1) &gt; 0)</span>
    {
<span style = "background-color:#fdd">      extent = GetExtent(1);
      if (width &gt; extent)
        newextentInMM = GetExtentInMM(1) / height * extent;</span>
      else
<span style = "background-color:#fdd">        newextentInMM = GetExtentInMM(1) * extent / height;
      SetExtentInMM(1, newextentInMM);</span>
    }
<span style = "background-color:#fdd">    SetBounds(bounds);
  }</span>

  bool PlaneGeometry::Project(const mitk::Point3D &amp;pt3d_mm, mitk::Point3D &amp;projectedPt3d_mm) const
<span style = "background-color:#fdd">  {
    assert(this-&gt;IsBoundingBoxNull() == false);</span>

<span style = "background-color:#fdd">    Point3D pt3d_units;
    Superclass::WorldToIndex(pt3d_mm, pt3d_units);
    pt3d_units[2] = 0;
    projectedPt3d_mm = GetIndexToWorldTransform()-&gt;TransformPoint(pt3d_units);
    return this-&gt;GetBoundingBox()-&gt;IsInside(pt3d_units);
  }</span>

  bool PlaneGeometry::Project(const mitk::Vector3D &amp;vec3d_mm, mitk::Vector3D &amp;projectedVec3d_mm) const
<span style = "background-color:#fdd">  {
    assert(this-&gt;IsBoundingBoxNull() == false);</span>

<span style = "background-color:#fdd">    Vector3D vec3d_units;
    Superclass::WorldToIndex(vec3d_mm, vec3d_units);
    vec3d_units[2] = 0;
    projectedVec3d_mm = GetIndexToWorldTransform()-&gt;TransformVector(vec3d_units);
    return true;
  }</span>

  bool PlaneGeometry::Project(const mitk::Point3D &amp;atPt3d_mm,
                              const mitk::Vector3D &amp;vec3d_mm,
                              mitk::Vector3D &amp;projectedVec3d_mm) const
<span style = "background-color:#fdd">  {
    MITK_WARN &lt;&lt; "Deprecated function! Call Project(vec3D,vec3D) instead.";
    assert(this-&gt;IsBoundingBoxNull() == false);</span>

<span style = "background-color:#fdd">    Vector3D vec3d_units;
    Superclass::WorldToIndex(atPt3d_mm, vec3d_mm, vec3d_units);
    vec3d_units[2] = 0;
    projectedVec3d_mm = GetIndexToWorldTransform()-&gt;TransformVector(vec3d_units);</span>

<span style = "background-color:#fdd">    Point3D pt3d_units;
    Superclass::WorldToIndex(atPt3d_mm, pt3d_units);
    return this-&gt;GetBoundingBox()-&gt;IsInside(pt3d_units);
  }</span>

  bool PlaneGeometry::Map(const mitk::Point3D &amp;atPt3d_mm,
                          const mitk::Vector3D &amp;vec3d_mm,
                          mitk::Vector2D &amp;vec2d_mm) const
<span style = "background-color:#fdd">  {
    Point2D pt2d_mm_start, pt2d_mm_end;
    Point3D pt3d_mm_end;
    bool inside = Map(atPt3d_mm, pt2d_mm_start);
    pt3d_mm_end = atPt3d_mm + vec3d_mm;
    inside &amp;= Map(pt3d_mm_end, pt2d_mm_end);
    vec2d_mm = pt2d_mm_end - pt2d_mm_start;
    return inside;
  }</span>

  void PlaneGeometry::Map(const mitk::Point2D &amp; /*atPt2d_mm*/,
                          const mitk::Vector2D &amp; /*vec2d_mm*/,
                          mitk::Vector3D &amp; /*vec3d_mm*/) const
<span style = "background-color:#fdd">  {</span>
    //@todo implement parallel to the other Map method!
<span style = "background-color:#fdd">    assert(false);
  }</span>

<span style = "background-color:#fdd">  void PlaneGeometry::SetReferenceGeometry(const mitk::BaseGeometry *geometry) { m_ReferenceGeometry = geometry; }
  const mitk::BaseGeometry *PlaneGeometry::GetReferenceGeometry() const { return m_ReferenceGeometry; }
  bool PlaneGeometry::HasReferenceGeometry() const { return (m_ReferenceGeometry != nullptr); }</span>
} // namespace</pre>
	</body>
</html>