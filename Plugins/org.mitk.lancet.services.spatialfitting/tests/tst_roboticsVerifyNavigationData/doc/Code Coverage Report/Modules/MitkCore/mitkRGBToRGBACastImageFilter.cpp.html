<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkRGBToRGBACastImageFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkRGBToRGBACastImageFilter.h"
#include "mitkImageAccessByItk.h"
#include "mitkImageTimeSelector.h"
#include "mitkImageToItk.h"
#include "mitkProperties.h"

#include &lt;itkImageIOBase.h&gt;
#include &lt;itkImageRegionConstIterator.h&gt;
#include &lt;itkImageRegionIteratorWithIndex.h&gt;
#include &lt;itkRGBAPixel.h&gt;

mitk::RGBToRGBACastImageFilter::RGBToRGBACastImageFilter()
<span style = "background-color:#fdd">{
  this-&gt;SetNumberOfIndexedInputs(1);
  this-&gt;SetNumberOfRequiredInputs(1);</span>

<span style = "background-color:#fdd">  m_InputTimeSelector = mitk::ImageTimeSelector::New();
  m_OutputTimeSelector = mitk::ImageTimeSelector::New();
}</span>

mitk::RGBToRGBACastImageFilter::~RGBToRGBACastImageFilter()
<span style = "background-color:#fdd">{
}</span>

bool mitk::RGBToRGBACastImageFilter::IsRGBImage(const mitk::Image *image)
<span style = "background-color:#fdd">{
  const mitk::PixelType &amp;inputPixelType = image-&gt;GetPixelType();</span>

<span style = "background-color:#fdd">  if ((inputPixelType.GetPixelType() == itk::IOPixelEnum::RGB) &amp;&amp;</span>
      ((inputPixelType.GetComponentType() == itk::IOComponentEnum::UCHAR) ||
       (inputPixelType.GetComponentType() == itk::IOComponentEnum::USHORT) ||
       (inputPixelType.GetComponentType() == itk::IOComponentEnum::FLOAT) ||
       (inputPixelType.GetComponentType() == itk::IOComponentEnum::DOUBLE)))
  {
<span style = "background-color:#fdd">    return true;</span>
  }

<span style = "background-color:#fdd">  return false;
}</span>

void mitk::RGBToRGBACastImageFilter::GenerateInputRequestedRegion()
<span style = "background-color:#fdd">{
  Superclass::GenerateInputRequestedRegion();</span>

<span style = "background-color:#fdd">  mitk::Image *output = this-&gt;GetOutput();
  mitk::Image *input = this-&gt;GetInput();
  if (!output-&gt;IsInitialized())</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  input-&gt;SetRequestedRegionToLargestPossibleRegion();</span>

  // GenerateTimeInInputRegion(output, input);
<span style = "background-color:#fdd">}</span>

void mitk::RGBToRGBACastImageFilter::GenerateOutputInformation()
<span style = "background-color:#fdd">{
  mitk::Image::ConstPointer input = this-&gt;GetInput();
  mitk::Image::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  if ((output-&gt;IsInitialized()) &amp;&amp; (this-&gt;GetMTime() &lt;= m_TimeOfHeaderInitialization.GetMTime()))
    return;</span>

<span style = "background-color:#fdd">  itkDebugMacro(&lt;&lt; "GenerateOutputInformation()");</span>

  // Initialize RGBA output with same pixel type as input image
<span style = "background-color:#fdd">  const mitk::PixelType &amp;inputPixelType = input-&gt;GetPixelType();</span>

  typedef itk::Image&lt;UCRGBPixelType&gt; UCRGBItkImageType;
  typedef itk::Image&lt;USRGBPixelType&gt; USRGBItkImageType;
  typedef itk::Image&lt;FloatRGBPixelType&gt; FloatCRGBItkImageType;
  typedef itk::Image&lt;DoubleRGBPixelType&gt; DoubleRGBItkImageType;

<span style = "background-color:#fdd">  if (inputPixelType == mitk::MakePixelType&lt;UCRGBItkImageType&gt;())</span>
  {
<span style = "background-color:#fdd">    const mitk::PixelType refPtype = MakePixelType&lt;UCRGBItkImageType&gt;();
    output-&gt;Initialize(refPtype, *input-&gt;GetTimeGeometry());
  }
  else if (inputPixelType == mitk::MakePixelType&lt;USRGBItkImageType&gt;())</span>
  {
<span style = "background-color:#fdd">    const mitk::PixelType refPtype = MakePixelType&lt;USRGBItkImageType&gt;();
    output-&gt;Initialize(refPtype, *input-&gt;GetTimeGeometry());
  }
  else if (inputPixelType == mitk::MakePixelType&lt;FloatCRGBItkImageType&gt;())</span>
  {
<span style = "background-color:#fdd">    const mitk::PixelType refPtype = MakePixelType&lt;FloatCRGBItkImageType&gt;();
    output-&gt;Initialize(refPtype, *input-&gt;GetTimeGeometry());
  }
  else if (inputPixelType == mitk::MakePixelType&lt;DoubleRGBItkImageType&gt;())</span>
  {
<span style = "background-color:#fdd">    const mitk::PixelType refPtype = MakePixelType&lt;DoubleRGBItkImageType&gt;();
    output-&gt;Initialize(refPtype, *input-&gt;GetTimeGeometry());
  }</span>

<span style = "background-color:#fdd">  output-&gt;SetPropertyList(input-&gt;GetPropertyList()-&gt;Clone());</span>

<span style = "background-color:#fdd">  m_TimeOfHeaderInitialization.Modified();
}</span>

void mitk::RGBToRGBACastImageFilter::GenerateData()
<span style = "background-color:#fdd">{
  mitk::Image::ConstPointer input = this-&gt;GetInput();
  mitk::Image::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  if (!output-&gt;IsInitialized())</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  m_InputTimeSelector-&gt;SetInput(input);
  m_OutputTimeSelector-&gt;SetInput(this-&gt;GetOutput());</span>

<span style = "background-color:#fdd">  mitk::Image::RegionType outputRegion = output-&gt;GetRequestedRegion();
  const mitk::TimeGeometry *outputTimeGeometry = output-&gt;GetTimeGeometry();
  const mitk::TimeGeometry *inputTimeGeometry = input-&gt;GetTimeGeometry();</span>
  TimePointType timeInMS;

<span style = "background-color:#fdd">  int timestep = 0;
  int tstart = outputRegion.GetIndex(3);
  int tmax = tstart + outputRegion.GetSize(3);</span>

  int t;
<span style = "background-color:#fdd">  for (t = tstart; t &lt; tmax; ++t)</span>
  {
<span style = "background-color:#fdd">    timeInMS = outputTimeGeometry-&gt;TimeStepToTimePoint(t);
    timestep = inputTimeGeometry-&gt;TimePointToTimeStep(timeInMS);</span>

<span style = "background-color:#fdd">    m_InputTimeSelector-&gt;SetTimeNr(timestep);
    m_InputTimeSelector-&gt;UpdateLargestPossibleRegion();
    m_OutputTimeSelector-&gt;SetTimeNr(t);
    m_OutputTimeSelector-&gt;UpdateLargestPossibleRegion();</span>

<span style = "background-color:#fdd">    mitk::Image *image = m_InputTimeSelector-&gt;GetOutput();</span>

<span style = "background-color:#fdd">    const mitk::PixelType &amp;pixelType = image-&gt;GetPixelType();</span>

    // Check if the pixel type is supported
<span style = "background-color:#fdd">    if (pixelType == MakePixelType&lt;itk::Image&lt;UCRGBPixelType&gt;&gt;())</span>
    {
<span style = "background-color:#fdd">      AccessFixedPixelTypeByItk_2(image, InternalCast, (UCRGBPixelType), this, 255);
    }
    else if (pixelType == MakePixelType&lt;itk::Image&lt;USRGBPixelType&gt;&gt;())</span>
    {
<span style = "background-color:#fdd">      AccessFixedPixelTypeByItk_2(image, InternalCast, (USRGBPixelType), this, 65535);
    }
    else if (pixelType == MakePixelType&lt;itk::Image&lt;FloatRGBPixelType&gt;&gt;())</span>
    {
<span style = "background-color:#fdd">      AccessFixedPixelTypeByItk_2(image, InternalCast, (FloatRGBPixelType), this, 1.0);
    }
    else if (pixelType == MakePixelType&lt;itk::Image&lt;DoubleRGBPixelType&gt;&gt;())</span>
    {
<span style = "background-color:#fdd">      AccessFixedPixelTypeByItk_2(image, InternalCast, (DoubleRGBPixelType), this, 1.0);</span>
    }
    else
    {
      // Otherwise, write warning and graft input to output

      // ...TBD...
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  m_TimeOfHeaderInitialization.Modified();
}</span>

template &lt;typename TPixel, unsigned int VImageDimension&gt;
void mitk::RGBToRGBACastImageFilter::InternalCast(itk::Image&lt;TPixel, VImageDimension&gt; *inputItkImage,
                                                  mitk::RGBToRGBACastImageFilter *addComponentFilter,
                                                  typename TPixel::ComponentType defaultAlpha)
<span style = "background-color:#fdd">{</span>
  typedef TPixel InputPixelType;
  typedef itk::RGBAPixel&lt;typename TPixel::ComponentType&gt; OutputPixelType;
  typedef itk::Image&lt;InputPixelType, VImageDimension&gt; InputImageType;
  typedef itk::Image&lt;OutputPixelType, VImageDimension&gt; OutputImageType;

  typedef itk::ImageRegionConstIterator&lt;InputImageType&gt; InputImageIteratorType;
  typedef itk::ImageRegionIteratorWithIndex&lt;OutputImageType&gt; OutputImageIteratorType;

<span style = "background-color:#fdd">  typename mitk::ImageToItk&lt;OutputImageType&gt;::Pointer outputimagetoitk = mitk::ImageToItk&lt;OutputImageType&gt;::New();
  outputimagetoitk-&gt;SetInput(addComponentFilter-&gt;m_OutputTimeSelector-&gt;GetOutput());
  outputimagetoitk-&gt;Update();
  typename OutputImageType::Pointer outputItkImage = outputimagetoitk-&gt;GetOutput();</span>

  // create the iterators
<span style = "background-color:#fdd">  typename InputImageType::RegionType inputRegionOfInterest = inputItkImage-&gt;GetLargestPossibleRegion();
  InputImageIteratorType inputIt(inputItkImage, inputRegionOfInterest);
  OutputImageIteratorType outputIt(outputItkImage, inputRegionOfInterest);</span>

<span style = "background-color:#fdd">  for (inputIt.GoToBegin(), outputIt.GoToBegin(); !inputIt.IsAtEnd(); ++inputIt, ++outputIt)</span>
  {
<span style = "background-color:#fdd">    typename InputPixelType::Iterator pixelInputIt = inputIt.Get().Begin();
    typename OutputPixelType::Iterator pixelOutputIt = outputIt.Get().Begin();</span>

<span style = "background-color:#fdd">    *pixelOutputIt++ = *pixelInputIt++;
    *pixelOutputIt++ = *pixelInputIt++;
    *pixelOutputIt++ = *pixelInputIt++;
    *pixelOutputIt = defaultAlpha;
  }
}</span></pre>
	</body>
</html>