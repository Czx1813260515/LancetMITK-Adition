<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSlicedData.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkSlicedData.h"
#include "mitkAbstractTransformGeometry.h"
#include "mitkBaseProcess.h"
#include &lt;mitkProportionalTimeGeometry.h&gt;

<span style = "background-color:#fdd">mitk::SlicedData::SlicedData() : m_RequestedRegionInitialized(false), m_UseLargestPossibleRegion(false)
{</span>
  unsigned int i;
<span style = "background-color:#fdd">  for (i = 0; i &lt; 4; ++i)</span>
  {
<span style = "background-color:#fdd">    m_LargestPossibleRegion.SetIndex(i, 0);
    m_LargestPossibleRegion.SetSize(i, 1);
  }
}</span>

mitk::SlicedData::SlicedData(const SlicedData &amp;other)
<span style = "background-color:#fdd">  : BaseData(other),
    m_LargestPossibleRegion(other.m_LargestPossibleRegion),
    m_RequestedRegion(other.m_RequestedRegion),
    m_RequestedRegionInitialized(other.m_RequestedRegionInitialized),
    m_BufferedRegion(other.m_BufferedRegion),
    m_UseLargestPossibleRegion(other.m_UseLargestPossibleRegion)
{
}</span>
mitk::SlicedData::~SlicedData()
<span style = "background-color:#fdd">{
}</span>

void mitk::SlicedData::UpdateOutputInformation()
<span style = "background-color:#fdd">{
  Superclass::UpdateOutputInformation();</span>

<span style = "background-color:#fdd">  if (this-&gt;GetSource().IsNull())</span>
  // If we don't have a source, then let's make our Image
  // span our buffer
  {
<span style = "background-color:#fdd">    m_UseLargestPossibleRegion = true;</span>
  }

  // Now we should know what our largest possible region is. If our
  // requested region was not set yet, (or has been set to something
  // invalid - with no data in it ) then set it to the largest possible
  // region.
<span style = "background-color:#fdd">  if (!m_RequestedRegionInitialized)</span>
  {
<span style = "background-color:#fdd">    this-&gt;SetRequestedRegionToLargestPossibleRegion();
    m_RequestedRegionInitialized = true;</span>
  }

<span style = "background-color:#fdd">  m_LastRequestedRegionWasOutsideOfTheBufferedRegion = false;
}</span>

void mitk::SlicedData::PrepareForNewData()
<span style = "background-color:#fdd">{
  if (GetUpdateMTime() &lt; GetPipelineMTime() || GetDataReleased())</span>
  {
<span style = "background-color:#fdd">    ReleaseData();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::SlicedData::SetRequestedRegionToLargestPossibleRegion()
<span style = "background-color:#fdd">{
  m_UseLargestPossibleRegion = true;
  if (GetGeometry() == nullptr)
    return;</span>
  unsigned int i;
<span style = "background-color:#fdd">  const RegionType::IndexType &amp;index = GetLargestPossibleRegion().GetIndex();
  const RegionType::SizeType &amp;size = GetLargestPossibleRegion().GetSize();
  for (i = 0; i &lt; RegionDimension; ++i)</span>
  {
<span style = "background-color:#fdd">    m_RequestedRegion.SetIndex(i, index[i]);
    m_RequestedRegion.SetSize(i, size[i]);
  }
}</span>

bool mitk::SlicedData::RequestedRegionIsOutsideOfTheBufferedRegion()
<span style = "background-color:#fdd">{</span>
  // Is the requested region within the currently buffered data?
  // SlicedData and subclasses store entire volumes or slices. The
  // methods IsVolumeSet() and IsSliceSet are provided to check,
  // a volume or slice, respectively, is available. Thus, these
  // methods used here.
<span style = "background-color:#fdd">  const IndexType &amp;requestedRegionIndex = m_RequestedRegion.GetIndex();</span>

<span style = "background-color:#fdd">  const SizeType &amp;requestedRegionSize = m_RequestedRegion.GetSize();
  const SizeType &amp;largestPossibleRegionSize = GetLargestPossibleRegion().GetSize();</span>

  // are whole channels requested?
  int c, cEnd;
<span style = "background-color:#fdd">  c = requestedRegionIndex[4];
  cEnd = c + static_cast&lt;long&gt;(requestedRegionSize[4]);
  if (requestedRegionSize[3] == largestPossibleRegionSize[3])</span>
  {
<span style = "background-color:#fdd">    for (; c &lt; cEnd; ++c)
      if (IsChannelSet(c) == false)
        return true;
    return false;</span>
  }

  // are whole volumes requested?
  int t, tEnd;
<span style = "background-color:#fdd">  t = requestedRegionIndex[3];
  tEnd = t + static_cast&lt;long&gt;(requestedRegionSize[3]);
  if (requestedRegionSize[2] == largestPossibleRegionSize[2])</span>
  {
<span style = "background-color:#fdd">    for (; c &lt; cEnd; ++c)
      for (; t &lt; tEnd; ++t)
        if (IsVolumeSet(t, c) == false)
          return true;
    return false;</span>
  }

  // ok, only slices are requested. Check if they are available.
  int s, sEnd;
<span style = "background-color:#fdd">  s = requestedRegionIndex[2];
  sEnd = s + static_cast&lt;long&gt;(requestedRegionSize[2]);
  for (; c &lt; cEnd; ++c)
    for (; t &lt; tEnd; ++t)
      for (; s &lt; sEnd; ++s)
        if (IsSliceSet(s, t, c) == false)
          return true;</span>

<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::SlicedData::VerifyRequestedRegion()
<span style = "background-color:#fdd">{
  if (GetTimeGeometry() == nullptr)
    return false;</span>

  unsigned int i;

  // Is the requested region within the LargestPossibleRegion?
  // Note that the test is indeed against the largest possible region
  // rather than the buffered region; see DataObject::VerifyRequestedRegion.
<span style = "background-color:#fdd">  const IndexType &amp;requestedRegionIndex = m_RequestedRegion.GetIndex();
  const IndexType &amp;largestPossibleRegionIndex = GetLargestPossibleRegion().GetIndex();</span>

<span style = "background-color:#fdd">  const SizeType &amp;requestedRegionSize = m_RequestedRegion.GetSize();
  const SizeType &amp;largestPossibleRegionSize = GetLargestPossibleRegion().GetSize();</span>

<span style = "background-color:#fdd">  for (i = 0; i &lt; RegionDimension; ++i)</span>
  {
<span style = "background-color:#fdd">    if ((requestedRegionIndex[i] &lt; largestPossibleRegionIndex[i]) ||</span>
        ((requestedRegionIndex[i] + static_cast&lt;long&gt;(requestedRegionSize[i])) &gt;
         (largestPossibleRegionIndex[i] + static_cast&lt;long&gt;(largestPossibleRegionSize[i]))))
    {
<span style = "background-color:#fdd">      return false;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return true;
}</span>

void mitk::SlicedData::SetRequestedRegion(const itk::DataObject *data)
<span style = "background-color:#fdd">{
  m_UseLargestPossibleRegion = false;</span>

<span style = "background-color:#fdd">  const auto *slicedData = dynamic_cast&lt;const mitk::SlicedData *&gt;(data);</span>

<span style = "background-color:#fdd">  if (slicedData)</span>
  {
<span style = "background-color:#fdd">    m_RequestedRegion = slicedData-&gt;GetRequestedRegion();
    m_RequestedRegionInitialized = true;
  }</span>
  else
  {
    // pointer could not be cast back down
<span style = "background-color:#fdd">    itkExceptionMacro(&lt;&lt; "mitk::SlicedData::SetRequestedRegion(DataObject*) cannot cast " &lt;&lt; typeid(data).name()</span>
                      &lt;&lt; " to "
                      &lt;&lt; typeid(SlicedData *).name());
  }
<span style = "background-color:#fdd">}</span>

void mitk::SlicedData::SetRequestedRegion(SlicedData::RegionType *region)
<span style = "background-color:#fdd">{
  m_UseLargestPossibleRegion = false;</span>

<span style = "background-color:#fdd">  if (region != nullptr)</span>
  {
<span style = "background-color:#fdd">    m_RequestedRegion = *region;
    m_RequestedRegionInitialized = true;
  }</span>
  else
  {
    // pointer could not be cast back down
<span style = "background-color:#fdd">    itkExceptionMacro(&lt;&lt; "mitk::SlicedData::SetRequestedRegion(SlicedData::RegionType*) cannot cast "</span>
                      &lt;&lt; typeid(region).name()
                      &lt;&lt; " to "
                      &lt;&lt; typeid(SlicedData *).name());
  }
<span style = "background-color:#fdd">}</span>

void mitk::SlicedData::SetLargestPossibleRegion(SlicedData::RegionType *region)
<span style = "background-color:#fdd">{
  if (region != nullptr)</span>
  {
<span style = "background-color:#fdd">    m_LargestPossibleRegion = *region;
    m_UseLargestPossibleRegion = true;
  }</span>
  else
  {
    // pointer could not be cast back down
<span style = "background-color:#fdd">    itkExceptionMacro(&lt;&lt; "mitk::SlicedData::SetLargestPossibleRegion(SlicedData::RegionType*) cannot cast "</span>
                      &lt;&lt; typeid(region).name()
                      &lt;&lt; " to "
                      &lt;&lt; typeid(SlicedData *).name());
  }
<span style = "background-color:#fdd">}</span>

void mitk::SlicedData::CopyInformation(const itk::DataObject *data)
<span style = "background-color:#fdd">{</span>
  // Standard call to the superclass' method
<span style = "background-color:#fdd">  Superclass::CopyInformation(data);</span>

  const mitk::SlicedData *slicedData;

<span style = "background-color:#fdd">  slicedData = dynamic_cast&lt;const mitk::SlicedData *&gt;(data);</span>

<span style = "background-color:#fdd">  if (slicedData)</span>
  {
<span style = "background-color:#fdd">    m_LargestPossibleRegion = slicedData-&gt;GetLargestPossibleRegion();
  }</span>
  else
  {
    // pointer could not be cast back down
<span style = "background-color:#fdd">    itkExceptionMacro(&lt;&lt; "mitk::SlicedData::CopyInformation(const DataObject *data) cannot cast " &lt;&lt; typeid(data).name()</span>
                      &lt;&lt; " to "
                      &lt;&lt; typeid(SlicedData *).name());
  }
<span style = "background-color:#fdd">}</span>

// const mitk::PlaneGeometry* mitk::SlicedData::GetPlaneGeometry(int s, int t) const
//{
//  const_cast&lt;SlicedData*&gt;(this)-&gt;SetRequestedRegionToLargestPossibleRegion();
//
//  const_cast&lt;SlicedData*&gt;(this)-&gt;UpdateOutputInformation();
//
//  return GetSlicedGeometry(t)-&gt;GetPlaneGeometry(s);
//}
//
mitk::SlicedGeometry3D *mitk::SlicedData::GetSlicedGeometry(unsigned int t) const
<span style = "background-color:#fdd">{
  if (GetTimeGeometry() == nullptr)
    return nullptr;
  return dynamic_cast&lt;SlicedGeometry3D *&gt;(GetTimeGeometry()-&gt;GetGeometryForTimeStep(t).GetPointer());
}</span>

const mitk::SlicedGeometry3D *mitk::SlicedData::GetUpdatedSlicedGeometry(unsigned int t)
<span style = "background-color:#fdd">{
  SetRequestedRegionToLargestPossibleRegion();</span>

<span style = "background-color:#fdd">  UpdateOutputInformation();</span>

<span style = "background-color:#fdd">  return GetSlicedGeometry(t);
}</span>

void mitk::SlicedData::SetGeometry(BaseGeometry *aGeometry3D)
<span style = "background-color:#fdd">{
  if (aGeometry3D != nullptr)</span>
  {
<span style = "background-color:#fdd">    ProportionalTimeGeometry::Pointer timeGeometry = ProportionalTimeGeometry::New();
    SlicedGeometry3D::Pointer slicedGeometry = dynamic_cast&lt;SlicedGeometry3D *&gt;(aGeometry3D);
    if (slicedGeometry.IsNull())</span>
    {
<span style = "background-color:#fdd">      auto *geometry2d = dynamic_cast&lt;PlaneGeometry *&gt;(aGeometry3D);
      if (geometry2d != nullptr &amp;&amp; dynamic_cast&lt;mitk::AbstractTransformGeometry *&gt;(aGeometry3D) == nullptr)</span>
      {
<span style = "background-color:#fdd">        if ((GetSlicedGeometry()-&gt;GetPlaneGeometry(0) == geometry2d) &amp;&amp; (GetSlicedGeometry()-&gt;GetSlices() == 1))
          return;
        slicedGeometry = SlicedGeometry3D::New();
        slicedGeometry-&gt;InitializeEvenlySpaced(geometry2d, 1);
      }</span>
      else
      {
<span style = "background-color:#fdd">        slicedGeometry = SlicedGeometry3D::New();
        PlaneGeometry::Pointer planeGeometry = PlaneGeometry::New();
        planeGeometry-&gt;InitializeStandardPlane(aGeometry3D);
        slicedGeometry-&gt;InitializeEvenlySpaced(planeGeometry, (unsigned int)(aGeometry3D-&gt;GetExtent(2)));
      }</span>
    }
<span style = "background-color:#fdd">    assert(slicedGeometry.IsNotNull());</span>

<span style = "background-color:#fdd">    timeGeometry-&gt;Initialize(slicedGeometry, 1);
    Superclass::SetTimeGeometry(timeGeometry);
  }</span>
  else
  {
<span style = "background-color:#fdd">    if (GetGeometry() == nullptr)
      return;
    Superclass::SetGeometry(nullptr);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::SlicedData::SetSpacing(const ScalarType aSpacing[])
<span style = "background-color:#fdd">{
  this-&gt;SetSpacing((mitk::Vector3D)aSpacing);
}</span>

void mitk::SlicedData::SetOrigin(const mitk::Point3D &amp;origin)
<span style = "background-color:#fdd">{
  TimeGeometry *timeGeometry = GetTimeGeometry();</span>

<span style = "background-color:#fdd">  assert(timeGeometry != nullptr);</span>

  mitk::SlicedGeometry3D *slicedGeometry;

<span style = "background-color:#fdd">  unsigned int steps = timeGeometry-&gt;CountTimeSteps();</span>

<span style = "background-color:#fdd">  for (unsigned int timestep = 0; timestep &lt; steps; ++timestep)</span>
  {
<span style = "background-color:#fdd">    slicedGeometry = GetSlicedGeometry(timestep);
    if (slicedGeometry != nullptr)</span>
    {
<span style = "background-color:#fdd">      slicedGeometry-&gt;SetOrigin(origin);
      if (slicedGeometry-&gt;GetEvenlySpaced())</span>
      {
<span style = "background-color:#fdd">        mitk::PlaneGeometry *geometry2D = slicedGeometry-&gt;GetPlaneGeometry(0);
        geometry2D-&gt;SetOrigin(origin);
        slicedGeometry-&gt;InitializeEvenlySpaced(geometry2D, slicedGeometry-&gt;GetSlices());</span>
      }
    }
    // ProportionalTimeGeometry* timeGeometry = dynamic_cast&lt;ProportionalTimeGeometry *&gt;(GetTimeGeometry());
    // if(timeGeometry != nullptr)
    //{
    //  timeGeometry-&gt;Initialize(slicedGeometry, steps);
    //  break;
    //}
<span style = "background-color:#fdd">  }
}</span>

void mitk::SlicedData::SetSpacing(mitk::Vector3D aSpacing)
<span style = "background-color:#fdd">{
  TimeGeometry *timeGeometry = GetTimeGeometry();</span>

<span style = "background-color:#fdd">  assert(timeGeometry != nullptr);</span>

<span style = "background-color:#fdd">  unsigned int steps = timeGeometry-&gt;CountTimeSteps();</span>

<span style = "background-color:#fdd">  for (unsigned int timestep = 0; timestep &lt; steps; ++timestep)</span>
  {
<span style = "background-color:#fdd">    mitk::SlicedGeometry3D *slicedGeometry = GetSlicedGeometry(timestep);
    if (slicedGeometry != nullptr)</span>
    {
<span style = "background-color:#fdd">      slicedGeometry-&gt;SetSpacing(aSpacing);</span>
    }
<span style = "background-color:#fdd">  }
  timeGeometry-&gt;Update();
}</span></pre>
	</body>
</html>