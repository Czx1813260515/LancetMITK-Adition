<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkUndoController.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkUndoController.h"
#include "mitkInteractionConst.h"
#include "mitkLimitedLinearUndo.h"
#include "mitkRenderingManager.h"
#include "mitkVerboseLimitedLinearUndo.h"

// static member-variables init.
<span style = "background-color:#dfd">mitk::UndoModel::Pointer mitk::UndoController::m_CurUndoModel;
mitk::UndoController::UndoModelMap mitk::UndoController::m_UndoModelList;</span>
mitk::UndoController::UndoType mitk::UndoController::m_CurUndoType;

// const mitk::UndoController::UndoType mitk::UndoController::DEFAULTUNDOMODEL = LIMITEDLINEARUNDO;
const mitk::UndoController::UndoType mitk::UndoController::DEFAULTUNDOMODEL = VERBOSE_LIMITEDLINEARUNDO;

mitk::UndoController::UndoController(UndoType undoType)
<span style = "background-color:#fdd">{
  if (SwitchUndoModel(undoType) == false) // existiert noch nicht in static-Liste</span>
  {
<span style = "background-color:#fdd">    switch (undoType)</span>
    {
      case LIMITEDLINEARUNDO:
<span style = "background-color:#fdd">        m_CurUndoModel = mitk::LimitedLinearUndo::New();
        m_CurUndoType = undoType;
        m_UndoModelList.insert(UndoModelMap::value_type(undoType, m_CurUndoModel));
        break;</span>
      case VERBOSE_LIMITEDLINEARUNDO:
<span style = "background-color:#fdd">        m_CurUndoModel = mitk::VerboseLimitedLinearUndo::New();
        m_CurUndoType = undoType;
        m_UndoModelList.insert(UndoModelMap::value_type(undoType, m_CurUndoModel));
        break;</span>
      // case ###
      // insert here, in add- and RemoveUndoModel new sets of UndoModels!
      // break;
      default:
<span style = "background-color:#fdd">        m_CurUndoModel = VerboseLimitedLinearUndo::New();
        m_CurUndoType = undoType;
        m_UndoModelList.insert(UndoModelMap::value_type(undoType, m_CurUndoModel));</span>
    }
  }
<span style = "background-color:#fdd">}</span>

mitk::UndoController::~UndoController()
<span style = "background-color:#fdd">{
}</span>

bool mitk::UndoController::SetOperationEvent(UndoStackItem *operationEvent)
<span style = "background-color:#fdd">{
  m_CurUndoModel-&gt;SetOperationEvent(operationEvent);
  return true;
}</span>

bool mitk::UndoController::Undo()
<span style = "background-color:#fdd">{
  return this-&gt;Undo(true);
}</span>

bool mitk::UndoController::Undo(bool fine)
<span style = "background-color:#fdd">{
  bool ret = m_CurUndoModel-&gt;Undo(fine);</span>

<span style = "background-color:#fdd">  mitk::RenderingManager::GetInstance()-&gt;RequestUpdateAll();</span>

<span style = "background-color:#fdd">  return ret;
}</span>

bool mitk::UndoController::Redo()
<span style = "background-color:#fdd">{
  return this-&gt;Redo(true);
}</span>

bool mitk::UndoController::Redo(bool fine)
<span style = "background-color:#fdd">{
  bool ret = m_CurUndoModel-&gt;Redo(fine);</span>

<span style = "background-color:#fdd">  mitk::RenderingManager::GetInstance()-&gt;RequestUpdateAll();</span>

<span style = "background-color:#fdd">  return ret;
}</span>

void mitk::UndoController::Clear()
<span style = "background-color:#fdd">{
  m_CurUndoModel-&gt;Clear();
}</span>

void mitk::UndoController::ClearRedoList()
<span style = "background-color:#fdd">{
  m_CurUndoModel-&gt;ClearRedoList();
}</span>

bool mitk::UndoController::RedoListEmpty()
<span style = "background-color:#fdd">{
  return m_CurUndoModel-&gt;RedoListEmpty();
}</span>

//##Documentation
//##Switches the UndoModel to the given Type
//##if there is no equal Type in List, then return false
bool mitk::UndoController::SwitchUndoModel(UndoType undoType)
<span style = "background-color:#fdd">{
  if (m_CurUndoType == undoType)</span>
  {
<span style = "background-color:#fdd">    return true; // already switched, don't need to be switched!</span>
  }

<span style = "background-color:#fdd">  auto undoModelIter = m_UndoModelList.find(undoType);
  if (undoModelIter == m_UndoModelList.end())</span>
  { // undoType not found in List
<span style = "background-color:#fdd">    return false;</span>
  }

  // found-&gt; switch to UndoModel
<span style = "background-color:#fdd">  m_CurUndoModel = (undoModelIter)-&gt;second;
  m_CurUndoType = (undoModelIter)-&gt;first;
  return true;
}</span>

//##Documentation
//##adds a new kind of UndoModel to the set of UndoModels
//##and switches to that UndoModel
//##if the UndoModel exists already in the List, then nothing is done
bool mitk::UndoController::AddUndoModel(UndoType undoType)
<span style = "background-color:#fdd">{
  if (m_UndoModelList.find(undoType) != m_UndoModelList.end())</span>
  { // UndoModel already exists
<span style = "background-color:#fdd">    return false;</span>
  }
  // doesn't already exist in list
<span style = "background-color:#fdd">  switch (undoType)</span>
  {
    case LIMITEDLINEARUNDO:
<span style = "background-color:#fdd">      m_CurUndoModel = LimitedLinearUndo::New();
      m_CurUndoType = undoType;
      m_UndoModelList.insert(UndoModelMap::value_type(undoType, m_CurUndoModel));
      break;</span>
    case VERBOSE_LIMITEDLINEARUNDO:
<span style = "background-color:#fdd">      m_CurUndoModel = VerboseLimitedLinearUndo::New();
      m_CurUndoType = undoType;
      m_UndoModelList.insert(UndoModelMap::value_type(undoType, m_CurUndoModel));
      break;</span>
    default:
      // that undoType is not implemented!
<span style = "background-color:#fdd">      return false;</span>
  }
<span style = "background-color:#fdd">  return true;
}</span>

//##Documentation
//##Removes an UndoModel from the set of UndoModels
//##If that UndoModel is currently selected, then the DefaultUndoModel(const) is set.
//##If the default is not in List, then the first UndoModel is set.
//##UndoList may not be empty, so if the UndoType is the last, then return false;
bool mitk::UndoController::RemoveUndoModel(UndoType undoType)
<span style = "background-color:#fdd">{
  if (m_UndoModelList.size() &lt; 2)</span>
  { // for no empty m_UndoModelList
<span style = "background-color:#fdd">    return false;</span>
  }
  // try deleting Element
<span style = "background-color:#fdd">  int ok = m_UndoModelList.erase(undoType);
  if (ok == 0)</span>
  { // delete unsucessful; Element of undoType not found
<span style = "background-color:#fdd">    return false;</span>
  }

  // if m_CurUndoModel is the one removed, then change it to default or to the next or first
<span style = "background-color:#fdd">  if (m_CurUndoType == undoType)</span>
  { // we have to change m_CurUndoModel and m_CurUndoType to an existing Model

    // if defaultUndoModel exists, then set to default
<span style = "background-color:#fdd">    auto undoModelIter = m_UndoModelList.find(DEFAULTUNDOMODEL);
    if (undoModelIter == m_UndoModelList.end())</span>
    { // DefaultUndoModel does not exists in m_CurUndoModelList
<span style = "background-color:#fdd">      undoModelIter = m_UndoModelList.begin();</span>
    }
<span style = "background-color:#fdd">    m_CurUndoModel = (undoModelIter)-&gt;second;
    m_CurUndoType = (undoModelIter)-&gt;first;
    return true;</span>
  }
  // m_CurUndoType was not undoType and is not changed
<span style = "background-color:#fdd">  return true;
}</span>

int mitk::UndoController::GetLastObjectEventIdInList()
<span style = "background-color:#fdd">{
  return m_CurUndoModel-&gt;GetLastObjectEventIdInList();
}</span>

int mitk::UndoController::GetLastGroupEventIdInList()
<span style = "background-color:#fdd">{
  return m_CurUndoModel-&gt;GetLastGroupEventIdInList();
}</span>

mitk::OperationEvent *mitk::UndoController::GetLastOfType(OperationActor *destination, OperationType opType)
<span style = "background-color:#fdd">{
  return m_CurUndoModel-&gt;GetLastOfType(destination, opType);
}</span>

mitk::UndoModel *mitk::UndoController::GetCurrentUndoModel()
<span style = "background-color:#fdd">{
  return m_CurUndoModel;
}</span></pre>
	</body>
</html>