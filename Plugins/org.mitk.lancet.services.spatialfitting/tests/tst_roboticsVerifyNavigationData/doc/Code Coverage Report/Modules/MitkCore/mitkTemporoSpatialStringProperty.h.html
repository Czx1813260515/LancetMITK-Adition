<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkTemporoSpatialStringProperty.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKTEMPOROSPATIALSTRINGPROPERTY_H_HEADER
#define MITKTEMPOROSPATIALSTRINGPROPERTY_H_HEADER

#include &lt;itkConfigure.h&gt;

#include "mitkBaseProperty.h"
#include &lt;MitkCoreExports.h&gt;

#include "mitkTimeGeometry.h"

#include &lt;string&gt;

namespace mitk
{
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4522)
#endif

  /**
   * @brief Property for time and space resolved string values
   * @ingroup DataManagement
   */
  class MITKCORE_EXPORT TemporoSpatialStringProperty : public BaseProperty
  {
  public:
    typedef ::itk::IndexValueType IndexValueType;
    typedef std::string ValueType;

<span style = "background-color:#fdd">    mitkClassMacro(TemporoSpatialStringProperty, BaseProperty);</span>

<span style = "background-color:#fdd">    itkFactorylessNewMacro(Self);</span>

<span style = "background-color:#fdd">    itkCloneMacro(Self);
    mitkNewMacro1Param(TemporoSpatialStringProperty, const char*);
    mitkNewMacro1Param(TemporoSpatialStringProperty, const std::string &amp;);</span>

    /**Returns the value of the first time point in the first slice.
     * If now value is set it returns an empty string.*/
    ValueType GetValue() const;
    /**Returns the value of the passed time step and slice. If it does not exist and allowedClosed is true
     * it will look for the closest value. If nothing could be found an empty string will be returned.*/
    ValueType GetValue(const TimeStepType &amp;timeStep,
                       const IndexValueType &amp;zSlice,
                       bool allowCloseTime = false,
                       bool allowCloseSlice = false) const;
    ValueType GetValueBySlice(const IndexValueType &amp;zSlice, bool allowClose = false) const;
    ValueType GetValueByTimeStep(const TimeStepType &amp;timeStep, bool allowClose = false) const;

    bool HasValue() const;
    bool HasValue(const TimeStepType &amp;timeStep,
                  const IndexValueType &amp;zSlice,
                  bool allowCloseTime = false,
                  bool allowCloseSlice = false) const;
    bool HasValueBySlice(const IndexValueType &amp;zSlice, bool allowClose = false) const;
    bool HasValueByTimeStep(const TimeStepType &amp;timeStep, bool allowClose = false) const;

    /** return all slices stored for the specified timestep.*/
    std::vector&lt;IndexValueType&gt; GetAvailableSlices(const TimeStepType&amp; timeStep) const;
    /** return all time steps stored for the specified slice.*/
    std::vector&lt;TimeStepType&gt; GetAvailableTimeSteps(const IndexValueType&amp; slice) const;
    /** return all time steps stored in the property.*/
    std::vector&lt;TimeStepType&gt; GetAvailableTimeSteps() const;
    /** return all slices stored in the property. @remark not all time steps may contain all slices.*/
    std::vector&lt;IndexValueType&gt; GetAvailableSlices() const;

    void SetValue(const TimeStepType &amp;timeStep, const IndexValueType &amp;zSlice, const ValueType &amp;value);

    void SetValue(const ValueType &amp;value);

    std::string GetValueAsString() const override;

    /** Inidicates of all values (all time steps, all slices) are the same, or if at least one value stored
    in the property is different. If IsUniform==true one can i.a. use GetValueAsString() without the loss of
    information to retrieve the stored value.*/
    bool IsUniform() const;

    using BaseProperty::operator=;

  protected:
    typedef std::map&lt;IndexValueType, std::string&gt; SliceMapType;
    typedef std::map&lt;TimeStepType, SliceMapType&gt; TimeMapType;

    TimeMapType m_Values;

    TemporoSpatialStringProperty(const char *string = nullptr);
    TemporoSpatialStringProperty(const std::string &amp;s);

    TemporoSpatialStringProperty(const TemporoSpatialStringProperty &amp;);

    std::pair&lt;bool, ValueType&gt; CheckValue(const TimeStepType &amp;timeStep,
                                          const IndexValueType &amp;zSlice,
                                          bool allowCloseTime = false,
                                          bool allowCloseSlice = false) const;

  private:
    // purposely not implemented
    TemporoSpatialStringProperty &amp;operator=(const TemporoSpatialStringProperty &amp;);

    itk::LightObject::Pointer InternalClone() const override;

    bool IsEqual(const BaseProperty &amp;property) const override;
    bool Assign(const BaseProperty &amp;property) override;
  };

  namespace PropertyPersistenceSerialization
  {
    /** Serialization of a TemporoSpatialStringProperty into a JSON string.*/
    MITKCORE_EXPORT::std::string serializeTemporoSpatialStringPropertyToJSON(const mitk::BaseProperty *prop);
  }

  namespace PropertyPersistenceDeserialization
  {
    /**Deserialize a passed JSON string into a TemporoSpatialStringProperty.*/
    MITKCORE_EXPORT mitk::BaseProperty::Pointer deserializeJSONToTemporoSpatialStringProperty(const std::string &amp;value);
  }

#ifdef _MSC_VER
#pragma warning(pop)
#endif

} // namespace mitk

#endif</pre>
	</body>
</html>