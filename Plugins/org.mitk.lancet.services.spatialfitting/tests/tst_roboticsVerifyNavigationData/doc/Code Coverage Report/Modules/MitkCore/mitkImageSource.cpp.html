<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageSource.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkImageSource.h"

#include "mitkImageVtkReadAccessor.h"
#include "mitkImageVtkWriteAccessor.h"

#include &lt;itkMultiThreaderBase.h&gt;

mitk::ImageSource::ImageSource()
<span style = "background-color:#fdd">{</span>
  // Create the output. We use static_cast&lt;&gt; here because we know the default
  // output must be of type TOutputImage
<span style = "background-color:#fdd">  OutputImageType::Pointer output = static_cast&lt;OutputImageType *&gt;(this-&gt;MakeOutput(0).GetPointer());
  Superclass::SetNumberOfRequiredOutputs(1);
  Superclass::SetNthOutput(0, output.GetPointer());
}</span>

itk::DataObject::Pointer mitk::ImageSource::MakeOutput(DataObjectPointerArraySizeType /*idx*/)
<span style = "background-color:#fdd">{
  return static_cast&lt;itk::DataObject *&gt;(mitk::Image::New().GetPointer());
}</span>

itk::DataObject::Pointer mitk::ImageSource::MakeOutput(const DataObjectIdentifierType &amp;name)
<span style = "background-color:#fdd">{
  itkDebugMacro("MakeOutput(" &lt;&lt; name &lt;&lt; ")");
  if (this-&gt;IsIndexedOutputName(name))</span>
  {
<span style = "background-color:#fdd">    return this-&gt;MakeOutput(this-&gt;MakeIndexFromOutputName(name));</span>
  }
<span style = "background-color:#fdd">  return static_cast&lt;itk::DataObject *&gt;(mitk::Image::New().GetPointer());
}</span>

//----------------------------------------------------------------------------
unsigned int mitk::ImageSource::SplitRequestedRegion(unsigned int i,
                                                     unsigned int num,
                                                     OutputImageRegionType &amp;splitRegion)
<span style = "background-color:#fdd">{</span>
  // Get the output pointer
<span style = "background-color:#fdd">  OutputImageType *outputPtr = this-&gt;GetOutput();
  const SlicedData::SizeType &amp;requestedRegionSize = outputPtr-&gt;GetRequestedRegion().GetSize();</span>

  int splitAxis;
  SlicedData::IndexType splitIndex;
  SlicedData::SizeType splitSize;

  // Initialize the splitRegion to the output requested region
<span style = "background-color:#fdd">  splitRegion = outputPtr-&gt;GetRequestedRegion();
  splitIndex = splitRegion.GetIndex();
  splitSize = splitRegion.GetSize();</span>

  // split on the outermost dimension available
<span style = "background-color:#fdd">  splitAxis = outputPtr-&gt;GetDimension() - 1;
  while (requestedRegionSize[splitAxis] == 1)</span>
  {
<span style = "background-color:#fdd">    --splitAxis;
    if (splitAxis &lt; 0)</span>
    { // cannot split
<span style = "background-color:#fdd">      itkDebugMacro("  Cannot Split");
      return 1;</span>
    }
<span style = "background-color:#fdd">  }</span>

  // determine the actual number of pieces that will be generated
<span style = "background-color:#fdd">  SlicedData::SizeType::SizeValueType range = requestedRegionSize[splitAxis];
  auto valuesPerThread = itk::Math::Ceil&lt;unsigned int&gt;(range / (double)num);
  unsigned int maxThreadIdUsed = itk::Math::Ceil&lt;unsigned int&gt;(range / (double)valuesPerThread) - 1;</span>

  // Split the region
<span style = "background-color:#fdd">  if (i &lt; maxThreadIdUsed)</span>
  {
<span style = "background-color:#fdd">    splitIndex[splitAxis] += i * valuesPerThread;
    splitSize[splitAxis] = valuesPerThread;</span>
  }
<span style = "background-color:#fdd">  if (i == maxThreadIdUsed)</span>
  {
<span style = "background-color:#fdd">    splitIndex[splitAxis] += i * valuesPerThread;</span>
    // last thread needs to process the "rest" dimension being split
<span style = "background-color:#fdd">    splitSize[splitAxis] = splitSize[splitAxis] - i * valuesPerThread;</span>
  }

  // set the split region ivars
<span style = "background-color:#fdd">  splitRegion.SetIndex(splitIndex);
  splitRegion.SetSize(splitSize);</span>

<span style = "background-color:#fdd">  itkDebugMacro("  Split Piece: " &lt;&lt; splitRegion);</span>

<span style = "background-color:#fdd">  return maxThreadIdUsed + 1;
}</span>

//----------------------------------------------------------------------------

void mitk::ImageSource::AllocateOutputs()
<span style = "background-color:#fdd">{
  OutputImagePointer outputPtr;</span>

  // Allocate the output memory
<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; this-&gt;GetNumberOfOutputs(); i++)</span>
  {
<span style = "background-color:#fdd">    outputPtr = this-&gt;GetOutput(i);</span>
    //    outputPtr-&gt;SetBufferedRegion(outputPtr-&gt;GetRequestedRegion()); @FIXME???
    //    outputPtr-&gt;Allocate(); @FIXME???
<span style = "background-color:#fdd">  }
}</span>

//----------------------------------------------------------------------------

void mitk::ImageSource::GenerateData()
<span style = "background-color:#fdd">{</span>
  // Call a method that can be overriden by a subclass to allocate
  // memory for the filter's outputs
<span style = "background-color:#fdd">  this-&gt;AllocateOutputs();</span>

  // Call a method that can be overridden by a subclass to perform
  // some calculations prior to splitting the main computations into
  // separate threads
<span style = "background-color:#fdd">  this-&gt;BeforeThreadedGenerateData();</span>

  // Set up the multithreaded processing
<span style = "background-color:#fdd">  ThreadStruct str;
  str.Filter = this;</span>

<span style = "background-color:#fdd">  this-&gt;GetMultiThreader()-&gt;SetNumberOfWorkUnits(this-&gt;GetNumberOfWorkUnits());
  this-&gt;GetMultiThreader()-&gt;SetSingleMethod(this-&gt;ThreaderCallback, &amp;str);</span>

  // multithread the execution
<span style = "background-color:#fdd">  this-&gt;GetMultiThreader()-&gt;SingleMethodExecute();</span>

  // Call a method that can be overridden by a subclass to perform
  // some calculations after all the threads have completed
<span style = "background-color:#fdd">  this-&gt;AfterThreadedGenerateData();
}</span>

//----------------------------------------------------------------------------
// The execute method created by the subclass.

void mitk::ImageSource::ThreadedGenerateData(const OutputImageRegionType &amp;, itk::ThreadIdType)
<span style = "background-color:#fdd">{
  itkExceptionMacro("subclass should override this method!!!");
}</span>

// Callback routine used by the threading library. This routine just calls
// the ThreadedGenerateData method after setting the correct region for this
// thread.

itk::ITK_THREAD_RETURN_TYPE mitk::ImageSource::ThreaderCallback(void *arg)
<span style = "background-color:#fdd">{</span>
  ThreadStruct *str;
  itk::ThreadIdType total, threadId, threadCount;

<span style = "background-color:#fdd">  threadId = ((itk::MultiThreaderBase::WorkUnitInfo *)(arg))-&gt;WorkUnitID;
  threadCount = ((itk::MultiThreaderBase::WorkUnitInfo *)(arg))-&gt;NumberOfWorkUnits;</span>

<span style = "background-color:#fdd">  str = (ThreadStruct *)(((itk::MultiThreaderBase::WorkUnitInfo *)(arg))-&gt;UserData);</span>

  // execute the actual method with appropriate output region
  // first find out how many pieces extent can be split into.
<span style = "background-color:#fdd">  SlicedData::RegionType splitRegion;
  total = str-&gt;Filter-&gt;SplitRequestedRegion(threadId, threadCount, splitRegion);</span>

<span style = "background-color:#fdd">  if (threadId &lt; total)</span>
  {
<span style = "background-color:#fdd">    str-&gt;Filter-&gt;ThreadedGenerateData(splitRegion, threadId);</span>
  }
  // else
  //   {
  //   otherwise don't use this thread. Sometimes the threads dont
  //   break up very well and it is just as efficient to leave a
  //   few threads idle.
  //   }

<span style = "background-color:#fdd">  return itk::ITK_THREAD_RETURN_DEFAULT_VALUE;
}</span>

void mitk::ImageSource::PrepareOutputs()
<span style = "background-color:#fdd">{
  Superclass::PrepareOutputs();
}</span>

vtkImageData *mitk::ImageSource::GetVtkImageData()
<span style = "background-color:#fdd">{
  Update();
  return GetOutput()-&gt;GetVtkImageData();
}</span>

const vtkImageData *mitk::ImageSource::GetVtkImageData() const
<span style = "background-color:#fdd">{
  return GetOutput()-&gt;GetVtkImageData();
}</span>

<span style = "background-color:#fdd">mitkBaseDataSourceGetOutputDefinitions(mitk::ImageSource)</span></pre>
	</body>
</html>