<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageAccessorBase.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKIMAGEACCESSORBASE_H
#define MITKIMAGEACCESSORBASE_H

#include &lt;itkImageRegion.h&gt;
#include &lt;itkIndex.h&gt;
#include &lt;itkSmartPointer.h&gt;

#include "mitkImageDataItem.h"

#include &lt;mutex&gt;

namespace mitk
{
  //##Documentation
  //## @brief The ImageAccessorBase class provides a lock mechanism for all inheriting image accessors.
  //##
  //## @ingroup Data

  class Image;

  /** \brief This struct allows to make ImageAccessors wait for this particular ImageAccessor object*/
  struct ImageAccessorWaitLock
  {
    /** \brief Holds the number of ImageAccessors, which are waiting until the represented ImageAccessor is released. */
    unsigned int m_WaiterCount;

    /** \brief A mutex that allows other ImageAccessors to wait for the represented ImageAccessor. */
    std::mutex m_Mutex;
  };

// Defs to assure dead lock prevention only in case of possible thread handling.
#if defined(ITK_USE_SPROC) || defined(ITK_USE_PTHREADS) || defined(ITK_USE_WIN32_THREADS)
#define MITK_USE_RECURSIVE_MUTEX_PREVENTION
#endif

  class MITKCORE_EXPORT ImageAccessorBase
  {
    friend class Image;

    friend class ImageReadAccessor;
    friend class ImageWriteAccessor;

    template &lt;class TPixel, unsigned int VDimension&gt;
    friend class ImagePixelReadAccessor;

    template &lt;class TPixel, unsigned int VDimension&gt;
    friend class ImagePixelWriteAccessor;

  public:
    typedef itk::SmartPointer&lt;const mitk::Image&gt; ImageConstPointer;

    /** \brief defines different flags for the ImageAccessor constructors
      */
    enum Options
    {
      /** No specific Options ==&gt; Default */
      DefaultBehavior = 0,
      /** Defines if the Constructor waits for locked memory until it is released or not. If not, an exception is
         thrown.*/
      ExceptionIfLocked = 1,
      /** Defines if requested Memory has to be coherent. If the parameter is true, it is possible that new Memory has
         to
         be allocated to arrange this desired condition. Consequently, this parameter can heavily affect computation
         time.*/
      ForceCoherentMemory = 2,
      /** Ignores the lock mechanism for immediate access. Only possible with read accessors. */
      IgnoreLock = 4
    };

    virtual ~ImageAccessorBase();

    /** \brief Gives const access to the data. */
<span style = "background-color:#fdd">    inline const void *GetData() const { return m_AddressBegin; }</span>
  protected:
// Define type of thread id
#ifdef ITK_USE_SPROC
    typedef int ThreadIDType;
#endif

#ifdef ITK_USE_WIN32_THREADS
    typedef DWORD ThreadIDType;
#endif

#ifdef ITK_USE_PTHREADS
    typedef pthread_t ThreadIDType;
#endif

    /** \brief Checks validity of given parameters from inheriting classes and stores those parameters in member
     * variables. */
    ImageAccessorBase(ImageConstPointer iP, const ImageDataItem *iDI = nullptr, int OptionFlags = DefaultBehavior);

    /** ImageAccessor has access to the image it belongs to. */
    // ImagePointer m_Image;

    /** Contains a SubRegion (always represented in maximal possible dimension) */
    itk::ImageRegion&lt;4&gt; *m_SubRegion;

    /** Points to the beginning of the image part. */
    void *m_AddressBegin;

    /** Contains the first address after the image part. */
    void *m_AddressEnd;

    /** \brief Stores all extended properties of an ImageAccessor.
      * The different flags in mitk::ImageAccessorBase::Options can be unified by bitwise operations.
      */
    int m_Options;

    /** Defines if the accessed image part lies coherently in memory */
    bool m_CoherentMemory;

    /** \brief Pointer to a WaitLock struct, that allows other ImageAccessors to wait for this ImageAccessor */
    ImageAccessorWaitLock *m_WaitLock;

    /** \brief Increments m_WaiterCount. A call of this method is prohibited unless the Mutex m_ReadWriteLock in the
     * mitk::Image class is Locked. */
<span style = "background-color:#fdd">    inline void Increment() { m_WaitLock-&gt;m_WaiterCount += 1; }</span>
    /** \brief Computes if there is an Overlap of the image part between this instantiation and another ImageAccessor
     * object
      * \throws mitk::Exception if memory area is incoherent (not supported yet)
      */
    bool Overlap(const ImageAccessorBase *iAB);

    /** \brief Uses the WaitLock to wait for another ImageAccessor*/
    void WaitForReleaseOf(ImageAccessorWaitLock *wL);

    ThreadIDType m_Thread;

    /** \brief Prevents a recursive mutex lock by comparing thread ids of competing image accessors */
    void PreventRecursiveMutexLock(ImageAccessorBase *iAB);

    virtual const Image *GetImage() const = 0;

  private:
    /** \brief System dependend thread method, to prevent recursive mutex access */
    ThreadIDType CurrentThreadHandle();
    /** \brief System dependend thread method, to prevent recursive mutex access */
    inline bool CompareThreadHandles(ThreadIDType, ThreadIDType);
  };

  class MemoryIsLockedException : public Exception
  {
  public:
<span style = "background-color:#fdd">    mitkExceptionClassMacro(MemoryIsLockedException, Exception)</span>
  };
}

#endif</pre>
	</body>
</html>