<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSlicedGeometry3D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
ï»¿/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;itkSpatialOrientationAdapter.h&gt;

#include "mitkSlicedGeometry3D.h"
#include "mitkAbstractTransformGeometry.h"
#include "mitkApplyTransformMatrixOperation.h"
#include "mitkInteractionConst.h"
#include "mitkPlaneGeometry.h"
#include "mitkPlaneOperation.h"
#include "mitkRestorePlanePositionOperation.h"
#include "mitkRotationOperation.h"
#include "mitkSliceNavigationController.h"

const mitk::ScalarType PI = 3.14159265359;

mitk::SlicedGeometry3D::SlicedGeometry3D()
<span style = "background-color:#fdd">  : m_EvenlySpaced(true), m_Slices(0), m_ReferenceGeometry(nullptr), m_SliceNavigationController(nullptr)
{
  m_DirectionVector.Fill(0);
  this-&gt;InitializeSlicedGeometry(m_Slices);
}</span>

mitk::SlicedGeometry3D::SlicedGeometry3D(const SlicedGeometry3D &amp;other)
<span style = "background-color:#fdd">  : Superclass(other),
    m_EvenlySpaced(other.m_EvenlySpaced),
    m_Slices(other.m_Slices),
    m_ReferenceGeometry(other.m_ReferenceGeometry),
    m_SliceNavigationController(other.m_SliceNavigationController)
{
  m_DirectionVector.Fill(0);
  SetSpacing(other.GetSpacing());
  SetDirectionVector(other.GetDirectionVector());</span>

<span style = "background-color:#fdd">  if (m_EvenlySpaced)</span>
  {
<span style = "background-color:#fdd">    assert(!other.m_PlaneGeometries.empty() &amp;&amp; "This may happen when you use one of the old Initialize methods, which had a bool parameter that is implicitly casted to the number of slices now.");
    PlaneGeometry::Pointer geometry = other.m_PlaneGeometries[0]-&gt;Clone();
    assert(geometry.IsNotNull());
    SetPlaneGeometry(geometry, 0);
  }</span>
  else
  {
    unsigned int s;
<span style = "background-color:#fdd">    for (s = 0; s &lt; other.m_Slices; ++s)</span>
    {
<span style = "background-color:#fdd">      if (other.m_PlaneGeometries[s].IsNull())</span>
      {
<span style = "background-color:#fdd">        assert(other.m_EvenlySpaced);
        m_PlaneGeometries[s] = nullptr;
      }</span>
      else
      {
<span style = "background-color:#fdd">        PlaneGeometry *geometry2D = other.m_PlaneGeometries[s]-&gt;Clone();
        assert(geometry2D != nullptr);
        SetPlaneGeometry(geometry2D, s);</span>
      }
<span style = "background-color:#fdd">    }</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::SlicedGeometry3D::~SlicedGeometry3D()
<span style = "background-color:#fdd">{
}</span>

mitk::PlaneGeometry *mitk::SlicedGeometry3D::GetPlaneGeometry(int s) const
<span style = "background-color:#fdd">{
  mitk::PlaneGeometry::Pointer geometry2D = nullptr;</span>

<span style = "background-color:#fdd">  if (this-&gt;IsValidSlice(s))</span>
  {
<span style = "background-color:#fdd">    geometry2D = m_PlaneGeometries[s];</span>

    // If (a) m_EvenlySpaced==true, (b) we don't have a PlaneGeometry stored
    // for the requested slice, and (c) the first slice (s=0)
    // is a PlaneGeometry instance, then we calculate the geometry of the
    // requested as the plane of the first slice shifted by m_Spacing[2]*s
    // in the direction of m_DirectionVector.
<span style = "background-color:#fdd">    if ((m_EvenlySpaced) &amp;&amp; (geometry2D.IsNull()))</span>
    {
<span style = "background-color:#fdd">      PlaneGeometry *firstSlice = m_PlaneGeometries[0];</span>

<span style = "background-color:#fdd">      if (firstSlice != nullptr &amp;&amp;</span>
          dynamic_cast&lt;AbstractTransformGeometry *&gt;(m_PlaneGeometries[0].GetPointer()) == nullptr)
      {
<span style = "background-color:#fdd">        if ((m_DirectionVector[0] == 0.0) &amp;&amp; (m_DirectionVector[1] == 0.0) &amp;&amp; (m_DirectionVector[2] == 0.0))</span>
        {
<span style = "background-color:#fdd">          m_DirectionVector = firstSlice-&gt;GetNormal();
          m_DirectionVector.Normalize();</span>
        }

<span style = "background-color:#fdd">        Vector3D direction;
        direction = m_DirectionVector * this-&gt;GetSpacing()[2];</span>

<span style = "background-color:#fdd">        mitk::PlaneGeometry::Pointer requestedslice;
        requestedslice = static_cast&lt;mitk::PlaneGeometry *&gt;(firstSlice-&gt;Clone().GetPointer());</span>

<span style = "background-color:#fdd">        requestedslice-&gt;SetOrigin(requestedslice-&gt;GetOrigin() + direction * s);</span>

<span style = "background-color:#fdd">        geometry2D = requestedslice;
        m_PlaneGeometries[s] = geometry2D;
      }</span>
    }
<span style = "background-color:#fdd">    return geometry2D;
  }</span>
  else
  {
<span style = "background-color:#fdd">    return nullptr;</span>
  }
<span style = "background-color:#fdd">}</span>

const mitk::BoundingBox *mitk::SlicedGeometry3D::GetBoundingBox() const
<span style = "background-color:#fdd">{
  assert(this-&gt;IsBoundingBoxNull() == false);
  return Superclass::GetBoundingBox();
}</span>

bool mitk::SlicedGeometry3D::SetPlaneGeometry(mitk::PlaneGeometry *geometry2D, int s)
<span style = "background-color:#fdd">{
  if (this-&gt;IsValidSlice(s))</span>
  {
<span style = "background-color:#fdd">    m_PlaneGeometries[s] = geometry2D;
    m_PlaneGeometries[s]-&gt;SetReferenceGeometry(m_ReferenceGeometry);
    return true;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

void mitk::SlicedGeometry3D::InitializeSlicedGeometry(unsigned int slices)
<span style = "background-color:#fdd">{
  Superclass::Initialize();
  m_Slices = slices;</span>

<span style = "background-color:#fdd">  PlaneGeometry::Pointer gnull = nullptr;
  m_PlaneGeometries.assign(m_Slices, gnull);</span>

<span style = "background-color:#fdd">  Vector3D spacing;
  spacing.Fill(1.0);
  this-&gt;SetSpacing(spacing);</span>

<span style = "background-color:#fdd">  m_DirectionVector.Fill(0);
}</span>

void mitk::SlicedGeometry3D::InitializeEvenlySpaced(mitk::PlaneGeometry *geometry2D, unsigned int slices)
<span style = "background-color:#fdd">{
  assert(geometry2D != nullptr);
  this-&gt;InitializeEvenlySpaced(geometry2D, geometry2D-&gt;GetExtentInMM(2) / geometry2D-&gt;GetExtent(2), slices);
}</span>

void mitk::SlicedGeometry3D::InitializeEvenlySpaced(mitk::PlaneGeometry *geometry2D,
                                                    mitk::ScalarType zSpacing,
                                                    unsigned int slices)
<span style = "background-color:#fdd">{
  assert(geometry2D != nullptr);
  assert(geometry2D-&gt;GetExtent(0) &gt; 0);
  assert(geometry2D-&gt;GetExtent(1) &gt; 0);</span>

<span style = "background-color:#fdd">  geometry2D-&gt;Register();</span>

<span style = "background-color:#fdd">  Superclass::Initialize();
  m_Slices = slices;</span>

<span style = "background-color:#fdd">  BoundingBox::BoundsArrayType bounds = geometry2D-&gt;GetBounds();
  bounds[4] = 0;
  bounds[5] = slices;</span>

  // clear and reserve
<span style = "background-color:#fdd">  PlaneGeometry::Pointer gnull = nullptr;
  m_PlaneGeometries.assign(m_Slices, gnull);</span>

<span style = "background-color:#fdd">  Vector3D directionVector = geometry2D-&gt;GetAxisVector(2);
  directionVector.Normalize();
  directionVector *= zSpacing;</span>

  // Normally we should use the following four lines to create a copy of
  // the transform contrained in geometry2D, because it may not be changed
  // by us. But we know that SetSpacing creates a new transform without
  // changing the old (coming from geometry2D), so we can use the fifth
  // line instead. We check this at (**).
  //
  // AffineTransform3D::Pointer transform = AffineTransform3D::New();
  // transform-&gt;SetMatrix(geometry2D-&gt;GetIndexToWorldTransform()-&gt;GetMatrix());
  // transform-&gt;SetOffset(geometry2D-&gt;GetIndexToWorldTransform()-&gt;GetOffset());
  // SetIndexToWorldTransform(transform);

<span style = "background-color:#fdd">  this-&gt;SetIndexToWorldTransform(geometry2D-&gt;GetIndexToWorldTransform());</span>

<span style = "background-color:#fdd">  mitk::Vector3D spacing;
  FillVector3D(spacing, geometry2D-&gt;GetExtentInMM(0) / bounds[1], geometry2D-&gt;GetExtentInMM(1) / bounds[3], zSpacing);</span>

<span style = "background-color:#fdd">  this-&gt;SetDirectionVector(directionVector);
  this-&gt;SetBounds(bounds);
  this-&gt;SetPlaneGeometry(geometry2D, 0);
  this-&gt;SetSpacing(spacing, true);
  this-&gt;SetEvenlySpaced();</span>

  // this-&gt;SetTimeBounds( geometry2D-&gt;GetTimeBounds() );

<span style = "background-color:#fdd">  assert(this-&gt;GetIndexToWorldTransform() != geometry2D-&gt;GetIndexToWorldTransform()); // (**) see above.</span>

<span style = "background-color:#fdd">  this-&gt;SetFrameOfReferenceID(geometry2D-&gt;GetFrameOfReferenceID());
  this-&gt;SetImageGeometry(geometry2D-&gt;GetImageGeometry());</span>

<span style = "background-color:#fdd">  geometry2D-&gt;UnRegister();
}</span>

void mitk::SlicedGeometry3D::InitializePlanes(const mitk::BaseGeometry *geometry3D,
                                              mitk::PlaneGeometry::PlaneOrientation planeorientation,
                                              bool top,
                                              bool frontside,
                                              bool rotated)
<span style = "background-color:#fdd">{
  m_ReferenceGeometry = geometry3D;</span>

<span style = "background-color:#fdd">  PlaneGeometry::Pointer planeGeometry = mitk::PlaneGeometry::New();
  planeGeometry-&gt;InitializeStandardPlane(geometry3D, top, planeorientation, frontside, rotated);</span>

<span style = "background-color:#fdd">  int worldAxis =</span>
      planeorientation == PlaneGeometry::Sagittal ? 0 :
      planeorientation == PlaneGeometry::Frontal  ? 1 : 2;

  // Inspired by:
  // http://www.na-mic.org/Wiki/index.php/Coordinate_System_Conversion_Between_ITK_and_Slicer3

<span style = "background-color:#fdd">  mitk::AffineTransform3D::MatrixType matrix = geometry3D-&gt;GetIndexToWorldTransform()-&gt;GetMatrix();
  matrix.GetVnlMatrix().normalize_columns();
  mitk::AffineTransform3D::MatrixType::InternalMatrixType inverseMatrix = matrix.GetTranspose();</span>

<span style = "background-color:#fdd">  int dominantAxis = planeGeometry-&gt;CalculateDominantAxes(inverseMatrix).at(worldAxis);
  ScalarType viewSpacing = geometry3D-&gt;GetSpacing()[dominantAxis];</span>

  /// Although the double value returned by GetExtent() holds a round number,
  /// you need to add 0.5 to safely convert it to unsigned it. I have seen a
  /// case when the result was less by one without this.
<span style = "background-color:#fdd">  auto slices = static_cast&lt;unsigned int&gt;(geometry3D-&gt;GetExtent(dominantAxis) + 0.5);
  if ( slices == 0 &amp;&amp; geometry3D-&gt;GetExtent(dominantAxis) &gt; 0) {</span>
      // require at least one slice if there is _some_ extent
<span style = "background-color:#fdd">      slices = 1;</span>
  }

#ifndef NDEBUG
<span style = "background-color:#fdd">  int upDirection = itk::Function::Sign(inverseMatrix[dominantAxis][worldAxis]);</span>

  /// The normal vector of an imaginary plane that points from the world origin (bottom left back
  /// corner or the world, with the lowest physical coordinates) towards the inside of the volume,
  /// along the renderer axis. Length is the slice thickness.
<span style = "background-color:#fdd">  Vector3D worldPlaneNormal = inverseMatrix.get_row(dominantAxis) * (upDirection * viewSpacing);</span>

  /// The normal of the standard plane geometry just created.
<span style = "background-color:#fdd">  Vector3D standardPlaneNormal = planeGeometry-&gt;GetNormal();</span>

  /// The standard plane must be parallel to the 'world plane'. The normal of the standard plane
  /// must point against the world plane if and only if 'top' is 'false'. The length of the
  /// standard plane normal must be equal to the slice thickness.
<span style = "background-color:#fdd">  assert((standardPlaneNormal - (top ? 1.0 : -1.0) * worldPlaneNormal).GetSquaredNorm() &lt; 0.000001);</span>
#endif

<span style = "background-color:#fdd">  this-&gt;InitializeEvenlySpaced(planeGeometry, viewSpacing, slices);</span>

#ifndef NDEBUG
  /// The standard plane normal and the z axis vector of the sliced geometry must point in
  /// the same direction.
<span style = "background-color:#fdd">  Vector3D zAxisVector = this-&gt;GetAxisVector(2);
  Vector3D upscaledStandardPlaneNormal = standardPlaneNormal;
  upscaledStandardPlaneNormal *= slices;
  assert((zAxisVector - upscaledStandardPlaneNormal).GetSquaredNorm() &lt; 0.000001);</span>

  /// You can use this test is to check the handedness of the coordinate system of the current
  /// geometry. In principle, you can use either left- or right-handed coordinate systems, but
  /// you normally want it to be consistent, that is the handedness should be the same across
  /// the renderers of the same viewer.
//  ScalarType det = vnl_det(this-&gt;GetIndexToWorldTransform()-&gt;GetMatrix().GetVnlMatrix());
//  MITK_DEBUG &lt;&lt; "world axis: " &lt;&lt; worldAxis &lt;&lt; (det &gt; 0 ? " ; right-handed" : " ; left-handed");
#endif
<span style = "background-color:#fdd">}</span>

void mitk::SlicedGeometry3D::ReinitializePlanes(const Point3D &amp;center, const Point3D &amp;referencePoint)
<span style = "background-color:#fdd">{</span>
  // Need a reference frame to align the rotated planes
<span style = "background-color:#fdd">  if (!m_ReferenceGeometry)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // Get first plane of plane stack
<span style = "background-color:#fdd">  PlaneGeometry *firstPlane = m_PlaneGeometries[0];</span>

  // If plane stack is empty, exit
<span style = "background-color:#fdd">  if (!firstPlane || dynamic_cast&lt;AbstractTransformGeometry *&gt;(firstPlane))</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // Calculate the "directed" spacing when taking the plane (defined by its axes
  // vectors and normal) as the reference coordinate frame.
  //
  // This is done by calculating the radius of the ellipsoid defined by the
  // original volume spacing axes, in the direction of the respective axis of the
  // reference frame.
<span style = "background-color:#fdd">  mitk::Vector3D axis0 = firstPlane-&gt;GetAxisVector(0);
  mitk::Vector3D axis1 = firstPlane-&gt;GetAxisVector(1);
  mitk::Vector3D normal = firstPlane-&gt;GetNormal();
  normal.Normalize();</span>

<span style = "background-color:#fdd">  Vector3D spacing;
  spacing[0] = this-&gt;CalculateSpacing(axis0);
  spacing[1] = this-&gt;CalculateSpacing(axis1);
  spacing[2] = this-&gt;CalculateSpacing(normal);</span>

<span style = "background-color:#fdd">  Superclass::SetSpacing(spacing);</span>

  // Now we need to calculate the number of slices in the plane's normal
  // direction, so that the entire volume is covered. This is done by first
  // calculating the dot product between the volume diagonal (the maximum
  // distance inside the volume) and the normal, and dividing this value by
  // the directed spacing calculated above.
<span style = "background-color:#fdd">  ScalarType directedExtent = std::abs(m_ReferenceGeometry-&gt;GetExtentInMM(0) * normal[0]) +</span>
                              std::abs(m_ReferenceGeometry-&gt;GetExtentInMM(1) * normal[1]) +
                              std::abs(m_ReferenceGeometry-&gt;GetExtentInMM(2) * normal[2]);

<span style = "background-color:#fdd">  if (directedExtent &gt;= spacing[2])</span>
  {
<span style = "background-color:#fdd">    m_Slices = static_cast&lt;unsigned int&gt;(directedExtent / spacing[2] + 0.5);
  }</span>
  else
  {
<span style = "background-color:#fdd">    m_Slices = 1;</span>
  }

  // The origin of our "first plane" needs to be adapted to this new extent.
  // To achieve this, we first calculate the current distance to the volume's
  // center, and then shift the origin in the direction of the normal by the
  // difference between this distance and half of the new extent.
<span style = "background-color:#fdd">  double centerOfRotationDistance = firstPlane-&gt;SignedDistanceFromPlane(center);</span>

<span style = "background-color:#fdd">  if (centerOfRotationDistance &gt; 0)</span>
  {
<span style = "background-color:#fdd">    firstPlane-&gt;SetOrigin(firstPlane-&gt;GetOrigin() + normal * (centerOfRotationDistance - directedExtent / 2.0));
    m_DirectionVector = normal;
  }</span>
  else
  {
<span style = "background-color:#fdd">    firstPlane-&gt;SetOrigin(firstPlane-&gt;GetOrigin() + normal * (directedExtent / 2.0 + centerOfRotationDistance));
    m_DirectionVector = -normal;</span>
  }

  // Now we adjust this distance according with respect to the given reference
  // point: we need to make sure that the point is touched by one slice of the
  // new slice stack.
<span style = "background-color:#fdd">  double referencePointDistance = firstPlane-&gt;SignedDistanceFromPlane(referencePoint);</span>

<span style = "background-color:#fdd">  auto referencePointSlice = static_cast&lt;int&gt;(referencePointDistance / spacing[2]);</span>

<span style = "background-color:#fdd">  double alignmentValue = referencePointDistance / spacing[2] - referencePointSlice;</span>

<span style = "background-color:#fdd">  firstPlane-&gt;SetOrigin(firstPlane-&gt;GetOrigin() + normal * alignmentValue * spacing[2]);</span>

  // Finally, we can clear the previous geometry stack and initialize it with
  // our re-initialized "first plane".
<span style = "background-color:#fdd">  m_PlaneGeometries.assign(m_Slices, PlaneGeometry::Pointer(nullptr));</span>

<span style = "background-color:#fdd">  if (m_Slices &gt; 0)</span>
  {
<span style = "background-color:#fdd">    m_PlaneGeometries[0] = firstPlane;</span>
  }

  // Reinitialize SNC with new number of slices
<span style = "background-color:#fdd">  m_SliceNavigationController-&gt;GetSlice()-&gt;SetSteps(m_Slices);</span>

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span>

double mitk::SlicedGeometry3D::CalculateSpacing(const mitk::Vector3D &amp;d) const
<span style = "background-color:#fdd">{</span>
  // Need the spacing of the underlying dataset / geometry
<span style = "background-color:#fdd">  if (!m_ReferenceGeometry)</span>
  {
<span style = "background-color:#fdd">    return 1.0;</span>
  }

<span style = "background-color:#fdd">  const mitk::Vector3D &amp;spacing = m_ReferenceGeometry-&gt;GetSpacing();
  return SlicedGeometry3D::CalculateSpacing(spacing, d);
}</span>

double mitk::SlicedGeometry3D::CalculateSpacing(const mitk::Vector3D &amp;spacing, const mitk::Vector3D &amp;d)
<span style = "background-color:#fdd">{</span>
  // The following can be derived from the ellipsoid equation
  //
  //   1 = x^2/a^2 + y^2/b^2 + z^2/c^2
  //
  // where (a,b,c) = spacing of original volume (ellipsoid radii)
  // and   (x,y,z) = scaled coordinates of vector d (according to ellipsoid)
  //
<span style = "background-color:#fdd">  double scaling = d[0] * d[0] / (spacing[0] * spacing[0]) + d[1] * d[1] / (spacing[1] * spacing[1]) +</span>
                   d[2] * d[2] / (spacing[2] * spacing[2]);

<span style = "background-color:#fdd">  scaling = sqrt(scaling);</span>

<span style = "background-color:#fdd">  return (sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]) / scaling);
}</span>

mitk::Vector3D mitk::SlicedGeometry3D::AdjustNormal(const mitk::Vector3D &amp;normal) const
<span style = "background-color:#fdd">{
  TransformType::Pointer inverse = TransformType::New();
  m_ReferenceGeometry-&gt;GetIndexToWorldTransform()-&gt;GetInverse(inverse);</span>

<span style = "background-color:#fdd">  Vector3D transformedNormal = inverse-&gt;TransformVector(normal);</span>

<span style = "background-color:#fdd">  transformedNormal.Normalize();
  return transformedNormal;
}</span>

void mitk::SlicedGeometry3D::SetImageGeometry(const bool isAnImageGeometry)
<span style = "background-color:#fdd">{
  Superclass::SetImageGeometry(isAnImageGeometry);</span>

  unsigned int s;
<span style = "background-color:#fdd">  for (s = 0; s &lt; m_Slices; ++s)</span>
  {
<span style = "background-color:#fdd">    mitk::BaseGeometry *geometry = m_PlaneGeometries[s];
    if (geometry != nullptr)</span>
    {
<span style = "background-color:#fdd">      geometry-&gt;SetImageGeometry(isAnImageGeometry);</span>
    }
<span style = "background-color:#fdd">  }
}</span>

void mitk::SlicedGeometry3D::ChangeImageGeometryConsideringOriginOffset(const bool isAnImageGeometry)
<span style = "background-color:#fdd">{</span>
  unsigned int s;
<span style = "background-color:#fdd">  for (s = 0; s &lt; m_Slices; ++s)</span>
  {
<span style = "background-color:#fdd">    mitk::BaseGeometry *geometry = m_PlaneGeometries[s];
    if (geometry != nullptr)</span>
    {
<span style = "background-color:#fdd">      geometry-&gt;ChangeImageGeometryConsideringOriginOffset(isAnImageGeometry);</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  Superclass::ChangeImageGeometryConsideringOriginOffset(isAnImageGeometry);
}</span>

bool mitk::SlicedGeometry3D::IsValidSlice(int s) const
<span style = "background-color:#fdd">{
  return ((s &gt;= 0) &amp;&amp; (s &lt; (int)m_Slices));
}</span>

const mitk::BaseGeometry *mitk::SlicedGeometry3D::GetReferenceGeometry() const
<span style = "background-color:#fdd">{
  return m_ReferenceGeometry;
}</span>

void mitk::SlicedGeometry3D::SetReferenceGeometry(const BaseGeometry *referenceGeometry)
<span style = "background-color:#fdd">{
  m_ReferenceGeometry = referenceGeometry;</span>

<span style = "background-color:#fdd">  std::vector&lt;PlaneGeometry::Pointer&gt;::iterator it;</span>

<span style = "background-color:#fdd">  for (it = m_PlaneGeometries.begin(); it != m_PlaneGeometries.end(); ++it)</span>
  {
<span style = "background-color:#fdd">    (*it)-&gt;SetReferenceGeometry(referenceGeometry);
  }
}</span>

bool mitk::SlicedGeometry3D::HasReferenceGeometry() const
<span style = "background-color:#fdd">{
  return ( m_ReferenceGeometry != nullptr );
}</span>

void mitk::SlicedGeometry3D::PreSetSpacing(const mitk::Vector3D &amp;aSpacing)
<span style = "background-color:#fdd">{
  bool hasEvenlySpacedPlaneGeometry = false;
  mitk::Point3D origin;
  mitk::Vector3D rightDV, bottomDV;</span>
  BoundingBox::BoundsArrayType bounds;

  // Check for valid spacing
<span style = "background-color:#fdd">  if (!(aSpacing[0] &gt; 0 &amp;&amp; aSpacing[1] &gt; 0 &amp;&amp; aSpacing[2] &gt; 0))</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "You try to set a spacing with at least one element equal or "</span>
                   "smaller to \"0\". This might lead to a crash during rendering. Please double"
                   " check your data!";
  }

  // In case of evenly-spaced data: re-initialize instances of PlaneGeometry,
  // since the spacing influences them
<span style = "background-color:#fdd">  if ((m_EvenlySpaced) &amp;&amp; (m_PlaneGeometries.size() &gt; 0))</span>
  {
<span style = "background-color:#fdd">    const PlaneGeometry *planeGeometry = m_PlaneGeometries[0];</span>

<span style = "background-color:#fdd">    if (planeGeometry &amp;&amp; !dynamic_cast&lt;const AbstractTransformGeometry *&gt;(planeGeometry))</span>
    {
<span style = "background-color:#fdd">      this-&gt;WorldToIndex(planeGeometry-&gt;GetOrigin(), origin);
      this-&gt;WorldToIndex(planeGeometry-&gt;GetAxisVector(0), rightDV);
      this-&gt;WorldToIndex(planeGeometry-&gt;GetAxisVector(1), bottomDV);</span>

<span style = "background-color:#fdd">      bounds = planeGeometry-&gt;GetBounds();
      hasEvenlySpacedPlaneGeometry = true;</span>
    }
  }

<span style = "background-color:#fdd">  BaseGeometry::_SetSpacing(aSpacing);</span>

<span style = "background-color:#fdd">  mitk::PlaneGeometry::Pointer firstGeometry;</span>

  // In case of evenly-spaced data: re-initialize instances of PlaneGeometry,
  // since the spacing influences them
<span style = "background-color:#fdd">  if (hasEvenlySpacedPlaneGeometry)</span>
  {
    // create planeGeometry according to new spacing
<span style = "background-color:#fdd">    this-&gt;IndexToWorld(origin, origin);
    this-&gt;IndexToWorld(rightDV, rightDV);
    this-&gt;IndexToWorld(bottomDV, bottomDV);</span>

<span style = "background-color:#fdd">    mitk::PlaneGeometry::Pointer planeGeometry = mitk::PlaneGeometry::New();
    planeGeometry-&gt;SetImageGeometry(this-&gt;GetImageGeometry());</span>

<span style = "background-color:#fdd">    planeGeometry-&gt;SetReferenceGeometry(m_ReferenceGeometry);</span>

    // Store spacing, as Initialize... needs a pointer
<span style = "background-color:#fdd">    mitk::Vector3D lokalSpacing = this-&gt;GetSpacing();
    planeGeometry-&gt;InitializeStandardPlane(rightDV.GetVnlVector(), bottomDV.GetVnlVector(), &amp;lokalSpacing);
    planeGeometry-&gt;SetOrigin(origin);
    planeGeometry-&gt;SetBounds(bounds);</span>

<span style = "background-color:#fdd">    firstGeometry = planeGeometry;
  }
  else if ((m_EvenlySpaced) &amp;&amp; (m_PlaneGeometries.size() &gt; 0))</span>
  {
<span style = "background-color:#fdd">    firstGeometry = m_PlaneGeometries[0].GetPointer();</span>
  }

  // clear and reserve
<span style = "background-color:#fdd">  PlaneGeometry::Pointer gnull = nullptr;
  m_PlaneGeometries.assign(m_Slices, gnull);</span>

<span style = "background-color:#fdd">  if (m_Slices &gt; 0)</span>
  {
<span style = "background-color:#fdd">    m_PlaneGeometries[0] = firstGeometry;</span>
  }

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span>

void mitk::SlicedGeometry3D::SetSliceNavigationController(SliceNavigationController *snc)
<span style = "background-color:#fdd">{
  m_SliceNavigationController = snc;
}</span>

mitk::SliceNavigationController *mitk::SlicedGeometry3D::GetSliceNavigationController()
<span style = "background-color:#fdd">{
  return m_SliceNavigationController;
}</span>

void mitk::SlicedGeometry3D::SetEvenlySpaced(bool on)
<span style = "background-color:#fdd">{
  if (m_EvenlySpaced != on)</span>
  {
<span style = "background-color:#fdd">    m_EvenlySpaced = on;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::SlicedGeometry3D::SetDirectionVector(const mitk::Vector3D &amp;directionVector)
<span style = "background-color:#fdd">{
  Vector3D newDir = directionVector;
  newDir.Normalize();
  if (newDir != m_DirectionVector)</span>
  {
<span style = "background-color:#fdd">    m_DirectionVector = newDir;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

// void
// mitk::SlicedGeometry3D::SetTimeBounds( const mitk::TimeBounds&amp; timebounds )
//{
//  Superclass::SetTimeBounds( timebounds );
//
//  unsigned int s;
//  for ( s = 0; s &lt; m_Slices; ++s )
//  {
//    if(m_Geometry2Ds[s].IsNotNull())
//    {
//      m_Geometry2Ds[s]-&gt;SetTimeBounds( timebounds );
//    }
//  }
//  m_TimeBounds = timebounds;
//}

itk::LightObject::Pointer mitk::SlicedGeometry3D::InternalClone() const
<span style = "background-color:#fdd">{
  Self::Pointer newGeometry = new SlicedGeometry3D(*this);
  newGeometry-&gt;UnRegister();
  return newGeometry.GetPointer();
}</span>

void mitk::SlicedGeometry3D::PrintSelf(std::ostream &amp;os, itk::Indent indent) const
<span style = "background-color:#fdd">{
  Superclass::PrintSelf(os, indent);
  os &lt;&lt; indent &lt;&lt; " EvenlySpaced: " &lt;&lt; m_EvenlySpaced &lt;&lt; std::endl;
  if (m_EvenlySpaced)</span>
  {
<span style = "background-color:#fdd">    os &lt;&lt; indent &lt;&lt; " DirectionVector: " &lt;&lt; m_DirectionVector &lt;&lt; std::endl;</span>
  }
<span style = "background-color:#fdd">  os &lt;&lt; indent &lt;&lt; " Slices: " &lt;&lt; m_Slices &lt;&lt; std::endl;</span>

<span style = "background-color:#fdd">  os &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; " GetPlaneGeometry(0): ";
  if (this-&gt;GetPlaneGeometry(0) == nullptr)</span>
  {
<span style = "background-color:#fdd">    os &lt;&lt; "nullptr" &lt;&lt; std::endl;
  }</span>
  else
  {
<span style = "background-color:#fdd">    this-&gt;GetPlaneGeometry(0)-&gt;Print(os, indent);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::SlicedGeometry3D::ExecuteOperation(Operation *operation)
<span style = "background-color:#fdd">{
  PlaneGeometry::Pointer geometry2D;</span>
  ApplyTransformMatrixOperation *applyMatrixOp;
<span style = "background-color:#fdd">  Point3D center;</span>

<span style = "background-color:#fdd">  switch (operation-&gt;GetOperationType())</span>
  {
    case OpNOTHING:
<span style = "background-color:#fdd">      break;</span>

    case OpROTATE:
<span style = "background-color:#fdd">      if (m_EvenlySpaced)</span>
      {
        // Need a reference frame to align the rotation
<span style = "background-color:#fdd">        if (m_ReferenceGeometry)</span>
        {
          // Clear all generated geometries and then rotate only the first slice.
          // The other slices will be re-generated on demand

          // Save first slice
<span style = "background-color:#fdd">          PlaneGeometry::Pointer geometry2D = m_PlaneGeometries[0];</span>

<span style = "background-color:#fdd">          auto *rotOp = dynamic_cast&lt;RotationOperation *&gt;(operation);</span>

          // Generate a RotationOperation using the dataset center instead of
          // the supplied rotation center. This is necessary so that the rotated
          // zero-plane does not shift away. The supplied center is instead used
          // to adjust the slice stack afterwards.
<span style = "background-color:#fdd">          Point3D center = m_ReferenceGeometry-&gt;GetCenter();</span>

<span style = "background-color:#fdd">          RotationOperation centeredRotation(</span>
            rotOp-&gt;GetOperationType(), center, rotOp-&gt;GetVectorOfRotation(), rotOp-&gt;GetAngleOfRotation());

          // Rotate first slice
<span style = "background-color:#fdd">          geometry2D-&gt;ExecuteOperation(&amp;centeredRotation);</span>

          // Clear the slice stack and adjust it according to the center of
          // the dataset and the supplied rotation center (see documentation of
          // ReinitializePlanes)
<span style = "background-color:#fdd">          this-&gt;ReinitializePlanes(center, rotOp-&gt;GetCenterOfRotation());</span>

<span style = "background-color:#fdd">          geometry2D-&gt;SetSpacing(this-&gt;GetSpacing());</span>

<span style = "background-color:#fdd">          if (m_SliceNavigationController)</span>
          {
<span style = "background-color:#fdd">            m_SliceNavigationController-&gt;SelectSliceByPoint(rotOp-&gt;GetCenterOfRotation());
            m_SliceNavigationController-&gt;AdjustSliceStepperRange();</span>
          }

<span style = "background-color:#fdd">          BaseGeometry::ExecuteOperation(&amp;centeredRotation);
        }</span>
        else
        {
          // we also have to consider the case, that there is no reference geometry available.
<span style = "background-color:#fdd">          if (m_PlaneGeometries.size() &gt; 0)</span>
          {
            // Reach through to all slices in my container
<span style = "background-color:#fdd">            for (auto iter = m_PlaneGeometries.begin(); iter != m_PlaneGeometries.end(); ++iter)</span>
            {
              // Test for empty slices, which can happen if evenly spaced geometry
<span style = "background-color:#fdd">              if ((*iter).IsNotNull())</span>
              {
<span style = "background-color:#fdd">                (*iter)-&gt;ExecuteOperation(operation);
              }
            }</span>

            // rotate overall geometry
<span style = "background-color:#fdd">            auto *rotOp = dynamic_cast&lt;RotationOperation *&gt;(operation);
            BaseGeometry::ExecuteOperation(rotOp);</span>
          }
        }
<span style = "background-color:#fdd">      }</span>
      else
      {
        // Reach through to all slices
<span style = "background-color:#fdd">        for (auto iter = m_PlaneGeometries.begin(); iter != m_PlaneGeometries.end(); ++iter)</span>
        {
<span style = "background-color:#fdd">          (*iter)-&gt;ExecuteOperation(operation);
        }</span>
      }
<span style = "background-color:#fdd">      break;</span>

    case OpORIENT:
<span style = "background-color:#fdd">      if (m_EvenlySpaced)</span>
      {
        // get operation data
<span style = "background-color:#fdd">        auto *planeOp = dynamic_cast&lt;PlaneOperation *&gt;(operation);</span>

        // Get first slice
<span style = "background-color:#fdd">        PlaneGeometry::Pointer planeGeometry = m_PlaneGeometries[0];</span>

        // Need a PlaneGeometry, a PlaneOperation and a reference frame to
        // carry out the re-orientation. If not all avaialble, stop here
        if (!m_ReferenceGeometry ||
<span style = "background-color:#fdd">            (!planeGeometry || dynamic_cast&lt;AbstractTransformGeometry *&gt;(planeGeometry.GetPointer())) || !planeOp)</span>
        {
<span style = "background-color:#fdd">          break;</span>
        }

        // General Behavior:
        // Clear all generated geometries and then rotate only the first slice.
        // The other slices will be re-generated on demand

        //
        // 1st Step: Reorient Normal Vector of first plane
        //
<span style = "background-color:#fdd">        Point3D center = planeOp-&gt;GetPoint(); // m_ReferenceGeometry-&gt;GetCenter();
        mitk::Vector3D currentNormal = planeGeometry-&gt;GetNormal();
        mitk::Vector3D newNormal;
        if (planeOp-&gt;AreAxisDefined())</span>
        {
          // If planeOp was defined by one centerpoint and two axis vectors
<span style = "background-color:#fdd">          newNormal = CrossProduct(planeOp-&gt;GetAxisVec0(), planeOp-&gt;GetAxisVec1());
        }</span>
        else
        {
          // If planeOp was defined by one centerpoint and one normal vector
<span style = "background-color:#fdd">          newNormal = planeOp-&gt;GetNormal();</span>
        }

        // Get Rotation axis und angle
<span style = "background-color:#fdd">        currentNormal.Normalize();
        newNormal.Normalize();
        ScalarType rotationAngle = angle(currentNormal.GetVnlVector(), newNormal.GetVnlVector());</span>

<span style = "background-color:#fdd">        rotationAngle *= 180.0 / vnl_math::pi; // from rad to deg
        Vector3D rotationAxis = itk::CrossProduct(currentNormal, newNormal);
        if (std::abs(rotationAngle - 180) &lt; mitk::eps)</span>
        {
          // current Normal and desired normal are not linear independent!!(e.g 1,0,0 and -1,0,0).
          // Rotation Axis should be ANY vector that is 90ï¿½ to current Normal
<span style = "background-color:#fdd">          mitk::Vector3D helpNormal;
          helpNormal = currentNormal;
          helpNormal[0] += 1;
          helpNormal[1] -= 1;
          helpNormal[2] += 1;
          helpNormal.Normalize();
          rotationAxis = itk::CrossProduct(helpNormal, currentNormal);</span>
        }

<span style = "background-color:#fdd">        RotationOperation centeredRotation(mitk::OpROTATE, center, rotationAxis, rotationAngle);</span>

        // Rotate first slice
<span style = "background-color:#fdd">        planeGeometry-&gt;ExecuteOperation(&amp;centeredRotation);</span>

        // Reinitialize planes and select slice, if my rotations are all done.
<span style = "background-color:#fdd">        if (!planeOp-&gt;AreAxisDefined())</span>
        {
          // Clear the slice stack and adjust it according to the center of
          // rotation and plane position (see documentation of ReinitializePlanes)
<span style = "background-color:#fdd">          this-&gt;ReinitializePlanes(center, planeOp-&gt;GetPoint());
          planeGeometry-&gt;SetSpacing(this-&gt;GetSpacing());</span>

<span style = "background-color:#fdd">          if (m_SliceNavigationController)</span>
          {
<span style = "background-color:#fdd">            m_SliceNavigationController-&gt;SelectSliceByPoint(planeOp-&gt;GetPoint());
            m_SliceNavigationController-&gt;AdjustSliceStepperRange();</span>
          }
        }

        // Also apply rotation on the slicedGeometry - Geometry3D (Bounding geometry)
<span style = "background-color:#fdd">        BaseGeometry::ExecuteOperation(&amp;centeredRotation);</span>

        //
        // 2nd step. If axis vectors were defined, rotate the plane around its normal to fit these
        //

<span style = "background-color:#fdd">        if (planeOp-&gt;AreAxisDefined())</span>
        {
<span style = "background-color:#fdd">          mitk::Vector3D vecAxixNew = planeOp-&gt;GetAxisVec0();
          vecAxixNew.Normalize();
          mitk::Vector3D VecAxisCurr = planeGeometry-&gt;GetAxisVector(0);
          VecAxisCurr.Normalize();</span>

<span style = "background-color:#fdd">          ScalarType rotationAngle = angle(VecAxisCurr.GetVnlVector(), vecAxixNew.GetVnlVector());
          rotationAngle = rotationAngle * 180 / PI; // Rad to Deg</span>

          // we rotate around the normal of the plane, but we do not know, if we need to rotate clockwise
          // or anti-clockwise. So we rotate around the crossproduct of old and new Axisvector.
          // Since both axis vectors lie in the plane, the crossproduct is the planes normal or the negative planes
          // normal

<span style = "background-color:#fdd">          rotationAxis = itk::CrossProduct(VecAxisCurr, vecAxixNew);
          if (std::abs(rotationAngle - 180) &lt; mitk::eps)</span>
          {
            // current axisVec and desired axisVec are not linear independent!!(e.g 1,0,0 and -1,0,0).
            // Rotation Axis can be just plane Normal. (have to rotate by 180ï¿½)
<span style = "background-color:#fdd">            rotationAxis = newNormal;</span>
          }

          // Perfom Rotation
<span style = "background-color:#fdd">          mitk::RotationOperation op(mitk::OpROTATE, center, rotationAxis, rotationAngle);
          planeGeometry-&gt;ExecuteOperation(&amp;op);</span>

          // Apply changes on first slice to whole slice stack
<span style = "background-color:#fdd">          this-&gt;ReinitializePlanes(center, planeOp-&gt;GetPoint());
          planeGeometry-&gt;SetSpacing(this-&gt;GetSpacing());</span>

<span style = "background-color:#fdd">          if (m_SliceNavigationController)</span>
          {
<span style = "background-color:#fdd">            m_SliceNavigationController-&gt;SelectSliceByPoint(planeOp-&gt;GetPoint());
            m_SliceNavigationController-&gt;AdjustSliceStepperRange();</span>
          }

          // Also apply rotation on the slicedGeometry - Geometry3D (Bounding geometry)
<span style = "background-color:#fdd">          BaseGeometry::ExecuteOperation(&amp;op);
        }
      }</span>
      else
      {
        // Reach through to all slices
<span style = "background-color:#fdd">        for (auto iter = m_PlaneGeometries.begin(); iter != m_PlaneGeometries.end(); ++iter)</span>
        {
<span style = "background-color:#fdd">          (*iter)-&gt;ExecuteOperation(operation);
        }</span>
      }
<span style = "background-color:#fdd">      break;</span>

    case OpRESTOREPLANEPOSITION:
<span style = "background-color:#fdd">      if (m_EvenlySpaced)</span>
      {
        // Save first slice
<span style = "background-color:#fdd">        PlaneGeometry::Pointer planeGeometry = m_PlaneGeometries[0];</span>

<span style = "background-color:#fdd">        auto *restorePlaneOp = dynamic_cast&lt;RestorePlanePositionOperation *&gt;(operation);</span>

        // Need a PlaneGeometry, a PlaneOperation and a reference frame to
        // carry out the re-orientation
        if (m_ReferenceGeometry &amp;&amp;
<span style = "background-color:#fdd">            (planeGeometry &amp;&amp; dynamic_cast&lt;AbstractTransformGeometry *&gt;(planeGeometry.GetPointer()) == nullptr) &amp;&amp;</span>
            restorePlaneOp)
        {
          // Clear all generated geometries and then rotate only the first slice.
          // The other slices will be re-generated on demand

          // Rotate first slice
<span style = "background-color:#fdd">          planeGeometry-&gt;ExecuteOperation(restorePlaneOp);</span>

<span style = "background-color:#fdd">          m_DirectionVector = restorePlaneOp-&gt;GetDirectionVector();</span>

<span style = "background-color:#fdd">          double centerOfRotationDistance = planeGeometry-&gt;SignedDistanceFromPlane(m_ReferenceGeometry-&gt;GetCenter());</span>

<span style = "background-color:#fdd">          if (centerOfRotationDistance &lt;= 0)</span>
          {
<span style = "background-color:#fdd">            m_DirectionVector = -m_DirectionVector;</span>
          }

<span style = "background-color:#fdd">          Vector3D spacing = restorePlaneOp-&gt;GetSpacing();</span>

<span style = "background-color:#fdd">          Superclass::SetSpacing(spacing);</span>

          // /*Now we need to calculate the number of slices in the plane's normal
          // direction, so that the entire volume is covered. This is done by first
          // calculating the dot product between the volume diagonal (the maximum
          // distance inside the volume) and the normal, and dividing this value by
          // the directed spacing calculated above.*/
<span style = "background-color:#fdd">          ScalarType directedExtent = std::abs(m_ReferenceGeometry-&gt;GetExtentInMM(0) * m_DirectionVector[0]) +</span>
                                      std::abs(m_ReferenceGeometry-&gt;GetExtentInMM(1) * m_DirectionVector[1]) +
                                      std::abs(m_ReferenceGeometry-&gt;GetExtentInMM(2) * m_DirectionVector[2]);

<span style = "background-color:#fdd">          if (directedExtent &gt;= spacing[2])</span>
          {
<span style = "background-color:#fdd">            m_Slices = static_cast&lt;unsigned int&gt;(directedExtent / spacing[2] + 0.5);
          }</span>
          else
          {
<span style = "background-color:#fdd">            m_Slices = 1;</span>
          }

<span style = "background-color:#fdd">          m_PlaneGeometries.assign(m_Slices, PlaneGeometry::Pointer(nullptr));</span>

<span style = "background-color:#fdd">          if (m_Slices &gt; 0)</span>
          {
<span style = "background-color:#fdd">            m_PlaneGeometries[0] = planeGeometry;</span>
          }

<span style = "background-color:#fdd">          m_SliceNavigationController-&gt;GetSlice()-&gt;SetSteps(m_Slices);</span>

<span style = "background-color:#fdd">          this-&gt;Modified();</span>

          // End Reinitialization

<span style = "background-color:#fdd">          if (m_SliceNavigationController)</span>
          {
<span style = "background-color:#fdd">            m_SliceNavigationController-&gt;GetSlice()-&gt;SetPos(restorePlaneOp-&gt;GetPos());
            m_SliceNavigationController-&gt;AdjustSliceStepperRange();</span>
          }
<span style = "background-color:#fdd">          BaseGeometry::ExecuteOperation(restorePlaneOp);</span>
        }
<span style = "background-color:#fdd">      }</span>
      else
      {
        // Reach through to all slices
<span style = "background-color:#fdd">        for (auto iter = m_PlaneGeometries.begin(); iter != m_PlaneGeometries.end(); ++iter)</span>
        {
<span style = "background-color:#fdd">          (*iter)-&gt;ExecuteOperation(operation);
        }</span>
      }
<span style = "background-color:#fdd">      break;</span>

    case OpAPPLYTRANSFORMMATRIX:

      // Clear all generated geometries and then transform only the first slice.
      // The other slices will be re-generated on demand

      // Save first slice
<span style = "background-color:#fdd">      geometry2D = m_PlaneGeometries[0];</span>

<span style = "background-color:#fdd">      applyMatrixOp = dynamic_cast&lt;ApplyTransformMatrixOperation *&gt;(operation);</span>

      // Apply transformation to first plane
<span style = "background-color:#fdd">      geometry2D-&gt;ExecuteOperation(applyMatrixOp);</span>

      // Generate a ApplyTransformMatrixOperation using the dataset center instead of
      // the supplied rotation center. The supplied center is instead used to adjust the
      // slice stack afterwards (see OpROTATE).
<span style = "background-color:#fdd">      center = m_ReferenceGeometry-&gt;GetCenter();</span>

      // Clear the slice stack and adjust it according to the center of
      // the dataset and the supplied rotation center (see documentation of
      // ReinitializePlanes)
<span style = "background-color:#fdd">      this-&gt;ReinitializePlanes(center, applyMatrixOp-&gt;GetReferencePoint());</span>

<span style = "background-color:#fdd">      BaseGeometry::ExecuteOperation(applyMatrixOp);
      break;</span>

    default: // let handle by base class if we don't do anything
<span style = "background-color:#fdd">      BaseGeometry::ExecuteOperation(operation);</span>
  }

<span style = "background-color:#fdd">  this-&gt;Modified();
}</span></pre>
	</body>
</html>