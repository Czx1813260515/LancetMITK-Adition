<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlaneGeometryDataToSurfaceFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlaneGeometryDataToSurfaceFilter.h"
#include "mitkAbstractTransformGeometry.h"
#include "mitkGeometry3D.h"
#include "mitkPlaneGeometry.h"
#include "mitkPlaneGeometryData.h"
#include "mitkSurface.h"

#include &lt;vtkPlaneSource.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;

#include &lt;vtkBox.h&gt;
#include &lt;vtkClipPolyData.h&gt;
#include &lt;vtkCubeSource.h&gt;
#include &lt;vtkCutter.h&gt;
#include &lt;vtkGeneralTransform.h&gt;
#include &lt;vtkPPolyDataNormals.h&gt;
#include &lt;vtkPlane.h&gt;
#include &lt;vtkStripper.h&gt;
#include &lt;vtkTextureMapToPlane.h&gt;
#include &lt;vtkTransform.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;
#include &lt;vtkTriangleFilter.h&gt;

mitk::PlaneGeometryDataToSurfaceFilter::PlaneGeometryDataToSurfaceFilter()
<span style = "background-color:#fdd">  : m_UseGeometryParametricBounds(true),
    m_XResolution(10),
    m_YResolution(10),
    m_PlaceByGeometry(false),
    m_UseBoundingBox(false)
{
  m_PlaneSource = vtkPlaneSource::New();
  m_Transform = vtkTransform::New();</span>

<span style = "background-color:#fdd">  m_CubeSource = vtkCubeSource::New();
  m_PolyDataTransformer = vtkTransformPolyDataFilter::New();</span>

<span style = "background-color:#fdd">  m_Plane = vtkPlane::New();
  m_PlaneCutter = vtkCutter::New();
  m_PlaneStripper = vtkStripper::New();
  m_PlanePolyData = vtkPolyData::New();
  m_NormalsUpdater = vtkPPolyDataNormals::New();
  m_PlaneTriangler = vtkTriangleFilter::New();
  m_TextureMapToPlane = vtkTextureMapToPlane::New();</span>

<span style = "background-color:#fdd">  m_Box = vtkBox::New();
  m_PlaneClipper = vtkClipPolyData::New();</span>

<span style = "background-color:#fdd">  m_VtkTransformPlaneFilter = vtkTransformPolyDataFilter::New();
  m_VtkTransformPlaneFilter-&gt;SetInputConnection(m_PlaneSource-&gt;GetOutputPort());
}</span>

mitk::PlaneGeometryDataToSurfaceFilter::~PlaneGeometryDataToSurfaceFilter()
<span style = "background-color:#fdd">{
  m_PlaneSource-&gt;Delete();
  m_Transform-&gt;Delete();</span>

<span style = "background-color:#fdd">  m_CubeSource-&gt;Delete();
  m_PolyDataTransformer-&gt;Delete();</span>

<span style = "background-color:#fdd">  m_Plane-&gt;Delete();
  m_PlaneCutter-&gt;Delete();
  m_PlaneStripper-&gt;Delete();
  m_PlanePolyData-&gt;Delete();
  m_NormalsUpdater-&gt;Delete();
  m_PlaneTriangler-&gt;Delete();
  m_TextureMapToPlane-&gt;Delete();</span>

<span style = "background-color:#fdd">  m_Box-&gt;Delete();
  m_PlaneClipper-&gt;Delete();</span>

<span style = "background-color:#fdd">  m_VtkTransformPlaneFilter-&gt;Delete();
}</span>

void mitk::PlaneGeometryDataToSurfaceFilter::GenerateOutputInformation()
<span style = "background-color:#fdd">{
  mitk::PlaneGeometryData::ConstPointer input = this-&gt;GetInput();
  mitk::Surface::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  if (input.IsNull() || (input-&gt;GetPlaneGeometry() == nullptr) || (input-&gt;GetPlaneGeometry()-&gt;IsValid() == false) ||</span>
      (m_UseBoundingBox &amp;&amp; (m_BoundingBox.IsNull() || (m_BoundingBox-&gt;GetDiagonalLength2() &lt; mitk::eps))))
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  Point3D origin;
  Point3D right, bottom;</span>

<span style = "background-color:#fdd">  vtkPolyData *planeSurface = nullptr;</span>

  // Does the PlaneGeometryData contain an AbstractTransformGeometry?
<span style = "background-color:#fdd">  if (auto *abstractGeometry =</span>
        dynamic_cast&lt;AbstractTransformGeometry *&gt;(input-&gt;GetPlaneGeometry()))
  {
    // In the case of an AbstractTransformGeometry (which holds a possibly
    // non-rigid transform), we proceed slightly differently: since the
    // plane can be arbitrarily deformed, we need to transform it by the
    // abstract transform before clipping it. The setup for this is partially
    // done in the constructor.
<span style = "background-color:#fdd">    origin = abstractGeometry-&gt;GetPlane()-&gt;GetOrigin();
    right = origin + abstractGeometry-&gt;GetPlane()-&gt;GetAxisVector(0);
    bottom = origin + abstractGeometry-&gt;GetPlane()-&gt;GetAxisVector(1);</span>

    // Define the plane
<span style = "background-color:#fdd">    m_PlaneSource-&gt;SetOrigin(origin[0], origin[1], origin[2]);
    m_PlaneSource-&gt;SetPoint1(right[0], right[1], right[2]);
    m_PlaneSource-&gt;SetPoint2(bottom[0], bottom[1], bottom[2]);</span>

    // Set the plane's resolution (unlike for non-deformable planes, the plane
    // grid needs to have a certain resolution so that the deformation has the
    // desired effect).
<span style = "background-color:#fdd">    if (m_UseGeometryParametricBounds)</span>
    {
<span style = "background-color:#fdd">      m_PlaneSource-&gt;SetXResolution((int)abstractGeometry-&gt;GetParametricExtent(0));
      m_PlaneSource-&gt;SetYResolution((int)abstractGeometry-&gt;GetParametricExtent(1));
    }</span>
    else
    {
<span style = "background-color:#fdd">      m_PlaneSource-&gt;SetXResolution(m_XResolution);
      m_PlaneSource-&gt;SetYResolution(m_YResolution);</span>
    }
<span style = "background-color:#fdd">    if (m_PlaceByGeometry)</span>
    {
      // Let the output use the input geometry to appropriately transform the
      // coordinate system.
<span style = "background-color:#fdd">      mitk::Geometry3D::TransformType *affineTransform = abstractGeometry-&gt;GetIndexToWorldTransform();</span>

<span style = "background-color:#fdd">      TimeGeometry *timeGeometry = output-&gt;GetTimeGeometry();
      BaseGeometry *g3d = timeGeometry-&gt;GetGeometryForTimeStep(0);
      g3d-&gt;SetIndexToWorldTransform(affineTransform);</span>

<span style = "background-color:#fdd">      vtkGeneralTransform *composedResliceTransform = vtkGeneralTransform::New();
      composedResliceTransform-&gt;Identity();
      composedResliceTransform-&gt;Concatenate(abstractGeometry-&gt;GetVtkTransform()-&gt;GetLinearInverse());
      composedResliceTransform-&gt;Concatenate(abstractGeometry-&gt;GetVtkAbstractTransform());</span>
      // Use the non-rigid transform for transforming the plane.
<span style = "background-color:#fdd">      m_VtkTransformPlaneFilter-&gt;SetTransform(composedResliceTransform);
    }</span>
    else
    {
      // Use the non-rigid transform for transforming the plane.
<span style = "background-color:#fdd">      m_VtkTransformPlaneFilter-&gt;SetTransform(abstractGeometry-&gt;GetVtkAbstractTransform());</span>
    }

<span style = "background-color:#fdd">    if (m_UseBoundingBox)</span>
    {
<span style = "background-color:#fdd">      mitk::BoundingBox::PointType boundingBoxMin = m_BoundingBox-&gt;GetMinimum();
      mitk::BoundingBox::PointType boundingBoxMax = m_BoundingBox-&gt;GetMaximum();</span>
      // mitk::BoundingBox::PointType boundingBoxCenter = m_BoundingBox-&gt;GetCenter();

<span style = "background-color:#fdd">      m_Box-&gt;SetXMin(boundingBoxMin[0], boundingBoxMin[1], boundingBoxMin[2]);
      m_Box-&gt;SetXMax(boundingBoxMax[0], boundingBoxMax[1], boundingBoxMax[2]);
    }</span>
    else
    {
      // Plane will not be clipped
<span style = "background-color:#fdd">      m_Box-&gt;SetXMin(-10000.0, -10000.0, -10000.0);
      m_Box-&gt;SetXMax(10000.0, 10000.0, 10000.0);</span>
    }

<span style = "background-color:#fdd">    m_Transform-&gt;Identity();
    m_Transform-&gt;Concatenate(input-&gt;GetPlaneGeometry()-&gt;GetVtkTransform());
    m_Transform-&gt;PreMultiply();</span>

<span style = "background-color:#fdd">    m_Box-&gt;SetTransform(m_Transform);</span>

<span style = "background-color:#fdd">    m_PlaneClipper-&gt;SetInputConnection(m_VtkTransformPlaneFilter-&gt;GetOutputPort());
    m_PlaneClipper-&gt;SetClipFunction(m_Box);
    m_PlaneClipper-&gt;GenerateClippedOutputOff(); // important to NOT generate normals data for clipped part
    m_PlaneClipper-&gt;InsideOutOn();
    m_PlaneClipper-&gt;SetValue(0.0);
    m_PlaneClipper-&gt;Update();</span>

<span style = "background-color:#fdd">    planeSurface = m_PlaneClipper-&gt;GetOutput();
  }</span>
  // Does the PlaneGeometryData contain a PlaneGeometry?
<span style = "background-color:#fdd">  else if (dynamic_cast&lt;PlaneGeometry *&gt;(input-&gt;GetPlaneGeometry()) != nullptr)</span>
  {
<span style = "background-color:#fdd">    auto *planeGeometry = dynamic_cast&lt;PlaneGeometry *&gt;(input-&gt;GetPlaneGeometry());</span>

<span style = "background-color:#fdd">    if (m_PlaceByGeometry)</span>
    {
      // Let the output use the input geometry to appropriately transform the
      // coordinate system.
<span style = "background-color:#fdd">      mitk::Geometry3D::TransformType *affineTransform = planeGeometry-&gt;GetIndexToWorldTransform();</span>

<span style = "background-color:#fdd">      TimeGeometry *timeGeometry = output-&gt;GetTimeGeometry();
      BaseGeometry *geometrie3d = timeGeometry-&gt;GetGeometryForTimeStep(0);
      geometrie3d-&gt;SetIndexToWorldTransform(affineTransform);</span>
    }

<span style = "background-color:#fdd">    if (!m_UseBoundingBox)</span>
    {
      // We do not have a bounding box, so no clipping is required.

<span style = "background-color:#fdd">      if (m_PlaceByGeometry)</span>
      {
        // Derive coordinate axes and origin from input geometry extent
<span style = "background-color:#fdd">        origin.Fill(0.0);
        FillVector3D(right, planeGeometry-&gt;GetExtent(0), 0.0, 0.0);
        FillVector3D(bottom, 0.0, planeGeometry-&gt;GetExtent(1), 0.0);
      }</span>
      else
      {
        // Take the coordinate axes and origin directly from the input geometry.
<span style = "background-color:#fdd">        origin = planeGeometry-&gt;GetOrigin();
        right = planeGeometry-&gt;GetCornerPoint(false, true);
        bottom = planeGeometry-&gt;GetCornerPoint(true, false);</span>
      }

      // Since the plane is planar, there is no need to subdivide the grid
      // (cf. AbstractTransformGeometry case)
<span style = "background-color:#fdd">      m_PlaneSource-&gt;SetXResolution(1);
      m_PlaneSource-&gt;SetYResolution(1);</span>

<span style = "background-color:#fdd">      m_PlaneSource-&gt;SetOrigin(origin[0], origin[1], origin[2]);
      m_PlaneSource-&gt;SetPoint1(right[0], right[1], right[2]);
      m_PlaneSource-&gt;SetPoint2(bottom[0], bottom[1], bottom[2]);</span>

<span style = "background-color:#fdd">      m_PlaneSource-&gt;Update();
      planeSurface = m_PlaneSource-&gt;GetOutput();
    }</span>
    else
    {
      // Set up a cube with the extent and origin of the bounding box. This
      // cube will be clipped by a plane later on. The intersection of the
      // cube and the plane will be the surface we are interested in. Note
      // that the bounding box needs to be explicitly specified by the user
      // of this class, since it is not necessarily clear from the data
      // available herein which bounding box to use. In most cases, this
      // would be the bounding box of the input geometry's reference
      // geometry, but this is not an inevitable requirement.
<span style = "background-color:#fdd">      mitk::BoundingBox::PointType boundingBoxMin = m_BoundingBox-&gt;GetMinimum();
      mitk::BoundingBox::PointType boundingBoxMax = m_BoundingBox-&gt;GetMaximum();
      mitk::BoundingBox::PointType boundingBoxCenter = m_BoundingBox-&gt;GetCenter();</span>

<span style = "background-color:#fdd">      m_CubeSource-&gt;SetXLength(boundingBoxMax[0] - boundingBoxMin[0]);
      m_CubeSource-&gt;SetYLength(boundingBoxMax[1] - boundingBoxMin[1]);
      m_CubeSource-&gt;SetZLength(boundingBoxMax[2] - boundingBoxMin[2]);
      m_CubeSource-&gt;SetCenter(boundingBoxCenter[0], boundingBoxCenter[1], boundingBoxCenter[2]);</span>

      // Now we have to transform the cube, so that it will cut our plane
      // appropriately. (As can be seen below, the plane corresponds to the
      // z-plane in the coordinate system and is *not* transformed.) Therefore,
      // we get the inverse of the plane geometry's transform and concatenate
      // it with the transform of the reference geometry, if available.
<span style = "background-color:#fdd">      m_Transform-&gt;Identity();
      m_Transform-&gt;Concatenate(planeGeometry-&gt;GetVtkTransform()-&gt;GetLinearInverse());</span>

<span style = "background-color:#fdd">      const BaseGeometry *referenceGeometry = planeGeometry-&gt;GetReferenceGeometry();
      if (referenceGeometry)</span>
      {
<span style = "background-color:#fdd">        m_Transform-&gt;Concatenate(referenceGeometry-&gt;GetVtkTransform());</span>
      }

      // Transform the cube accordingly (s.a.)
<span style = "background-color:#fdd">      m_PolyDataTransformer-&gt;SetInputConnection(m_CubeSource-&gt;GetOutputPort());
      m_PolyDataTransformer-&gt;SetTransform(m_Transform);</span>

      // Initialize the plane to clip the cube with, as lying on the z-plane
<span style = "background-color:#fdd">      m_Plane-&gt;SetOrigin(0.0, 0.0, 0.0);
      m_Plane-&gt;SetNormal(0.0, 0.0, 1.0);</span>

      // Cut the plane with the cube.
<span style = "background-color:#fdd">      m_PlaneCutter-&gt;SetInputConnection(m_PolyDataTransformer-&gt;GetOutputPort());
      m_PlaneCutter-&gt;SetCutFunction(m_Plane);</span>

      // The output of the cutter must be converted into appropriate poly data.
<span style = "background-color:#fdd">      m_PlaneStripper-&gt;SetInputConnection(m_PlaneCutter-&gt;GetOutputPort());
      m_PlaneStripper-&gt;Update();</span>

<span style = "background-color:#fdd">      if (m_PlaneStripper-&gt;GetOutput()-&gt;GetNumberOfPoints() &lt; 3)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

<span style = "background-color:#fdd">      m_PlanePolyData-&gt;SetPoints(m_PlaneStripper-&gt;GetOutput()-&gt;GetPoints());
      m_PlanePolyData-&gt;SetPolys(m_PlaneStripper-&gt;GetOutput()-&gt;GetLines());</span>

<span style = "background-color:#fdd">      m_PlaneTriangler-&gt;SetInputData(m_PlanePolyData);</span>

      // Get bounds of the resulting surface and use it to generate the texture
      // mapping information
<span style = "background-color:#fdd">      m_PlaneTriangler-&gt;Update();
      m_PlaneTriangler-&gt;GetOutput()-&gt;ComputeBounds();
      double *surfaceBounds = m_PlaneTriangler-&gt;GetOutput()-&gt;GetBounds();</span>

<span style = "background-color:#fdd">      origin[0] = surfaceBounds[0];
      origin[1] = surfaceBounds[2];
      origin[2] = surfaceBounds[4];</span>

<span style = "background-color:#fdd">      right[0] = surfaceBounds[1];
      right[1] = surfaceBounds[2];
      right[2] = surfaceBounds[4];</span>

<span style = "background-color:#fdd">      bottom[0] = surfaceBounds[0];
      bottom[1] = surfaceBounds[3];
      bottom[2] = surfaceBounds[4];</span>

      // Now we tell the data how it shall be textured afterwards;
      // description see above.
<span style = "background-color:#fdd">      m_TextureMapToPlane-&gt;SetInputConnection(m_PlaneTriangler-&gt;GetOutputPort());
      m_TextureMapToPlane-&gt;AutomaticPlaneGenerationOn();
      m_TextureMapToPlane-&gt;SetOrigin(origin[0], origin[1], origin[2]);
      m_TextureMapToPlane-&gt;SetPoint1(right[0], right[1], right[2]);
      m_TextureMapToPlane-&gt;SetPoint2(bottom[0], bottom[1], bottom[2]);</span>

      // Need to call update so that output data and bounds are immediately
      // available
<span style = "background-color:#fdd">      m_TextureMapToPlane-&gt;Update();</span>

      // Return the output of this generation process
<span style = "background-color:#fdd">      planeSurface = dynamic_cast&lt;vtkPolyData *&gt;(m_TextureMapToPlane-&gt;GetOutput());</span>
    }
  }

<span style = "background-color:#fdd">  m_NormalsUpdater-&gt;SetInputData(planeSurface);
  m_NormalsUpdater-&gt;AutoOrientNormalsOn(); // that's the trick! Brings consistency between</span>
                                           //  normals direction and front/back faces direction (see bug 1440)
<span style = "background-color:#fdd">  m_NormalsUpdater-&gt;ComputePointNormalsOn();
  m_NormalsUpdater-&gt;Update();</span>

<span style = "background-color:#fdd">  output-&gt;SetVtkPolyData(m_NormalsUpdater-&gt;GetOutput());
  output-&gt;CalculateBoundingBox();
}</span>

void mitk::PlaneGeometryDataToSurfaceFilter::GenerateData()
<span style = "background-color:#fdd">{
  mitk::Surface::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  if (output.IsNull())
    return;
  if (output-&gt;GetVtkPolyData() == nullptr)
    return;</span>

  //  output-&gt;GetVtkPolyData()-&gt;Update(); //VTK6_TODO vtk pipeline
<span style = "background-color:#fdd">}</span>

const mitk::PlaneGeometryData *mitk::PlaneGeometryDataToSurfaceFilter::GetInput()
<span style = "background-color:#fdd">{
  if (this-&gt;GetNumberOfInputs() &lt; 1)</span>
  {
<span style = "background-color:#fdd">    return nullptr;</span>
  }

<span style = "background-color:#fdd">  return static_cast&lt;const mitk::PlaneGeometryData *&gt;(this-&gt;ProcessObject::GetInput(0));
}</span>

const mitk::PlaneGeometryData *mitk::PlaneGeometryDataToSurfaceFilter::GetInput(unsigned int idx)
<span style = "background-color:#fdd">{
  return static_cast&lt;const mitk::PlaneGeometryData *&gt;(this-&gt;ProcessObject::GetInput(idx));
}</span>

void mitk::PlaneGeometryDataToSurfaceFilter::SetInput(const mitk::PlaneGeometryData *input)
<span style = "background-color:#fdd">{</span>
  // Process object is not const-correct so the const_cast is required here
<span style = "background-color:#fdd">  this-&gt;ProcessObject::SetNthInput(0, const_cast&lt;mitk::PlaneGeometryData *&gt;(input));
}</span>

void mitk::PlaneGeometryDataToSurfaceFilter::SetInput(unsigned int index, const mitk::PlaneGeometryData *input)
<span style = "background-color:#fdd">{
  if (index + 1 &gt; this-&gt;GetNumberOfInputs())</span>
  {
<span style = "background-color:#fdd">    this-&gt;SetNumberOfRequiredInputs(index + 1);</span>
  }
  // Process object is not const-correct so the const_cast is required here
<span style = "background-color:#fdd">  this-&gt;ProcessObject::SetNthInput(index, const_cast&lt;mitk::PlaneGeometryData *&gt;(input));
}</span>

void mitk::PlaneGeometryDataToSurfaceFilter::SetBoundingBox(const mitk::BoundingBox *boundingBox)
<span style = "background-color:#fdd">{
  m_BoundingBox = boundingBox;
  this-&gt;UseBoundingBoxOn();
}</span>

const mitk::BoundingBox *mitk::PlaneGeometryDataToSurfaceFilter::GetBoundingBox() const
<span style = "background-color:#fdd">{
  return m_BoundingBox.GetPointer();
}</span></pre>
	</body>
</html>