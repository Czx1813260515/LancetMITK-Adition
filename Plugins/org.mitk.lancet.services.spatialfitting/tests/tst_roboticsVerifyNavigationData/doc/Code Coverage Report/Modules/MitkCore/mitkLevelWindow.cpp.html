<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkLevelWindow.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkLevelWindow.h"
#include "mitkImage.h"
#include "mitkImageSliceSelector.h"
#include "mitkImageStatisticsHolder.h"

#include &lt;algorithm&gt;

void mitk::LevelWindow::EnsureConsistency()
<span style = "background-color:#fdd">{</span>
  // Check if total range is ok
  {
<span style = "background-color:#fdd">    if (m_RangeMin &gt; m_RangeMax)
      std::swap(m_RangeMin, m_RangeMax);
    if (m_RangeMin == m_RangeMax)
      m_RangeMin = m_RangeMax - 1;</span>
  }

  // Check if current window is ok
  {
<span style = "background-color:#fdd">    if (m_LowerWindowBound &gt; m_UpperWindowBound)
      std::swap(m_LowerWindowBound, m_UpperWindowBound);</span>

<span style = "background-color:#fdd">    if (m_LowerWindowBound &lt;= m_RangeMin)
      m_LowerWindowBound = m_RangeMin;
    if (m_UpperWindowBound &lt;= m_RangeMin)
      m_UpperWindowBound = m_RangeMin + 1;
    if (m_LowerWindowBound &gt;= m_RangeMax)
      m_LowerWindowBound = m_RangeMax - 1;
    if (m_UpperWindowBound &gt;= m_RangeMax)
      m_UpperWindowBound = m_RangeMax;</span>

<span style = "background-color:#fdd">    if (m_LowerWindowBound == m_UpperWindowBound)</span>
    {
<span style = "background-color:#fdd">      m_UpperWindowBound += 0.5;
      m_LowerWindowBound -= 0.5;</span>

<span style = "background-color:#fdd">      m_UpperWindowBound = std::min(m_UpperWindowBound, m_RangeMax);
      m_LowerWindowBound = std::max(m_LowerWindowBound, m_RangeMin);</span>
    }
  }
<span style = "background-color:#fdd">}</span>

mitk::LevelWindow::LevelWindow(mitk::ScalarType level, mitk::ScalarType window)
<span style = "background-color:#fdd">  : m_LowerWindowBound(level - window / 2.0),
    m_UpperWindowBound(level + window / 2.0),
    m_RangeMin(-2048.0),
    m_RangeMax(4096.0),
    m_DefaultLowerBound(-2048.0),
    m_DefaultUpperBound(4096.0),
    m_IsFloatingImage(false),
    m_Fixed(false)
{
  SetDefaultLevelWindow(level, window);
  SetLevelWindow(level, window, true);
}</span>

mitk::LevelWindow::LevelWindow(const mitk::LevelWindow &amp;levWin)
<span style = "background-color:#fdd">  : m_LowerWindowBound(levWin.GetLowerWindowBound()),
    m_UpperWindowBound(levWin.GetUpperWindowBound()),
    m_RangeMin(levWin.GetRangeMin()),
    m_RangeMax(levWin.GetRangeMax()),
    m_DefaultLowerBound(levWin.GetDefaultLowerBound()),
    m_DefaultUpperBound(levWin.GetDefaultUpperBound()),
    m_IsFloatingImage(levWin.IsFloatingValues()),
    m_Fixed(levWin.GetFixed())
{
}</span>

mitk::LevelWindow::~LevelWindow()
<span style = "background-color:#fdd">{
}</span>

mitk::ScalarType mitk::LevelWindow::GetLevel() const
<span style = "background-color:#fdd">{
  return (m_UpperWindowBound - m_LowerWindowBound) / 2.0 + m_LowerWindowBound;
}</span>

mitk::ScalarType mitk::LevelWindow::GetWindow() const
<span style = "background-color:#fdd">{
  return (m_UpperWindowBound - m_LowerWindowBound);
}</span>

mitk::ScalarType mitk::LevelWindow::GetDefaultLevel() const
<span style = "background-color:#fdd">{
  return ((m_DefaultUpperBound + m_DefaultLowerBound) / 2.0);
}</span>

mitk::ScalarType mitk::LevelWindow::GetDefaultWindow() const
<span style = "background-color:#fdd">{
  return ((m_DefaultUpperBound - m_DefaultLowerBound));
}</span>

void mitk::LevelWindow::ResetDefaultLevelWindow()
<span style = "background-color:#fdd">{
  SetLevelWindow(GetDefaultLevel(), GetDefaultWindow());
}</span>

mitk::ScalarType mitk::LevelWindow::GetLowerWindowBound() const
<span style = "background-color:#fdd">{
  return m_LowerWindowBound;
}</span>

mitk::ScalarType mitk::LevelWindow::GetUpperWindowBound() const
<span style = "background-color:#fdd">{
  return m_UpperWindowBound;
}</span>

void mitk::LevelWindow::SetDefaultLevelWindow(mitk::ScalarType level, mitk::ScalarType window)
<span style = "background-color:#fdd">{
  SetDefaultBoundaries((level - (window / 2.0)), (level + (window / 2.0)));
}</span>

void mitk::LevelWindow::SetLevelWindow(mitk::ScalarType level, mitk::ScalarType window, bool expandRangesIfNecessary)
<span style = "background-color:#fdd">{
  SetWindowBounds((level - (window / 2.0)), (level + (window / 2.0)), expandRangesIfNecessary);
}</span>

void mitk::LevelWindow::SetWindowBounds(mitk::ScalarType lowerBound,
                                        mitk::ScalarType upperBound,
                                        bool expandRangesIfNecessary)
<span style = "background-color:#fdd">{
  if (IsFixed())
    return;</span>

<span style = "background-color:#fdd">  m_LowerWindowBound = lowerBound;
  m_UpperWindowBound = upperBound;</span>

<span style = "background-color:#fdd">  if (expandRangesIfNecessary)</span>
  {
    /* if caller is sure he wants exactly that level/window, we make sure the limits match */
<span style = "background-color:#fdd">    if (m_LowerWindowBound &gt; m_UpperWindowBound)
      std::swap(m_LowerWindowBound, m_UpperWindowBound);
    if (m_LowerWindowBound &lt; m_RangeMin)</span>
    {
<span style = "background-color:#fdd">      m_RangeMin = m_LowerWindowBound;</span>
    }

<span style = "background-color:#fdd">    if (m_UpperWindowBound &gt; m_RangeMax)</span>
    {
<span style = "background-color:#fdd">      m_RangeMax = m_UpperWindowBound;</span>
    }
  }

<span style = "background-color:#fdd">  EnsureConsistency();
}</span>

void mitk::LevelWindow::SetRangeMinMax(mitk::ScalarType min, mitk::ScalarType max)
<span style = "background-color:#fdd">{
  if (IsFixed())
    return;
  m_RangeMin = min;
  m_RangeMax = max;
  EnsureConsistency();
}</span>

void mitk::LevelWindow::SetDefaultBoundaries(mitk::ScalarType low, mitk::ScalarType up)
<span style = "background-color:#fdd">{
  if (IsFixed())
    return;
  m_DefaultLowerBound = low;
  m_DefaultUpperBound = up;</span>
  // Check if default window is ok
  {
<span style = "background-color:#fdd">    if (m_DefaultLowerBound &gt; m_DefaultUpperBound)
      std::swap(m_DefaultLowerBound, m_DefaultUpperBound);</span>

<span style = "background-color:#fdd">    if (m_DefaultLowerBound == m_DefaultUpperBound)
      m_DefaultLowerBound--;</span>
  }
<span style = "background-color:#fdd">  EnsureConsistency();
}</span>

void mitk::LevelWindow::SetToMaxWindowSize()
<span style = "background-color:#fdd">{
  SetWindowBounds(m_RangeMin, m_RangeMax);
}</span>

mitk::ScalarType mitk::LevelWindow::GetRangeMin() const
<span style = "background-color:#fdd">{
  return m_RangeMin;
}</span>

mitk::ScalarType mitk::LevelWindow::GetRangeMax() const
<span style = "background-color:#fdd">{
  return m_RangeMax;
}</span>

mitk::ScalarType mitk::LevelWindow::GetRange() const
<span style = "background-color:#fdd">{
  return m_RangeMax - m_RangeMin;
}</span>

mitk::ScalarType mitk::LevelWindow::GetDefaultUpperBound() const
<span style = "background-color:#fdd">{
  return m_DefaultUpperBound;
}</span>

mitk::ScalarType mitk::LevelWindow::GetDefaultLowerBound() const
<span style = "background-color:#fdd">{
  return m_DefaultLowerBound;
}</span>

void mitk::LevelWindow::ResetDefaultRangeMinMax()
<span style = "background-color:#fdd">{
  SetRangeMinMax(m_DefaultLowerBound, m_DefaultUpperBound);
}</span>

/*!
This method initializes a mitk::LevelWindow from an mitk::Image. The algorithm is as follows:

Default to taking the central image slice for quick analysis.

Compute the smallest (minValue), second smallest (min2ndValue), second largest (max2ndValue), and
largest (maxValue) data value by traversing the pixel values only once. In the
same scan it also computes the count of minValue values and maxValue values.
After that a basic histogram with specific information about the
extrems is complete.

If minValue == maxValue, the center slice is uniform and the above scan is repeated for
the complete image, not just one slice

Next, special cases of images with only 1, 2 or 3 distinct data values
have hand assigned level window ranges.

Next the level window is set relative to the inner range IR = lengthOf([min2ndValue, max2ndValue])

For count(minValue) &gt; 20% the smallest values are frequent and should be
distinct from the min2ndValue and larger values (minValue may be std:min, may signify
something special) hence the lower end of the level window is set to min2ndValue - 0.5 * IR

For count(minValue) &lt;= 20% the smallest values are not so important and can
blend with the next ones =&gt; min(level window) = min2ndValue

And analog for max(level window):
count(max2ndValue) &gt; 20%:  max(level window) = max2ndValue + 0.5 * IR
count(max2ndValue) &lt; 20%:  max(level window) = max2ndValue

In both 20%+ cases the level window bounds are clamped to the [minValue, maxValue] range

In consequence the level window maximizes contrast with minimal amount of
computation and does do useful things if the data contains std::min or
std:max values or has only 1 or 2 or 3 data values.
*/
void mitk::LevelWindow::SetAuto(const mitk::Image *image,
                                bool /*tryPicTags*/,
                                bool guessByCentralSlice,
                                unsigned selectedComponent)
<span style = "background-color:#fdd">{
  if (IsFixed())
    return;</span>

<span style = "background-color:#fdd">  if (image == nullptr || !image-&gt;IsInitialized())
    return;</span>

  if (itk::IOComponentEnum::FLOAT == image-&gt;GetPixelType().GetComponentType()
<span style = "background-color:#fdd">  ||  itk::IOComponentEnum::DOUBLE == image-&gt;GetPixelType().GetComponentType())</span>
  {
<span style = "background-color:#fdd">    m_IsFloatingImage = true;
  }</span>
  else
  {
<span style = "background-color:#fdd">    m_IsFloatingImage = false;</span>
  }

<span style = "background-color:#fdd">  const mitk::Image *wholeImage = image;
  ScalarType minValue = 0.0;
  ScalarType maxValue = 0.0;
  ScalarType min2ndValue = 0.0;
  ScalarType max2ndValue = 0.0;
  mitk::ImageSliceSelector::Pointer sliceSelector = mitk::ImageSliceSelector::New();
  if (guessByCentralSlice)</span>
  {
<span style = "background-color:#fdd">    sliceSelector-&gt;SetInput(image);
    sliceSelector-&gt;SetSliceNr(image-&gt;GetDimension(2) / 2);
    sliceSelector-&gt;SetTimeNr(image-&gt;GetDimension(3) / 2);
    sliceSelector-&gt;SetChannelNr(image-&gt;GetDimension(4) / 2);
    sliceSelector-&gt;Update();
    image = sliceSelector-&gt;GetOutput();
    if (image == nullptr || !image-&gt;IsInitialized())
      return;</span>

<span style = "background-color:#fdd">    minValue = image-&gt;GetStatistics()-&gt;GetScalarValueMin(0, selectedComponent);
    maxValue = image-&gt;GetStatistics()-&gt;GetScalarValueMaxNoRecompute();
    min2ndValue = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMinNoRecompute();
    max2ndValue = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMaxNoRecompute();
    if (minValue == maxValue)</span>
    {
      // guessByCentralSlice seems to have failed, lets look at all data
<span style = "background-color:#fdd">      image = wholeImage;
      minValue = image-&gt;GetStatistics()-&gt;GetScalarValueMin(0, selectedComponent);
      maxValue = image-&gt;GetStatistics()-&gt;GetScalarValueMaxNoRecompute();
      min2ndValue = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMinNoRecompute();
      max2ndValue = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMaxNoRecompute();</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    const_cast&lt;Image *&gt;(image)-&gt;Update();
    minValue = image-&gt;GetStatistics()-&gt;GetScalarValueMin(0, selectedComponent);
    maxValue = image-&gt;GetStatistics()-&gt;GetScalarValueMaxNoRecompute(0);
    min2ndValue = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMinNoRecompute(0);
    max2ndValue = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMaxNoRecompute(0);
    for (unsigned int i = 1; i &lt; image-&gt;GetDimension(3); ++i)</span>
    {
<span style = "background-color:#fdd">      ScalarType minValueTemp = image-&gt;GetStatistics()-&gt;GetScalarValueMin(i, selectedComponent);
      if (minValue &gt; minValueTemp)
        minValue = minValueTemp;
      ScalarType maxValueTemp = image-&gt;GetStatistics()-&gt;GetScalarValueMaxNoRecompute(i);
      if (maxValue &lt; maxValueTemp)
        maxValue = maxValueTemp;
      ScalarType min2ndValueTemp = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMinNoRecompute(i);
      if (min2ndValue &gt; min2ndValueTemp)
        min2ndValue = min2ndValueTemp;
      ScalarType max2ndValueTemp = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMaxNoRecompute(i);
      if (max2ndValue &gt; max2ndValueTemp)
        max2ndValue = max2ndValueTemp;
    }</span>
  }

  // Fix for bug# 344 Level Window wird bei Eris Cut bildern nicht richtig gesetzt
  if (image-&gt;GetPixelType().GetPixelType() == itk::IOPixelEnum::SCALAR &amp;&amp;
<span style = "background-color:#fdd">      image-&gt;GetPixelType().GetComponentType() == itk::IOComponentEnum::INT &amp;&amp; image-&gt;GetPixelType().GetBpe() &gt;= 8)</span>
  {
    // the windows compiler complains about ambiguos 'pow' call, therefore static casting to (double, int)
<span style = "background-color:#fdd">    if (minValue == -(pow((double)2.0, static_cast&lt;int&gt;(image-&gt;GetPixelType().GetBpe() / 2))))</span>
    {
<span style = "background-color:#fdd">      minValue = min2ndValue;</span>
    }
  }
  // End fix

  //// uniform image
<span style = "background-color:#fdd">  if (minValue == maxValue)</span>
  {
<span style = "background-color:#fdd">    minValue = maxValue - 1;
  }</span>
  else
  {
    // Due to bug #8690 level window now is no longer of fixed range by default but the range adapts according to
    // levelwindow interaction
    // This is done because the range should be a little bit larger from the beginning so that the scale doesn't start
    // to resize right from the beginning
<span style = "background-color:#fdd">    double additionalRange = 0.15 * (maxValue - minValue);
    minValue -= additionalRange;
    maxValue += additionalRange;</span>
  }

<span style = "background-color:#fdd">  if (!std::isfinite(minValue))</span>
  {
<span style = "background-color:#fdd">    minValue = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMinNoRecompute(0);</span>
  }
<span style = "background-color:#fdd">  if (!std::isfinite(maxValue))</span>
  {
<span style = "background-color:#fdd">    maxValue = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMaxNoRecompute(0);</span>
  }

<span style = "background-color:#fdd">  SetRangeMinMax(minValue, maxValue);
  SetDefaultBoundaries(minValue, maxValue);</span>

<span style = "background-color:#fdd">  size_t numPixelsInDataset = image-&gt;GetDimensions()[0];
  for (decltype(image-&gt;GetDimension()) k = 1; k &lt; image-&gt;GetDimension(); ++k)
    numPixelsInDataset *= image-&gt;GetDimensions()[k];
  const auto minCount = image-&gt;GetStatistics()-&gt;GetCountOfMinValuedVoxelsNoRecompute();
  const auto maxCount = image-&gt;GetStatistics()-&gt;GetCountOfMaxValuedVoxelsNoRecompute();
  const auto minCountFraction = minCount / static_cast&lt;ScalarType&gt;(numPixelsInDataset);
  const auto maxCountFraction = maxCount / static_cast&lt;ScalarType&gt;(numPixelsInDataset);</span>

  //// binary image
<span style = "background-color:#fdd">  if (min2ndValue == maxValue)</span>
  {
    // noop; full range is fine
<span style = "background-color:#fdd">  }</span>

  //// triple value image, put middle value in center of gray level ramp
<span style = "background-color:#fdd">  else if (min2ndValue == max2ndValue)</span>
  {
<span style = "background-color:#fdd">    ScalarType minDelta = std::min(min2ndValue - minValue, maxValue - min2ndValue);
    minValue = min2ndValue - minDelta;
    maxValue = min2ndValue + minDelta;
  }</span>

  // now we can assume more than three distict scalar values
  else
  {
<span style = "background-color:#fdd">    ScalarType innerRange = max2ndValue - min2ndValue;</span>

<span style = "background-color:#fdd">    if (minCountFraction &gt; 0.2) //// lots of min values -&gt; make different from rest, but not miles away</span>
    {
<span style = "background-color:#fdd">      ScalarType halfInnerRangeGapMinValue = min2ndValue - innerRange / 2.0;
      minValue = std::max(minValue, halfInnerRangeGapMinValue);
    }</span>
    else //// few min values -&gt; focus on innerRange
    {
<span style = "background-color:#fdd">      minValue = min2ndValue;</span>
    }

<span style = "background-color:#fdd">    if (maxCountFraction &gt; 0.2) //// lots of max values -&gt; make different from rest</span>
    {
<span style = "background-color:#fdd">      ScalarType halfInnerRangeGapMaxValue = max2ndValue + innerRange / 2.0;
      maxValue = std::min(maxValue, halfInnerRangeGapMaxValue);
    }</span>
    else //// few max values -&gt; focus on innerRange
    {
<span style = "background-color:#fdd">      maxValue = max2ndValue;</span>
    }
  }
<span style = "background-color:#fdd">  SetWindowBounds(minValue, maxValue);
  SetDefaultLevelWindow((maxValue - minValue) / 2 + minValue, maxValue - minValue);
}</span>

void mitk::LevelWindow::SetToImageRange(const mitk::Image *image)
<span style = "background-color:#fdd">{
  if (IsFixed())
    return;</span>

<span style = "background-color:#fdd">  if (image == nullptr || !image-&gt;IsInitialized())
    return;</span>

<span style = "background-color:#fdd">  ScalarType minValue = image-&gt;GetStatistics()-&gt;GetScalarValueMin(0);
  if (!std::isfinite(minValue))</span>
  {
<span style = "background-color:#fdd">    minValue = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMinNoRecompute(0);</span>
  }
<span style = "background-color:#fdd">  ScalarType maxValue = image-&gt;GetStatistics()-&gt;GetScalarValueMaxNoRecompute(0);
  if (!std::isfinite(maxValue))</span>
  {
<span style = "background-color:#fdd">    maxValue = image-&gt;GetStatistics()-&gt;GetScalarValue2ndMaxNoRecompute(0);</span>
  }

<span style = "background-color:#fdd">  SetRangeMinMax(minValue, maxValue);
  SetDefaultBoundaries(minValue, maxValue);
  SetWindowBounds(minValue, maxValue);
  SetDefaultLevelWindow((maxValue - minValue) / 2 + minValue, maxValue - minValue);
}</span>

void mitk::LevelWindow::SetFixed(bool fixed)
<span style = "background-color:#fdd">{
  m_Fixed = fixed;
}</span>

bool mitk::LevelWindow::GetFixed() const
<span style = "background-color:#fdd">{
  return m_Fixed;
}</span>

bool mitk::LevelWindow::IsFixed() const
<span style = "background-color:#fdd">{
  return m_Fixed;
}</span>

bool mitk::LevelWindow::IsFloatingValues() const
<span style = "background-color:#fdd">{
  return m_IsFloatingImage;
}</span>

void mitk::LevelWindow::SetFloatingValues(bool value)
<span style = "background-color:#fdd">{
  m_IsFloatingImage = value;
}</span>

bool mitk::LevelWindow::operator==(const mitk::LevelWindow &amp;levWin) const
<span style = "background-color:#fdd">{
  return mitk::Equal(this-&gt;m_RangeMin, levWin.m_RangeMin, mitk::sqrteps) &amp;&amp;</span>
         mitk::Equal(this-&gt;m_RangeMax, levWin.m_RangeMax, mitk::sqrteps) &amp;&amp;
         mitk::Equal(this-&gt;m_DefaultLowerBound, levWin.m_DefaultLowerBound, mitk::sqrteps) &amp;&amp;
         mitk::Equal(this-&gt;m_DefaultUpperBound, levWin.m_DefaultUpperBound, mitk::sqrteps) &amp;&amp;
         mitk::Equal(this-&gt;m_LowerWindowBound, levWin.m_LowerWindowBound, mitk::sqrteps) &amp;&amp;
         mitk::Equal(this-&gt;m_UpperWindowBound, levWin.m_UpperWindowBound, mitk::sqrteps) &amp;&amp;
         m_Fixed == levWin.IsFixed() &amp;&amp; m_IsFloatingImage == levWin.IsFloatingValues();
<span style = "background-color:#fdd">}</span>

bool mitk::LevelWindow::operator!=(const mitk::LevelWindow &amp;levWin) const
<span style = "background-color:#fdd">{
  return !((*this) == levWin);
}</span>

mitk::LevelWindow &amp;mitk::LevelWindow::operator=(const mitk::LevelWindow &amp;levWin)
<span style = "background-color:#fdd">{
  if (this == &amp;levWin)</span>
  {
<span style = "background-color:#fdd">    return *this;
  }</span>
  else
  {
<span style = "background-color:#fdd">    m_RangeMin = levWin.GetRangeMin();
    m_RangeMax = levWin.GetRangeMax();
    m_LowerWindowBound = levWin.GetLowerWindowBound();
    m_UpperWindowBound = levWin.GetUpperWindowBound();
    m_DefaultLowerBound = levWin.GetDefaultLowerBound();
    m_DefaultUpperBound = levWin.GetDefaultUpperBound();
    m_Fixed = levWin.GetFixed();
    m_IsFloatingImage = levWin.IsFloatingValues();
    return *this;</span>
  }
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>