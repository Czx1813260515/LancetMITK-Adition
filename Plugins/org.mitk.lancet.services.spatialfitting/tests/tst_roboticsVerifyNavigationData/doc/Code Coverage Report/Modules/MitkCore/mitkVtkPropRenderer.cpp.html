<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkVtkPropRenderer.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkVtkPropRenderer.h"

// MAPPERS
#include "mitkCameraController.h"
#include "mitkImageVtkMapper2D.h"
#include "mitkMapper.h"
#include "mitkPlaneGeometryDataVtkMapper3D.h"
#include "mitkVtkMapper.h"

#include &lt;mitkAbstractTransformGeometry.h&gt;
#include &lt;mitkGeometry3D.h&gt;
#include &lt;mitkImageSliceSelector.h&gt;
#include &lt;mitkLevelWindow.h&gt;
#include &lt;mitkNodePredicateDataType.h&gt;
#include &lt;mitkPlaneGeometry.h&gt;
#include &lt;mitkProperties.h&gt;
#include &lt;mitkRenderingManager.h&gt;
#include &lt;mitkSurface.h&gt;
#include &lt;mitkVtkInteractorStyle.h&gt;

// VTK
#include &lt;vtkAssemblyNode.h&gt;
#include &lt;vtkAssemblyPath.h&gt;
#include &lt;vtkCamera.h&gt;
#include &lt;vtkCellPicker.h&gt;
#include &lt;vtkInteractorStyleTrackballCamera.h&gt;
#include &lt;vtkInformation.h&gt;
#include &lt;vtkLight.h&gt;
#include &lt;vtkLightKit.h&gt;
#include &lt;vtkLinearTransform.h&gt;
#include &lt;vtkMapper.h&gt;
#include &lt;vtkPointPicker.h&gt;
#include &lt;vtkProp.h&gt;
#include &lt;vtkRenderWindow.h&gt;
#include &lt;vtkRenderWindowInteractor.h&gt;
#include &lt;vtkRenderer.h&gt;
#include &lt;vtkRendererCollection.h&gt;
#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkTextActor.h&gt;
#include &lt;vtkTextProperty.h&gt;
#include &lt;vtkTransform.h&gt;
#include &lt;vtkWorldPointPicker.h&gt;

mitk::VtkPropRenderer::VtkPropRenderer(const char *name, vtkRenderWindow *renWin)
<span style = "background-color:#fdd">  : BaseRenderer(name, renWin),
    m_CameraInitializedForMapperID(0)
{
  didCount = false;</span>

<span style = "background-color:#fdd">  m_WorldPointPicker = vtkWorldPointPicker::New();</span>

<span style = "background-color:#fdd">  m_PointPicker = vtkPointPicker::New();
  m_PointPicker-&gt;SetTolerance(0.0025);</span>

<span style = "background-color:#fdd">  m_CellPicker = vtkCellPicker::New();
  m_CellPicker-&gt;SetTolerance(0.0025);</span>

<span style = "background-color:#fdd">  mitk::PlaneGeometryDataVtkMapper3D::Pointer geometryMapper = mitk::PlaneGeometryDataVtkMapper3D::New();
  m_CurrentWorldPlaneGeometryMapper = geometryMapper;
  m_CurrentWorldPlaneGeometryNode-&gt;SetMapper(2, geometryMapper);</span>

<span style = "background-color:#fdd">  m_LightKit = vtkLightKit::New();
  m_LightKit-&gt;AddLightsToRenderer(m_VtkRenderer);
  m_PickingMode = WorldPointPicking;</span>

<span style = "background-color:#fdd">  m_TextRenderer = vtkRenderer::New();
  m_TextRenderer-&gt;SetRenderWindow(renWin);
  m_TextRenderer-&gt;SetInteractive(0);
  m_TextRenderer-&gt;SetErase(0);
}</span>

/*!
\brief Destructs the VtkPropRenderer.
*/
mitk::VtkPropRenderer::~VtkPropRenderer()
<span style = "background-color:#fdd">{</span>
  // Workaround for GLDisplayList Bug
  {
<span style = "background-color:#fdd">    m_MapperID = 0;
    checkState();</span>
  }

<span style = "background-color:#fdd">  if (m_LightKit != nullptr)
    m_LightKit-&gt;Delete();</span>

<span style = "background-color:#fdd">  if (m_VtkRenderer != nullptr)</span>
  {
<span style = "background-color:#fdd">    m_CameraController = nullptr;</span>

<span style = "background-color:#fdd">    m_VtkRenderer-&gt;Delete();</span>

<span style = "background-color:#fdd">    m_VtkRenderer = nullptr;
  }</span>
  else
<span style = "background-color:#fdd">    m_CameraController = nullptr;</span>

<span style = "background-color:#fdd">  if (m_WorldPointPicker != nullptr)
    m_WorldPointPicker-&gt;Delete();
  if (m_PointPicker != nullptr)
    m_PointPicker-&gt;Delete();
  if (m_CellPicker != nullptr)
    m_CellPicker-&gt;Delete();
  if (m_TextRenderer != nullptr)
    m_TextRenderer-&gt;Delete();
}</span>

void mitk::VtkPropRenderer::SetDataStorage(mitk::DataStorage *storage)
<span style = "background-color:#fdd">{
  if (storage == nullptr || storage == m_DataStorage)
    return;</span>

<span style = "background-color:#fdd">  BaseRenderer::SetDataStorage(storage);</span>

<span style = "background-color:#fdd">  static_cast&lt;mitk::PlaneGeometryDataVtkMapper3D *&gt;(m_CurrentWorldPlaneGeometryMapper.GetPointer())</span>
    -&gt;SetDataStorageForTexture(m_DataStorage.GetPointer());

  // Compute the geometry from the current data tree bounds and set it as world geometry
<span style = "background-color:#fdd">  this-&gt;SetWorldGeometryToDataStorageBounds();
}</span>

bool mitk::VtkPropRenderer::SetWorldGeometryToDataStorageBounds()
<span style = "background-color:#fdd">{
  if (m_DataStorage.IsNull())
    return false;</span>

  // initialize world geometry
<span style = "background-color:#fdd">  auto geometry = m_DataStorage-&gt;ComputeVisibleBoundingGeometry3D(nullptr, "includeInBoundingBox");</span>

<span style = "background-color:#fdd">  if (geometry.IsNull())
    return false;</span>

<span style = "background-color:#fdd">  this-&gt;SetWorldTimeGeometry(geometry);
  this-&gt;GetVtkRenderer()-&gt;ResetCamera();
  this-&gt;GetCameraController()-&gt;Fit();
  this-&gt;Modified();
  return true;
}</span>

/*!
\brief

Called by the vtkMitkRenderProp in order to start MITK rendering process.
*/
int mitk::VtkPropRenderer::Render(mitk::VtkPropRenderer::RenderType type)
<span style = "background-color:#fdd">{</span>
  // Do we have objects to render?
<span style = "background-color:#fdd">  if (this-&gt;GetEmptyWorldGeometry())
    return 0;</span>

<span style = "background-color:#fdd">  if (m_DataStorage.IsNull())
    return 0;</span>

  // Update mappers and prepare mapper queue
<span style = "background-color:#fdd">  if (type == VtkPropRenderer::Opaque)</span>
  {
<span style = "background-color:#fdd">    this-&gt;PrepareMapperQueue();</span>
    // Share vtkInformation, there might be new mappers
<span style = "background-color:#fdd">    this-&gt;PropagateRenderInfoToMappers();</span>
  }

  // go through the generated list and let the sorted mappers paint
<span style = "background-color:#fdd">  for (auto it = m_MappersMap.cbegin(); it != m_MappersMap.cend(); it++)</span>
  {
<span style = "background-color:#fdd">    Mapper *mapper = (*it).second;
    mapper-&gt;MitkRender(this, type);
  }</span>

  // Render text
<span style = "background-color:#fdd">  if (type == VtkPropRenderer::Overlay)</span>
  {
<span style = "background-color:#fdd">    if (m_TextCollection.size() &gt; 0)</span>
    {
<span style = "background-color:#fdd">      m_TextRenderer-&gt;SetViewport(this-&gt;GetVtkRenderer()-&gt;GetViewport());
      for (auto it = m_TextCollection.begin(); it != m_TextCollection.end(); ++it)
        m_TextRenderer-&gt;AddViewProp((*it).second);
      m_TextRenderer-&gt;Render();</span>
    }
  }
<span style = "background-color:#fdd">  return 1;
}</span>

/*!
\brief PrepareMapperQueue iterates the datatree

PrepareMapperQueue iterates the datatree in order to find mappers which shall be rendered. Also, it sortes the mappers
wrt to their layer.
*/
void mitk::VtkPropRenderer::PrepareMapperQueue()
<span style = "background-color:#fdd">{</span>
  // variable for counting LOD-enabled mappers
<span style = "background-color:#fdd">  m_NumberOfVisibleLODEnabledMappers = 0;</span>

  // Do we have to update the mappers ?
<span style = "background-color:#fdd">  if (m_LastUpdateTime &lt; GetMTime() || m_LastUpdateTime &lt; this-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetMTime())</span>
  {
<span style = "background-color:#fdd">    Update();
  }
  else if (m_MapperID &gt;= 1 &amp;&amp; m_MapperID &lt; 6)
    Update();</span>

  // remove all text properties before mappers will add new ones
<span style = "background-color:#fdd">  m_TextRenderer-&gt;RemoveAllViewProps();</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; m_TextCollection.size(); i++)</span>
  {
<span style = "background-color:#fdd">    m_TextCollection[i]-&gt;Delete();
  }
  m_TextCollection.clear();</span>

  // clear priority_queue
<span style = "background-color:#fdd">  m_MappersMap.clear();</span>

<span style = "background-color:#fdd">  int mapperNo = 0;</span>

  // DataStorage
<span style = "background-color:#fdd">  if (m_DataStorage.IsNull())
    return;</span>

<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer allObjects = m_DataStorage-&gt;GetAll();</span>

<span style = "background-color:#fdd">  for (DataStorage::SetOfObjects::ConstIterator it = allObjects-&gt;Begin(); it != allObjects-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    const DataNode::Pointer node = it-&gt;Value();
    if (node.IsNull())
      continue;
    const mitk::Mapper::Pointer mapper = node-&gt;GetMapper(m_MapperID);</span>

<span style = "background-color:#fdd">    if (mapper.IsNull())
      continue;</span>

<span style = "background-color:#fdd">    bool visible = true;
    node-&gt;GetVisibility(visible, this, "visible");</span>

    // The information about LOD-enabled mappers is required by RenderingManager
<span style = "background-color:#fdd">    if (mapper-&gt;IsLODEnabled(this) &amp;&amp; visible)</span>
    {
<span style = "background-color:#fdd">      ++m_NumberOfVisibleLODEnabledMappers;</span>
    }
    // mapper without a layer property get layer number 1
<span style = "background-color:#fdd">    int layer = 1;
    node-&gt;GetIntProperty("layer", layer, this);
    int nr = (layer &lt;&lt; 16) + mapperNo;
    m_MappersMap.insert(std::pair&lt;int, Mapper *&gt;(nr, mapper));
    mapperNo++;
  }
}</span>

void mitk::VtkPropRenderer::SetPropertyKeys(vtkInformation *info)
<span style = "background-color:#fdd">{
  if (info == m_VtkRenderInfo)
    return;</span>

<span style = "background-color:#fdd">  m_VtkRenderInfo = info;
  this-&gt;PropagateRenderInfoToMappers();
}</span>

void mitk::VtkPropRenderer::PropagateRenderInfoToMappers()
<span style = "background-color:#fdd">{
  if (m_VtkRenderInfo == nullptr)
    return;</span>

<span style = "background-color:#fdd">  for (const auto &amp;mapEntry : m_MappersMap)</span>
  {
<span style = "background-color:#fdd">    auto vtkMapper = dynamic_cast&lt;mitk::VtkMapper*&gt;(mapEntry.second);</span>

<span style = "background-color:#fdd">    if (nullptr != vtkMapper)</span>
    {
<span style = "background-color:#fdd">      auto prop = vtkMapper-&gt;GetVtkProp(this);</span>

<span style = "background-color:#fdd">      if (nullptr != prop)
        prop-&gt;SetPropertyKeys(m_VtkRenderInfo);</span>
    }
<span style = "background-color:#fdd">  }
}</span>

void mitk::VtkPropRenderer::Update(mitk::DataNode *datatreenode)
<span style = "background-color:#fdd">{
  if (datatreenode != nullptr)</span>
  {
<span style = "background-color:#fdd">    mitk::Mapper::Pointer mapper = datatreenode-&gt;GetMapper(m_MapperID);
    if (mapper.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      if (GetCurrentWorldPlaneGeometry()-&gt;IsValid())</span>
      {
<span style = "background-color:#fdd">        mapper-&gt;Update(this);</span>
        {
<span style = "background-color:#fdd">          auto *vtkmapper = dynamic_cast&lt;VtkMapper *&gt;(mapper.GetPointer());
          if (vtkmapper != nullptr)</span>
          {
<span style = "background-color:#fdd">            vtkmapper-&gt;UpdateVtkTransform(this);</span>
          }
        }
      }
    }
<span style = "background-color:#fdd">  }
}</span>

void mitk::VtkPropRenderer::Update()
<span style = "background-color:#fdd">{
  if (m_DataStorage.IsNull())
    return;</span>

<span style = "background-color:#fdd">  mitk::DataStorage::SetOfObjects::ConstPointer all = m_DataStorage-&gt;GetAll();
  for (mitk::DataStorage::SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)
    Update(it-&gt;Value());</span>

<span style = "background-color:#fdd">  Modified();
  m_LastUpdateTime = GetMTime();
}</span>

/*!
\brief

This method is called from the two Constructors
*/
void mitk::VtkPropRenderer::InitRenderer(vtkRenderWindow *renderWindow)
<span style = "background-color:#fdd">{
  BaseRenderer::InitRenderer(renderWindow);</span>

<span style = "background-color:#fdd">  vtkCallbackCommand *renderCallbackCommand = vtkCallbackCommand::New();
  renderCallbackCommand-&gt;SetCallback(VtkPropRenderer::RenderingCallback);
  renderWindow-&gt;GetInteractor()-&gt;AddObserver(vtkCommand::RenderEvent, renderCallbackCommand);
  renderCallbackCommand-&gt;Delete();</span>

<span style = "background-color:#fdd">  if (renderWindow == nullptr)</span>
  {
<span style = "background-color:#fdd">    m_InitNeeded = false;
    m_ResizeNeeded = false;
    return;</span>
  }

<span style = "background-color:#fdd">  m_InitNeeded = true;
  m_ResizeNeeded = true;</span>

<span style = "background-color:#fdd">  m_LastUpdateTime = 0;
}</span>

void mitk::VtkPropRenderer::RenderingCallback(vtkObject *caller, unsigned long, void *, void *)
<span style = "background-color:#fdd">{
  auto *renderWindowInteractor = dynamic_cast&lt;vtkRenderWindowInteractor *&gt;(caller);
  if (!renderWindowInteractor)
    return;
  mitk::BaseRenderer *renderer = mitk::BaseRenderer::GetInstance(renderWindowInteractor-&gt;GetRenderWindow());
  if (renderer)
    renderer-&gt;RequestUpdate();
}</span>

/*!
\brief Resize the OpenGL Window
*/
void mitk::VtkPropRenderer::Resize(int w, int h)
<span style = "background-color:#fdd">{
  BaseRenderer::Resize(w, h);
  RenderingManager::GetInstance()-&gt;RequestUpdate(this-&gt;GetRenderWindow());
}</span>

void mitk::VtkPropRenderer::InitSize(int w, int h)
<span style = "background-color:#fdd">{
  m_RenderWindow-&gt;SetSize(w, h);
  Superclass::InitSize(w, h);
  Modified();
  Update();
  if (m_VtkRenderer != nullptr)</span>
  {
<span style = "background-color:#fdd">    int w = vtkObject::GetGlobalWarningDisplay();
    vtkObject::GlobalWarningDisplayOff();
    m_VtkRenderer-&gt;ResetCamera();
    vtkObject::SetGlobalWarningDisplay(w);</span>
  }
<span style = "background-color:#fdd">  this-&gt;GetCameraController()-&gt;Fit();
}</span>

int mitk::VtkPropRenderer::WriteSimpleText(
  std::string text, double posX, double posY, double color1, double color2, double color3, float opacity)
<span style = "background-color:#fdd">{
  this-&gt;GetVtkRenderer()-&gt;ViewToDisplay();
  if (!text.empty())</span>
  {
<span style = "background-color:#fdd">    Point2D p;
    vtkTextActor *textActor = vtkTextActor::New();</span>

<span style = "background-color:#fdd">    textActor-&gt;SetDisplayPosition(posX, posY);
    textActor-&gt;SetInput(text.c_str());
    textActor-&gt;SetTextScaleModeToNone();
    textActor-&gt;GetTextProperty()-&gt;SetColor(color1, color2, color3); // TODO: Read color from node property
    textActor-&gt;GetTextProperty()-&gt;SetOpacity(opacity);
    int text_id = m_TextCollection.size();
    m_TextCollection.insert(TextMapType::value_type(text_id, textActor));
    return text_id;
  }</span>
  else
  {
<span style = "background-color:#fdd">    return -1;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::VtkPropRenderer::SetMapperID(const MapperSlotId mapperId)
<span style = "background-color:#fdd">{
  if (m_MapperID != mapperId)
    Superclass::SetMapperID(mapperId);</span>

  // Workaround for GL Displaylist Bug
<span style = "background-color:#fdd">  checkState();
}</span>

/*!
\brief Activates the current renderwindow.
*/
void mitk::VtkPropRenderer::MakeCurrent()
<span style = "background-color:#fdd">{
  if (m_RenderWindow != nullptr)
    m_RenderWindow-&gt;MakeCurrent();
}</span>

void mitk::VtkPropRenderer::PickWorldPoint(const mitk::Point2D &amp;displayPoint, mitk::Point3D &amp;worldPoint) const
<span style = "background-color:#fdd">{
  if (this-&gt;GetRenderWindow()-&gt;GetNeverRendered() != 0)
    return; // somebody called picking before we ever rendered; cannot have enough information yet</span>

<span style = "background-color:#fdd">  switch (m_PickingMode)</span>
  {
    case (WorldPointPicking):
    {
<span style = "background-color:#fdd">      m_WorldPointPicker-&gt;Pick(displayPoint[0], displayPoint[1], 0, m_VtkRenderer);
      vtk2itk(m_WorldPointPicker-&gt;GetPickPosition(), worldPoint);
      break;</span>
    }
    case (PointPicking):
    {
<span style = "background-color:#fdd">      m_PointPicker-&gt;Pick(displayPoint[0], displayPoint[1], 0, m_VtkRenderer);
      vtk2itk(m_PointPicker-&gt;GetPickPosition(), worldPoint);
      break;</span>
    }
    case (CellPicking):
    {
<span style = "background-color:#fdd">      m_CellPicker-&gt;Pick(displayPoint[0], displayPoint[1], 0, m_VtkRenderer);
      vtk2itk(m_CellPicker-&gt;GetPickPosition(), worldPoint);</span>
      break;
    }
  }
  // todo: is this picking in 2D renderwindows?
  //    Superclass::PickWorldPoint(displayPoint, worldPoint);
<span style = "background-color:#fdd">}</span>

mitk::DataNode *mitk::VtkPropRenderer::PickObject(const Point2D &amp;displayPosition, Point3D &amp;worldPosition) const
<span style = "background-color:#fdd">{
  m_CellPicker-&gt;InitializePickList();</span>

  // Iterate over all DataStorage objects to determine all vtkProps intended
  // for picking
<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer allObjects = m_DataStorage-&gt;GetAll();
  for (DataStorage::SetOfObjects::ConstIterator it = allObjects-&gt;Begin(); it != allObjects-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    const DataNode *node = it-&gt;Value();
    if (node == nullptr)
      continue;</span>

<span style = "background-color:#fdd">    bool pickable = false;
    node-&gt;GetBoolProperty("pickable", pickable);
    if (!pickable)
      continue;</span>

<span style = "background-color:#fdd">    auto *mapper = dynamic_cast&lt;VtkMapper *&gt;(node-&gt;GetMapper(m_MapperID));
    if (mapper == nullptr)
      continue;</span>

<span style = "background-color:#fdd">    vtkProp *prop = mapper-&gt;GetVtkProp((mitk::BaseRenderer *)this);
    if (prop == nullptr)
      continue;</span>

<span style = "background-color:#fdd">    m_CellPicker-&gt;AddPickList(prop);
  }</span>

  // Do the picking and retrieve the picked vtkProp (if any)
<span style = "background-color:#fdd">  m_CellPicker-&gt;PickFromListOn();
  m_CellPicker-&gt;Pick(displayPosition[0], displayPosition[1], 0.0, m_VtkRenderer);
  m_CellPicker-&gt;PickFromListOff();</span>

<span style = "background-color:#fdd">  vtk2itk(m_CellPicker-&gt;GetPickPosition(), worldPosition);
  vtkProp *prop = m_CellPicker-&gt;GetViewProp();</span>

<span style = "background-color:#fdd">  if (prop == nullptr)</span>
  {
<span style = "background-color:#fdd">    return nullptr;</span>
  }

  // Iterate over all DataStorage objects to determine if the retrieved
  // vtkProp is owned by any associated mapper.
<span style = "background-color:#fdd">  for (DataStorage::SetOfObjects::ConstIterator it = allObjects-&gt;Begin(); it != allObjects-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = it-&gt;Value();
    if (node.IsNull())
      continue;</span>

<span style = "background-color:#fdd">    mitk::Mapper *mapper = node-&gt;GetMapper(m_MapperID);
    if (mapper == nullptr)
      continue;</span>

<span style = "background-color:#fdd">    auto *vtkmapper = dynamic_cast&lt;VtkMapper *&gt;(mapper);</span>

<span style = "background-color:#fdd">    if (vtkmapper)</span>
    {
      // if vtk-based, then ...
<span style = "background-color:#fdd">      if (vtkmapper-&gt;HasVtkProp(prop, const_cast&lt;mitk::VtkPropRenderer *&gt;(this)))</span>
      {
<span style = "background-color:#fdd">        return node;</span>
      }
    }
<span style = "background-color:#fdd">  }
  return nullptr;
}</span>
// todo: is this 2D renderwindow picking?
//    return Superclass::PickObject( displayPosition, worldPosition );

vtkTextProperty *mitk::VtkPropRenderer::GetTextLabelProperty(int text_id)
<span style = "background-color:#fdd">{
  return this-&gt;m_TextCollection[text_id]-&gt;GetTextProperty();
}</span>

void mitk::VtkPropRenderer::InitPathTraversal()
<span style = "background-color:#fdd">{
  if (m_DataStorage.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    this-&gt;UpdatePaths();
    this-&gt;m_Paths-&gt;InitTraversal();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::VtkPropRenderer::UpdatePaths()
<span style = "background-color:#fdd">{
  if (m_DataStorage.IsNull())</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  if (GetMTime() &gt; m_PathTime || (m_Paths != nullptr &amp;&amp; m_Paths-&gt;GetMTime() &gt; m_PathTime))</span>
  {
    // Create the list to hold all the paths
<span style = "background-color:#fdd">    m_Paths = vtkSmartPointer&lt;vtkAssemblyPaths&gt;::New();</span>

<span style = "background-color:#fdd">    DataStorage::SetOfObjects::ConstPointer objects = m_DataStorage-&gt;GetAll();
    for (auto iter = objects-&gt;begin(); iter != objects-&gt;end(); ++iter)</span>
    {
<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkAssemblyPath&gt; onePath = vtkSmartPointer&lt;vtkAssemblyPath&gt;::New();
      Mapper *mapper = (*iter)-&gt;GetMapper(BaseRenderer::Standard3D);
      if (mapper)</span>
      {
<span style = "background-color:#fdd">        auto *vtkmapper = dynamic_cast&lt;VtkMapper *&gt;(mapper);</span>

<span style = "background-color:#fdd">        if (nullptr != vtkmapper)</span>
        {
<span style = "background-color:#fdd">          vtkProp *prop = vtkmapper-&gt;GetVtkProp(this);
          if (prop &amp;&amp; prop-&gt;GetVisibility())</span>
          {
            // add to assembly path
<span style = "background-color:#fdd">            onePath-&gt;AddNode(prop, prop-&gt;GetMatrix());
            m_Paths-&gt;AddItem(onePath);</span>
          }
        }
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    m_PathTime.Modified();
  }
}</span>

int mitk::VtkPropRenderer::GetNumberOfPaths()
<span style = "background-color:#fdd">{
  UpdatePaths();
  return m_Paths-&gt;GetNumberOfItems();
}</span>

vtkAssemblyPath *mitk::VtkPropRenderer::GetNextPath()
<span style = "background-color:#fdd">{
  return m_Paths ? m_Paths-&gt;GetNextItem() : nullptr;
}</span>

void mitk::VtkPropRenderer::ReleaseGraphicsResources(vtkWindow * /*renWin*/)
<span style = "background-color:#fdd">{
  if (m_DataStorage.IsNull())
    return;</span>

<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer allObjects = m_DataStorage-&gt;GetAll();
  for (auto iter = allObjects-&gt;begin(); iter != allObjects-&gt;end(); ++iter)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = *iter;
    if (node.IsNull())
      continue;</span>

<span style = "background-color:#fdd">    Mapper *mapper = node-&gt;GetMapper(m_MapperID);</span>

<span style = "background-color:#fdd">    if (mapper)</span>
    {
<span style = "background-color:#fdd">      auto *vtkmapper = dynamic_cast&lt;VtkMapper *&gt;(mapper);</span>

<span style = "background-color:#fdd">      if (vtkmapper)
        vtkmapper-&gt;ReleaseGraphicsResources(this);</span>
    }
<span style = "background-color:#fdd">  }
}</span>

const vtkWorldPointPicker *mitk::VtkPropRenderer::GetWorldPointPicker() const
<span style = "background-color:#fdd">{
  return m_WorldPointPicker;
}</span>

const vtkPointPicker *mitk::VtkPropRenderer::GetPointPicker() const
<span style = "background-color:#fdd">{
  return m_PointPicker;
}</span>

const vtkCellPicker *mitk::VtkPropRenderer::GetCellPicker() const
<span style = "background-color:#fdd">{
  return m_CellPicker;
}</span>

mitk::VtkPropRenderer::MappersMapType mitk::VtkPropRenderer::GetMappersMap() const
<span style = "background-color:#fdd">{
  return m_MappersMap;
}</span>

// Workaround for GL Displaylist bug
static int glWorkAroundGlobalCount = 0;

bool mitk::VtkPropRenderer::useImmediateModeRendering()
<span style = "background-color:#fdd">{
  return glWorkAroundGlobalCount &gt; 1;
}</span>

void mitk::VtkPropRenderer::checkState()
<span style = "background-color:#fdd">{
  if (m_MapperID == Standard3D)</span>
  {
<span style = "background-color:#fdd">    if (!didCount)</span>
    {
<span style = "background-color:#fdd">      didCount = true;
      glWorkAroundGlobalCount++;</span>

<span style = "background-color:#fdd">      if (glWorkAroundGlobalCount == 2)</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "Multiple 3D Renderwindows active...: turning Immediate Rendering ON for legacy mappers";</span>
        //          vtkMapper::GlobalImmediateModeRenderingOn();
      }
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    if (didCount)</span>
    {
<span style = "background-color:#fdd">      didCount = false;
      glWorkAroundGlobalCount--;
      if (glWorkAroundGlobalCount == 1)</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "Single 3D Renderwindow active...: turning Immediate Rendering OFF for legacy mappers";</span>
        //        vtkMapper::GlobalImmediateModeRenderingOff();
      }
    }
  }
<span style = "background-color:#fdd">}</span>

//### Contains all methods which are neceassry before each VTK Render() call
void mitk::VtkPropRenderer::PrepareRender()
<span style = "background-color:#fdd">{
  if (this-&gt;GetMapperID() != m_CameraInitializedForMapperID)</span>
  {
<span style = "background-color:#fdd">    Initialize2DvtkCamera(); // Set parallel projection etc.</span>
  }
<span style = "background-color:#fdd">  GetCameraController()-&gt;AdjustCameraToPlane();
}</span>

bool mitk::VtkPropRenderer::Initialize2DvtkCamera()
<span style = "background-color:#fdd">{
  if (this-&gt;GetMapperID() == Standard3D)</span>
  {
    // activate parallel projection for 2D
<span style = "background-color:#fdd">    this-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;SetParallelProjection(false);
    vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt; style =</span>
      vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt;::New();
<span style = "background-color:#fdd">    this-&gt;GetRenderWindow()-&gt;GetInteractor()-&gt;SetInteractorStyle(style);
    this-&gt;GetRenderWindow()-&gt;GetInteractor()-&gt;EnableRenderOff();
    m_CameraInitializedForMapperID = Standard3D;
  }
  else if (this-&gt;GetMapperID() == Standard2D)</span>
  {
    // activate parallel projection for 2D
<span style = "background-color:#fdd">    this-&gt;GetVtkRenderer()-&gt;GetActiveCamera()-&gt;SetParallelProjection(true);</span>
    // turn the light out in the scene in order to render correct grey values.
    // TODO Implement a property for light in the 2D render windows (in another method)
<span style = "background-color:#fdd">    this-&gt;GetVtkRenderer()-&gt;RemoveAllLights();</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;mitkVtkInteractorStyle&gt; style = vtkSmartPointer&lt;mitkVtkInteractorStyle&gt;::New();
    this-&gt;GetRenderWindow()-&gt;GetInteractor()-&gt;SetInteractorStyle(style);
    this-&gt;GetRenderWindow()-&gt;GetInteractor()-&gt;EnableRenderOff();
    m_CameraInitializedForMapperID = Standard2D;
  }
  return true;
}</span></pre>
	</body>
</html>