<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlanarFigureMaskGenerator.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;mitkPlanarFigureMaskGenerator.h&gt;
#include &lt;mitkBaseGeometry.h&gt;
#include &lt;mitkITKImageImport.h&gt;
#include "mitkImageAccessByItk.h"
#include &lt;mitkExtractImageFilter.h&gt;
#include &lt;mitkConvert2Dto3DImageFilter.h&gt;
#include &lt;mitkImageTimeSelector.h&gt;
#include &lt;mitkIOUtil.h&gt;

#include &lt;itkCastImageFilter.h&gt;
#include &lt;itkVTKImageExport.h&gt;
#include &lt;itkVTKImageImport.h&gt;
#include &lt;itkImageDuplicator.h&gt;
#include &lt;itkMacro.h&gt;
#include &lt;itkLineIterator.h&gt;

#include &lt;vtkPoints.h&gt;
#include &lt;vtkImageStencil.h&gt;
#include &lt;vtkImageImport.h&gt;
#include &lt;vtkImageExport.h&gt;
#include &lt;vtkLassoStencilSource.h&gt;
#include &lt;vtkSmartPointer.h&gt;



namespace mitk
{

void PlanarFigureMaskGenerator::SetPlanarFigure(mitk::PlanarFigure::Pointer planarFigure)
<span style = "background-color:#fdd">{
    if ( planarFigure.IsNull() )</span>
    {
<span style = "background-color:#fdd">      throw std::runtime_error( "Error: planar figure empty!" );</span>
    }

<span style = "background-color:#fdd">    const PlaneGeometry *planarFigurePlaneGeometry = planarFigure-&gt;GetPlaneGeometry();
    if ( planarFigurePlaneGeometry == nullptr )</span>
    {
<span style = "background-color:#fdd">      throw std::runtime_error( "Planar-Figure not yet initialized!" );</span>
    }

<span style = "background-color:#fdd">    const auto *planarFigureGeometry =</span>
      dynamic_cast&lt; const PlaneGeometry * &gt;( planarFigurePlaneGeometry );
<span style = "background-color:#fdd">    if ( planarFigureGeometry == nullptr )</span>
    {
<span style = "background-color:#fdd">      throw std::runtime_error( "Non-planar planar figures not supported!" );</span>
    }

<span style = "background-color:#fdd">    if (planarFigure != m_PlanarFigure)</span>
    {
<span style = "background-color:#fdd">        this-&gt;Modified();
        m_PlanarFigure = planarFigure;</span>
    }

<span style = "background-color:#fdd">}</span>

mitk::Image::ConstPointer PlanarFigureMaskGenerator::GetReferenceImage()
<span style = "background-color:#fdd">{
    if (IsUpdateRequired())</span>
    {
<span style = "background-color:#fdd">        this-&gt;CalculateMask();</span>
    }
<span style = "background-color:#fdd">    return m_ReferenceImage;
}</span>

template &lt; typename TPixel, unsigned int VImageDimension &gt;
void PlanarFigureMaskGenerator::InternalCalculateMaskFromPlanarFigure(
  const itk::Image&lt; TPixel, VImageDimension &gt; *image, unsigned int axis )
<span style = "background-color:#fdd">{</span>
  typedef itk::Image&lt; unsigned short, 2 &gt; MaskImage2DType;

<span style = "background-color:#fdd">  typename MaskImage2DType::Pointer maskImage = MaskImage2DType::New();
  maskImage-&gt;SetOrigin(image-&gt;GetOrigin());
  maskImage-&gt;SetSpacing(image-&gt;GetSpacing());
  maskImage-&gt;SetLargestPossibleRegion(image-&gt;GetLargestPossibleRegion());
  maskImage-&gt;SetBufferedRegion(image-&gt;GetBufferedRegion());
  maskImage-&gt;SetDirection(image-&gt;GetDirection());
  maskImage-&gt;SetNumberOfComponentsPerPixel(image-&gt;GetNumberOfComponentsPerPixel());
  maskImage-&gt;Allocate();
  maskImage-&gt;FillBuffer(1);</span>

  // all PolylinePoints of the PlanarFigure are stored in a vtkPoints object.
  // These points are used by the vtkLassoStencilSource to create
  // a vtkImageStencil.
<span style = "background-color:#fdd">  const mitk::PlaneGeometry *planarFigurePlaneGeometry = m_PlanarFigure-&gt;GetPlaneGeometry();
  const typename PlanarFigure::PolyLineType planarFigurePolyline = m_PlanarFigure-&gt;GetPolyLine( 0 );
  const mitk::BaseGeometry *imageGeometry3D = m_inputImage-&gt;GetGeometry( 0 );</span>
  // If there is a second poly line in a closed planar figure, treat it as a hole.
<span style = "background-color:#fdd">  PlanarFigure::PolyLineType planarFigureHolePolyline;</span>

<span style = "background-color:#fdd">  if (m_PlanarFigure-&gt;GetPolyLinesSize() == 2)
    planarFigureHolePolyline = m_PlanarFigure-&gt;GetPolyLine(1);</span>


  // Determine x- and y-dimensions depending on principal axis
  // TODO use plane geometry normal to determine that automatically, then check whether the PF is aligned with one of the three principal axis
  int i0, i1;
<span style = "background-color:#fdd">  switch ( axis )</span>
  {
  case 0:
<span style = "background-color:#fdd">    i0 = 1;
    i1 = 2;
    break;</span>

  case 1:
<span style = "background-color:#fdd">    i0 = 0;
    i1 = 2;
    break;</span>

  case 2:
  default:
<span style = "background-color:#fdd">    i0 = 0;
    i1 = 1;</span>
    break;
  }

  // store the polyline contour as vtkPoints object
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPoints&gt; points = vtkSmartPointer&lt;vtkPoints&gt;::New();
  for (const auto&amp; point : planarFigurePolyline)</span>
  {
<span style = "background-color:#fdd">    Point3D point3D;</span>

    // Convert 2D point back to the local index coordinates of the selected image
<span style = "background-color:#fdd">    planarFigurePlaneGeometry-&gt;Map(point, point3D);
    imageGeometry3D-&gt;WorldToIndex(point3D, point3D);</span>

<span style = "background-color:#fdd">    points-&gt;InsertNextPoint(point3D[i0], point3D[i1], 0);
  }</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPoints&gt; holePoints;</span>

<span style = "background-color:#fdd">  if (!planarFigureHolePolyline.empty())</span>
  {
<span style = "background-color:#fdd">    holePoints = vtkSmartPointer&lt;vtkPoints&gt;::New();
    Point3D point3D;</span>

<span style = "background-color:#fdd">    for (const auto&amp; point : planarFigureHolePolyline)</span>
    {
<span style = "background-color:#fdd">      planarFigurePlaneGeometry-&gt;Map(point, point3D);
      imageGeometry3D-&gt;WorldToIndex(point3D, point3D);
      holePoints-&gt;InsertNextPoint(point3D[i0], point3D[i1], 0);
    }</span>
  }

  // mark a malformed 2D planar figure ( i.e. area = 0 ) as out of bounds
  // this can happen when all control points of a rectangle lie on the same line = two of the three extents are zero
<span style = "background-color:#fdd">  double bounds[6] = {0};
  points-&gt;GetBounds(bounds);
  bool extent_x = (fabs(bounds[0] - bounds[1])) &lt; mitk::eps;
  bool extent_y = (fabs(bounds[2] - bounds[3])) &lt; mitk::eps;
  bool extent_z = (fabs(bounds[4] - bounds[5])) &lt; mitk::eps;</span>

  // throw an exception if a closed planar figure is deformed, i.e. has only one non-zero extent
<span style = "background-color:#fdd">  if (m_PlanarFigure-&gt;IsClosed() &amp;&amp; ((extent_x &amp;&amp; extent_y) || (extent_x &amp;&amp; extent_z)  || (extent_y &amp;&amp; extent_z)))</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Figure has a zero area and cannot be used for masking.";</span>
  }

  // create a vtkLassoStencilSource and set the points of the Polygon
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkLassoStencilSource&gt; lassoStencil = vtkSmartPointer&lt;vtkLassoStencilSource&gt;::New();
  lassoStencil-&gt;SetShapeToPolygon();
  lassoStencil-&gt;SetPoints(points);</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkLassoStencilSource&gt; holeLassoStencil = nullptr;</span>

<span style = "background-color:#fdd">  if (holePoints.GetPointer() != nullptr)</span>
  {
<span style = "background-color:#fdd">    holeLassoStencil = vtkSmartPointer&lt;vtkLassoStencilSource&gt;::New();
    holeLassoStencil-&gt;SetShapeToPolygon();
    holeLassoStencil-&gt;SetPoints(holePoints);</span>
  }

  // Export from ITK to VTK (to use a VTK filter)
  typedef itk::VTKImageImport&lt; MaskImage2DType &gt; ImageImportType;
  typedef itk::VTKImageExport&lt; MaskImage2DType &gt; ImageExportType;

<span style = "background-color:#fdd">  typename ImageExportType::Pointer itkExporter = ImageExportType::New();
  itkExporter-&gt;SetInput( maskImage );</span>
//  itkExporter-&gt;SetInput( castFilter-&gt;GetOutput() );

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkImageImport&gt; vtkImporter = vtkSmartPointer&lt;vtkImageImport&gt;::New();
  this-&gt;ConnectPipelines( itkExporter, vtkImporter );</span>

  // Apply the generated image stencil to the input image
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkImageStencil&gt; imageStencilFilter = vtkSmartPointer&lt;vtkImageStencil&gt;::New();
  imageStencilFilter-&gt;SetInputConnection( vtkImporter-&gt;GetOutputPort() );
  imageStencilFilter-&gt;SetStencilConnection(lassoStencil-&gt;GetOutputPort());
  imageStencilFilter-&gt;ReverseStencilOff();
  imageStencilFilter-&gt;SetBackgroundValue( 0 );
  imageStencilFilter-&gt;Update();</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkImageStencil&gt; holeStencilFilter = nullptr;</span>

<span style = "background-color:#fdd">  if (holeLassoStencil.GetPointer() != nullptr)</span>
  {
<span style = "background-color:#fdd">    holeStencilFilter = vtkSmartPointer&lt;vtkImageStencil&gt;::New();
    holeStencilFilter-&gt;SetInputConnection(imageStencilFilter-&gt;GetOutputPort());
    holeStencilFilter-&gt;SetStencilConnection(holeLassoStencil-&gt;GetOutputPort());
    holeStencilFilter-&gt;ReverseStencilOn();
    holeStencilFilter-&gt;SetBackgroundValue(0);
    holeStencilFilter-&gt;Update();</span>
  }

  // Export from VTK back to ITK
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkImageExport&gt; vtkExporter = vtkSmartPointer&lt;vtkImageExport&gt;::New();
  vtkExporter-&gt;SetInputConnection( holeStencilFilter.GetPointer() == nullptr</span>
    ? imageStencilFilter-&gt;GetOutputPort()
    : holeStencilFilter-&gt;GetOutputPort());
<span style = "background-color:#fdd">  vtkExporter-&gt;Update();</span>

<span style = "background-color:#fdd">  typename ImageImportType::Pointer itkImporter = ImageImportType::New();
  this-&gt;ConnectPipelines( vtkExporter, itkImporter );
  itkImporter-&gt;Update();</span>

  typedef itk::ImageDuplicator&lt; ImageImportType::OutputImageType &gt; DuplicatorType;
<span style = "background-color:#fdd">  DuplicatorType::Pointer duplicator = DuplicatorType::New();
  duplicator-&gt;SetInputImage( itkImporter-&gt;GetOutput() );
  duplicator-&gt;Update();</span>

  // Store mask
<span style = "background-color:#fdd">  m_InternalITKImageMask2D = duplicator-&gt;GetOutput();
}</span>

template &lt; typename TPixel, unsigned int VImageDimension &gt;
void PlanarFigureMaskGenerator::InternalCalculateMaskFromOpenPlanarFigure(
  const itk::Image&lt; TPixel, VImageDimension &gt; *image, unsigned int axis )
<span style = "background-color:#fdd">{</span>
  typedef itk::Image&lt; unsigned short, 2 &gt;       MaskImage2DType;
  typedef itk::LineIterator&lt; MaskImage2DType &gt;  LineIteratorType;
  typedef MaskImage2DType::IndexType            IndexType2D;
  typedef std::vector&lt; IndexType2D &gt;            IndexVecType;

<span style = "background-color:#fdd">  typename MaskImage2DType::Pointer maskImage = MaskImage2DType::New();
  maskImage-&gt;SetOrigin(image-&gt;GetOrigin());
  maskImage-&gt;SetSpacing(image-&gt;GetSpacing());
  maskImage-&gt;SetLargestPossibleRegion(image-&gt;GetLargestPossibleRegion());
  maskImage-&gt;SetBufferedRegion(image-&gt;GetBufferedRegion());
  maskImage-&gt;SetDirection(image-&gt;GetDirection());
  maskImage-&gt;SetNumberOfComponentsPerPixel(image-&gt;GetNumberOfComponentsPerPixel());
  maskImage-&gt;Allocate();
  maskImage-&gt;FillBuffer(0);</span>

  // all PolylinePoints of the PlanarFigure are stored in a vtkPoints object.
<span style = "background-color:#fdd">  const mitk::PlaneGeometry *planarFigurePlaneGeometry = m_PlanarFigure-&gt;GetPlaneGeometry();
  const typename PlanarFigure::PolyLineType planarFigurePolyline = m_PlanarFigure-&gt;GetPolyLine( 0 );
  const mitk::BaseGeometry *imageGeometry3D = m_inputImage-&gt;GetGeometry( 0 );</span>

  // Determine x- and y-dimensions depending on principal axis
  // TODO use plane geometry normal to determine that automatically, then check whether the PF is aligned with one of the three principal axis
  int i0, i1;
<span style = "background-color:#fdd">  switch ( axis )</span>
  {
  case 0:
<span style = "background-color:#fdd">    i0 = 1;
    i1 = 2;
    break;</span>

  case 1:
<span style = "background-color:#fdd">    i0 = 0;
    i1 = 2;
    break;</span>

  case 2:
  default:
<span style = "background-color:#fdd">    i0 = 0;
    i1 = 1;</span>
    break;
  }

<span style = "background-color:#fdd">  int numPolyLines = m_PlanarFigure-&gt;GetPolyLinesSize();
  for ( int lineId = 0; lineId &lt; numPolyLines; ++lineId )</span>
  {
    // store the polyline contour as vtkPoints object
<span style = "background-color:#fdd">    IndexVecType pointIndices;
    for(const auto&amp; point : planarFigurePolyline)</span>
    {
<span style = "background-color:#fdd">      Point3D point3D;</span>

<span style = "background-color:#fdd">      planarFigurePlaneGeometry-&gt;Map(point, point3D);
      imageGeometry3D-&gt;WorldToIndex(point3D, point3D);</span>

      IndexType2D index2D;
<span style = "background-color:#fdd">      index2D[0] = point3D[i0];
      index2D[1] = point3D[i1];</span>

<span style = "background-color:#fdd">      pointIndices.push_back( index2D );
    }</span>

<span style = "background-color:#fdd">    size_t numLineSegments = pointIndices.size() - 1;
    for (size_t i = 0; i &lt; numLineSegments; ++i)</span>
    {
<span style = "background-color:#fdd">      LineIteratorType lineIt(maskImage, pointIndices[i], pointIndices[i+1]);
      while (!lineIt.IsAtEnd())</span>
      {
<span style = "background-color:#fdd">        lineIt.Set(1);
        ++lineIt;
      }
    }
  }</span>

  // Store mask
<span style = "background-color:#fdd">  m_InternalITKImageMask2D = maskImage;
}</span>

bool PlanarFigureMaskGenerator::CheckPlanarFigureIsNotTilted(const PlaneGeometry* planarGeometry, const BaseGeometry *geometry)
<span style = "background-color:#fdd">{
  if (!planarGeometry) return false;
  if (!geometry) return false;</span>

  unsigned int axis;
<span style = "background-color:#fdd">  return GetPrincipalAxis(geometry,planarGeometry-&gt;GetNormal(), axis);
}</span>

bool PlanarFigureMaskGenerator::GetPrincipalAxis(
  const BaseGeometry *geometry, Vector3D vector,
  unsigned int &amp;axis )
<span style = "background-color:#fdd">{
  vector.Normalize();
  for ( unsigned int i = 0; i &lt; 3; ++i )</span>
  {
<span style = "background-color:#fdd">    Vector3D axisVector = geometry-&gt;GetAxisVector( i );
    axisVector.Normalize();</span>

    //normal mitk::eps is to pedantic for this check. See e.g. T27122
    //therefore choose a larger epsilon. The value was set a) as small as
    //possible but b) still allowing to datasets like in (T27122) to pass
    //when floating rounding errors sum up.
<span style = "background-color:#fdd">    const double epsilon = 5e-5;
    if ( fabs( fabs( axisVector * vector ) - 1.0) &lt; epsilon)</span>
    {
<span style = "background-color:#fdd">      axis = i;
      return true;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return false;
}</span>

void PlanarFigureMaskGenerator::CalculateMask()
<span style = "background-color:#fdd">{
    if (m_inputImage.IsNull())</span>
    {
<span style = "background-color:#fdd">        MITK_ERROR &lt;&lt; "Image is not set.";</span>
    }

<span style = "background-color:#fdd">    if (m_PlanarFigure.IsNull())</span>
    {
<span style = "background-color:#fdd">        MITK_ERROR &lt;&lt; "PlanarFigure is not set.";</span>
    }

<span style = "background-color:#fdd">    if (m_TimeStep != 0)</span>
    {
<span style = "background-color:#fdd">        MITK_WARN &lt;&lt; "Multiple TimeSteps are not supported in PlanarFigureMaskGenerator (yet).";</span>
    }

<span style = "background-color:#fdd">    const BaseGeometry *imageGeometry = m_inputImage-&gt;GetGeometry();
    if ( imageGeometry == nullptr )</span>
    {
<span style = "background-color:#fdd">      throw std::runtime_error( "Image geometry invalid!" );</span>
    }

<span style = "background-color:#fdd">    if (m_inputImage-&gt;GetTimeSteps() &gt; 0)</span>
    {
<span style = "background-color:#fdd">        mitk::ImageTimeSelector::Pointer imgTimeSel = mitk::ImageTimeSelector::New();
        imgTimeSel-&gt;SetInput(m_inputImage);
        imgTimeSel-&gt;SetTimeNr(m_TimeStep);
        imgTimeSel-&gt;UpdateLargestPossibleRegion();
        m_InternalTimeSliceImage = imgTimeSel-&gt;GetOutput();
    }</span>
    else
    {
<span style = "background-color:#fdd">        m_InternalTimeSliceImage = m_inputImage;</span>
    }

<span style = "background-color:#fdd">    m_InternalITKImageMask2D = nullptr;
    const PlaneGeometry *planarFigurePlaneGeometry = m_PlanarFigure-&gt;GetPlaneGeometry();
    const auto *planarFigureGeometry = dynamic_cast&lt; const PlaneGeometry * &gt;( planarFigurePlaneGeometry );</span>
    //const BaseGeometry *imageGeometry = m_inputImage-&gt;GetGeometry();

    // Find principal direction of PlanarFigure in input image
    unsigned int axis;
<span style = "background-color:#fdd">    if ( !this-&gt;GetPrincipalAxis( imageGeometry,</span>
      planarFigureGeometry-&gt;GetNormal(), axis ) )
    {
<span style = "background-color:#fdd">      throw std::runtime_error( "Non-aligned planar figures not supported!" );</span>
    }
<span style = "background-color:#fdd">    m_PlanarFigureAxis = axis;</span>

    // Find slice number corresponding to PlanarFigure in input image
    itk::Image&lt; unsigned short, 3 &gt;::IndexType index;
<span style = "background-color:#fdd">    imageGeometry-&gt;WorldToIndex( planarFigureGeometry-&gt;GetOrigin(), index );</span>

<span style = "background-color:#fdd">    unsigned int slice = index[axis];
    m_PlanarFigureSlice = slice;</span>

    // extract image slice which corresponds to the planarFigure and store it in m_InternalImageSlice
<span style = "background-color:#fdd">    mitk::Image::ConstPointer inputImageSlice = extract2DImageSlice(axis, slice);</span>
    //mitk::IOUtil::Save(inputImageSlice, "/home/fabian/inputSliceImage.nrrd");
    // Compute mask from PlanarFigure
    // rastering for open planar figure:
<span style = "background-color:#fdd">    if ( !m_PlanarFigure-&gt;IsClosed() )</span>
    {
<span style = "background-color:#fdd">      AccessFixedDimensionByItk_1(inputImageSlice,</span>
        InternalCalculateMaskFromOpenPlanarFigure,
        2, axis)
<span style = "background-color:#fdd">    }</span>
    else//for closed planar figure
    {
<span style = "background-color:#fdd">      AccessFixedDimensionByItk_1(inputImageSlice,</span>
                                  InternalCalculateMaskFromPlanarFigure,
                                  2, axis)
    }

    //convert itk mask to mitk::Image::Pointer and return it
<span style = "background-color:#fdd">    mitk::Image::Pointer planarFigureMaskImage;
    planarFigureMaskImage = mitk::GrabItkImageMemory(m_InternalITKImageMask2D);</span>
    //mitk::IOUtil::Save(planarFigureMaskImage, "/home/fabian/planarFigureMaskImage.nrrd");

    //Convert2Dto3DImageFilter::Pointer sliceTo3DImageConverter = Convert2Dto3DImageFilter::New();
    //sliceTo3DImageConverter-&gt;SetInput(planarFigureMaskImage);
    //sliceTo3DImageConverter-&gt;Update();
    //mitk::IOUtil::Save(sliceTo3DImageConverter-&gt;GetOutput(), "/home/fabian/3DsliceImage.nrrd");

<span style = "background-color:#fdd">    m_ReferenceImage = inputImageSlice;</span>
    //mitk::IOUtil::Save(m_ReferenceImage, "/home/fabian/referenceImage.nrrd");
<span style = "background-color:#fdd">    m_InternalMask = planarFigureMaskImage;
}</span>

void PlanarFigureMaskGenerator::SetTimeStep(unsigned int timeStep)
<span style = "background-color:#fdd">{
    if (timeStep != m_TimeStep)</span>
    {
<span style = "background-color:#fdd">        m_TimeStep = timeStep;</span>
    }
<span style = "background-color:#fdd">}</span>

mitk::Image::Pointer PlanarFigureMaskGenerator::GetMask()
<span style = "background-color:#fdd">{
    if (IsUpdateRequired())</span>
    {
<span style = "background-color:#fdd">        this-&gt;CalculateMask();
        this-&gt;Modified();</span>
    }

<span style = "background-color:#fdd">    m_InternalMaskUpdateTime = this-&gt;GetMTime();
    return m_InternalMask;
}</span>

mitk::Image::ConstPointer PlanarFigureMaskGenerator::extract2DImageSlice(unsigned int axis, unsigned int slice)
<span style = "background-color:#fdd">{</span>
    // Extract slice with given position and direction from image
<span style = "background-color:#fdd">    unsigned int dimension = m_InternalTimeSliceImage-&gt;GetDimension();</span>

<span style = "background-color:#fdd">    if (dimension == 3)</span>
    {
<span style = "background-color:#fdd">      ExtractImageFilter::Pointer imageExtractor = ExtractImageFilter::New();
      imageExtractor-&gt;SetInput( m_InternalTimeSliceImage );
      imageExtractor-&gt;SetSliceDimension( axis );
      imageExtractor-&gt;SetSliceIndex( slice );
      imageExtractor-&gt;Update();
      return imageExtractor-&gt;GetOutput();
    }
    else if(dimension == 2)</span>
    {
<span style = "background-color:#fdd">      return m_InternalTimeSliceImage;
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Unsupported image dimension. Dimension is: " &lt;&lt; dimension &lt;&lt; ". Only 2D and 3D images are supported.";
      return nullptr;</span>
    }
<span style = "background-color:#fdd">}</span>

bool PlanarFigureMaskGenerator::IsUpdateRequired() const
<span style = "background-color:#fdd">{
    unsigned long thisClassTimeStamp = this-&gt;GetMTime();
    unsigned long internalMaskTimeStamp = m_InternalMask-&gt;GetMTime();
    unsigned long planarFigureTimeStamp = m_PlanarFigure-&gt;GetMTime();
    unsigned long inputImageTimeStamp = m_inputImage-&gt;GetMTime();</span>

<span style = "background-color:#fdd">    if (thisClassTimeStamp &gt; m_InternalMaskUpdateTime) // inputs have changed</span>
    {
<span style = "background-color:#fdd">        return true;</span>
    }

<span style = "background-color:#fdd">    if (m_InternalMaskUpdateTime &lt; planarFigureTimeStamp || m_InternalMaskUpdateTime &lt; inputImageTimeStamp) // mask image has changed outside of this class</span>
    {
<span style = "background-color:#fdd">        return true;</span>
    }

<span style = "background-color:#fdd">    if (internalMaskTimeStamp &gt; m_InternalMaskUpdateTime) // internal mask has been changed outside of this class</span>
    {
<span style = "background-color:#fdd">        return true;</span>
    }

<span style = "background-color:#fdd">    return false;
}</span>

}
</pre>
	</body>
</html>