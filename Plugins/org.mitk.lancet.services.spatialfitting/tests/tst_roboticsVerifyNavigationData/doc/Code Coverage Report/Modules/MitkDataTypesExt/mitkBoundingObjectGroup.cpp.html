<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkBoundingObjectGroup.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkBoundingObjectGroup.h"
#include "mitkBaseProcess.h"
#include &lt;mitkProportionalTimeGeometry.h&gt;
#include &lt;vtkLinearTransform.h&gt;

mitk::BoundingObjectGroup::BoundingObjectGroup()
<span style = "background-color:#fdd">  : m_BoundingObjects(0), m_Counter(0), m_CSGMode(Union) // m_CSGMode(Difference) //m_CSGMode(Intersection)
{
  ProportionalTimeGeometry::Pointer timeGeometry = ProportionalTimeGeometry::New();
  timeGeometry-&gt;Initialize(1);
  SetTimeGeometry(timeGeometry);</span>

<span style = "background-color:#fdd">  SetVtkPolyData(nullptr);
}</span>

mitk::BoundingObjectGroup::~BoundingObjectGroup()
<span style = "background-color:#fdd">{
}</span>

void mitk::BoundingObjectGroup::UpdateOutputInformation()
<span style = "background-color:#fdd">{
  if (this-&gt;GetSource())</span>
  {
<span style = "background-color:#fdd">    this-&gt;GetSource()-&gt;UpdateOutputInformation();</span>
  }

  // calculate global bounding box
<span style = "background-color:#fdd">  if (m_BoundingObjects.size() &lt; 1) // if there is no BoundingObject, the bounding box is zero</span>
  {
    mitk::BoundingBox::BoundsArrayType boundsArray;
<span style = "background-color:#fdd">    boundsArray.Fill(0);
    ProportionalTimeGeometry::Pointer timeGeometry = ProportionalTimeGeometry::New();
    timeGeometry-&gt;Initialize(1);
    SetTimeGeometry(timeGeometry);
    GetGeometry()-&gt;SetBounds(boundsArray);
    GetTimeGeometry()-&gt;Update();
    return;</span>
  }

  // initialize container
<span style = "background-color:#fdd">  mitk::BoundingBox::PointsContainer::Pointer pointscontainer = mitk::BoundingBox::PointsContainer::New();</span>

<span style = "background-color:#fdd">  mitk::BoundingBox::PointIdentifier pointid = 0;
  mitk::Point3D point;</span>

<span style = "background-color:#fdd">  mitk::AffineTransform3D *transform = GetGeometry()-&gt;GetIndexToWorldTransform();
  mitk::AffineTransform3D::Pointer inverse = mitk::AffineTransform3D::New();
  transform-&gt;GetInverse(inverse);</span>

  // calculate a bounding box that includes all BoundingObjects
  // \todo probably we should do this additionally for each time-step
  // while (boundingObjectsIterator != boundingObjectsIteratorEnd)
<span style = "background-color:#fdd">  for (unsigned int j = 0; j &lt; m_BoundingObjects.size(); j++)</span>
  {
<span style = "background-color:#fdd">    const TimeGeometry *geometry = m_BoundingObjects.at(j)-&gt;GetUpdatedTimeGeometry();</span>
    unsigned char i;
<span style = "background-color:#fdd">    for (i = 0; i &lt; 8; ++i)</span>
    {
<span style = "background-color:#fdd">      point = inverse-&gt;TransformPoint(geometry-&gt;GetCornerPointInWorld(i));
      if (point[0] * point[0] + point[1] * point[1] + point[2] * point[2] &lt; mitk::large)
        pointscontainer-&gt;InsertElement(pointid++, point);</span>
      else
      {
<span style = "background-color:#fdd">        itkGenericOutputMacro(&lt;&lt; "Unrealistically distant corner point encountered. Ignored. BoundingObject: "</span>
                              &lt;&lt; m_BoundingObjects.at(j));
      }
<span style = "background-color:#fdd">    }
  }</span>

<span style = "background-color:#fdd">  mitk::BoundingBox::Pointer boundingBox = mitk::BoundingBox::New();
  boundingBox-&gt;SetPoints(pointscontainer);
  boundingBox-&gt;ComputeBoundingBox();</span>

<span style = "background-color:#fdd">  BaseGeometry *geometry3d = GetGeometry(0);
  geometry3d-&gt;SetIndexToWorldTransform(transform);
  geometry3d-&gt;SetBounds(boundingBox-&gt;GetBounds());</span>
  /* the objects position is the center of all sub bounding objects */
  // geometry3d-&gt;SetOrigin(center);

<span style = "background-color:#fdd">  ProportionalTimeGeometry::Pointer timeGeometry = ProportionalTimeGeometry::New();
  timeGeometry-&gt;Initialize(geometry3d, GetTimeGeometry()-&gt;CountTimeSteps());
  SetTimeGeometry(timeGeometry);
}</span>

void mitk::BoundingObjectGroup::AddBoundingObject(mitk::BoundingObject::Pointer boundingObject)
<span style = "background-color:#fdd">{
  if (boundingObject-&gt;GetPositive())
    m_BoundingObjects.push_front(boundingObject);</span>
  else
<span style = "background-color:#fdd">    m_BoundingObjects.push_back(boundingObject);
  ++m_Counter;
  UpdateOutputInformation();
}</span>

void mitk::BoundingObjectGroup::RemoveBoundingObject(mitk::BoundingObject::Pointer boundingObject)
<span style = "background-color:#fdd">{
  auto it = m_BoundingObjects.begin();
  for (unsigned int i = 0; i &lt; m_BoundingObjects.size(); i++)</span>
  {
<span style = "background-color:#fdd">    if (m_BoundingObjects.at(i) == boundingObject)
      m_BoundingObjects.erase(it);
    ++it;
  }
  --m_Counter;
  UpdateOutputInformation();
}</span>

bool mitk::BoundingObjectGroup::IsInside(const mitk::Point3D &amp;p) const
<span style = "background-color:#fdd">{
  bool inside = false; // initialize with true for intersection, with false for union
  bool posInside = false;
  bool negInside = false;</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; m_BoundingObjects.size(); i++)</span>
  {
<span style = "background-color:#fdd">    switch (m_CSGMode)</span>
    {
      case Intersection:
<span style = "background-color:#fdd">        inside = true;</span>
        // calculate intersection: each point, that is inside each BoundingObject is considered inside the group
<span style = "background-color:#fdd">        inside = m_BoundingObjects.at(i)-&gt;IsInside(p) &amp;&amp; inside;
        if (!inside) // shortcut, it is enough to find one object that does not contain the point
          i = m_BoundingObjects.size();
        break;</span>

      case Union:
      case Difference:
<span style = "background-color:#fdd">        posInside = false;
        negInside = false;</span>
        // calculate union: each point, that is inside least one BoundingObject is considered inside the group
<span style = "background-color:#fdd">        if (m_BoundingObjects.at(i)-&gt;GetPositive())
          posInside = m_BoundingObjects.at(i)-&gt;IsInside(p) || posInside;</span>
        else
<span style = "background-color:#fdd">          negInside = m_BoundingObjects.at(i)-&gt;IsInside(p) || negInside;</span>

<span style = "background-color:#fdd">        if (posInside &amp;&amp; !negInside)
          inside = true;</span>
        else
<span style = "background-color:#fdd">          inside = false;
        break;</span>

      default:
<span style = "background-color:#fdd">        inside = false;</span>
        // calculate union: each point, that is inside least one BoundingObject is considered inside the group
<span style = "background-color:#fdd">        inside = m_BoundingObjects.at(i)-&gt;IsInside(p) || inside;
        if (inside) // shortcut, it is enough to find one object that contains the point
          i = m_BoundingObjects.size();</span>
        break;
    }
<span style = "background-color:#fdd">  }
  return inside;
}</span>

unsigned int mitk::BoundingObjectGroup::GetCount() const
<span style = "background-color:#fdd">{
  return m_Counter;
}</span>

bool mitk::BoundingObjectGroup::VerifyRequestedRegion()
<span style = "background-color:#fdd">{
  return m_Counter &gt; 0;
}</span>

mitk::BaseGeometry *mitk::BoundingObjectGroup::GetGeometry(int t) const
<span style = "background-color:#fdd">{</span>
  // if ( m_BoundingObjects == nullptr )
<span style = "background-color:#fdd">  return Superclass::GetGeometry(t);</span>

  // mitk::BoundingObjectGroup::BoundingObjectContainer::ConstIterator boI = m_BoundingObjects-&gt;Begin();
  // const mitk::BoundingObjectGroup::BoundingObjectContainer::ConstIterator boIEnd = m_BoundingObjects-&gt;End();
  // mitk::Geometry3D* currentGeometry = nullptr;

  // while ( boI != boIEnd )
  //{
  //  currentGeometry = boI.Value()-&gt;GetGeometry( t );
  //  boI++;
  //}

  // return currentGeometry;
<span style = "background-color:#fdd">}</span>

void mitk::BoundingObjectGroup::SetBoundingObjects(const std::deque&lt;mitk::BoundingObject::Pointer&gt; boundingObjects)
<span style = "background-color:#fdd">{
  m_BoundingObjects = boundingObjects;
}</span>

std::deque&lt;mitk::BoundingObject::Pointer&gt; mitk::BoundingObjectGroup::GetBoundingObjects()
<span style = "background-color:#fdd">{
  return m_BoundingObjects;
}</span></pre>
	</body>
</html>