<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>usServiceRegistrationBase.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

  Library: CppMicroServices

  Copyright (c) German Cancer Research Center (DKFZ)
  All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

============================================================================*/

#include "usServiceRegistrationBase.h"
#include "usServiceRegistrationBasePrivate.h"
#include "usServiceListenerEntry_p.h"
#include "usServiceRegistry_p.h"
#include "usServiceFactory.h"

#include "usModulePrivate.h"
#include "usCoreModuleContext_p.h"

#include &lt;stdexcept&gt;

US_BEGIN_NAMESPACE

ServiceRegistrationBase::ServiceRegistrationBase()
<span style = "background-color:#dfd">  : d(nullptr)
{</span>

<span style = "background-color:#dfd">}</span>

ServiceRegistrationBase::ServiceRegistrationBase(const ServiceRegistrationBase&amp; reg)
<span style = "background-color:#dfd">  : d(reg.d)
{
  if (d) d-&gt;ref.Ref();
}</span>

ServiceRegistrationBase::ServiceRegistrationBase(ServiceRegistrationBasePrivate* registrationPrivate)
<span style = "background-color:#fdd">  : d(registrationPrivate)
{
  if (d) d-&gt;ref.Ref();
}</span>

ServiceRegistrationBase::ServiceRegistrationBase(ModulePrivate* module, const InterfaceMap&amp; service,
                                                 const ServicePropertiesImpl&amp; props)
<span style = "background-color:#dfd">  : d(new ServiceRegistrationBasePrivate(module, service, props))
{</span>

<span style = "background-color:#dfd">}</span>

ServiceRegistrationBase::operator bool_type() const
<span style = "background-color:#dfd">{
  return d != nullptr ? &amp;ServiceRegistrationBase::d : nullptr;
}</span>

ServiceRegistrationBase&amp; ServiceRegistrationBase::operator=(int null)
<span style = "background-color:#dfd">{
  if (null == 0)</span>
  {
<span style = "background-color:#dfd">    if (d &amp;&amp; !d-&gt;ref.Deref())</span>
    {
<span style = "background-color:#dfd">      delete d;</span>
    }
<span style = "background-color:#dfd">    d = nullptr;</span>
  }
<span style = "background-color:#dfd">  return *this;
}</span>

ServiceRegistrationBase::~ServiceRegistrationBase()
<span style = "background-color:#dfd">{
  if (d &amp;&amp; !d-&gt;ref.Deref())
    delete d;
}</span>

ServiceReferenceBase ServiceRegistrationBase::GetReference(const std::string&amp; interfaceId) const
<span style = "background-color:#dfd">{
  if (!d) throw std::logic_error("ServiceRegistrationBase object invalid");
  if (!d-&gt;available) throw std::logic_error("Service is unregistered");</span>

<span style = "background-color:#dfd">  ServiceReferenceBase ref = d-&gt;reference;
  ref.SetInterfaceId(interfaceId);
  return ref;
}</span>

void ServiceRegistrationBase::SetProperties(const ServiceProperties&amp; props)
<span style = "background-color:#fdd">{
  if (!d) throw std::logic_error("ServiceRegistrationBase object invalid");</span>

<span style = "background-color:#fdd">  MutexLock lock(d-&gt;eventLock);</span>

<span style = "background-color:#fdd">  ServiceEvent modifiedEndMatchEvent(ServiceEvent::MODIFIED_ENDMATCH, d-&gt;reference);
  ServiceListeners::ServiceListenerEntries before;</span>
  // TBD, optimize the locking of services
  {
    //MutexLock lock2(d-&gt;module-&gt;coreCtx-&gt;globalFwLock);

<span style = "background-color:#fdd">    if (d-&gt;available)</span>
    {
      // NYI! Optimize the MODIFIED_ENDMATCH code
<span style = "background-color:#fdd">      int old_rank = 0;
      int new_rank = 0;</span>

<span style = "background-color:#fdd">      std::vector&lt;std::string&gt; classes;</span>
      {
<span style = "background-color:#fdd">        MutexLock lock3(d-&gt;propsLock);</span>

        {
<span style = "background-color:#fdd">          const Any&amp; any = d-&gt;properties.Value(ServiceConstants::SERVICE_RANKING());
          if (any.Type() == typeid(int)) old_rank = any_cast&lt;int&gt;(any);</span>
        }

<span style = "background-color:#fdd">        d-&gt;module-&gt;coreCtx-&gt;listeners.GetMatchingServiceListeners(modifiedEndMatchEvent, before, false);
        classes = ref_any_cast&lt;std::vector&lt;std::string&gt; &gt;(d-&gt;properties.Value(ServiceConstants::OBJECTCLASS()));
        long int sid = any_cast&lt;long int&gt;(d-&gt;properties.Value(ServiceConstants::SERVICE_ID()));
        d-&gt;properties = ServiceRegistry::CreateServiceProperties(props, classes, false, false, sid);</span>

        {
<span style = "background-color:#fdd">          const Any&amp; any = d-&gt;properties.Value(ServiceConstants::SERVICE_RANKING());
          if (any.Type() == typeid(int)) new_rank = any_cast&lt;int&gt;(any);</span>
        }
<span style = "background-color:#fdd">      }</span>

<span style = "background-color:#fdd">      if (old_rank != new_rank)</span>
      {
<span style = "background-color:#fdd">        d-&gt;module-&gt;coreCtx-&gt;services.UpdateServiceRegistrationOrder(*this, classes);</span>
      }
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">      throw std::logic_error("Service is unregistered");</span>
    }
  }
<span style = "background-color:#fdd">  ServiceEvent modifiedEvent(ServiceEvent::MODIFIED, d-&gt;reference);
  ServiceListeners::ServiceListenerEntries matchingListeners;
  d-&gt;module-&gt;coreCtx-&gt;listeners.GetMatchingServiceListeners(modifiedEvent, matchingListeners);
  d-&gt;module-&gt;coreCtx-&gt;listeners.ServiceChanged(matchingListeners,</span>
                                               modifiedEvent,
                                               before);

<span style = "background-color:#fdd">  d-&gt;module-&gt;coreCtx-&gt;listeners.ServiceChanged(before,</span>
                                               modifiedEndMatchEvent);
<span style = "background-color:#fdd">}</span>

void ServiceRegistrationBase::Unregister()
<span style = "background-color:#dfd">{
  if (!d) throw std::logic_error("ServiceRegistrationBase object invalid");</span>

<span style = "background-color:#dfd">  if (d-&gt;unregistering) return; // Silently ignore redundant unregistration.</span>
  {
<span style = "background-color:#dfd">    MutexLock lock(d-&gt;eventLock);
    if (d-&gt;unregistering) return;
    d-&gt;unregistering = true;</span>

<span style = "background-color:#dfd">    if (d-&gt;available)</span>
    {
<span style = "background-color:#dfd">      if (d-&gt;module)</span>
      {
<span style = "background-color:#dfd">        d-&gt;module-&gt;coreCtx-&gt;services.RemoveServiceRegistration(*this);</span>
      }
<span style = "background-color:#dfd">    }</span>
    else
    {
<span style = "background-color:#dfd">      throw std::logic_error("Service is unregistered");</span>
    }
<span style = "background-color:#dfd">  }</span>

<span style = "background-color:#dfd">  if (d-&gt;module)</span>
  {
<span style = "background-color:#dfd">    ServiceListeners::ServiceListenerEntries listeners;
    ServiceEvent unregisteringEvent(ServiceEvent::UNREGISTERING, d-&gt;reference);
    d-&gt;module-&gt;coreCtx-&gt;listeners.GetMatchingServiceListeners(unregisteringEvent, listeners);
    d-&gt;module-&gt;coreCtx-&gt;listeners.ServiceChanged(</span>
          listeners,
          unregisteringEvent);
<span style = "background-color:#dfd">  }</span>

  {
<span style = "background-color:#dfd">    MutexLock lock(d-&gt;eventLock);</span>
    {
<span style = "background-color:#dfd">      MutexLock lock2(d-&gt;propsLock);
      d-&gt;available = false;
      InterfaceMap::const_iterator factoryIter = d-&gt;service.find("org.cppmicroservices.factory");
      if (d-&gt;module &amp;&amp; factoryIter != d-&gt;service.end())</span>
      {
<span style = "background-color:#dfd">        ServiceFactory* serviceFactory = reinterpret_cast&lt;ServiceFactory*&gt;(factoryIter-&gt;second);
        ServiceRegistrationBasePrivate::ModuleToServicesMap::const_iterator end = d-&gt;prototypeServiceInstances.end();</span>

        // unget all prototype services
<span style = "background-color:#dfd">        for (ServiceRegistrationBasePrivate::ModuleToServicesMap::const_iterator i = d-&gt;prototypeServiceInstances.begin();</span>
<span style = "background-color:#fdd">             i != end; ++i)</span>
        {
<span style = "background-color:#fdd">          for (std::list&lt;InterfaceMap&gt;::const_iterator listIter = i-&gt;second.begin();
               listIter != i-&gt;second.end(); ++listIter)</span>
          {
<span style = "background-color:#fdd">            const InterfaceMap&amp; service = *listIter;</span>
            try
            {
              // NYI, don't call inside lock
<span style = "background-color:#fdd">              serviceFactory-&gt;UngetService(i-&gt;first, *this, service);</span>
            }
            catch (const std::exception&amp; /*ue*/)
<span style = "background-color:#fdd">            {
              US_WARN &lt;&lt; "ServiceFactory UngetService implementation threw an exception";
            }
          }</span>
<span style = "background-color:#dfd">        }</span>

        // unget module scope services
<span style = "background-color:#dfd">        ServiceRegistrationBasePrivate::ModuleToServiceMap::const_iterator moduleEnd = d-&gt;moduleServiceInstance.end();
        for (ServiceRegistrationBasePrivate::ModuleToServiceMap::const_iterator i = d-&gt;moduleServiceInstance.begin();</span>
<span style = "background-color:#fdd">             i != moduleEnd; ++i)</span>
        {
          try
          {
            // NYI, don't call inside lock
<span style = "background-color:#fdd">            serviceFactory-&gt;UngetService(i-&gt;first, *this, i-&gt;second);</span>
          }
          catch (const std::exception&amp; /*ue*/)
<span style = "background-color:#fdd">          {
            US_WARN &lt;&lt; "ServiceFactory UngetService implementation threw an exception";
          }
        }</span>
<span style = "background-color:#dfd">      }
      d-&gt;module = nullptr;
      d-&gt;dependents.clear();
      d-&gt;service.clear();
      d-&gt;prototypeServiceInstances.clear();
      d-&gt;moduleServiceInstance.clear();</span>
      // increment the reference count, since "d-&gt;reference" was used originally
      // to keep d alive.
<span style = "background-color:#dfd">      d-&gt;ref.Ref();
      d-&gt;reference = 0;
      d-&gt;unregistering = false;
    }
  }
}</span>

bool ServiceRegistrationBase::operator&lt;(const ServiceRegistrationBase&amp; o) const
<span style = "background-color:#dfd">{
  if ((!d &amp;&amp; !o.d) || !o.d) return false;
  if (!d) return true;
  return d-&gt;reference &lt;(o.d-&gt;reference);
}</span>

bool ServiceRegistrationBase::operator==(const ServiceRegistrationBase&amp; registration) const
<span style = "background-color:#dfd">{
  return d == registration.d;
}</span>

ServiceRegistrationBase&amp; ServiceRegistrationBase::operator=(const ServiceRegistrationBase&amp; registration)
<span style = "background-color:#dfd">{
  ServiceRegistrationBasePrivate* curr_d = d;
  d = registration.d;
  if (d) d-&gt;ref.Ref();</span>

<span style = "background-color:#dfd">  if (curr_d &amp;&amp; !curr_d-&gt;ref.Deref())</span>
<span style = "background-color:#fdd">    delete curr_d;</span>

<span style = "background-color:#dfd">  return *this;
}</span>

US_END_NAMESPACE</pre>
	</body>
</html>