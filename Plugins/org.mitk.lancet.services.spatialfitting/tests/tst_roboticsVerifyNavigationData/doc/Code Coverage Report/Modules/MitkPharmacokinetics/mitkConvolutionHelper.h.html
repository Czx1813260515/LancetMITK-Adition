<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkConvolutionHelper.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/
#ifndef mitkConvolutionHelper_h
#define mitkConvolutionHelper_h

#include "itkArray.h"
#include "mitkAIFBasedModelBase.h"
#include &lt;iostream&gt;
#include "MitkPharmacokineticsExports.h"

namespace  mitk {
/** @namespace convolution
 * @brief Helper for itk implementation of vnl fourier transformation
 * This namespace provides functions for the preperation of vnl_fft_1d, including a wrapper
 * for wrapping the convolution kernel (turning it inside out) and a function for zeropadding
 * to avoid convolution artefacts. */
  namespace convolution {

    /** Some typedefs concerning data structures needed for vnl_fft_1d, which has vnl_vector&lt; vcl_complex&lt; double &gt; &gt;
     * as output typ of the forward transformation fwd_transform. Input is of type vnl_vector&lt; vcl_complex&lt; T &gt; &gt;
     * but since itk::Array is derived from vnl_vector, this works as well*/



    /** @brief Function that wraps the kernel */
inline    itk::Array&lt;double&gt; wrap1d(itk::Array&lt;double&gt; kernel)
        {
            int dim = kernel.GetNumberOfElements();
            itk::Array&lt;double&gt; wrappedKernel(dim);
            wrappedKernel.fill(0.);
                    for(int i=0; i&lt; dim; ++i)
                    {
                        wrappedKernel.SetElement(i, kernel.GetElement((i+(dim/2))%dim));
                    }

            return wrappedKernel;
        }

    /** @brief Fuction for zeropadding (adding zeros) of an Array/vnl_vector, so that is has size paddedDimensions
     * @param unpaddedSpectrum
     * @param paddedDimension Dimensions that the Array should have after padding (convolution dimensions)
     * \remark dim = Dimensions of padded image --&gt; PaddedDimension
     * \remark m dimensions of larger image
     * \remark n dimensions of image to be padded --&gt; InitialDimension*/
   inline  itk::Array&lt;double&gt; zeropadding1d(itk::Array&lt;double&gt; unpaddedSpectrum, int paddedDimension)
        {

            int initialDimension = unpaddedSpectrum.GetNumberOfElements();

            itk::Array&lt;double&gt; paddedSpectrum(paddedDimension);
            paddedSpectrum.fill(0.);

            if(paddedDimension &gt; initialDimension)
            {
                unsigned int padding = paddedDimension - initialDimension;

                for(int i=0; i&lt;initialDimension ;++i)
                {
                    paddedSpectrum.SetElement(i+padding/2, unpaddedSpectrum.GetElement(i));
                }
            }
            return paddedSpectrum;
        }

     /** @brief Follow up function after back transformation from fourier space bwd_transform.
      * removes padding and scales (transformed values have to be divided by transformation dimensions) */
  inline  itk::Array&lt;double&gt; unpadAndScale(itk::Array&lt;double&gt; convolutionResult, int initialDimension)
        {
            int transformationDimension = convolutionResult.size();
            unsigned int padding = transformationDimension - initialDimension;

            itk::Array&lt;double&gt;  scaledResult(initialDimension);
            scaledResult.fill(0.0);

            for(int i = 0; i&lt;initialDimension; ++i)
            {
                double value = convolutionResult(i+padding/2) / transformationDimension;
                scaledResult.SetElement(i,value);
            }
            return scaledResult;
        }
    /** @brief Convinience function for preparing 2 array for convolution with each other.
     * Takes both arrays of type itk::Array, zeropadds them to the sum of their sizes and wraps
     * the one specified as kernel. Returns them as vnl_vector&lt;vcl_complex&lt;double&gt; &gt;, ready to
     * be entered in fwd_transform*/

  inline  void prepareConvolution(const itk::Array&lt;double&gt;&amp; kernel, const itk::Array&lt;double&gt;&amp; spectrum, itk::Array&lt;double&gt;&amp; preparedKernel, itk::Array&lt;double&gt;&amp; preparedSpectrum ){
        int convolutionDimensions = kernel.GetSize() + spectrum.GetSize();

//        itk::Array&lt;double&gt; paddedKernel = zeropadding1d(kernel,convolutionDimensions);
        preparedKernel=zeropadding1d(kernel,convolutionDimensions);

        preparedSpectrum = zeropadding1d(spectrum,convolutionDimensions);
//        preparedKernel = wrap1d(paddedKernel);
    }

    }

  inline itk::Array&lt;double&gt; convoluteAIFWithExponential(mitk::ModelBase::TimeGridType timeGrid, mitk::AIFBasedModelBase::AterialInputFunctionType aif, double lambda)
<span style = "background-color:#fdd">  {</span>
      /** @brief Iterative Formula to Convolve aif(t) with an exponential Residuefunction R(t) = exp(lambda*t)
       **/
      typedef itk::Array&lt;double&gt; ConvolutionResultType;
<span style = "background-color:#fdd">      ConvolutionResultType convolution(timeGrid.GetSize());
      convolution.fill(0.0);</span>

<span style = "background-color:#fdd">      convolution(0) = 0;
      for(unsigned int i = 0; i&lt; (timeGrid.GetSize()-1); ++i)</span>
      {
<span style = "background-color:#fdd">          double dt = timeGrid(i+1) - timeGrid(i);
          double m = (aif(i+1) - aif(i))/dt;
          double edt = exp(-lambda *dt);</span>

<span style = "background-color:#fdd">          convolution(i+1) =edt * convolution(i)</span>
                           + (aif(i) - m*timeGrid(i))/lambda * (1 - edt )
                           + m/(lambda * lambda) * ((lambda * timeGrid(i+1) - 1) - edt*(lambda*timeGrid(i) -1));

<span style = "background-color:#fdd">      }
      return convolution;
  }</span>


  inline itk::Array&lt;double&gt; convoluteAIFWithConstant(mitk::ModelBase::TimeGridType timeGrid, mitk::AIFBasedModelBase::AterialInputFunctionType aif, double constant)
<span style = "background-color:#fdd">  {</span>
      /** @brief Iterative Formula to Convolve aif(t) with a constant value by linear interpolation of the Aif between sampling points
       **/
      typedef itk::Array&lt;double&gt; ConvolutionResultType;
<span style = "background-color:#fdd">      ConvolutionResultType convolution(timeGrid.GetSize());
      convolution.fill(0.0);</span>

<span style = "background-color:#fdd">      convolution(0) = 0;
      for(unsigned int i = 0; i&lt; (timeGrid.GetSize()-1); ++i)</span>
      {
<span style = "background-color:#fdd">          double dt = timeGrid(i+1) - timeGrid(i);
          double m = (aif(i+1) - aif(i))/dt;</span>

<span style = "background-color:#fdd">          convolution(i+1) = convolution(i) + constant * (aif(i)*dt + m*timeGrid(i)*dt + m/2*(timeGrid(i+1)*timeGrid(i+1) - timeGrid(i)*timeGrid(i)));</span>

<span style = "background-color:#fdd">      }
      return convolution;
  }</span>

}

#endif // mitkConvolutionHelper_h</pre>
	</body>
</html>