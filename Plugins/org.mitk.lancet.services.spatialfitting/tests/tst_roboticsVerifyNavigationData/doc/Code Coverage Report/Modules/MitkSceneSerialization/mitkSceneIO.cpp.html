<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSceneIO.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;Poco/Delegate.h&gt;
#include &lt;Poco/Path.h&gt;
#include &lt;Poco/TemporaryFile.h&gt;
#include &lt;Poco/Zip/Compress.h&gt;
#include &lt;Poco/Zip/Decompress.h&gt;

#include "mitkBaseDataSerializer.h"
#include "mitkPropertyListSerializer.h"
#include "mitkSceneIO.h"
#include "mitkSceneReader.h"

#include "mitkBaseRenderer.h"
#include "mitkProgressBar.h"
#include "mitkRenderingManager.h"
#include "mitkStandaloneDataStorage.h"
#include &lt;mitkLocaleSwitch.h&gt;
#include &lt;mitkStandardFileLocations.h&gt;

#include &lt;itkObjectFactoryBase.h&gt;

#include &lt;fstream&gt;
#include &lt;mitkIOUtil.h&gt;
#include &lt;sstream&gt;

#include "itksys/SystemTools.hxx"

#include &lt;tinyxml2.h&gt;

<span style = "background-color:#fdd">mitk::SceneIO::SceneIO() : m_WorkingDirectory(""), m_UnzipErrors(0)
{
}</span>

mitk::SceneIO::~SceneIO()
<span style = "background-color:#fdd">{
}</span>

std::string mitk::SceneIO::CreateEmptyTempDirectory()
<span style = "background-color:#fdd">{
  mitk::UIDGenerator uidGen;</span>

  // std::string returnValue = mitk::StandardFileLocations::GetInstance()-&gt;GetOptionDirectory() +
  // Poco::Path::separator() + "SceneIOTemp" + uidGen.GetUID();
<span style = "background-color:#fdd">  std::string returnValue = Poco::Path::temp() + "SceneIOTemp" + uidGen.GetUID();
  std::string uniquename = returnValue + Poco::Path::separator();
  Poco::File tempdir(uniquename);</span>

  try
  {
<span style = "background-color:#fdd">    bool existsNot = tempdir.createDirectory();
    if (!existsNot)</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Warning: Directory already exitsts: " &lt;&lt; uniquename &lt;&lt; " (choosing another)";
      returnValue = mitk::StandardFileLocations::GetInstance()-&gt;GetOptionDirectory() + Poco::Path::separator() +</span>
                    "SceneIOTempDirectory" + uidGen.GetUID();
<span style = "background-color:#fdd">      uniquename = returnValue + Poco::Path::separator();
      Poco::File tempdir2(uniquename);
      if (!tempdir2.createDirectory())</span>
      {
<span style = "background-color:#fdd">        MITK_ERROR &lt;&lt; "Warning: Second directory also already exitsts: " &lt;&lt; uniquename;</span>
      }
<span style = "background-color:#fdd">    }</span>
  }
  catch (std::exception &amp;e)
<span style = "background-color:#fdd">  {
    MITK_ERROR &lt;&lt; "Could not create temporary directory " &lt;&lt; uniquename &lt;&lt; ":" &lt;&lt; e.what();
    return "";
  }</span>

<span style = "background-color:#fdd">  return returnValue;
}</span>

mitk::DataStorage::Pointer mitk::SceneIO::LoadScene(const std::string &amp;filename,
                                                    DataStorage *pStorage,
                                                    bool clearStorageFirst)
<span style = "background-color:#fdd">{
  mitk::LocaleSwitch localeSwitch("C");</span>

  // prepare data storage
<span style = "background-color:#fdd">  DataStorage::Pointer storage = pStorage;
  if (storage.IsNull())</span>
  {
<span style = "background-color:#fdd">    storage = StandaloneDataStorage::New().GetPointer();</span>
  }

  // test input filename
<span style = "background-color:#fdd">  if (filename.empty())</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "No filename given. Not possible to load scene.";
    return storage;</span>
  }

  // test if filename can be read
<span style = "background-color:#fdd">  std::ifstream file(filename.c_str(), std::ios::binary);
  if (!file.good())</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Cannot open '" &lt;&lt; filename &lt;&lt; "' for reading";
    return storage;</span>
  }

  // get new temporary directory
<span style = "background-color:#fdd">  m_WorkingDirectory = CreateEmptyTempDirectory();
  if (m_WorkingDirectory.empty())</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Could not create temporary directory. Cannot open scene files.";
    return storage;</span>
  }

  // unzip all filenames contents to temp dir
<span style = "background-color:#fdd">  m_UnzipErrors = 0;
  Poco::Zip::Decompress unzipper(file, Poco::Path(m_WorkingDirectory));
  unzipper.EError += Poco::Delegate&lt;SceneIO, std::pair&lt;const Poco::Zip::ZipLocalFileHeader, const std::string&gt;&gt;(</span>
    this, &amp;SceneIO::OnUnzipError);
<span style = "background-color:#fdd">  unzipper.EOk += Poco::Delegate&lt;SceneIO, std::pair&lt;const Poco::Zip::ZipLocalFileHeader, const Poco::Path&gt;&gt;(</span>
    this, &amp;SceneIO::OnUnzipOk);
<span style = "background-color:#fdd">  unzipper.decompressAllFiles();
  unzipper.EError -= Poco::Delegate&lt;SceneIO, std::pair&lt;const Poco::Zip::ZipLocalFileHeader, const std::string&gt;&gt;(</span>
    this, &amp;SceneIO::OnUnzipError);
<span style = "background-color:#fdd">  unzipper.EOk -= Poco::Delegate&lt;SceneIO, std::pair&lt;const Poco::Zip::ZipLocalFileHeader, const Poco::Path&gt;&gt;(</span>
    this, &amp;SceneIO::OnUnzipOk);

<span style = "background-color:#fdd">  if (m_UnzipErrors)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "There were " &lt;&lt; m_UnzipErrors &lt;&lt; " errors unzipping '" &lt;&lt; filename</span>
               &lt;&lt; "'. Will attempt to read whatever could be unzipped.";
  }

  // transcode locale-dependent string
<span style = "background-color:#fdd">  m_WorkingDirectory = Poco::Path::transcode (m_WorkingDirectory);</span>

<span style = "background-color:#fdd">  auto indexFile = m_WorkingDirectory + mitk::IOUtil::GetDirectorySeparator() + "index.xml";
  storage = LoadSceneUnzipped(indexFile, storage, clearStorageFirst);</span>

  // delete temp directory
  try
  {
<span style = "background-color:#fdd">    Poco::File deleteDir(m_WorkingDirectory);
    deleteDir.remove(true); // recursive
  }</span>
  catch (...)
<span style = "background-color:#fdd">  {
    MITK_ERROR &lt;&lt; "Could not delete temporary directory " &lt;&lt; m_WorkingDirectory;
  }</span>

  // return new data storage, even if empty or uncomplete (return as much as possible but notify calling method)
<span style = "background-color:#fdd">  return storage;
}</span>

mitk::DataStorage::Pointer mitk::SceneIO::LoadSceneUnzipped(const std::string &amp;indexfilename,
  DataStorage *pStorage,
  bool clearStorageFirst)
<span style = "background-color:#fdd">{
  mitk::LocaleSwitch localeSwitch("C");</span>

  // prepare data storage
<span style = "background-color:#fdd">  DataStorage::Pointer storage = pStorage;
  if (storage.IsNull())</span>
  {
<span style = "background-color:#fdd">    storage = StandaloneDataStorage::New().GetPointer();</span>
  }

<span style = "background-color:#fdd">  if (clearStorageFirst)</span>
  {
    try
    {
<span style = "background-color:#fdd">      storage-&gt;Remove(storage-&gt;GetAll());</span>
    }
    catch (...)
<span style = "background-color:#fdd">    {
      MITK_ERROR &lt;&lt; "DataStorage cannot be cleared properly.";
    }</span>
  }

  // test input filename
<span style = "background-color:#fdd">  if (indexfilename.empty())</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "No filename given. Not possible to load scene.";
    return storage;</span>
  }

  // transcode locale-dependent string
<span style = "background-color:#fdd">  std::string tempfilename;
  std::string workingDir;
  itksys::SystemTools::SplitProgramPath(indexfilename, workingDir, tempfilename);</span>

  // test if index.xml exists
  // parse index.xml with TinyXML
<span style = "background-color:#fdd">  tinyxml2::XMLDocument document;
  if (tinyxml2::XML_SUCCESS != document.LoadFile(indexfilename.c_str()))</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Could not open/read/parse " &lt;&lt; workingDir &lt;&lt; mitk::IOUtil::GetDirectorySeparator()</span>
      &lt;&lt; "index.xml\nTinyXML reports: " &lt;&lt; document.ErrorStr() &lt;&lt; std::endl;
<span style = "background-color:#fdd">    return storage;</span>
  }

<span style = "background-color:#fdd">  SceneReader::Pointer reader = SceneReader::New();
  if (!reader-&gt;LoadScene(document, workingDir, storage))</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "There were errors while loading scene file " &lt;&lt; indexfilename &lt;&lt; ". Your data may be corrupted";</span>
  }

  // return new data storage, even if empty or uncomplete (return as much as possible but notify calling method)
<span style = "background-color:#fdd">  return storage;
}</span>

bool mitk::SceneIO::SaveScene(DataStorage::SetOfObjects::ConstPointer sceneNodes,
                              const DataStorage *storage,
                              const std::string &amp;filename)
<span style = "background-color:#fdd">{
  if (!sceneNodes)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "No set of nodes given. Not possible to save scene.";
    return false;</span>
  }
<span style = "background-color:#fdd">  if (!storage)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "No data storage given. Not possible to save scene."; // \TODO: Technically, it would be possible to</span>
                                                                        // save the nodes without their relation
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  if (filename.empty())</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "No filename given. Not possible to save scene.";
    return false;</span>
  }

<span style = "background-color:#fdd">  mitk::LocaleSwitch localeSwitch("C");</span>

  try
  {
<span style = "background-color:#fdd">    m_FailedNodes = DataStorage::SetOfObjects::New();
    m_FailedProperties = PropertyList::New();</span>

    // start XML DOM
<span style = "background-color:#fdd">    tinyxml2::XMLDocument document;
    document.InsertEndChild(document.NewDeclaration());</span>

<span style = "background-color:#fdd">    auto *version = document.NewElement("Version");
    version-&gt;SetAttribute("Writer", __FILE__);
    version-&gt;SetAttribute("Revision", "$Revision: 17055 $");
    version-&gt;SetAttribute("FileVersion", 1);
    document.InsertEndChild(version);</span>

    // DataStorage::SetOfObjects::ConstPointer sceneNodes = storage-&gt;GetSubset( predicate );

<span style = "background-color:#fdd">    if (sceneNodes.IsNull())</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Saving empty scene to " &lt;&lt; filename;
    }</span>
    else
    {
<span style = "background-color:#fdd">      if (sceneNodes-&gt;size() == 0)</span>
      {
<span style = "background-color:#fdd">        MITK_WARN &lt;&lt; "Saving empty scene to " &lt;&lt; filename;</span>
      }

<span style = "background-color:#fdd">      MITK_INFO &lt;&lt; "Storing scene with " &lt;&lt; sceneNodes-&gt;size() &lt;&lt; " objects to " &lt;&lt; filename;</span>

<span style = "background-color:#fdd">      m_WorkingDirectory = CreateEmptyTempDirectory();
      if (m_WorkingDirectory.empty())</span>
      {
<span style = "background-color:#fdd">        MITK_ERROR &lt;&lt; "Could not create temporary directory. Cannot create scene files.";
        return false;</span>
      }

<span style = "background-color:#fdd">      ProgressBar::GetInstance()-&gt;AddStepsToDo(sceneNodes-&gt;size());</span>

      // find out about dependencies
      typedef std::map&lt;DataNode *, std::string&gt; UIDMapType;
      typedef std::map&lt;DataNode *, std::list&lt;std::string&gt;&gt; SourcesMapType;

<span style = "background-color:#fdd">      UIDMapType nodeUIDs;       // for dependencies: ID of each node
      SourcesMapType sourceUIDs; // for dependencies: IDs of a node's parent nodes</span>

<span style = "background-color:#fdd">      UIDGenerator nodeUIDGen("OBJECT_");</span>

<span style = "background-color:#fdd">      for (auto iter = sceneNodes-&gt;begin(); iter != sceneNodes-&gt;end(); ++iter)</span>
      {
<span style = "background-color:#fdd">        DataNode *node = iter-&gt;GetPointer();
        if (!node)
          continue; // unlikely event that we get a nullptr pointer as an object for saving. just ignore</span>

        // generate UIDs for all source objects
<span style = "background-color:#fdd">        DataStorage::SetOfObjects::ConstPointer sourceObjects = storage-&gt;GetSources(node);
        for (auto sourceIter = sourceObjects-&gt;begin();
             sourceIter != sourceObjects-&gt;end();
             ++sourceIter)</span>
        {
<span style = "background-color:#fdd">          if (std::find(sceneNodes-&gt;begin(), sceneNodes-&gt;end(), *sourceIter) == sceneNodes-&gt;end())
            continue; // source is not saved, so don't generate a UID for this source</span>

          // create a uid for the parent object
<span style = "background-color:#fdd">          if (nodeUIDs[*sourceIter].empty())</span>
          {
<span style = "background-color:#fdd">            nodeUIDs[*sourceIter] = nodeUIDGen.GetUID();</span>
          }

          // store this dependency for writing
<span style = "background-color:#fdd">          sourceUIDs[node].push_back(nodeUIDs[*sourceIter]);
        }</span>

<span style = "background-color:#fdd">        if (nodeUIDs[node].empty())</span>
        {
<span style = "background-color:#fdd">          nodeUIDs[node] = nodeUIDGen.GetUID();</span>
        }
<span style = "background-color:#fdd">      }</span>

      // write out objects, dependencies and properties
<span style = "background-color:#fdd">      for (auto iter = sceneNodes-&gt;begin(); iter != sceneNodes-&gt;end(); ++iter)</span>
      {
<span style = "background-color:#fdd">        DataNode *node = iter-&gt;GetPointer();</span>

<span style = "background-color:#fdd">        if (node)</span>
        {
<span style = "background-color:#fdd">          auto *nodeElement = document.NewElement("node");
          std::string filenameHint(node-&gt;GetName());
          filenameHint = itksys::SystemTools::MakeCindentifier(</span>
            filenameHint.c_str()); // escape filename &lt;-- only allow [A-Za-z0-9_], replace everything else with _

          // store dependencies
<span style = "background-color:#fdd">          auto searchUIDIter = nodeUIDs.find(node);
          if (searchUIDIter != nodeUIDs.end())</span>
          {
            // store this node's ID
<span style = "background-color:#fdd">            nodeElement-&gt;SetAttribute("UID", searchUIDIter-&gt;second.c_str());</span>
          }

<span style = "background-color:#fdd">          auto searchSourcesIter = sourceUIDs.find(node);
          if (searchSourcesIter != sourceUIDs.end())</span>
          {
            // store all source IDs
<span style = "background-color:#fdd">            for (auto sourceUIDIter = searchSourcesIter-&gt;second.begin();
                 sourceUIDIter != searchSourcesIter-&gt;second.end();
                 ++sourceUIDIter)</span>
            {
<span style = "background-color:#fdd">              auto *uidElement = document.NewElement("source");
              uidElement-&gt;SetAttribute("UID", sourceUIDIter-&gt;c_str());
              nodeElement-&gt;InsertEndChild(uidElement);
            }</span>
          }

          // store basedata
<span style = "background-color:#fdd">          if (BaseData *data = node-&gt;GetData())</span>
          {
            // std::string filenameHint( node-&gt;GetName() );
<span style = "background-color:#fdd">            bool error(false);
            auto *dataElement = SaveBaseData(document, data, filenameHint, error); // returns a reference to a file
            if (error)</span>
            {
<span style = "background-color:#fdd">              m_FailedNodes-&gt;push_back(node);</span>
            }

            // store basedata properties
<span style = "background-color:#fdd">            PropertyList *propertyList = data-&gt;GetPropertyList();
            if (propertyList &amp;&amp; !propertyList-&gt;IsEmpty())</span>
            {
<span style = "background-color:#fdd">              auto *baseDataPropertiesElement =</span>
                SavePropertyList(document, propertyList, filenameHint + "-data"); // returns a reference to a file
<span style = "background-color:#fdd">              dataElement-&gt;InsertEndChild(baseDataPropertiesElement);</span>
            }

<span style = "background-color:#fdd">            nodeElement-&gt;InsertEndChild(dataElement);</span>
          }

          // store all renderwindow specific propertylists
<span style = "background-color:#fdd">          mitk::DataNode::PropertyListKeyNames propertyListKeys = node-&gt;GetPropertyListNames();
          for (const auto &amp;renderWindowName : propertyListKeys)</span>
          {
<span style = "background-color:#fdd">            PropertyList *propertyList = node-&gt;GetPropertyList(renderWindowName);
            if (propertyList &amp;&amp; !propertyList-&gt;IsEmpty())</span>
            {
<span style = "background-color:#fdd">              auto *renderWindowPropertiesElement =</span>
                SavePropertyList(document, propertyList, filenameHint + "-" + renderWindowName); // returns a reference to a file
<span style = "background-color:#fdd">              renderWindowPropertiesElement-&gt;SetAttribute("renderwindow", renderWindowName.c_str());
              nodeElement-&gt;InsertEndChild(renderWindowPropertiesElement);</span>
            }
<span style = "background-color:#fdd">          }</span>

          // don't forget the renderwindow independent list
<span style = "background-color:#fdd">          PropertyList *propertyList = node-&gt;GetPropertyList();
          if (propertyList &amp;&amp; !propertyList-&gt;IsEmpty())</span>
          {
<span style = "background-color:#fdd">            auto *propertiesElement =</span>
              SavePropertyList(document, propertyList, filenameHint + "-node"); // returns a reference to a file
<span style = "background-color:#fdd">            nodeElement-&gt;InsertEndChild(propertiesElement);</span>
          }
<span style = "background-color:#fdd">          document.InsertEndChild(nodeElement);
        }</span>
        else
        {
<span style = "background-color:#fdd">          MITK_WARN &lt;&lt; "Ignoring nullptr node during scene serialization.";</span>
        }

<span style = "background-color:#fdd">        ProgressBar::GetInstance()-&gt;Progress();
      } // end for all nodes
    }   // end if sceneNodes</span>

<span style = "background-color:#fdd">    std::string defaultLocale_WorkingDirectory = Poco::Path::transcode( m_WorkingDirectory );</span>

<span style = "background-color:#fdd">    auto xmlFilename = defaultLocale_WorkingDirectory + Poco::Path::separator() + "index.xml";
    if (tinyxml2::XML_SUCCESS != document.SaveFile(xmlFilename.c_str()))</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Could not write scene to " &lt;&lt; defaultLocale_WorkingDirectory &lt;&lt; Poco::Path::separator() &lt;&lt; "index.xml"</span>
                 &lt;&lt; "\nTinyXML reports '" &lt;&lt; document.ErrorStr() &lt;&lt; "'";
<span style = "background-color:#fdd">      return false;
    }</span>
    else
    {
      try
      {
<span style = "background-color:#fdd">        Poco::File deleteFile(filename.c_str());
        if (deleteFile.exists())</span>
        {
<span style = "background-color:#fdd">          deleteFile.remove();</span>
        }

        // create zip at filename
<span style = "background-color:#fdd">        std::ofstream file(filename.c_str(), std::ios::binary | std::ios::out);
        if (!file.good())</span>
        {
<span style = "background-color:#fdd">          MITK_ERROR &lt;&lt; "Could not open a zip file for writing: '" &lt;&lt; filename &lt;&lt; "'";
          return false;
        }</span>
        else
        {
<span style = "background-color:#fdd">          Poco::Zip::Compress zipper(file, true);
          Poco::Path tmpdir(m_WorkingDirectory);
          zipper.addRecursive(tmpdir);
          zipper.close();
        }</span>
        try
        {
<span style = "background-color:#fdd">          Poco::File deleteDir(m_WorkingDirectory);
          deleteDir.remove(true); // recursive
        }</span>
        catch (...)
<span style = "background-color:#fdd">        {
          MITK_ERROR &lt;&lt; "Could not delete temporary directory " &lt;&lt; m_WorkingDirectory;
          return false; // ok?
        }
      }</span>
      catch (std::exception &amp;e)
<span style = "background-color:#fdd">      {
        MITK_ERROR &lt;&lt; "Could not create ZIP file from " &lt;&lt; m_WorkingDirectory &lt;&lt; "\nReason: " &lt;&lt; e.what();
        return false;
      }
      return true;</span>
    }
<span style = "background-color:#fdd">  }</span>
  catch (std::exception &amp;e)
<span style = "background-color:#fdd">  {
    MITK_ERROR &lt;&lt; "Caught exception during saving temporary files to disk. Error description: '" &lt;&lt; e.what() &lt;&lt; "'";
    return false;
  }
}</span>

tinyxml2::XMLElement *mitk::SceneIO::SaveBaseData(tinyxml2::XMLDocument &amp;doc, BaseData *data, const std::string &amp;filenamehint, bool &amp;error)
<span style = "background-color:#fdd">{
  assert(data);
  error = true;</span>

  // find correct serializer
  // the serializer must
  //  - create a file containing all information to recreate the BaseData object --&gt; needs to know where to put this
  //  file (and a filename?)
  //  - TODO what to do about writers that creates one file per timestep?
<span style = "background-color:#fdd">  auto *element = doc.NewElement("data");
  element-&gt;SetAttribute("type", data-&gt;GetNameOfClass());</span>

  // construct name of serializer class
<span style = "background-color:#fdd">  std::string serializername(data-&gt;GetNameOfClass());
  serializername += "Serializer";</span>

<span style = "background-color:#fdd">  std::list&lt;itk::LightObject::Pointer&gt; thingsThatCanSerializeThis =</span>
    itk::ObjectFactoryBase::CreateAllInstance(serializername.c_str());
<span style = "background-color:#fdd">  if (thingsThatCanSerializeThis.size() &lt; 1)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "No serializer found for " &lt;&lt; data-&gt;GetNameOfClass() &lt;&lt; ". Skipping object";</span>
  }

<span style = "background-color:#fdd">  for (auto iter = thingsThatCanSerializeThis.begin();
       iter != thingsThatCanSerializeThis.end();
       ++iter)</span>
  {
<span style = "background-color:#fdd">    if (auto *serializer = dynamic_cast&lt;BaseDataSerializer *&gt;(iter-&gt;GetPointer()))</span>
    {
<span style = "background-color:#fdd">      serializer-&gt;SetData(data);
      serializer-&gt;SetFilenameHint(filenamehint);
      std::string defaultLocale_WorkingDirectory = Poco::Path::transcode( m_WorkingDirectory );
      serializer-&gt;SetWorkingDirectory(defaultLocale_WorkingDirectory);</span>
      try
      {
<span style = "background-color:#fdd">        std::string writtenfilename = serializer-&gt;Serialize();
        element-&gt;SetAttribute("file", writtenfilename.c_str());
        error = false;
      }</span>
      catch (std::exception &amp;e)
<span style = "background-color:#fdd">      {
        MITK_ERROR &lt;&lt; "Serializer " &lt;&lt; serializer-&gt;GetNameOfClass() &lt;&lt; " failed: " &lt;&lt; e.what();
      }
      break;
    }
  }
  element-&gt;SetAttribute("UID", data-&gt;GetUID().c_str());</span>

<span style = "background-color:#fdd">  return element;
}</span>

tinyxml2::XMLElement *mitk::SceneIO::SavePropertyList(tinyxml2::XMLDocument &amp;doc, PropertyList *propertyList, const std::string &amp;filenamehint)
<span style = "background-color:#fdd">{
  assert(propertyList);</span>

  //  - TODO what to do about shared properties (same object in two lists or behind several keys)?
<span style = "background-color:#fdd">  auto *element = doc.NewElement("properties");</span>

  // construct name of serializer class
<span style = "background-color:#fdd">  PropertyListSerializer::Pointer serializer = PropertyListSerializer::New();</span>

<span style = "background-color:#fdd">  serializer-&gt;SetPropertyList(propertyList);
  serializer-&gt;SetFilenameHint(filenamehint);
  std::string defaultLocale_WorkingDirectory = Poco::Path::transcode( m_WorkingDirectory );
  serializer-&gt;SetWorkingDirectory(defaultLocale_WorkingDirectory);</span>
  try
  {
<span style = "background-color:#fdd">    std::string writtenfilename = serializer-&gt;Serialize();
    element-&gt;SetAttribute("file", writtenfilename.c_str());
    PropertyList::Pointer failedProperties = serializer-&gt;GetFailedProperties();
    if (failedProperties.IsNotNull())</span>
    {
      // move failed properties to global list
<span style = "background-color:#fdd">      m_FailedProperties-&gt;ConcatenatePropertyList(failedProperties, true);</span>
    }
<span style = "background-color:#fdd">  }</span>
  catch (std::exception &amp;e)
<span style = "background-color:#fdd">  {
    MITK_ERROR &lt;&lt; "Serializer " &lt;&lt; serializer-&gt;GetNameOfClass() &lt;&lt; " failed: " &lt;&lt; e.what();
  }</span>

<span style = "background-color:#fdd">  return element;
}</span>

const mitk::SceneIO::FailedBaseDataListType *mitk::SceneIO::GetFailedNodes()
<span style = "background-color:#fdd">{
  return m_FailedNodes.GetPointer();
}</span>

const mitk::PropertyList *mitk::SceneIO::GetFailedProperties()
<span style = "background-color:#fdd">{
  return m_FailedProperties;
}</span>

void mitk::SceneIO::OnUnzipError(const void * /*pSender*/,
                                 std::pair&lt;const Poco::Zip::ZipLocalFileHeader, const std::string&gt; &amp;info)
<span style = "background-color:#fdd">{
  ++m_UnzipErrors;
  MITK_ERROR &lt;&lt; "Error while unzipping: " &lt;&lt; info.second;
}</span>

void mitk::SceneIO::OnUnzipOk(const void * /*pSender*/,
                              std::pair&lt;const Poco::Zip::ZipLocalFileHeader, const Poco::Path&gt; &amp; /*info*/)
<span style = "background-color:#fdd">{</span>
  // MITK_INFO &lt;&lt; "Unzipped ok: " &lt;&lt; info.second.toString();
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>