<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSceneReaderV1.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkSceneReaderV1.h"
#include "Poco/Path.h"
#include "mitkBaseRenderer.h"
#include "mitkIOUtil.h"
#include "mitkProgressBar.h"
#include "mitkPropertyListDeserializer.h"
#include "mitkSerializerMacros.h"
#include &lt;mitkUIDManipulator.h&gt;
#include &lt;mitkRenderingModeProperty.h&gt;
#include &lt;tinyxml2.h&gt;

<span style = "background-color:#dfd">MITK_REGISTER_SERIALIZER(SceneReaderV1)</span>

namespace
{
  typedef std::pair&lt;mitk::DataNode::Pointer, std::list&lt;std::string&gt;&gt; NodesAndParentsPair;

  bool NodeSortByLayerIsLessThan(const NodesAndParentsPair &amp;left, const NodesAndParentsPair &amp;right)
<span style = "background-color:#fdd">  {
    if (left.first.IsNotNull() &amp;&amp; right.first.IsNotNull())</span>
    {
      int leftLayer;
      int rightLayer;
<span style = "background-color:#fdd">      if (left.first-&gt;GetIntProperty("layer", leftLayer) &amp;&amp; right.first-&gt;GetIntProperty("layer", rightLayer))</span>
      {
<span style = "background-color:#fdd">        return leftLayer &lt; rightLayer;
      }</span>
      else
      {
        // fall back to name sort
<span style = "background-color:#fdd">        return left.first-&gt;GetName() &lt; right.first-&gt;GetName();</span>
      }
    }

    // in all other cases, fall back to stupid pointer comparison
    // this is not reasonable but at least answers the sorting
    // question clearly
<span style = "background-color:#fdd">    return left.first.GetPointer() &lt; right.first.GetPointer();
  }</span>

  // This is a workaround until we are able to save time-related information in an
  // actual file format of surfaces.
  void ApplyProportionalTimeGeometryProperties(mitk::BaseData* data)
<span style = "background-color:#fdd">  {
    if (nullptr == data)
      return;</span>

<span style = "background-color:#fdd">    auto properties = data-&gt;GetPropertyList();</span>

<span style = "background-color:#fdd">    if (properties.IsNull())
      return;</span>

<span style = "background-color:#fdd">    auto* geometry = dynamic_cast&lt;mitk::ProportionalTimeGeometry*&gt;(data-&gt;GetTimeGeometry());</span>

<span style = "background-color:#fdd">    if (nullptr == geometry)
      return;</span>

<span style = "background-color:#fdd">    float value = 0.0f;</span>

<span style = "background-color:#fdd">    if (properties-&gt;GetFloatProperty("ProportionalTimeGeometry.FirstTimePoint", value))</span>
    {
<span style = "background-color:#fdd">      if (value == -std::numeric_limits&lt;float&gt;::infinity())
        value = std::numeric_limits&lt;float&gt;::lowest();</span>

<span style = "background-color:#fdd">      geometry-&gt;SetFirstTimePoint(value);</span>
    }

<span style = "background-color:#fdd">    if (properties-&gt;GetFloatProperty("ProportionalTimeGeometry.StepDuration", value))
      geometry-&gt;SetStepDuration(value);
  }</span>
}

bool mitk::SceneReaderV1::LoadScene(tinyxml2::XMLDocument &amp;document, const std::string &amp;workingDirectory, DataStorage *storage)
<span style = "background-color:#fdd">{
  assert(storage);
  bool error(false);</span>

  // TODO prepare to detect errors (such as cycles) from wrongly written or edited xml files

  // Get number of elements to initialze progress bar
  //   1. if there is a &lt;data type="..." file="..."&gt; element,
  //        - construct a name for the appropriate serializer
  //        - try to instantiate this serializer via itk object factory
  //        - if serializer could be created, use it to read the file into a BaseData object
  //        - if successful, call the new node's SetData(..)

  // create a node for the tag "data" and test if node was created
  typedef std::vector&lt;mitk::DataNode::Pointer&gt; DataNodeVector;
<span style = "background-color:#fdd">  DataNodeVector DataNodes;
  unsigned int listSize = 0;
  for (auto *element = document.FirstChildElement("node"); element != nullptr;
       element = element-&gt;NextSiblingElement("node"))</span>
  {
<span style = "background-color:#fdd">    ++listSize;
  }</span>

<span style = "background-color:#fdd">  ProgressBar::GetInstance()-&gt;AddStepsToDo(listSize * 2);</span>

<span style = "background-color:#fdd">  for (auto *element = document.FirstChildElement("node"); element != nullptr;
       element = element-&gt;NextSiblingElement("node"))</span>
  {
<span style = "background-color:#fdd">    DataNodes.push_back(LoadBaseDataFromDataTag(element-&gt;FirstChildElement("data"), workingDirectory, error));
    ProgressBar::GetInstance()-&gt;Progress();
  }</span>

  // iterate all nodes
  // first level nodes should be &lt;node&gt; elements
<span style = "background-color:#fdd">  auto nit = DataNodes.begin();
  for (auto *element = document.FirstChildElement("node"); element != nullptr || nit != DataNodes.end();
       element = element-&gt;NextSiblingElement("node"), ++nit)</span>
  {
<span style = "background-color:#fdd">    mitk::DataNode::Pointer node = *nit;</span>
    // in case dataXmlElement is valid test whether it containts the "properties" child tag
    // and process further if and only if yes
<span style = "background-color:#fdd">    auto *dataXmlElement = element-&gt;FirstChildElement("data");
    if (dataXmlElement &amp;&amp; dataXmlElement-&gt;FirstChildElement("properties"))</span>
    {
<span style = "background-color:#fdd">      auto *baseDataElement = dataXmlElement-&gt;FirstChildElement("properties");
      if (node-&gt;GetData())</span>
      {
<span style = "background-color:#fdd">        DecorateBaseDataWithProperties(node-&gt;GetData(), baseDataElement, workingDirectory);
        ApplyProportionalTimeGeometryProperties(node-&gt;GetData());
      }</span>
      else
      {
<span style = "background-color:#fdd">        MITK_WARN &lt;&lt; "BaseData properties stored in scene file, but BaseData could not be read" &lt;&lt; std::endl;</span>
      }
    }

    //   2. check child nodes
<span style = "background-color:#fdd">    const char *uida = element-&gt;Attribute("UID");
    std::string uid("");</span>

<span style = "background-color:#fdd">    if (uida)</span>
    {
<span style = "background-color:#fdd">      uid = uida;
      m_NodeForID[uid] = node.GetPointer();
      m_IDForNode[node.GetPointer()] = uid;
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "No UID found for current node. Node will have no parents.";
      error = true;</span>
    }

    //   3. if there are &lt;properties&gt; nodes,
    //        - instantiate the appropriate PropertyListDeSerializer
    //        - use them to construct PropertyList objects
    //        - add these properties to the node (if necessary, use renderwindow name)
<span style = "background-color:#fdd">    bool success = DecorateNodeWithProperties(node, element, workingDirectory);
    if (!success)</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Could not load properties for node.";
      error = true;</span>
    }

    // remember node for later adding to DataStorage
<span style = "background-color:#fdd">    m_OrderedNodePairs.push_back(std::make_pair(node, std::list&lt;std::string&gt;()));</span>

    //   4. if there are &lt;source&gt; elements, remember parent objects
<span style = "background-color:#fdd">    for (auto *source = element-&gt;FirstChildElement("source"); source != nullptr;
         source = source-&gt;NextSiblingElement("source"))</span>
    {
<span style = "background-color:#fdd">      const char *sourceUID = source-&gt;Attribute("UID");
      if (sourceUID)</span>
      {
<span style = "background-color:#fdd">        m_OrderedNodePairs.back().second.push_back(std::string(sourceUID));</span>
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    ProgressBar::GetInstance()-&gt;Progress();
  } // end for all &lt;node&gt;</span>

  // sort our nodes by their "layer" property
  // (to be inserted in that order)
<span style = "background-color:#fdd">  m_OrderedNodePairs.sort(&amp;NodeSortByLayerIsLessThan);</span>

  // remove all unknown parent UIDs
<span style = "background-color:#fdd">  for (auto nodesIter = m_OrderedNodePairs.begin(); nodesIter != m_OrderedNodePairs.end();
       ++nodesIter)</span>
  {
<span style = "background-color:#fdd">    for (auto parentsIter = nodesIter-&gt;second.begin();
         parentsIter != nodesIter-&gt;second.end();)</span>
    {
<span style = "background-color:#fdd">      if (m_NodeForID.find(*parentsIter) == m_NodeForID.end())</span>
      {
<span style = "background-color:#fdd">        parentsIter = nodesIter-&gt;second.erase(parentsIter);
        MITK_WARN &lt;&lt; "Found a DataNode with unknown parents. Will add it to DataStorage without any parent objects.";
        error = true;
      }</span>
      else
      {
<span style = "background-color:#fdd">        ++parentsIter;
      }
    }
  }</span>

  // repeat the following loop ...
  //   ... for all created nodes
<span style = "background-color:#fdd">  unsigned int lastMapSize(0);
  while (lastMapSize !=</span>
         m_OrderedNodePairs
           .size()) // this is to prevent infinite loops; each iteration must at least add one node to DataStorage
  {
<span style = "background-color:#fdd">    lastMapSize = m_OrderedNodePairs.size();</span>

    // iterate (layer) ordered nodes backwards
    // we insert the highest layers first
<span style = "background-color:#fdd">    for (auto nodesIter = m_OrderedNodePairs.begin(); nodesIter != m_OrderedNodePairs.end();
         ++nodesIter)</span>
    {
<span style = "background-color:#fdd">      bool addThisNode(true);</span>

      // if any parent node is not yet in DataStorage, skip node for now and check later
<span style = "background-color:#fdd">      for (auto parentsIter = nodesIter-&gt;second.begin();
           parentsIter != nodesIter-&gt;second.end();
           ++parentsIter)</span>
      {
<span style = "background-color:#fdd">        if (!storage-&gt;Exists(m_NodeForID[*parentsIter]))</span>
        {
<span style = "background-color:#fdd">          addThisNode = false;
          break;
        }
      }</span>

<span style = "background-color:#fdd">      if (addThisNode)</span>
      {
<span style = "background-color:#fdd">        DataStorage::SetOfObjects::Pointer parents = DataStorage::SetOfObjects::New();
        for (auto parentsIter = nodesIter-&gt;second.begin();
             parentsIter != nodesIter-&gt;second.end();
             ++parentsIter)</span>
        {
<span style = "background-color:#fdd">          parents-&gt;push_back(m_NodeForID[*parentsIter]);
        }</span>

        // if all parents are found in datastorage (or are unknown), add node to DataStorage
<span style = "background-color:#fdd">        storage-&gt;Add(nodesIter-&gt;first, parents);</span>

        // remove this node from m_OrderedNodePairs
<span style = "background-color:#fdd">        m_OrderedNodePairs.erase(nodesIter);</span>

        // break this for loop because iterators are probably invalid
<span style = "background-color:#fdd">        break;
      }
    }
  }</span>

  // All nodes that are still in m_OrderedNodePairs at this point are not part of a proper directed graph structure.
  // We'll add such nodes without any parent information.
<span style = "background-color:#fdd">  for (auto nodesIter = m_OrderedNodePairs.begin(); nodesIter != m_OrderedNodePairs.end();
       ++nodesIter)</span>
  {
<span style = "background-color:#fdd">    storage-&gt;Add(nodesIter-&gt;first);
    MITK_WARN &lt;&lt; "Encountered node that is not part of a directed graph structure. Will be added to DataStorage "</span>
                 "without parents.";
<span style = "background-color:#fdd">    error = true;
  }</span>

<span style = "background-color:#fdd">  return !error;
}</span>

mitk::DataNode::Pointer mitk::SceneReaderV1::LoadBaseDataFromDataTag(const tinyxml2::XMLElement *dataElement,
                                                                     const std::string &amp;workingDirectory,
                                                                     bool &amp;error)
<span style = "background-color:#fdd">{
  DataNode::Pointer node;</span>

<span style = "background-color:#fdd">  if (dataElement)</span>
  {
<span style = "background-color:#fdd">    const char *filename = dataElement-&gt;Attribute("file");
    if (filename &amp;&amp; strlen(filename) != 0)</span>
    {
      try
      {
<span style = "background-color:#fdd">        std::vector&lt;BaseData::Pointer&gt; baseData = IOUtil::Load(workingDirectory + Poco::Path::separator() + filename);
        if (baseData.size() &gt; 1)</span>
        {
<span style = "background-color:#fdd">          MITK_WARN &lt;&lt; "Discarding multiple base data results from " &lt;&lt; filename &lt;&lt; " except the first one.";</span>
        }
<span style = "background-color:#fdd">        node = DataNode::New();
        node-&gt;SetData(baseData.front());
      }</span>
      catch (std::exception &amp;e)
<span style = "background-color:#fdd">      {
        MITK_ERROR &lt;&lt; "Error during attempt to read '" &lt;&lt; filename &lt;&lt; "'. Exception says: " &lt;&lt; e.what();
        error = true;
      }</span>

<span style = "background-color:#fdd">      if (node.IsNull())</span>
      {
<span style = "background-color:#fdd">        MITK_ERROR &lt;&lt; "Error during attempt to read '" &lt;&lt; filename &lt;&lt; "'. Factory returned nullptr object.";
        error = true;</span>
      }
    }

<span style = "background-color:#fdd">    const char* dataUID = dataElement-&gt;Attribute("UID");
    if (!error &amp;&amp; dataUID != nullptr)</span>
    {
<span style = "background-color:#fdd">      UIDManipulator manip(node-&gt;GetData());
      manip.SetUID(dataUID);
    }</span>
  }

  // in case there was no &lt;data&gt; element we create a new empty node (for appending a propertylist later)
<span style = "background-color:#fdd">  if (node.IsNull())</span>
  {
<span style = "background-color:#fdd">    node = DataNode::New();</span>
  }

<span style = "background-color:#fdd">  return node;
}</span>

void mitk::SceneReaderV1::ClearNodePropertyListWithExceptions(DataNode &amp;node, PropertyList &amp;propertyList)
<span style = "background-color:#fdd">{</span>
  // Basically call propertyList.Clear(), but implement exceptions (see bug 19354)
<span style = "background-color:#fdd">  BaseData *data = node.GetData();</span>

<span style = "background-color:#fdd">  PropertyList::Pointer propertiesToKeep = PropertyList::New();</span>

<span style = "background-color:#fdd">  if (dynamic_cast&lt;Image *&gt;(data))</span>
  {
    /*
      Older scene files (before changes of bug 17547) could contain
      a RenderingMode property with value "LevelWindow_Color".
      Since bug 17547 this value has been removed and replaced by
      the default value LookupTable_LevelWindow_Color.

      This new default value does only result in "black-to-white"
      CT images (or others) if there is a corresponding lookup
      table. Such a lookup table is provided as a default value
      by the Image mapper. Since that value was never present in
      older scene files, we do well in not removing the new
      default value here. Otherwise the mapper would fall back
      to another default which is all the colors of the rainbow :-(
    */
<span style = "background-color:#fdd">    BaseProperty::Pointer lutProperty = propertyList.GetProperty("LookupTable");
    propertiesToKeep-&gt;SetProperty("LookupTable", lutProperty);</span>

    /*
      Older scene files (before changes of T14807) may contain
      multi-component images without the "Image.Displayed Component"
      property.

      As the treatment as multi-component image and the corresponding
      visualization options hinges on that property we should not delete
      it, if it was added by the mapper.

      This is a fix for the issue reported in T19919.
    */
<span style = "background-color:#fdd">    BaseProperty::Pointer compProperty = propertyList.GetProperty("Image.Displayed Component");
    if (compProperty.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      propertiesToKeep-&gt;SetProperty("Image.Displayed Component", compProperty);</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  propertyList.Clear();</span>

<span style = "background-color:#fdd">  propertyList.ConcatenatePropertyList(propertiesToKeep);
}</span>

bool mitk::SceneReaderV1::DecorateNodeWithProperties(DataNode *node,
                                                     const tinyxml2::XMLElement *nodeElement,
                                                     const std::string &amp;workingDirectory)
<span style = "background-color:#fdd">{
  assert(node);
  assert(nodeElement);
  bool error(false);</span>

<span style = "background-color:#fdd">  for (auto *properties = nodeElement-&gt;FirstChildElement("properties"); properties != nullptr;
       properties = properties-&gt;NextSiblingElement("properties"))</span>
  {
<span style = "background-color:#fdd">    const char *propertiesfilea(properties-&gt;Attribute("file"));
    std::string propertiesfile(propertiesfilea ? propertiesfilea : "");</span>

<span style = "background-color:#fdd">    const char *renderwindowa(properties-&gt;Attribute("renderwindow"));
    std::string renderwindow(renderwindowa ? renderwindowa : "");</span>

<span style = "background-color:#fdd">    PropertyList::Pointer propertyList =</span>
      node-&gt;GetPropertyList(renderwindow); // DataNode implementation always returns a propertylist
<span style = "background-color:#fdd">    ClearNodePropertyListWithExceptions(*node, *propertyList);</span>

    // use deserializer to construct new properties
<span style = "background-color:#fdd">    PropertyListDeserializer::Pointer deserializer = PropertyListDeserializer::New();</span>

<span style = "background-color:#fdd">    deserializer-&gt;SetFilename(workingDirectory + Poco::Path::separator() + propertiesfile);
    bool success = deserializer-&gt;Deserialize();
    error |= !success;
    PropertyList::Pointer readProperties = deserializer-&gt;GetOutput();</span>

<span style = "background-color:#fdd">    if (readProperties.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      propertyList-&gt;ConcatenatePropertyList(readProperties, true); // true = replace
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Property list reader did not return a property list. This is an implementation error. Please tell "</span>
                    "your developer.";
<span style = "background-color:#fdd">      error = true;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return !error;
}</span>

bool mitk::SceneReaderV1::DecorateBaseDataWithProperties(BaseData::Pointer data,
                                                         const tinyxml2::XMLElement *baseDataNodeElem,
                                                         const std::string &amp;workingDir)
<span style = "background-color:#fdd">{</span>
  // check given variables, initialize error variable
<span style = "background-color:#fdd">  assert(baseDataNodeElem);
  bool error(false);</span>

  // get the file name stored in the &lt;properties ...&gt; tag
<span style = "background-color:#fdd">  const char *baseDataPropertyFile(baseDataNodeElem-&gt;Attribute("file"));</span>
  // check if the filename was found
<span style = "background-color:#fdd">  if (baseDataPropertyFile)</span>
  {
    // PropertyList::Pointer dataPropList = data-&gt;GetPropertyList();

<span style = "background-color:#fdd">    PropertyListDeserializer::Pointer propertyDeserializer = PropertyListDeserializer::New();</span>

    // initialize the property reader
<span style = "background-color:#fdd">    propertyDeserializer-&gt;SetFilename(workingDir + Poco::Path::separator() + baseDataPropertyFile);
    bool ioSuccess = propertyDeserializer-&gt;Deserialize();
    error = !ioSuccess;</span>

    // get the output
<span style = "background-color:#fdd">    PropertyList::Pointer inProperties = propertyDeserializer-&gt;GetOutput();</span>

    // store the read-in properties to the given node or throw error otherwise
<span style = "background-color:#fdd">    if (inProperties.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      data-&gt;SetPropertyList(inProperties);
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "The property deserializer did not return a (valid) property list.";
      error = true;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Function DecorateBaseDataWithProperties(...) called with false XML element. \n \t -&gt;Given element "</span>
                  "does not contain a 'file' attribute. \n";
<span style = "background-color:#fdd">    error = true;</span>
  }

<span style = "background-color:#fdd">  return !error;
}</span></pre>
	</body>
</html>