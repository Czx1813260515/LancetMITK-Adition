<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageMappingHelper.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;itkInterpolateImageFunction.h&gt;
#include &lt;itkNearestNeighborInterpolateImageFunction.h&gt;
#include &lt;itkLinearInterpolateImageFunction.h&gt;
#include &lt;itkBSplineInterpolateImageFunction.h&gt;
#include &lt;itkWindowedSincInterpolateImageFunction.h&gt;

#include &lt;mitkImageAccessByItk.h&gt;
#include &lt;mitkImageCast.h&gt;
#include &lt;mitkGeometry3D.h&gt;
#include &lt;mitkImageToItk.h&gt;
#include &lt;mitkImageTimeSelector.h&gt;
#include &lt;mitkLabelSetImage.h&gt;

#include "mapRegistration.h"

#include "mitkImageMappingHelper.h"
#include "mitkRegistrationHelper.h"

template &lt;typename TImage &gt;
typename ::itk::InterpolateImageFunction&lt; TImage &gt;::Pointer generateInterpolator(mitk::ImageMappingInterpolator::Type interpolatorType)
<span style = "background-color:#fdd">{</span>
  typedef ::itk::InterpolateImageFunction&lt; TImage &gt; BaseInterpolatorType;
<span style = "background-color:#fdd">  typename BaseInterpolatorType::Pointer result;</span>

<span style = "background-color:#fdd">  switch (interpolatorType)</span>
  {
  case mitk::ImageMappingInterpolator::NearestNeighbor:
    {
<span style = "background-color:#fdd">      result = ::itk::NearestNeighborInterpolateImageFunction&lt;TImage&gt;::New();
      break;</span>
    }
  case mitk::ImageMappingInterpolator::BSpline_3:
    {
<span style = "background-color:#fdd">      typename ::itk::BSplineInterpolateImageFunction&lt;TImage&gt;::Pointer spInterpolator = ::itk::BSplineInterpolateImageFunction&lt;TImage&gt;::New();
      spInterpolator-&gt;SetSplineOrder(3);
      result = spInterpolator;
      break;
    }</span>
  case mitk::ImageMappingInterpolator::WSinc_Hamming:
    {
<span style = "background-color:#fdd">      result = ::itk::WindowedSincInterpolateImageFunction&lt;TImage,4&gt;::New();
      break;</span>
    }
  case mitk::ImageMappingInterpolator::WSinc_Welch:
    {
<span style = "background-color:#fdd">      result = ::itk::WindowedSincInterpolateImageFunction&lt;TImage,4,::itk::Function::WelchWindowFunction&lt;4&gt; &gt;::New();
      break;</span>
    }
  default:
    {
<span style = "background-color:#fdd">      result = ::itk::LinearInterpolateImageFunction&lt;TImage&gt;::New();</span>
      break;
    }

  }

<span style = "background-color:#fdd">  return result;
};</span>

template &lt;typename TPixelType, unsigned int VImageDimension &gt;
void doMITKMap(const ::itk::Image&lt;TPixelType,VImageDimension&gt;* input, mitk::ImageMappingHelper::ResultImageType::Pointer&amp; result, const mitk::ImageMappingHelper::RegistrationType*&amp; registration,
  bool throwOnOutOfInputAreaError, const double&amp; paddingValue, const mitk::ImageMappingHelper::ResultImageGeometryType*&amp; resultGeometry,
  bool throwOnMappingError, const double&amp; errorValue, mitk::ImageMappingInterpolator::Type interpolatorType)
<span style = "background-color:#fdd">{</span>
  typedef ::map::core::Registration&lt;VImageDimension,VImageDimension&gt; ConcreteRegistrationType;
  typedef ::map::core::ImageMappingTask&lt;ConcreteRegistrationType, ::itk::Image&lt;TPixelType,VImageDimension&gt;, ::itk::Image&lt;TPixelType,VImageDimension&gt; &gt; MappingTaskType;
<span style = "background-color:#fdd">  typename MappingTaskType::Pointer spTask = MappingTaskType::New();</span>

  typedef typename MappingTaskType::ResultImageDescriptorType ResultImageDescriptorType;
<span style = "background-color:#fdd">  typename ResultImageDescriptorType::Pointer resultDescriptor;</span>

  //check if image and result geometry fits the passed registration
  /////////////////////////////////////////////////////////////////
<span style = "background-color:#fdd">  if (registration-&gt;getMovingDimensions()!=VImageDimension)</span>
  {
<span style = "background-color:#fdd">    map::core::OStringStream str;
    str &lt;&lt; "Dimension of MITK image ("&lt;&lt;VImageDimension&lt;&lt;") does not equal the moving dimension of the registration object ("&lt;&lt;registration-&gt;getMovingDimensions()&lt;&lt;").";
    throw mitk::AccessByItkException(str.str());
  }</span>

<span style = "background-color:#fdd">  if (registration-&gt;getTargetDimensions()!=VImageDimension)</span>
  {
<span style = "background-color:#fdd">    map::core::OStringStream str;
    str &lt;&lt; "Dimension of MITK image ("&lt;&lt;VImageDimension&lt;&lt;") does not equal the target dimension of the registration object ("&lt;&lt;registration-&gt;getTargetDimensions()&lt;&lt;").";
    throw mitk::AccessByItkException(str.str());
  }</span>

<span style = "background-color:#fdd">  const ConcreteRegistrationType* castedReg = dynamic_cast&lt;const ConcreteRegistrationType*&gt;(registration);</span>

<span style = "background-color:#fdd">  if (registration-&gt;getTargetDimensions()==2 &amp;&amp; resultGeometry)</span>
  {
<span style = "background-color:#fdd">    mitk::ImageMappingHelper::ResultImageGeometryType::BoundsArrayType bounds = resultGeometry-&gt;GetBounds();</span>

<span style = "background-color:#fdd">    if (bounds[4]!=0 || bounds[5]!=0)</span>
    {
      //array "bounds" is constructed as [min Dim1, max Dim1, min Dim2, max Dim2, min Dim3, max Dim3]
      //therfore [4] and [5] must be 0

<span style = "background-color:#fdd">      map::core::OStringStream str;
      str &lt;&lt; "Dimension of defined result geometry does not equal the target dimension of the registration object ("&lt;&lt;registration-&gt;getTargetDimensions()&lt;&lt;").";
      throw mitk::AccessByItkException(str.str());
    }</span>
  }

  //check/create resultDescriptor
  /////////////////////////
<span style = "background-color:#fdd">  if (resultGeometry)</span>
  {
<span style = "background-color:#fdd">    resultDescriptor = ResultImageDescriptorType::New();</span>

    typename ResultImageDescriptorType::PointType origin;
    typename ResultImageDescriptorType::SizeType size;
    typename ResultImageDescriptorType::SpacingType fieldSpacing;
<span style = "background-color:#fdd">    typename ResultImageDescriptorType::DirectionType matrix;</span>

<span style = "background-color:#fdd">    mitk::ImageMappingHelper::ResultImageGeometryType::BoundsArrayType geoBounds = resultGeometry-&gt;GetBounds();
    mitk::Vector3D geoSpacing = resultGeometry-&gt;GetSpacing();
    mitk::Point3D geoOrigin = resultGeometry-&gt;GetOrigin();
    mitk::AffineTransform3D::MatrixType geoMatrix = resultGeometry-&gt;GetIndexToWorldTransform()-&gt;GetMatrix();</span>

<span style = "background-color:#fdd">    for (unsigned int i = 0; i&lt;VImageDimension; ++i)</span>
    {
<span style = "background-color:#fdd">      origin[i] = static_cast&lt;typename ResultImageDescriptorType::PointType::ValueType&gt;(geoOrigin[i]);
      fieldSpacing[i] = static_cast&lt;typename ResultImageDescriptorType::SpacingType::ValueType&gt;(geoSpacing[i]);
      size[i] = static_cast&lt;typename ResultImageDescriptorType::SizeType::SizeValueType&gt;(geoBounds[(2*i)+1]-geoBounds[2*i])*fieldSpacing[i];
    }</span>

    //Matrix extraction
<span style = "background-color:#fdd">    matrix.SetIdentity();</span>
    unsigned int i;
    unsigned int j;

    /// \warning 2D MITK images could have a 3D rotation, since they have a 3x3 geometry matrix.
    /// If it is only a rotation around the transversal plane normal, it can be express with a 2x2 matrix.
    /// In this case, the ITK image conservs this information and is identical to the MITK image!
    /// If the MITK image contains any other rotation, the ITK image will have no rotation at all.
    /// Spacing is of course conserved in both cases.

    // the following loop devides by spacing now to normalize columns.
    // counterpart of InitializeByItk in mitkImage.h line 372 of revision 15092.

    // Check if information is lost
<span style = "background-color:#fdd">    if (  VImageDimension == 2)</span>
    {
      if (  ( geoMatrix[0][2] != 0) ||
        ( geoMatrix[1][2] != 0) ||
        ( geoMatrix[2][0] != 0) ||
<span style = "background-color:#fdd">        ( geoMatrix[2][1] != 0) ||</span>
        (( geoMatrix[2][2] != 1) &amp;&amp;  ( geoMatrix[2][2] != -1) ))
      {
        // The 2D MITK image contains 3D rotation information.
        // This cannot be expressed in a 2D ITK image, so the ITK image will have no rotation
<span style = "background-color:#fdd">      }</span>
      else
      {
        // The 2D MITK image can be converted to an 2D ITK image without information loss!
<span style = "background-color:#fdd">        for ( i=0; i &lt; 2; ++i)</span>
        {
<span style = "background-color:#fdd">          for( j=0; j &lt; 2; ++j )</span>
          {
<span style = "background-color:#fdd">            matrix[i][j] = geoMatrix[i][j]/fieldSpacing[j];
          }
        }</span>
      }
<span style = "background-color:#fdd">    }
    else if (VImageDimension == 3)</span>
    {
      // Normal 3D image. Conversion possible without problem!
<span style = "background-color:#fdd">      for ( i=0; i &lt; 3; ++i)</span>
      {
<span style = "background-color:#fdd">        for( j=0; j &lt; 3; ++j )</span>
        {
<span style = "background-color:#fdd">          matrix[i][j] = geoMatrix[i][j]/fieldSpacing[j];
        }
      }
    }</span>
    else
    {
<span style = "background-color:#fdd">      assert(0);
      throw mitk::AccessByItkException("Usage of resultGeometry for 2D images is not yet implemented.");</span>
      /**@TODO Implement extraction of 2D-Rotation-Matrix out of 3D-Rotation-Matrix
      * to cover this case as well.
      * matrix = extract2DRotationMatrix(resultGeometry)*/
    }

<span style = "background-color:#fdd">    resultDescriptor-&gt;setOrigin(origin);
    resultDescriptor-&gt;setSize(size);
    resultDescriptor-&gt;setSpacing(fieldSpacing);
    resultDescriptor-&gt;setDirection(matrix);</span>
  }

  //do the mapping
  /////////////////////////
  typedef ::itk::InterpolateImageFunction&lt; ::itk::Image&lt;TPixelType,VImageDimension&gt; &gt; BaseInterpolatorType;
<span style = "background-color:#fdd">  typename BaseInterpolatorType::Pointer interpolator = generateInterpolator&lt; ::itk::Image&lt;TPixelType,VImageDimension&gt; &gt;(interpolatorType);
  assert(interpolator.IsNotNull());
  spTask-&gt;setImageInterpolator(interpolator);
  spTask-&gt;setInputImage(input);
  spTask-&gt;setRegistration(castedReg);
  spTask-&gt;setResultImageDescriptor(resultDescriptor);
  spTask-&gt;setThrowOnMappingError(throwOnMappingError);
  spTask-&gt;setErrorValue(errorValue);
  spTask-&gt;setThrowOnPaddingError(throwOnOutOfInputAreaError);
  spTask-&gt;setPaddingValue(paddingValue);</span>

<span style = "background-color:#fdd">  spTask-&gt;execute();
  mitk::CastToMitkImage&lt;&gt;(spTask-&gt;getResultImage(),result);
}</span>


/**Helper function to ensure the mapping of all time steps of an image.*/
void doMapTimesteps(const mitk::ImageMappingHelper::InputImageType* input, mitk::Image* result, const mitk::ImageMappingHelper::RegistrationType* registration, bool throwOnOutOfInputAreaError,double paddingValue, const mitk::ImageMappingHelper::ResultImageGeometryType* resultGeometry, bool throwOnMappingError, double errorValue, mitk::ImageMappingInterpolator::Type interpolatorType)
<span style = "background-color:#fdd">{
  for (unsigned int i = 0; i&lt;input-&gt;GetTimeSteps(); ++i)</span>
  {
<span style = "background-color:#fdd">    mitk::ImageTimeSelector::Pointer imageTimeSelector = mitk::ImageTimeSelector::New();
    imageTimeSelector-&gt;SetInput(input);
    imageTimeSelector-&gt;SetTimeNr(i);
    imageTimeSelector-&gt;UpdateLargestPossibleRegion();</span>

<span style = "background-color:#fdd">    mitk::ImageMappingHelper::InputImageType::Pointer timeStepInput = imageTimeSelector-&gt;GetOutput();
    mitk::ImageMappingHelper::ResultImageType::Pointer timeStepResult;
    AccessByItk_n(timeStepInput, doMITKMap, (timeStepResult, registration, throwOnOutOfInputAreaError, paddingValue, resultGeometry, throwOnMappingError, errorValue, interpolatorType));
    mitk::ImageReadAccessor readAccess(timeStepResult);
    result-&gt;SetVolume(readAccess.GetData(), i);
  }
}</span>

mitk::TimeGeometry::Pointer CreateResultTimeGeometry(const mitk::ImageMappingHelper::InputImageType* input, const mitk::ImageMappingHelper::ResultImageGeometryType* resultGeometry)
<span style = "background-color:#fdd">{
  mitk::TimeGeometry::ConstPointer timeGeometry = input-&gt;GetTimeGeometry();
  mitk::TimeGeometry::Pointer mappedTimeGeometry = timeGeometry-&gt;Clone();</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; input-&gt;GetTimeSteps(); ++i)</span>
  {
<span style = "background-color:#fdd">    mitk::ImageMappingHelper::ResultImageGeometryType::Pointer mappedGeometry = resultGeometry-&gt;Clone();
    mappedTimeGeometry-&gt;SetTimeStepGeometry(mappedGeometry, i);
  }
  return mappedTimeGeometry;
}</span>

mitk::ImageMappingHelper::ResultImageType::Pointer
  mitk::ImageMappingHelper::map(const InputImageType* input, const RegistrationType* registration,
  bool throwOnOutOfInputAreaError, const double&amp; paddingValue, const ResultImageGeometryType* resultGeometry,
  bool throwOnMappingError, const double&amp; errorValue, mitk::ImageMappingInterpolator::Type interpolatorType)
<span style = "background-color:#fdd">{
  if (!registration)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot map image. Passed registration wrapper pointer is nullptr.";</span>
  }
<span style = "background-color:#fdd">  if (!input)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot map image. Passed image pointer is nullptr.";</span>
  }

<span style = "background-color:#fdd">  ResultImageType::Pointer result;</span>

<span style = "background-color:#fdd">  auto inputLabelSetImage = dynamic_cast&lt;const LabelSetImage*&gt;(input);</span>

<span style = "background-color:#fdd">  if (nullptr == inputLabelSetImage)</span>
  {
<span style = "background-color:#fdd">    if (input-&gt;GetTimeSteps() == 1)</span>
    { //map the image and done
<span style = "background-color:#fdd">      AccessByItk_n(input, doMITKMap, (result, registration, throwOnOutOfInputAreaError, paddingValue, resultGeometry, throwOnMappingError, errorValue, interpolatorType));
    }</span>
    else
    { //map every time step and compose

<span style = "background-color:#fdd">      auto mappedTimeGeometry = CreateResultTimeGeometry(input, resultGeometry);
      result = mitk::Image::New();
      result-&gt;Initialize(input-&gt;GetPixelType(), *mappedTimeGeometry, 1, input-&gt;GetTimeSteps());</span>

<span style = "background-color:#fdd">      doMapTimesteps(input, result, registration, throwOnOutOfInputAreaError, paddingValue, resultGeometry, throwOnMappingError, errorValue, interpolatorType);
    }
  }</span>
  else
  {
<span style = "background-color:#fdd">    auto resultLabelSetImage = LabelSetImage::New();</span>

<span style = "background-color:#fdd">    auto mappedTimeGeometry = CreateResultTimeGeometry(input, resultGeometry);</span>

<span style = "background-color:#fdd">    auto resultTemplate = mitk::Image::New();
    resultTemplate-&gt;Initialize(input-&gt;GetPixelType(), *mappedTimeGeometry, 1, input-&gt;GetTimeSteps());</span>

<span style = "background-color:#fdd">    resultLabelSetImage-&gt;Initialize(resultTemplate);</span>

<span style = "background-color:#fdd">    auto cloneInput = inputLabelSetImage-&gt;Clone();</span>
    //We need to clone the LabelSetImage due to its illposed design. It is state full
    //and we have to iterate through all layers as active layers to ensure the content
    //via realy stored (directly working with the layer images does not work with the
    //active layer. The clone wastes rescources but is the easiest and safest way to
    //ensure 1) correct mapping 2) avoid race conditions with other parts of the
    //application because we would change the state of the input.
    //This whole code block should be reworked as soon as T28525 is done.

<span style = "background-color:#fdd">    for (unsigned int layerID = 0; layerID &lt; inputLabelSetImage-&gt;GetNumberOfLayers(); ++layerID)</span>
    {
<span style = "background-color:#fdd">      if (resultLabelSetImage-&gt;GetNumberOfLayers() &lt;= layerID)</span>
      {
<span style = "background-color:#fdd">        resultLabelSetImage-&gt;AddLayer();</span>
      }
<span style = "background-color:#fdd">      resultLabelSetImage-&gt;AddLabelSetToLayer(layerID, inputLabelSetImage-&gt;GetLabelSet(layerID)-&gt;Clone());
      cloneInput-&gt;SetActiveLayer(layerID);
      resultLabelSetImage-&gt;SetActiveLayer(layerID);</span>

<span style = "background-color:#fdd">      doMapTimesteps(cloneInput, resultLabelSetImage, registration, throwOnOutOfInputAreaError, paddingValue, resultGeometry, throwOnMappingError, errorValue, mitk::ImageMappingInterpolator::Linear);
    }</span>

<span style = "background-color:#fdd">    resultLabelSetImage-&gt;SetActiveLayer(inputLabelSetImage-&gt;GetActiveLayer());
    resultLabelSetImage-&gt;GetLabelSet(inputLabelSetImage-&gt;GetActiveLayer())-&gt;SetActiveLabel(inputLabelSetImage-&gt;GetActiveLabel(inputLabelSetImage-&gt;GetActiveLayer())-&gt;GetValue());
    result = resultLabelSetImage;
  }</span>

<span style = "background-color:#fdd">  return result;
}</span>

mitk::ImageMappingHelper::ResultImageType::Pointer
  mitk::ImageMappingHelper::map(const InputImageType* input, const MITKRegistrationType* registration,
  bool throwOnOutOfInputAreaError, const double&amp; paddingValue, const ResultImageGeometryType* resultGeometry,
  bool throwOnMappingError, const double&amp; errorValue, mitk::ImageMappingInterpolator::Type)
<span style = "background-color:#fdd">{
  if (!registration)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot map image. Passed registration wrapper pointer is nullptr.";</span>
  }
<span style = "background-color:#fdd">  if (!registration-&gt;GetRegistration())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot map image. Passed registration wrapper containes no registration.";</span>
  }
<span style = "background-color:#fdd">  if (!input)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot map image. Passed image pointer is nullptr.";</span>
  }

<span style = "background-color:#fdd">  ResultImageType::Pointer result = map(input, registration-&gt;GetRegistration(), throwOnOutOfInputAreaError, paddingValue, resultGeometry, throwOnMappingError, errorValue);
  return result;
}</span>


mitk::ImageMappingHelper::ResultImageType::Pointer
  mitk::ImageMappingHelper::
  refineGeometry(const InputImageType* input, const RegistrationType* registration,
  bool throwOnError)
<span style = "background-color:#fdd">{
  mitk::ImageMappingHelper::ResultImageType::Pointer result = nullptr;</span>

<span style = "background-color:#fdd">  if (!registration)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot refine image geometry. Passed registration pointer is nullptr.";</span>
  }
<span style = "background-color:#fdd">  if (!input)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot refine image geometry. Passed image pointer is nullptr.";</span>
  }

<span style = "background-color:#fdd">  mitk::MITKRegistrationHelper::Affine3DTransformType::Pointer spTransform = mitk::MITKRegistrationHelper::getAffineMatrix(registration,false);
  if(spTransform.IsNull() &amp;&amp; throwOnError)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot refine image geometry. Registration does not contain a suitable direct mapping kernel (3D affine transformation or compatible required).";</span>
  }

<span style = "background-color:#fdd">  if(spTransform.IsNotNull())</span>
  {
    //copy input image
<span style = "background-color:#fdd">    result = input-&gt;Clone();</span>

    //refine geometries
<span style = "background-color:#fdd">    for(unsigned int i = 0; i &lt; result-&gt;GetTimeSteps(); ++i)</span>
    { //refine every time step
<span style = "background-color:#fdd">      result-&gt;GetGeometry(i)-&gt;Compose(spTransform);
    }
    result-&gt;GetTimeGeometry()-&gt;Update();</span>
  }

<span style = "background-color:#fdd">  return result;
}</span>

mitk::ImageMappingHelper::ResultImageType::Pointer
  mitk::ImageMappingHelper::
  refineGeometry(const InputImageType* input, const MITKRegistrationType* registration,
  bool throwOnError)
<span style = "background-color:#fdd">{
  if (!registration)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot refine image geometry. Passed registration wrapper pointer is nullptr.";</span>
  }
<span style = "background-color:#fdd">  if (!registration-&gt;GetRegistration())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot refine image geometry. Passed registration wrapper containes no registration.";</span>
  }
<span style = "background-color:#fdd">  if (!input)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot refine image geometry. Passed image pointer is nullptr.";</span>
  }

<span style = "background-color:#fdd">  ResultImageType::Pointer result = refineGeometry(input, registration-&gt;GetRegistration(), throwOnError);
  return result;
}</span>

bool
  mitk::ImageMappingHelper::
  canRefineGeometry(const RegistrationType* registration)
<span style = "background-color:#fdd">{
  bool result = true;</span>

<span style = "background-color:#fdd">  if (!registration)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot check refine capability of registration. Passed registration pointer is nullptr.";</span>
  }

  //if the helper does not return null, we can refine the geometry.
<span style = "background-color:#fdd">  result = mitk::MITKRegistrationHelper::getAffineMatrix(registration,false).IsNotNull();</span>

<span style = "background-color:#fdd">  return result;
}</span>

bool
  mitk::ImageMappingHelper::
  canRefineGeometry(const MITKRegistrationType* registration)
<span style = "background-color:#fdd">{
  if (!registration)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot check refine capability of registration. Passed registration wrapper pointer is nullptr.";</span>
  }
<span style = "background-color:#fdd">  if (!registration-&gt;GetRegistration())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot check refine capability of registration. Passed registration wrapper containes no registration.";</span>
  }

<span style = "background-color:#fdd">  return canRefineGeometry(registration-&gt;GetRegistration());
}</span>
</pre>
	</body>
</html>