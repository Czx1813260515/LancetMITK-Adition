<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageStitchingHelper.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkImageStitchingHelper.h"

#include &lt;itkInterpolateImageFunction.h&gt;
#include &lt;itkNearestNeighborInterpolateImageFunction.h&gt;
#include &lt;itkLinearInterpolateImageFunction.h&gt;
#include &lt;itkBSplineInterpolateImageFunction.h&gt;
#include &lt;itkWindowedSincInterpolateImageFunction.h&gt;

#include &lt;mitkImageAccessByItk.h&gt;
#include &lt;mitkImageCast.h&gt;
#include &lt;mitkGeometry3D.h&gt;
#include &lt;mitkImageToItk.h&gt;
#include &lt;mitkMAPAlgorithmHelper.h&gt;

#include "mapRegistration.h"

#include "mitkRegistrationHelper.h"

template &lt;typename TImage &gt;
typename ::itk::InterpolateImageFunction&lt; TImage &gt;::Pointer generateInterpolator(mitk::ImageMappingInterpolator::Type interpolatorType)
{
  typedef ::itk::InterpolateImageFunction&lt; TImage &gt; BaseInterpolatorType;
  typename BaseInterpolatorType::Pointer result;

  switch (interpolatorType)
  {
  case mitk::ImageMappingInterpolator::NearestNeighbor:
    {
      result = ::itk::NearestNeighborInterpolateImageFunction&lt;TImage&gt;::New();
      break;
    }
  case mitk::ImageMappingInterpolator::BSpline_3:
    {
      typename ::itk::BSplineInterpolateImageFunction&lt;TImage&gt;::Pointer spInterpolator = ::itk::BSplineInterpolateImageFunction&lt;TImage&gt;::New();
      spInterpolator-&gt;SetSplineOrder(3);
      result = spInterpolator;
      break;
    }
  case mitk::ImageMappingInterpolator::WSinc_Hamming:
    {
      result = ::itk::WindowedSincInterpolateImageFunction&lt;TImage,4&gt;::New();
      break;
    }
  case mitk::ImageMappingInterpolator::WSinc_Welch:
    {
      result = ::itk::WindowedSincInterpolateImageFunction&lt;TImage,4,::itk::Function::WelchWindowFunction&lt;4&gt; &gt;::New();
      break;
    }
  default:
    {
      result = ::itk::LinearInterpolateImageFunction&lt;TImage&gt;::New();
      break;
    }

  }

  return result;
};

template &lt;typename TPixelType, unsigned int VImageDimension &gt;
void doMITKStitching(const ::itk::Image&lt;TPixelType,VImageDimension&gt;* /*input1*/,
  mitk::Image::Pointer&amp; result,
  std::vector&lt;mitk::Image::ConstPointer&gt; inputs,
  std::vector&lt;::map::core::RegistrationBase::ConstPointer&gt; registrations,
  const mitk::BaseGeometry* resultGeometry,
  const double&amp; paddingValue, itk::StitchStrategy stitchStrategy, mitk::ImageMappingInterpolator::Type interpolatorType)
<span style = "background-color:#fdd">{</span>
  using ConcreteRegistrationType = ::map::core::Registration&lt;VImageDimension, VImageDimension&gt;;
  using ItkImageType = itk::Image&lt;TPixelType, VImageDimension&gt;;

  using StitchingFilterType = ::itk::StitchImageFilter&lt;ItkImageType, ItkImageType&gt;;
<span style = "background-color:#fdd">  auto stitcher = StitchingFilterType::New();</span>
  
<span style = "background-color:#fdd">  stitcher-&gt;SetDefaultPixelValue(paddingValue);</span>

<span style = "background-color:#fdd">  stitcher-&gt;SetOutputOrigin(resultGeometry-&gt;GetOrigin());</span>

<span style = "background-color:#fdd">  const auto spacing = resultGeometry-&gt;GetSpacing();
  stitcher-&gt;SetOutputSpacing(spacing);</span>

<span style = "background-color:#fdd">  typename StitchingFilterType::DirectionType itkDirection;
  const auto mitkDirection = resultGeometry-&gt;GetIndexToWorldTransform()-&gt;GetMatrix();
  for (unsigned int i = 0; i &lt; VImageDimension; ++i)</span>
  {
<span style = "background-color:#fdd">    for (unsigned int j = 0; j &lt; VImageDimension; ++j)</span>
    {
<span style = "background-color:#fdd">      itkDirection[i][j] = mitkDirection[i][j] / spacing[j];
    }
  }
  stitcher-&gt;SetOutputDirection(itkDirection);</span>

  typename ItkImageType::SizeType size;
<span style = "background-color:#fdd">  size[0] = resultGeometry-&gt;GetExtent(0);
  size[1] = resultGeometry-&gt;GetExtent(1);
  size[2] = resultGeometry-&gt;GetExtent(2);
  stitcher-&gt;SetSize(size);
  stitcher-&gt;SetNumberOfWorkUnits(1);
  stitcher-&gt;SetStitchStrategy(stitchStrategy);</span>

<span style = "background-color:#fdd">  auto inputIter = inputs.begin();
  auto regIter = registrations.begin();
  unsigned int index = 0;</span>

<span style = "background-color:#fdd">  while (inputIter != inputs.end())</span>
  {
<span style = "background-color:#fdd">    auto itkInput = mitk::ImageToItkImage&lt;TPixelType, VImageDimension&gt;(*inputIter);</span>

<span style = "background-color:#fdd">    auto castedReg = dynamic_cast&lt;const ConcreteRegistrationType*&gt;(regIter-&gt;GetPointer());</span>

<span style = "background-color:#fdd">    auto kernel = dynamic_cast&lt;const ::map::core::RegistrationKernel&lt;VImageDimension, VImageDimension&gt;* &gt;(&amp;(castedReg-&gt;getInverseMapping()));
    if (nullptr == kernel)</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot stitch images. At least passed registration object #"&lt;&lt;index&lt;&lt;" doesn't have a valid inverse mapping registration kernel.";</span>
    }

<span style = "background-color:#fdd">    stitcher-&gt;SetInput(index, itkInput, kernel-&gt;getTransformModel(), generateInterpolator&lt; ::itk::Image&lt;TPixelType, VImageDimension&gt; &gt;(interpolatorType));
    ++inputIter;
    ++regIter;
    ++index;
  }</span>

<span style = "background-color:#fdd">  stitcher-&gt;Update();
  mitk::CastToMitkImage&lt;&gt;(stitcher-&gt;GetOutput(),result);
}</span>

mitk::Image::Pointer
mitk::StitchImages(std::vector&lt;Image::ConstPointer&gt; inputs,
  std::vector&lt;::map::core::RegistrationBase::ConstPointer&gt; registrations,
  const BaseGeometry* resultGeometry,
  const double&amp; paddingValue, itk::StitchStrategy stitchStrategy,
  mitk::ImageMappingInterpolator::Type interpolatorType)
<span style = "background-color:#fdd">{
  if (inputs.size() != registrations.size())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot stitch images. Passed inputs vector and registrations vector have different sizes.";</span>
  }

<span style = "background-color:#fdd">  if (inputs.empty())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot stitch images. No input images are defined.";</span>
  }

<span style = "background-color:#fdd">  auto inputDim = inputs.front()-&gt;GetDimension();
  auto inputPixelType = inputs.front()-&gt;GetPixelType();</span>

<span style = "background-color:#fdd">  for (const auto&amp; input : inputs)</span>
  {
<span style = "background-color:#fdd">    if (input-&gt;GetDimension() != inputDim)</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot stitch images. Images have different dimensions. Dimeonsion of first input: " &lt;&lt; inputDim &lt;&lt; "; wrong dimension: " &lt;&lt; input-&gt;GetDimension();</span>
    }
<span style = "background-color:#fdd">    if (input-&gt;GetPixelType() != inputPixelType)</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot stitch images. Input images have different pixeltypes. The current implementation does only support stitching of images with same pixel type. Dimeonsion of first input: " &lt;&lt; inputPixelType.GetTypeAsString() &lt;&lt; "; wrong dimension: " &lt;&lt; input-&gt;GetPixelType().GetTypeAsString();</span>
    }
<span style = "background-color:#fdd">    if (input-&gt;GetTimeSteps() &gt; 1)</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot stitch dynamic images. At least one input image has multiple time steps.";</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  for (const auto&amp; reg : registrations)</span>
  {
<span style = "background-color:#fdd">    if (reg-&gt;getMovingDimensions() != inputDim)</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot stitch images. At least one registration has a different moving dimension then the inputs. Dimeonsion of inputs: " &lt;&lt; inputDim &lt;&lt; "; wrong dimension: " &lt;&lt; reg-&gt;getMovingDimensions();</span>
    }
<span style = "background-color:#fdd">    if (reg-&gt;getTargetDimensions() != inputDim)</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot stitch images. At least one registration has a different target dimension then the inputs. Dimeonsion of inputs: " &lt;&lt; inputDim &lt;&lt; "; wrong dimension: " &lt;&lt; reg-&gt;getTargetDimensions();</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  Image::Pointer result;</span>

<span style = "background-color:#fdd">  AccessFixedDimensionByItk_n(inputs.front(), doMITKStitching, 3, (result, inputs, registrations, resultGeometry, paddingValue, stitchStrategy, interpolatorType));</span>

<span style = "background-color:#fdd">  return result;
}</span>

mitk::Image::Pointer
mitk::StitchImages(std::vector&lt;Image::ConstPointer&gt; inputs,
  std::vector&lt;MAPRegistrationWrapper::ConstPointer&gt; registrations,
  const BaseGeometry* resultGeometry,
  const double&amp; paddingValue, itk::StitchStrategy stitchStrategy,
  mitk::ImageMappingInterpolator::Type interpolatorType)
<span style = "background-color:#fdd">{</span>

<span style = "background-color:#fdd">  std::vector&lt;::map::core::RegistrationBase::ConstPointer&gt; unwrappedRegs;
  for (const auto&amp; reg : registrations)</span>
  {
<span style = "background-color:#fdd">    if (!reg)</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot stitch images. At least one passed registration wrapper pointer is nullptr.";</span>
    }
<span style = "background-color:#fdd">    unwrappedRegs.push_back(reg-&gt;GetRegistration());
  }</span>

<span style = "background-color:#fdd">  Image::Pointer result = StitchImages(inputs, unwrappedRegs, resultGeometry, paddingValue, stitchStrategy, interpolatorType);
  return result;
}</span>

mitk::Image::Pointer
mitk::StitchImages(std::vector&lt;Image::ConstPointer&gt; inputs,
  const BaseGeometry* resultGeometry,
  const double&amp; paddingValue, itk::StitchStrategy stitchStrategy,
  mitk::ImageMappingInterpolator::Type interpolatorType)
<span style = "background-color:#fdd">{
  auto defaultReg = GenerateIdentityRegistration3D();
  std::vector&lt;::map::core::RegistrationBase::ConstPointer&gt; defaultRegs;
  defaultRegs.resize(inputs.size());
  std::fill(defaultRegs.begin(), defaultRegs.end(), defaultReg-&gt;GetRegistration());</span>
  
<span style = "background-color:#fdd">  Image::Pointer result = StitchImages(inputs, defaultRegs, resultGeometry, paddingValue, stitchStrategy, interpolatorType);
  return result;
}</span>
</pre>
	</body>
</html>