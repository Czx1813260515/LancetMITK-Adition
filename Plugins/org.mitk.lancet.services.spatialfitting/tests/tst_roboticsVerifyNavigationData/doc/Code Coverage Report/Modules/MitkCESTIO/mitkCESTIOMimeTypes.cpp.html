<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkCESTIOMimeTypes.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkCESTIOMimeTypes.h"
#include "mitkIOMimeTypes.h"
#include &lt;mitkCustomTagParser.h&gt;
#include &lt;mitkDICOMDCMTKTagScanner.h&gt;
#include &lt;mitkDICOMFileReaderSelector.h&gt;

#include &lt;mitkLogMacros.h&gt;

#include &lt;itkGDCMImageIO.h&gt;

#include &lt;itksys/SystemTools.hxx&gt;

namespace mitk
{
  std::vector&lt;CustomMimeType *&gt; MitkCESTIOMimeTypes::Get()
<span style = "background-color:#dfd">  {
    std::vector&lt;CustomMimeType *&gt; mimeTypes;</span>

    // order matters here (descending rank for mime types)

<span style = "background-color:#dfd">    mimeTypes.push_back(CEST_DICOM_WITH_META_FILE_MIMETYPE().Clone());
    mimeTypes.push_back(CEST_DICOM_MIMETYPE().Clone());
    mimeTypes.push_back(CEST_DICOM_WITHOUT_META_FILE_MIMETYPE().Clone());</span>

<span style = "background-color:#dfd">    return mimeTypes;
  }</span>

  // Mime Types

<span style = "background-color:#dfd">  MitkCESTIOMimeTypes::MitkCESTDicomMimeType::MitkCESTDicomMimeType() : IOMimeTypes::BaseDicomMimeType(CEST_DICOM_MIMETYPE_NAME())
  {
    this-&gt;SetCategory(IOMimeTypes::CATEGORY_IMAGES());
    this-&gt;SetComment("CEST DICOM");
  }</span>

  bool MitkCESTIOMimeTypes::MitkCESTDicomMimeType::AppliesTo(const std::string &amp;path) const
<span style = "background-color:#fdd">  {
    bool canRead(IOMimeTypes::BaseDicomMimeType::AppliesTo(path));</span>

    // fix for bug 18572
    // Currently this function is called for writing as well as reading, in that case
    // the image information can of course not be read
    // This is a bug, this function should only be called for reading.
<span style = "background-color:#fdd">    if (!itksys::SystemTools::FileExists(path.c_str()))</span>
    {
<span style = "background-color:#fdd">      return canRead;</span>
    }
    // end fix for bug 18572

<span style = "background-color:#fdd">    if (!canRead)</span>
    {
<span style = "background-color:#fdd">      return canRead;</span>
    }

<span style = "background-color:#fdd">    mitk::DICOMDCMTKTagScanner::Pointer scanner = mitk::DICOMDCMTKTagScanner::New();</span>

<span style = "background-color:#fdd">    mitk::DICOMTag siemensCESTprivateTag(0x0029, 0x1020);</span>

<span style = "background-color:#fdd">    mitk::StringList relevantFiles;
    relevantFiles.push_back(path);</span>

<span style = "background-color:#fdd">    scanner-&gt;AddTag(siemensCESTprivateTag);
    scanner-&gt;SetInputFiles(relevantFiles);
    scanner-&gt;Scan();
    mitk::DICOMTagCache::Pointer tagCache = scanner-&gt;GetScanCache();</span>

<span style = "background-color:#fdd">    mitk::DICOMImageFrameList imageFrameList = mitk::ConvertToDICOMImageFrameList(tagCache-&gt;GetFrameInfoList());</span>

<span style = "background-color:#fdd">    bool mapNotEmpty = false;</span>

<span style = "background-color:#fdd">    if (!imageFrameList.empty())</span>
    {
<span style = "background-color:#fdd">      mitk::DICOMImageFrameInfo* firstFrame = imageFrameList.begin()-&gt;GetPointer();</span>

<span style = "background-color:#fdd">      std::string byteString = tagCache-&gt;GetTagValue(firstFrame, siemensCESTprivateTag).value;</span>

<span style = "background-color:#fdd">      if (byteString.empty()) {
        return false;</span>
      }
<span style = "background-color:#fdd">      mitk::CustomTagParser tagParser(relevantFiles[0]);</span>

<span style = "background-color:#fdd">      auto parsedPropertyList = tagParser.ParseDicomPropertyString(byteString);</span>

<span style = "background-color:#fdd">      mapNotEmpty = !parsedPropertyList-&gt;GetMap()-&gt;empty();
    }</span>

<span style = "background-color:#fdd">    return mapNotEmpty;
  }</span>

  MitkCESTIOMimeTypes::MitkCESTDicomMimeType *MitkCESTIOMimeTypes::MitkCESTDicomMimeType::Clone() const
<span style = "background-color:#dfd">  {
    return new MitkCESTDicomMimeType(*this);
  }</span>

  MitkCESTIOMimeTypes::MitkCESTDicomMimeType MitkCESTIOMimeTypes::CEST_DICOM_MIMETYPE()
<span style = "background-color:#dfd">  {
    return MitkCESTDicomMimeType();
  }</span>

  std::string MitkCESTIOMimeTypes::CEST_DICOM_MIMETYPE_NAME()
<span style = "background-color:#dfd">  {</span>
    // create a unique and sensible name for this mime type
<span style = "background-color:#dfd">    static std::string name = IOMimeTypes::DEFAULT_BASE_NAME() + ".image.dicom.cest";
    return name;
  }</span>

<span style = "background-color:#dfd">  MitkCESTIOMimeTypes::MitkCESTDicomWithMetaFileMimeType::MitkCESTDicomWithMetaFileMimeType() : IOMimeTypes::BaseDicomMimeType(CEST_DICOM_WITH_META_FILE_NAME())
  {
    this-&gt;SetCategory(IOMimeTypes::CATEGORY_IMAGES());
    this-&gt;SetComment("CEST DICOM");
  }</span>

  bool MitkCESTIOMimeTypes::MitkCESTDicomWithMetaFileMimeType::AppliesTo(const std::string&amp; path) const
<span style = "background-color:#fdd">  {
    bool canRead(IOMimeTypes::BaseDicomMimeType::AppliesTo(path));</span>

    // fix for bug 18572
    // Currently this function is called for writing as well as reading, in that case
    // the image information can of course not be read
    // This is a bug, this function should only be called for reading.
<span style = "background-color:#fdd">    if (!itksys::SystemTools::FileExists(path.c_str()))</span>
    {
<span style = "background-color:#fdd">      return canRead;</span>
    }
    // end fix for bug 18572

<span style = "background-color:#fdd">    if (!canRead)</span>
    {
<span style = "background-color:#fdd">      return canRead;</span>
    }

<span style = "background-color:#fdd">    std::string dir = path;
    if (!itksys::SystemTools::FileIsDirectory(path))</span>
    {
<span style = "background-color:#fdd">      dir = itksys::SystemTools::GetProgramPath(path);</span>
    }

<span style = "background-color:#fdd">    std::string metafilePath = dir +"/" + "CEST_META.json";</span>

<span style = "background-color:#fdd">    canRead = itksys::SystemTools::FileExists(metafilePath.c_str());</span>

<span style = "background-color:#fdd">    return canRead;
  }</span>

  MitkCESTIOMimeTypes::MitkCESTDicomWithMetaFileMimeType* MitkCESTIOMimeTypes::MitkCESTDicomWithMetaFileMimeType::Clone() const
<span style = "background-color:#dfd">  {
    return new MitkCESTDicomWithMetaFileMimeType(*this);
  }</span>

  MitkCESTIOMimeTypes::MitkCESTDicomWithMetaFileMimeType MitkCESTIOMimeTypes::CEST_DICOM_WITH_META_FILE_MIMETYPE()
<span style = "background-color:#dfd">  {
    return MitkCESTDicomWithMetaFileMimeType();
  }</span>

  std::string MitkCESTIOMimeTypes::CEST_DICOM_WITH_META_FILE_NAME()
<span style = "background-color:#dfd">  {</span>
    // create a unique and sensible name for this mime type
<span style = "background-color:#dfd">    static std::string name = IOMimeTypes::DEFAULT_BASE_NAME() + ".image.dicom.cest.generic.meta";
    return name;
  }</span>

<span style = "background-color:#dfd">  MitkCESTIOMimeTypes::MitkCESTDicomWOMetaFileMimeType::MitkCESTDicomWOMetaFileMimeType() : IOMimeTypes::BaseDicomMimeType(CEST_DICOM_WITHOUT_META_FILE_NAME())
  {
    this-&gt;SetCategory(IOMimeTypes::CATEGORY_IMAGES());
    this-&gt;SetComment("CEST DICOM");
  }</span>

  bool MitkCESTIOMimeTypes::MitkCESTDicomWOMetaFileMimeType::AppliesTo(const std::string&amp; path) const
<span style = "background-color:#fdd">  {
    bool canRead(IOMimeTypes::BaseDicomMimeType::AppliesTo(path));</span>

    // fix for bug 18572
    // Currently this function is called for writing as well as reading, in that case
    // the image information can of course not be read
    // This is a bug, this function should only be called for reading.
<span style = "background-color:#fdd">    if (!itksys::SystemTools::FileExists(path.c_str()))</span>
    {
<span style = "background-color:#fdd">      return canRead;</span>
    }
    // end fix for bug 18572

<span style = "background-color:#fdd">    if (!canRead)</span>
    {
<span style = "background-color:#fdd">      return canRead;</span>
    }

<span style = "background-color:#fdd">    std::string dir = path;
    if (!itksys::SystemTools::FileIsDirectory(path))</span>
    {
<span style = "background-color:#fdd">      dir = itksys::SystemTools::GetProgramPath(path);</span>
    }

<span style = "background-color:#fdd">    std::string metafilePath = dir + "/" + "CEST_META.json";</span>

<span style = "background-color:#fdd">    canRead = !itksys::SystemTools::FileExists(metafilePath.c_str());</span>

<span style = "background-color:#fdd">    return canRead;
  }</span>

  MitkCESTIOMimeTypes::MitkCESTDicomWOMetaFileMimeType* MitkCESTIOMimeTypes::MitkCESTDicomWOMetaFileMimeType::Clone() const
<span style = "background-color:#dfd">  {
    return new MitkCESTDicomWOMetaFileMimeType(*this);
  }</span>

  MitkCESTIOMimeTypes::MitkCESTDicomWOMetaFileMimeType MitkCESTIOMimeTypes::CEST_DICOM_WITHOUT_META_FILE_MIMETYPE()
<span style = "background-color:#dfd">  {
    return MitkCESTDicomWOMetaFileMimeType();
  }</span>

  std::string MitkCESTIOMimeTypes::CEST_DICOM_WITHOUT_META_FILE_NAME()
<span style = "background-color:#dfd">  {</span>
    // create a unique and sensible name for this mime type
<span style = "background-color:#dfd">    static std::string name = IOMimeTypes::DEFAULT_BASE_NAME() + ".image.dicom.cest.generic.nometa";
    return name;
  }</span>

}</pre>
	</body>
</html>