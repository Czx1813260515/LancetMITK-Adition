<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkCESTDICOMReaderService.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkCESTDICOMReaderService.h"

#include "mitkCESTIOMimeTypes.h"
#include &lt;mitkCustomTagParser.h&gt;
#include &lt;mitkDICOMDCMTKTagScanner.h&gt;
#include &lt;mitkDICOMFileReaderSelector.h&gt;
#include "mitkCESTImageNormalizationFilter.h"

#include &lt;itkGDCMImageIO.h&gt;

#include &lt;usGetModuleContext.h&gt;
#include &lt;usModuleContext.h&gt;
#include &lt;usModuleResource.h&gt;

namespace mitk
{
  CESTDICOMReaderService::CESTDICOMReaderService()
<span style = "background-color:#dfd">    : BaseDICOMReaderService(CustomMimeType(MitkCESTIOMimeTypes::CEST_DICOM_MIMETYPE_NAME()), "MITK CEST DICOM Reader")
  {
    Options defaultOptions;</span>

<span style = "background-color:#dfd">    std::vector&lt;std::string&gt; parseStrategy;
    parseStrategy.push_back("Automatic");
    parseStrategy.push_back("CEST/WASABI");
    parseStrategy.push_back("T1");
    defaultOptions["Force type"] = parseStrategy;</span>

<span style = "background-color:#dfd">    std::vector&lt;std::string&gt; mappingStrategy;
    mappingStrategy.push_back("Strict");
    mappingStrategy.push_back("Fuzzy");
    defaultOptions["Revision mapping"] = mappingStrategy;</span>

<span style = "background-color:#dfd">    std::vector&lt;std::string&gt; normalizationStrategy;
    normalizationStrategy.push_back("Automatic");
    normalizationStrategy.push_back("No");
    defaultOptions["Normalize data"] = normalizationStrategy;</span>


<span style = "background-color:#dfd">    this-&gt;SetDefaultOptions(defaultOptions);
    this-&gt;SetOnlyRegardOwnSeries(false);</span>

<span style = "background-color:#dfd">    this-&gt;RegisterService();
  }</span>

  DICOMFileReader::Pointer CESTDICOMReaderService::GetReader(const mitk::StringList &amp;relevantFiles) const
<span style = "background-color:#fdd">  {
    mitk::DICOMFileReaderSelector::Pointer selector = mitk::DICOMFileReaderSelector::New();</span>

<span style = "background-color:#fdd">    auto r = ::us::GetModuleContext()-&gt;GetModule()-&gt;GetResource("cest_DKFZ.xml");
    selector-&gt;AddConfigFromResource(r);
    selector-&gt;SetInputFiles(relevantFiles);</span>

<span style = "background-color:#fdd">    mitk::DICOMFileReader::Pointer reader = selector-&gt;GetFirstReaderWithMinimumNumberOfOutputImages();
    if (reader.IsNotNull())</span>
    {
      // reset tag cache to ensure that additional tags of interest
      // will be regarded by the reader if set later on.
<span style = "background-color:#fdd">      reader-&gt;SetTagCache(nullptr);</span>
    }

<span style = "background-color:#fdd">    return reader;
  }</span>

  std::vector&lt;itk::SmartPointer&lt;BaseData&gt;&gt; CESTDICOMReaderService::Read()
<span style = "background-color:#fdd">  {
    std::vector&lt;BaseData::Pointer&gt; result;
    std::vector&lt;BaseData::Pointer&gt; dicomResult = BaseDICOMReaderService::Read();</span>

<span style = "background-color:#fdd">    const Options options = this-&gt;GetOptions();</span>

<span style = "background-color:#fdd">    const std::string parseStrategy = options.find("Force type")-&gt;second.ToString();
    const std::string mappingStrategy = options.find("Revision mapping")-&gt;second.ToString();
    const std::string normalizationStrategy = options.find("Normalize data")-&gt;second.ToString();</span>

<span style = "background-color:#fdd">    for (auto &amp;item : dicomResult)</span>
    {
<span style = "background-color:#fdd">      auto prop = item-&gt;GetProperty("files");
      auto fileProp = dynamic_cast&lt;mitk::StringLookupTableProperty*&gt;(prop.GetPointer());
      if (!fileProp)</span>
      {
<span style = "background-color:#fdd">        mitkThrow() &lt;&lt; "Cannot load CEST file. Property \"files\" is missing after BaseDICOMReaderService::Read().";</span>
      }

<span style = "background-color:#fdd">      mitk::StringList relevantFiles = { fileProp-&gt;GetValue().GetTableValue(0) };</span>

<span style = "background-color:#fdd">      mitk::DICOMDCMTKTagScanner::Pointer scanner = mitk::DICOMDCMTKTagScanner::New();</span>

<span style = "background-color:#fdd">      DICOMTag siemensCESTprivateTag(0x0029, 0x1020);</span>

<span style = "background-color:#fdd">      scanner-&gt;AddTag(siemensCESTprivateTag);
      scanner-&gt;SetInputFiles(relevantFiles);
      scanner-&gt;Scan();
      mitk::DICOMTagCache::Pointer tagCache = scanner-&gt;GetScanCache();</span>

<span style = "background-color:#fdd">      DICOMImageFrameList imageFrameList = mitk::ConvertToDICOMImageFrameList(tagCache-&gt;GetFrameInfoList());
      DICOMImageFrameInfo *firstFrame = imageFrameList.begin()-&gt;GetPointer();</span>

<span style = "background-color:#fdd">      std::string byteString = tagCache-&gt;GetTagValue(firstFrame, siemensCESTprivateTag).value;</span>

<span style = "background-color:#fdd">      mitk::CustomTagParser tagParser(relevantFiles[0]);
      tagParser.SetParseStrategy(parseStrategy);
      tagParser.SetRevisionMappingStrategy(mappingStrategy);</span>

<span style = "background-color:#fdd">      auto parsedPropertyList = tagParser.ParseDicomPropertyString(byteString);</span>

<span style = "background-color:#fdd">      item-&gt;GetPropertyList()-&gt;ConcatenatePropertyList(parsedPropertyList);</span>

<span style = "background-color:#fdd">      auto image = dynamic_cast&lt;mitk::Image*&gt;(item.GetPointer());
      if (normalizationStrategy == "Automatic" &amp;&amp; mitk::IsNotNormalizedCESTImage(image))</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "Unnormalized CEST image was loaded and will be normalized automatically.";
        auto normalizationFilter = mitk::CESTImageNormalizationFilter::New();
        normalizationFilter-&gt;SetInput(image);
        normalizationFilter-&gt;Update();
        auto normalizedImage = normalizationFilter-&gt;GetOutput();</span>

<span style = "background-color:#fdd">        auto nameProp = item-&gt;GetProperty("name");
        if (!nameProp)</span>
        {
<span style = "background-color:#fdd">          mitkThrow() &lt;&lt; "Cannot load CEST file. Property \"name\" is missing after BaseDICOMReaderService::Read().";</span>
        }
<span style = "background-color:#fdd">        normalizedImage-&gt;SetProperty("name", mitk::StringProperty::New(nameProp-&gt;GetValueAsString() + "_normalized"));
        result.push_back(normalizedImage);
      }</span>
      else
      {
<span style = "background-color:#fdd">        result.push_back(item);</span>
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    return result;
  }</span>

<span style = "background-color:#fdd">  CESTDICOMReaderService *CESTDICOMReaderService::Clone() const { return new CESTDICOMReaderService(*this); }</span>
}</pre>
	</body>
</html>