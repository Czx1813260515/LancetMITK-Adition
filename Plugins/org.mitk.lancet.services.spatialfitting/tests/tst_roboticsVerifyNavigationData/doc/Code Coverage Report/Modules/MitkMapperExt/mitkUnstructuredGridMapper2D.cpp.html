<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkUnstructuredGridMapper2D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkUnstructuredGridMapper2D.h"
#include &lt;mitkGL.h&gt;

#include "mitkAbstractTransformGeometry.h"
#include "mitkBaseRenderer.h"
#include "mitkColorProperty.h"
#include "mitkPlaneGeometry.h"
#include "mitkProperties.h"
#include "mitkTransferFunction.h"
#include "mitkTransferFunctionProperty.h"
#include "mitkUnstructuredGrid.h"
#include "mitkVtkMapper3D.h"
#include "mitkVtkScalarModeProperty.h"

#include &lt;vtkAbstractMapper3D.h&gt;
#include &lt;vtkAbstractVolumeMapper.h&gt;
#include &lt;vtkAssembly.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkCellData.h&gt;
#include &lt;vtkColorTransferFunction.h&gt;
#include &lt;vtkLinearTransform.h&gt;
#include &lt;vtkLookupTable.h&gt;
#include &lt;vtkPiecewiseFunction.h&gt;
#include &lt;vtkPlane.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkProp3DCollection.h&gt;
#include &lt;vtkScalarsToColors.h&gt;
#include &lt;vtkUnstructuredGrid.h&gt;
#include &lt;vtkVolume.h&gt;
#include &lt;vtkVolumeProperty.h&gt;

#include "vtkPointSetSlicer.h"

void mitk::UnstructuredGridMapper2D::GenerateDataForRenderer(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  BaseLocalStorage *ls = m_LSH.GetLocalStorage(renderer);
  bool needGenerateData = ls-&gt;IsGenerateDataRequired(renderer, this, GetDataNode());</span>

<span style = "background-color:#fdd">  if (needGenerateData)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;UpdateGenerateDataTime();</span>

<span style = "background-color:#fdd">    mitk::DataNode::ConstPointer node = this-&gt;GetDataNode();
    if (node.IsNull())
      return;</span>

<span style = "background-color:#fdd">    if (!node-&gt;GetProperty(m_ScalarMode, "scalar mode"))</span>
    {
<span style = "background-color:#fdd">      m_ScalarMode = mitk::VtkScalarModeProperty::New(0);</span>
    }

<span style = "background-color:#fdd">    if (!node-&gt;GetProperty(m_ScalarVisibility, "scalar visibility"))</span>
    {
<span style = "background-color:#fdd">      m_ScalarVisibility = mitk::BoolProperty::New(true);</span>
    }

<span style = "background-color:#fdd">    if (!node-&gt;GetProperty(m_Outline, "outline polygons"))</span>
    {
<span style = "background-color:#fdd">      m_Outline = mitk::BoolProperty::New(false);</span>
    }

<span style = "background-color:#fdd">    if (!node-&gt;GetProperty(m_Color, "color"))</span>
    {
<span style = "background-color:#fdd">      m_Color = mitk::ColorProperty::New(1.0f, 1.0f, 1.0f);</span>
    }

<span style = "background-color:#fdd">    if (!node-&gt;GetProperty(m_LineWidth, "line width"))</span>
    {
<span style = "background-color:#fdd">      m_LineWidth = mitk::IntProperty::New(1);</span>
    }
<span style = "background-color:#fdd">  }
  mitk::BaseData::Pointer input = GetDataNode()-&gt;GetData();
  assert(input);</span>

<span style = "background-color:#fdd">  input-&gt;Update();</span>

<span style = "background-color:#fdd">  if (m_VtkPointSet)
    m_VtkPointSet-&gt;UnRegister(nullptr);
  m_VtkPointSet = this-&gt;GetVtkPointSet(renderer, this-&gt;GetTimestep());
  assert(m_VtkPointSet);
  m_VtkPointSet-&gt;Register(nullptr);</span>

<span style = "background-color:#fdd">  if (m_ScalarVisibility-&gt;GetValue())</span>
  {
<span style = "background-color:#fdd">    mitk::DataNode::ConstPointer node = this-&gt;GetDataNode();
    mitk::TransferFunctionProperty::Pointer transferFuncProp;
    node-&gt;GetProperty(transferFuncProp, "TransferFunction", renderer);
    if (transferFuncProp.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      mitk::TransferFunction::Pointer tf = transferFuncProp-&gt;GetValue();
      if (m_ScalarsToColors)
        m_ScalarsToColors-&gt;UnRegister(nullptr);
      m_ScalarsToColors = static_cast&lt;vtkScalarsToColors *&gt;(tf-&gt;GetColorTransferFunction());
      m_ScalarsToColors-&gt;Register(nullptr);</span>

<span style = "background-color:#fdd">      if (m_ScalarsToOpacity)
        m_ScalarsToOpacity-&gt;UnRegister(nullptr);
      m_ScalarsToOpacity = tf-&gt;GetScalarOpacityFunction();
      m_ScalarsToOpacity-&gt;Register(nullptr);
    }</span>
    else
    {
<span style = "background-color:#fdd">      if (m_ScalarsToColors)
        m_ScalarsToColors-&gt;UnRegister(nullptr);
      m_ScalarsToColors = this-&gt;GetVtkLUT(renderer);
      assert(m_ScalarsToColors);
      m_ScalarsToColors-&gt;Register(nullptr);</span>

      float opacity;
<span style = "background-color:#fdd">      node-&gt;GetOpacity(opacity, renderer);
      if (m_ScalarsToOpacity)
        m_ScalarsToOpacity-&gt;UnRegister(nullptr);
      m_ScalarsToOpacity = vtkPiecewiseFunction::New();</span>
      double range[2];
<span style = "background-color:#fdd">      m_VtkPointSet-&gt;GetScalarRange(range);
      m_ScalarsToOpacity-&gt;AddSegment(range[0], opacity, range[1], opacity);</span>
    }
<span style = "background-color:#fdd">  }
}</span>

void mitk::UnstructuredGridMapper2D::Paint(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  bool visible = true;
  GetDataNode()-&gt;GetVisibility(visible, renderer, "visible");
  if (!visible)
    return;</span>

<span style = "background-color:#fdd">  vtkLinearTransform *vtktransform = GetDataNode()-&gt;GetVtkTransform();
  vtkLinearTransform *inversetransform = vtktransform-&gt;GetLinearInverse();</span>

<span style = "background-color:#fdd">  PlaneGeometry::ConstPointer worldGeometry = renderer-&gt;GetCurrentWorldPlaneGeometry();
  PlaneGeometry::ConstPointer worldPlaneGeometry = dynamic_cast&lt;const PlaneGeometry *&gt;(worldGeometry.GetPointer());</span>

<span style = "background-color:#fdd">  Point3D point;
  Vector3D normal;</span>

<span style = "background-color:#fdd">  if (worldPlaneGeometry.IsNotNull())</span>
  {
    // set up vtkPlane according to worldGeometry
<span style = "background-color:#fdd">    point = worldPlaneGeometry-&gt;GetOrigin();
    normal = worldPlaneGeometry-&gt;GetNormal();
    normal.Normalize();
    m_Plane-&gt;SetTransform((vtkAbstractTransform *)nullptr);
  }</span>
  else
  {
    //@FIXME: does not work correctly. Does m_Plane-&gt;SetTransform really transforms a "plane plane" into a "curved
    //plane"?
<span style = "background-color:#fdd">    return;
    AbstractTransformGeometry::ConstPointer worldAbstractGeometry =</span>
      dynamic_cast&lt;const AbstractTransformGeometry *&gt;(renderer-&gt;GetCurrentWorldPlaneGeometry());
<span style = "background-color:#fdd">    if (worldAbstractGeometry.IsNotNull())</span>
    {
      // set up vtkPlane according to worldGeometry
<span style = "background-color:#fdd">      point = worldAbstractGeometry-&gt;GetParametricBoundingBox()-&gt;GetMinimum();
      FillVector3D(normal, 0, 0, 1);
      m_Plane-&gt;SetTransform(worldAbstractGeometry-&gt;GetVtkAbstractTransform()-&gt;GetInverse());
    }</span>
    else
<span style = "background-color:#fdd">      return;</span>
  }

  double vp[3], vnormal[3];

<span style = "background-color:#fdd">  vnl2vtk(point.GetVnlVector(), vp);
  vnl2vtk(normal.GetVnlVector(), vnormal);</span>

  // normally, we would need to transform the surface and cut the transformed surface with the cutter.
  // This might be quite slow. Thus, the idea is, to perform an inverse transform of the plane instead.
  //@todo It probably does not work for scaling operations yet:scaling operations have to be
  // dealed with after the cut is performed by scaling the contour.
<span style = "background-color:#fdd">  inversetransform-&gt;TransformPoint(vp, vp);
  inversetransform-&gt;TransformNormalAtPoint(vp, vnormal, vnormal);</span>

<span style = "background-color:#fdd">  m_Plane-&gt;SetOrigin(vp);
  m_Plane-&gt;SetNormal(vnormal);</span>

  // set data into cutter
<span style = "background-color:#fdd">  m_Slicer-&gt;SetInputData(m_VtkPointSet);</span>
  //    m_Cutter-&gt;GenerateCutScalarsOff();
  //    m_Cutter-&gt;SetSortByToSortByCell();

  // calculate the cut
<span style = "background-color:#fdd">  m_Slicer-&gt;Update();</span>

  // apply color and opacity read from the PropertyList
<span style = "background-color:#fdd">  ApplyColorAndOpacityProperties(renderer);</span>

  // traverse the cut contour
<span style = "background-color:#fdd">  vtkPolyData *contour = m_Slicer-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  vtkPoints *vpoints = contour-&gt;GetPoints();
  vtkCellArray *vlines = contour-&gt;GetLines();
  vtkCellArray *vpolys = contour-&gt;GetPolys();
  vtkPointData *vpointdata = contour-&gt;GetPointData();
  vtkDataArray *vscalars = vpointdata-&gt;GetScalars();</span>

<span style = "background-color:#fdd">  vtkCellData *vcelldata = contour-&gt;GetCellData();
  vtkDataArray *vcellscalars = vcelldata-&gt;GetScalars();</span>

<span style = "background-color:#fdd">  const int numberOfLines = contour-&gt;GetNumberOfLines();
  const int numberOfPolys = contour-&gt;GetNumberOfPolys();</span>

<span style = "background-color:#fdd">  const bool useCellData = m_ScalarMode-&gt;GetVtkScalarMode() == VTK_SCALAR_MODE_DEFAULT ||</span>
                           m_ScalarMode-&gt;GetVtkScalarMode() == VTK_SCALAR_MODE_USE_CELL_DATA;
<span style = "background-color:#fdd">  const bool usePointData = m_ScalarMode-&gt;GetVtkScalarMode() == VTK_SCALAR_MODE_USE_POINT_DATA;</span>

<span style = "background-color:#fdd">  Point3D p;
  Point2D p2d;</span>

<span style = "background-color:#fdd">  vlines-&gt;InitTraversal();
  vpolys-&gt;InitTraversal();</span>

<span style = "background-color:#fdd">  mitk::Color outlineColor = m_Color-&gt;GetColor();</span>

<span style = "background-color:#fdd">  glLineWidth((float)m_LineWidth-&gt;GetValue());</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; numberOfLines; ++i)</span>
  {
<span style = "background-color:#fdd">    const vtkIdType *cell(nullptr);
    vtkIdType cellSize(0);</span>

<span style = "background-color:#fdd">    vlines-&gt;GetNextCell(cellSize, cell);</span>

<span style = "background-color:#fdd">    float rgba[4] = {outlineColor[0], outlineColor[1], outlineColor[2], 1.0f};
    if (m_ScalarVisibility-&gt;GetValue() &amp;&amp; vcellscalars)</span>
    {
<span style = "background-color:#fdd">      if (useCellData)</span>
      { // color each cell according to cell data
<span style = "background-color:#fdd">        double scalar = vcellscalars-&gt;GetComponent(i, 0);
        double rgb[3] = {1.0f, 1.0f, 1.0f};
        m_ScalarsToColors-&gt;GetColor(scalar, rgb);
        rgba[0] = (float)rgb[0];
        rgba[1] = (float)rgb[1];
        rgba[2] = (float)rgb[2];
        rgba[3] = (float)m_ScalarsToOpacity-&gt;GetValue(scalar);
      }
      else if (usePointData)</span>
      {
<span style = "background-color:#fdd">        double scalar = vscalars-&gt;GetComponent(i, 0);
        double rgb[3] = {1.0f, 1.0f, 1.0f};
        m_ScalarsToColors-&gt;GetColor(scalar, rgb);
        rgba[0] = (float)rgb[0];
        rgba[1] = (float)rgb[1];
        rgba[2] = (float)rgb[2];
        rgba[3] = (float)m_ScalarsToOpacity-&gt;GetValue(scalar);</span>
      }
    }

<span style = "background-color:#fdd">    glColor4fv(rgba);</span>

<span style = "background-color:#fdd">    glBegin(GL_LINE_LOOP);
    for (int j = 0; j &lt; cellSize; ++j)</span>
    {
<span style = "background-color:#fdd">      vpoints-&gt;GetPoint(cell[j], vp);</span>
      // take transformation via vtktransform into account
<span style = "background-color:#fdd">      vtktransform-&gt;TransformPoint(vp, vp);</span>

<span style = "background-color:#fdd">      vtk2itk(vp, p);</span>

      // convert 3D point (in mm) to display coordinates (units )
<span style = "background-color:#fdd">      renderer-&gt;WorldToDisplay(p, p2d);</span>

      // convert display coordinates ( (0,0) is top-left ) in GL coordinates ( (0,0) is bottom-left )
      // p2d[1]=toGL-p2d[1];

      // add the current vertex to the line
<span style = "background-color:#fdd">      glVertex2f(p2d[0], p2d[1]);
    }
    glEnd();
  }</span>

<span style = "background-color:#fdd">  bool polyOutline = m_Outline-&gt;GetValue();
  bool scalarVisibility = m_ScalarVisibility-&gt;GetValue();</span>

  // cache the transformed points
  // a fixed size array is way faster than 'new'
  // slices through 3d cells usually do not generated
  // polygons with more than 6 vertices
<span style = "background-color:#fdd">  const int maxPolySize = 10;
  auto *cachedPoints = new Point2D[maxPolySize * numberOfPolys];</span>

<span style = "background-color:#fdd">  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span>

  // only draw polygons if there are cell scalars
  // or the outline property is set to true
<span style = "background-color:#fdd">  if (scalarVisibility &amp;&amp; vcellscalars)</span>
  {
<span style = "background-color:#fdd">    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</span>

<span style = "background-color:#fdd">    for (int i = 0; i &lt; numberOfPolys; ++i)</span>
    {
<span style = "background-color:#fdd">      const vtkIdType *cell(nullptr);
      vtkIdType cellSize(0);</span>

<span style = "background-color:#fdd">      vpolys-&gt;GetNextCell(cellSize, cell);</span>

<span style = "background-color:#fdd">      float rgba[4] = {1.0f, 1.0f, 1.0f, 0};
      if (scalarVisibility &amp;&amp; vcellscalars)</span>
      {
<span style = "background-color:#fdd">        if (useCellData)</span>
        { // color each cell according to cell data
<span style = "background-color:#fdd">          double scalar = vcellscalars-&gt;GetComponent(i + numberOfLines, 0);
          double rgb[3] = {1.0f, 1.0f, 1.0f};
          m_ScalarsToColors-&gt;GetColor(scalar, rgb);
          rgba[0] = (float)rgb[0];
          rgba[1] = (float)rgb[1];
          rgba[2] = (float)rgb[2];
          rgba[3] = (float)m_ScalarsToOpacity-&gt;GetValue(scalar);
        }
        else if (usePointData)</span>
        {
<span style = "background-color:#fdd">          double scalar = vscalars-&gt;GetComponent(i, 0);
          double rgb[3] = {1.0f, 1.0f, 1.0f};
          m_ScalarsToColors-&gt;GetColor(scalar, rgb);
          rgba[0] = (float)rgb[0];
          rgba[1] = (float)rgb[1];
          rgba[2] = (float)rgb[2];
          rgba[3] = (float)m_ScalarsToOpacity-&gt;GetValue(scalar);</span>
        }
      }
<span style = "background-color:#fdd">      glColor4fv(rgba);</span>

<span style = "background-color:#fdd">      glBegin(GL_POLYGON);
      for (int j = 0; j &lt; cellSize; ++j)</span>
      {
<span style = "background-color:#fdd">        vpoints-&gt;GetPoint(cell[j], vp);</span>
        // take transformation via vtktransform into account
<span style = "background-color:#fdd">        vtktransform-&gt;TransformPoint(vp, vp);</span>

<span style = "background-color:#fdd">        vtk2itk(vp, p);</span>

        // convert 3D point (in mm) to display coordinates (units )
<span style = "background-color:#fdd">        renderer-&gt;WorldToDisplay(p, p2d);</span>

        // convert display coordinates ( (0,0) is top-left ) in GL coordinates ( (0,0) is bottom-left )
        // p2d[1]=toGL-p2d[1];

<span style = "background-color:#fdd">        cachedPoints[i * 10 + j][0] = p2d[0];
        cachedPoints[i * 10 + j][1] = p2d[1];</span>

        // add the current vertex to the line
<span style = "background-color:#fdd">        glVertex2f(p2d[0], p2d[1]);
      }
      glEnd();
    }</span>

<span style = "background-color:#fdd">    if (polyOutline)</span>
    {
<span style = "background-color:#fdd">      vpolys-&gt;InitTraversal();</span>

<span style = "background-color:#fdd">      glColor4f(outlineColor[0], outlineColor[1], outlineColor[2], 1.0f);
      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
      for (int i = 0; i &lt; numberOfPolys; ++i)</span>
      {
<span style = "background-color:#fdd">        const vtkIdType *cell(nullptr);
        vtkIdType cellSize(0);</span>

<span style = "background-color:#fdd">        vpolys-&gt;GetNextCell(cellSize, cell);</span>

<span style = "background-color:#fdd">        glBegin(GL_POLYGON);</span>
        // glPolygonOffset(1.0, 1.0);
<span style = "background-color:#fdd">        for (int j = 0; j &lt; cellSize; ++j)</span>
        {
          // add the current vertex to the line
<span style = "background-color:#fdd">          glVertex2f(cachedPoints[i * 10 + j][0], cachedPoints[i * 10 + j][1]);
        }
        glEnd();
      }</span>
    }
  }
<span style = "background-color:#fdd">  glDisable(GL_BLEND);
  delete[] cachedPoints;
}</span>

vtkAbstractMapper3D *mitk::UnstructuredGridMapper2D::GetVtkAbstractMapper3D(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{</span>
  // MITK_INFO &lt;&lt; "GETVTKABSTRACTMAPPER3D\n";
<span style = "background-color:#fdd">  mitk::DataNode::ConstPointer node = this-&gt;GetDataNode();
  if (node.IsNull())
    return nullptr;</span>

<span style = "background-color:#fdd">  mitk::VtkMapper::Pointer mitkMapper = dynamic_cast&lt;mitk::VtkMapper *&gt;(node-&gt;GetMapper(2));
  if (mitkMapper.IsNull())</span>
  {
<span style = "background-color:#fdd">    return nullptr;</span>
  }

<span style = "background-color:#fdd">  mitkMapper-&gt;Update(renderer);</span>

<span style = "background-color:#fdd">  auto *assembly = dynamic_cast&lt;vtkAssembly *&gt;(mitkMapper-&gt;GetVtkProp(renderer));
  if (assembly)</span>
  {
<span style = "background-color:#fdd">    vtkProp3DCollection *collection = assembly-&gt;GetParts();
    collection-&gt;InitTraversal();
    vtkProp3D *prop3d = nullptr;</span>
    do
    {
<span style = "background-color:#fdd">      prop3d = collection-&gt;GetNextProp3D();
      auto *actor = dynamic_cast&lt;vtkActor *&gt;(prop3d);
      if (actor)</span>
      {
<span style = "background-color:#fdd">        return dynamic_cast&lt;vtkAbstractMapper3D *&gt;(actor-&gt;GetMapper());</span>
      }

<span style = "background-color:#fdd">      auto *volume = dynamic_cast&lt;vtkVolume *&gt;(prop3d);
      if (volume)</span>
      {
<span style = "background-color:#fdd">        return dynamic_cast&lt;vtkAbstractMapper3D *&gt;(volume-&gt;GetMapper());</span>
      }
<span style = "background-color:#fdd">    } while (prop3d != collection-&gt;GetLastProp3D());
  }</span>
  else
  {
<span style = "background-color:#fdd">    auto *actor = dynamic_cast&lt;vtkActor *&gt;(mitkMapper-&gt;GetVtkProp(renderer));
    if (actor)</span>
    {
<span style = "background-color:#fdd">      return dynamic_cast&lt;vtkAbstractMapper3D *&gt;(actor-&gt;GetMapper());</span>
    }

<span style = "background-color:#fdd">    auto *volume = dynamic_cast&lt;vtkVolume *&gt;(mitkMapper-&gt;GetVtkProp(renderer));
    if (volume)</span>
    {
<span style = "background-color:#fdd">      return dynamic_cast&lt;vtkAbstractMapper3D *&gt;(volume-&gt;GetMapper());</span>
    }
  }
<span style = "background-color:#fdd">  return nullptr;
}</span>

vtkPointSet *mitk::UnstructuredGridMapper2D::GetVtkPointSet(mitk::BaseRenderer *renderer, int time)
<span style = "background-color:#fdd">{</span>
  // MITK_INFO &lt;&lt; "GETVTKPOINTSET\n";
<span style = "background-color:#fdd">  vtkAbstractMapper3D *abstractMapper = GetVtkAbstractMapper3D(renderer);
  if (abstractMapper == nullptr)</span>
  {
    // try to get data from the node
<span style = "background-color:#fdd">    mitk::DataNode::ConstPointer node = this-&gt;GetDataNode();
    if (node.IsNull())
      return nullptr;
    mitk::BaseData::Pointer data = node-&gt;GetData();
    mitk::UnstructuredGrid::Pointer grid = dynamic_cast&lt;mitk::UnstructuredGrid *&gt;(data.GetPointer());
    if (!grid.IsNull())
      return static_cast&lt;vtkPointSet *&gt;(grid-&gt;GetVtkUnstructuredGrid(time));</span>

<span style = "background-color:#fdd">    return nullptr;
  }</span>
  else
  {
<span style = "background-color:#fdd">    auto *mapper = dynamic_cast&lt;vtkMapper *&gt;(abstractMapper);
    if (mapper)</span>
    {
<span style = "background-color:#fdd">      return dynamic_cast&lt;vtkPointSet *&gt;(mapper-&gt;GetInput());</span>
    }
<span style = "background-color:#fdd">    auto *volMapper = dynamic_cast&lt;vtkAbstractVolumeMapper *&gt;(abstractMapper);
    if (volMapper)</span>
    {
<span style = "background-color:#fdd">      return dynamic_cast&lt;vtkPointSet *&gt;(volMapper-&gt;GetDataSetInput());</span>
    }
  }

<span style = "background-color:#fdd">  return nullptr;
}</span>

vtkScalarsToColors *mitk::UnstructuredGridMapper2D::GetVtkLUT(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{</span>
  // MITK_INFO &lt;&lt; "GETVTKLUT\n";
<span style = "background-color:#fdd">  auto *mapper = dynamic_cast&lt;vtkMapper *&gt;(GetVtkAbstractMapper3D(renderer));
  if (mapper)
    return mapper-&gt;GetLookupTable();</span>
  else
  {
<span style = "background-color:#fdd">    mitk::DataNode::ConstPointer node = this-&gt;GetDataNode();
    if (node.IsNull())
      return nullptr;</span>

<span style = "background-color:#fdd">    mitk::VtkMapper::Pointer mitkMapper = dynamic_cast&lt;mitk::VtkMapper *&gt;(node-&gt;GetMapper(2));
    if (mitkMapper.IsNull())</span>
    {
      // MITK_INFO &lt;&lt; "mitkMapper is null\n";
<span style = "background-color:#fdd">      return nullptr;</span>
    }

<span style = "background-color:#fdd">    mitkMapper-&gt;Update(renderer);</span>

<span style = "background-color:#fdd">    auto *volume = dynamic_cast&lt;vtkVolume *&gt;(mitkMapper-&gt;GetVtkProp(renderer));
    if (volume)</span>
    {
      // MITK_INFO &lt;&lt; "found volume prop\n";
<span style = "background-color:#fdd">      return static_cast&lt;vtkScalarsToColors *&gt;(volume-&gt;GetProperty()-&gt;GetRGBTransferFunction());</span>
    }

<span style = "background-color:#fdd">    auto *assembly = dynamic_cast&lt;vtkAssembly *&gt;(mitkMapper-&gt;GetVtkProp(renderer));
    if (assembly)</span>
    {
      // MITK_INFO &lt;&lt; "found assembly prop\n";
<span style = "background-color:#fdd">      mitk::TransferFunctionProperty::Pointer transferFuncProp;
      node-&gt;GetProperty(transferFuncProp, "TransferFunction", nullptr);
      if (transferFuncProp.IsNotNull())</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "return colortransferfunction\n";
        return static_cast&lt;vtkScalarsToColors *&gt;(transferFuncProp-&gt;GetValue()-&gt;GetColorTransferFunction());</span>
      }
<span style = "background-color:#fdd">    }
    return nullptr;</span>
  }
<span style = "background-color:#fdd">}</span>

bool mitk::UnstructuredGridMapper2D::IsConvertibleToVtkPointSet(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  return (GetVtkPointSet(renderer, this-&gt;GetTimestep()) != nullptr);
}</span>

mitk::UnstructuredGridMapper2D::UnstructuredGridMapper2D()
<span style = "background-color:#fdd">{
  m_Plane = vtkPlane::New();
  m_Slicer = vtkPointSetSlicer::New();</span>

<span style = "background-color:#fdd">  m_Slicer-&gt;SetSlicePlane(m_Plane);</span>

<span style = "background-color:#fdd">  m_ScalarsToColors = nullptr;
  m_ScalarsToOpacity = nullptr;
  m_VtkPointSet = nullptr;</span>

  // m_LUT = vtkLookupTable::New();
  // m_LUT-&gt;SetTableRange( 0, 255 );
  // m_LUT-&gt;SetNumberOfColors( 255 );
  // m_LUT-&gt;SetRampToLinear ();
  // m_LUT-&gt;Build();
<span style = "background-color:#fdd">}</span>

mitk::UnstructuredGridMapper2D::~UnstructuredGridMapper2D()
<span style = "background-color:#fdd">{
  m_Slicer-&gt;Delete();
  m_Plane-&gt;Delete();</span>

<span style = "background-color:#fdd">  if (m_ScalarsToOpacity != nullptr)
    m_ScalarsToOpacity-&gt;UnRegister(nullptr);
  if (m_ScalarsToColors != nullptr)
    m_ScalarsToColors-&gt;UnRegister(nullptr);
  if (m_VtkPointSet != nullptr)
    m_VtkPointSet-&gt;UnRegister(nullptr);
}</span></pre>
	</body>
</html>