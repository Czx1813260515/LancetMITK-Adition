<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkVectorImageMapper2D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkVectorImageMapper2D.h"

// vtk related includes
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkCellData.h&gt;
#include &lt;vtkCutter.h&gt;
#include &lt;vtkDataArray.h&gt;
#include &lt;vtkDataObject.h&gt;
#include &lt;vtkDataSetWriter.h&gt;
#include &lt;vtkFloatArray.h&gt;
#include &lt;vtkGlyph2D.h&gt;
#include &lt;vtkGlyphSource2D.h&gt;
#include &lt;vtkImageData.h&gt;
#include &lt;vtkImageReslice.h&gt;
#include &lt;vtkIndent.h&gt;
#include &lt;vtkLinearTransform.h&gt;
#include &lt;vtkLookupTable.h&gt;
#include &lt;vtkLookupTable.h&gt;
#include &lt;vtkMaskedGlyph2D.h&gt;
#include &lt;vtkMaskedGlyph3D.h&gt;
#include &lt;vtkMath.h&gt;
#include &lt;vtkMatrix4x4.h&gt;
#include &lt;vtkMatrixToLinearTransform.h&gt;
#include &lt;vtkPlane.h&gt;
#include &lt;vtkPlane.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkPoints.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkScalarsToColors.h&gt;
#include &lt;vtkScalarsToColors.h&gt;
#include &lt;vtkTransform.h&gt;

#include &lt;fstream&gt;

// mitk related includes
#include "mitkAbstractTransformGeometry.h"
#include "mitkBaseRenderer.h"
#include "mitkColorProperty.h"
#include "mitkGL.h"
#include "mitkProperties.h"
#include &lt;mitkLookupTableProperty.h&gt;

const mitk::Image *mitk::VectorImageMapper2D::GetInput(void)
<span style = "background-color:#fdd">{
  if (m_Image.IsNotNull())
    return m_Image;</span>
  else
<span style = "background-color:#fdd">    return dynamic_cast&lt;const mitk::Image *&gt;(GetDataNode()-&gt;GetData());
}</span>

void mitk::VectorImageMapper2D::Paint(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{</span>
  // std::cout &lt;&lt; "2d vector mapping..." &lt;&lt; std::endl;

<span style = "background-color:#fdd">  bool visible = true;
  GetDataNode()-&gt;GetVisibility(visible, renderer, "visible");</span>

<span style = "background-color:#fdd">  if (!visible)
    return;</span>

<span style = "background-color:#fdd">  mitk::Image::Pointer input = const_cast&lt;mitk::Image *&gt;(this-&gt;GetInput());</span>

<span style = "background-color:#fdd">  if (input.IsNull())
    return;</span>

<span style = "background-color:#fdd">  vtkImageData *vtkImage = input-&gt;GetVtkImageData(this-&gt;GetCurrentTimeStep(input, renderer));</span>

  //
  // set up the cutter orientation according to the current geometry of
  // the renderers plane
  //
<span style = "background-color:#fdd">  Point3D point;
  Vector3D normal;
  PlaneGeometry::ConstPointer worldPlaneGeometry = renderer-&gt;GetCurrentWorldPlaneGeometry();</span>

<span style = "background-color:#fdd">  if (worldPlaneGeometry.IsNotNull())</span>
  {
    // set up vtkPlane according to worldGeometry
<span style = "background-color:#fdd">    point = worldPlaneGeometry-&gt;GetOrigin();
    normal = worldPlaneGeometry-&gt;GetNormal();
    normal.Normalize();
    m_Plane-&gt;SetTransform((vtkAbstractTransform *)nullptr);
  }</span>
  else
  {
<span style = "background-color:#fdd">    itkWarningMacro(&lt;&lt; "worldPlaneGeometry is nullptr!");
    return;</span>
  }

  double vp[3], vp_slice[3], vnormal[3];
<span style = "background-color:#fdd">  vnl2vtk(point.GetVnlVector(), vp);
  vnl2vtk(normal.GetVnlVector(), vnormal);</span>
  // std::cout &lt;&lt; "Origin: " &lt;&lt; vp[0] &lt;&lt;" "&lt;&lt; vp[1] &lt;&lt;" "&lt;&lt; vp[2] &lt;&lt; std::endl;
  // std::cout &lt;&lt; "Normal: " &lt;&lt; vnormal[0] &lt;&lt;" "&lt;&lt; vnormal[1] &lt;&lt;" "&lt;&lt; vnormal[2] &lt;&lt; std::endl;

  // normally, we would need to transform the surface and cut the transformed surface with the cutter.
  // This might be quite slow. Thus, the idea is, to perform an inverse transform of the plane instead.
  //@todo It probably does not work for scaling operations yet:scaling operations have to be
  // dealed with after the cut is performed by scaling the contour.
<span style = "background-color:#fdd">  vtkLinearTransform *vtktransform = GetDataNode()-&gt;GetVtkTransform();</span>

<span style = "background-color:#fdd">  vtkTransform *world2vtk = vtkTransform::New();
  world2vtk-&gt;Identity();
  world2vtk-&gt;Concatenate(vtktransform-&gt;GetLinearInverse());</span>
  double myscale[3];
<span style = "background-color:#fdd">  world2vtk-&gt;GetScale(myscale);
  world2vtk-&gt;PostMultiply();
  world2vtk-&gt;Scale(1 / myscale[0], 1 / myscale[1], 1 / myscale[2]);
  world2vtk-&gt;TransformPoint(vp, vp);
  world2vtk-&gt;TransformNormalAtPoint(vp, vnormal, vnormal);
  world2vtk-&gt;Delete();</span>

  // vtk works in axis align coords
  // thus the normal also must be axis align, since
  // we do not allow arbitrary cutting through volume
  //
  // vnormal should already be axis align, but in order
  // to get rid of precision effects, we set the two smaller
  // components to zero here
  int dims[3];
<span style = "background-color:#fdd">  vtkImage-&gt;GetDimensions(dims);</span>
  double spac[3];
<span style = "background-color:#fdd">  vtkImage-&gt;GetSpacing(spac);
  vp_slice[0] = vp[0];
  vp_slice[1] = vp[1];
  vp_slice[2] = vp[2];
  if (fabs(vnormal[0]) &gt; fabs(vnormal[1]) &amp;&amp; fabs(vnormal[0]) &gt; fabs(vnormal[2]))</span>
  {
<span style = "background-color:#fdd">    if (fabs(vp_slice[0] / spac[0]) &lt; 0.4)
      vp_slice[0] = 0.4 * spac[0];
    if (fabs(vp_slice[0] / spac[0]) &gt; (dims[0] - 1) - 0.4)
      vp_slice[0] = ((dims[0] - 1) - 0.4) * spac[0];
    vnormal[1] = 0;
    vnormal[2] = 0;</span>
  }

<span style = "background-color:#fdd">  if (fabs(vnormal[1]) &gt; fabs(vnormal[0]) &amp;&amp; fabs(vnormal[1]) &gt; fabs(vnormal[2]))</span>
  {
<span style = "background-color:#fdd">    if (fabs(vp_slice[1] / spac[1]) &lt; 0.4)
      vp_slice[1] = 0.4 * spac[1];
    if (fabs(vp_slice[1] / spac[1]) &gt; (dims[1] - 1) - 0.4)
      vp_slice[1] = ((dims[1] - 1) - 0.4) * spac[1];
    vnormal[0] = 0;
    vnormal[2] = 0;</span>
  }

<span style = "background-color:#fdd">  if (fabs(vnormal[2]) &gt; fabs(vnormal[1]) &amp;&amp; fabs(vnormal[2]) &gt; fabs(vnormal[0]))</span>
  {
<span style = "background-color:#fdd">    if (fabs(vp_slice[2] / spac[2]) &lt; 0.4)
      vp_slice[2] = 0.4 * spac[2];
    if (fabs(vp_slice[2] / spac[2]) &gt; (dims[2] - 1) - 0.4)
      vp_slice[2] = ((dims[2] - 1) - 0.4) * spac[2];
    vnormal[0] = 0;
    vnormal[1] = 0;</span>
  }

<span style = "background-color:#fdd">  m_Plane-&gt;SetOrigin(vp_slice);
  m_Plane-&gt;SetNormal(vnormal);</span>

  vtkPolyData *cuttedPlane;
<span style = "background-color:#fdd">  if (!((dims[0] == 1 &amp;&amp; vnormal[0] != 0) || (dims[1] == 1 &amp;&amp; vnormal[1] != 0) || (dims[2] == 1 &amp;&amp; vnormal[2] != 0)))</span>
  {
<span style = "background-color:#fdd">    m_Cutter-&gt;SetCutFunction(m_Plane);
    m_Cutter-&gt;SetInputData(vtkImage);
    m_Cutter-&gt;GenerateCutScalarsOff(); //!
    m_Cutter-&gt;Update();
    cuttedPlane = m_Cutter-&gt;GetOutput();
  }</span>
  else
  {
    // cutting of a 2D-Volume does not work,
    // so we have to build up our own polydata object
<span style = "background-color:#fdd">    cuttedPlane = vtkPolyData::New();
    vtkPoints *points = vtkPoints::New();
    points-&gt;SetNumberOfPoints(vtkImage-&gt;GetNumberOfPoints());
    for (int i = 0; i &lt; vtkImage-&gt;GetNumberOfPoints(); i++)
      points-&gt;SetPoint(i, vtkImage-&gt;GetPoint(i));
    cuttedPlane-&gt;SetPoints(points);
    vtkFloatArray *pointdata = vtkFloatArray::New();
    int comps = vtkImage-&gt;GetPointData()-&gt;GetScalars()-&gt;GetNumberOfComponents();
    pointdata-&gt;SetNumberOfComponents(comps);
    int tuples = vtkImage-&gt;GetPointData()-&gt;GetScalars()-&gt;GetNumberOfTuples();
    pointdata-&gt;SetNumberOfTuples(tuples);
    for (int i = 0; i &lt; tuples; i++)
      pointdata-&gt;SetTuple(i, vtkImage-&gt;GetPointData()-&gt;GetScalars()-&gt;GetTuple(i));
    pointdata-&gt;SetName("vector");
    cuttedPlane-&gt;GetPointData()-&gt;AddArray(pointdata);</span>
  }

<span style = "background-color:#fdd">  if (cuttedPlane-&gt;GetNumberOfPoints() != 0)</span>
  {
    //
    // make sure, that we have point data with more than 1 component (as vectors)
    //
<span style = "background-color:#fdd">    vtkPointData *pointData = cuttedPlane-&gt;GetPointData();
    if (pointData == nullptr)</span>
    {
<span style = "background-color:#fdd">      itkWarningMacro(&lt;&lt; "no point data associated with cutters result!");
      return;</span>
    }
<span style = "background-color:#fdd">    if (pointData-&gt;GetNumberOfArrays() == 0)</span>
    {
<span style = "background-color:#fdd">      itkWarningMacro(&lt;&lt; "point data returned by cutter doesn't have any arrays associated!");
      return;
    }
    else if (pointData-&gt;GetArray(0)-&gt;GetNumberOfComponents() &lt;= 1)</span>
    {
<span style = "background-color:#fdd">      itkWarningMacro(&lt;&lt; "number of components &lt;= 1!");
      return;
    }
    else if (pointData-&gt;GetArrayName(0) == nullptr)</span>
    {
<span style = "background-color:#fdd">      pointData-&gt;GetArray(0)-&gt;SetName("vector");</span>
      // std::cout &lt;&lt; "array name = vectors now" &lt;&lt; std::endl;
    }
    // std::cout &lt;&lt; "  projecting..."&lt;&lt; std::endl;

    //
    // constrain the vectors to lie on the plane, which means to remove the vector component,
    // which is orthogonal to the plane.
    //
    vtkIdType numPoints, pointId;
<span style = "background-color:#fdd">    numPoints = cuttedPlane-&gt;GetNumberOfPoints();
    vtkDataArray *inVectors = cuttedPlane-&gt;GetPointData()-&gt;GetVectors("vector");
    assert(inVectors != nullptr);
    vtkFloatArray *vectorMagnitudes = vtkFloatArray::New();
    vectorMagnitudes-&gt;SetName("vectorMagnitudes");
    vectorMagnitudes-&gt;SetNumberOfComponents(1);
    vectorMagnitudes-&gt;SetNumberOfValues(numPoints);
    vectorMagnitudes-&gt;SetNumberOfTuples(numPoints);</span>
    double inVector[3], outVector[3], wnormal[3]; //, tmpVector[ 3 ], outVector[ 3 ];
<span style = "background-color:#fdd">    double k = 0.0;
    vnl2vtk(normal.GetVnlVector(), wnormal);
    vtkMath::Normalize(wnormal);</span>
    bool normalizeVecs;
<span style = "background-color:#fdd">    m_DataNode-&gt;GetBoolProperty("NormalizeVecs", normalizeVecs);
    for (pointId = 0; pointId &lt; numPoints; ++pointId)</span>
    {
<span style = "background-color:#fdd">      inVectors-&gt;GetTuple(pointId, inVector);
      if (normalizeVecs)</span>
      {
<span style = "background-color:#fdd">        vnl_vector&lt;double&gt; tmp(3);
        vtk2vnl(inVector, tmp);
        tmp.normalize();
        vnl2vtk(tmp, inVector);
      }
      k = vtkMath::Dot(wnormal, inVector);</span>
      // Remove non orthogonal component.
<span style = "background-color:#fdd">      outVector[0] = inVector[0] - (wnormal[0] * k);
      outVector[1] = inVector[1] - (wnormal[1] * k);
      outVector[2] = inVector[2] - (wnormal[2] * k);
      inVectors-&gt;SetTuple(pointId, outVector);</span>

      // ?? this was set to norm(inVector) before, but outVector made more sense to me
<span style = "background-color:#fdd">      vectorMagnitudes-&gt;SetValue(pointId, vtkMath::Norm(outVector));</span>

      // std::cout &lt;&lt; "method old: " &lt;&lt; inVector[0] &lt;&lt;", " &lt;&lt; inVector[1] &lt;&lt; ", "&lt;&lt;inVector[2] &lt;&lt; ", method new: " &lt;&lt;
      // outVector[0] &lt;&lt; ", "&lt;&lt; outVector[1] &lt;&lt; ", "&lt;&lt; outVector[2] &lt;&lt; std::endl;
<span style = "background-color:#fdd">    }
    pointData-&gt;AddArray(vectorMagnitudes);
    pointData-&gt;CopyAllOn();</span>

    // pointData-&gt;PrintSelf(std::cout, vtkIndent(4));
    // std::cout &lt;&lt; "  ...done!"&lt;&lt; std::endl;
    // std::cout &lt;&lt; "  glyphing..."&lt;&lt; std::endl;

    // call glyph2D to generate 2D glyphs for each of the
    // vectors
<span style = "background-color:#fdd">    vtkGlyphSource2D *glyphSource = vtkGlyphSource2D::New();</span>
    // glyphSource-&gt;SetGlyphTypeToDash();
<span style = "background-color:#fdd">    glyphSource-&gt;DashOn();</span>
    // glyphSource-&gt;SetScale( 0.1 );
    // glyphSource-&gt;SetScale2( .5 );
    // glyphSource-&gt;SetCenter( 0.5, 0.5, 0.5 );
<span style = "background-color:#fdd">    glyphSource-&gt;CrossOff();</span>
    // glyphSource-&gt;FilledOff();
    // glyphSource-&gt;Update();

    double spacing[3];
<span style = "background-color:#fdd">    vtkImage-&gt;GetSpacing(spacing);
    double min = spacing[0];
    min = min &gt; spacing[1] ? spacing[1] : min;
    min = min &gt; spacing[2] ? spacing[2] : min;</span>

<span style = "background-color:#fdd">    float scale = 1;
    mitk::FloatProperty::Pointer mitkScaleProp =</span>
      dynamic_cast&lt;mitk::FloatProperty *&gt;(GetDataNode()-&gt;GetProperty("Scale"));
<span style = "background-color:#fdd">    if (mitkScaleProp.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      scale = mitkScaleProp-&gt;GetValue();</span>
    }

<span style = "background-color:#fdd">    vtkMaskedGlyph3D *glyphGenerator = vtkMaskedGlyph3D::New();
    glyphGenerator-&gt;SetSourceData(glyphSource-&gt;GetOutput());
    glyphGenerator-&gt;SetInput(cuttedPlane);
    glyphGenerator-&gt;SetInputArrayToProcess(1, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, "vector");
    glyphGenerator-&gt;SetVectorModeToUseVector();
    glyphGenerator-&gt;OrientOn();
    glyphGenerator-&gt;SetScaleFactor(min * scale);
    glyphGenerator-&gt;SetUseMaskPoints(true);
    glyphGenerator-&gt;SetRandomMode(true);
    glyphGenerator-&gt;SetMaximumNumberOfPoints(128 * 128);</span>

<span style = "background-color:#fdd">    glyphGenerator-&gt;Update();</span>

    /*
    vtkLookupTable* vtkLut = nullptr;
    mitk::LookupTableProperty::Pointer mitkLutProp =
    dynamic_cast&lt;mitk::LookupTableProperty*&gt;(GetDataNode()-&gt;GetProperty("LookupTable"));
    if (mitkLutProp.IsNotNull())
    {
      vtkLut = mitkLutProp-&gt;GetLookupTable()-&gt;GetVtkLookupTable();
    }
    */

<span style = "background-color:#fdd">    mitk::Color color;
    mitk::ColorProperty::Pointer mitkColorProp =</span>
      dynamic_cast&lt;mitk::ColorProperty *&gt;(GetDataNode()-&gt;GetProperty("color"));
<span style = "background-color:#fdd">    if (mitkColorProp.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      color = mitkColorProp-&gt;GetColor();
    }</span>
    else
    {
<span style = "background-color:#fdd">      color.SetRed(0);
      color.SetBlue(1);
      color.SetGreen(0);</span>
    }

<span style = "background-color:#fdd">    float lwidth = 1;
    mitk::FloatProperty::Pointer mitkLWidthProp =</span>
      dynamic_cast&lt;mitk::FloatProperty *&gt;(GetDataNode()-&gt;GetProperty("LineWidth"));
<span style = "background-color:#fdd">    if (mitkLWidthProp.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      lwidth = mitkLWidthProp-&gt;GetValue();</span>
    }

<span style = "background-color:#fdd">    vtkTransform *trafo = vtkTransform::New();
    trafo-&gt;Identity();
    trafo-&gt;Concatenate(vtktransform);
    trafo-&gt;PreMultiply();</span>
    double myscale[3];
<span style = "background-color:#fdd">    trafo-&gt;GetScale(myscale);
    trafo-&gt;Scale(1 / myscale[0], 1 / myscale[1], 1 / myscale[2]);</span>

<span style = "background-color:#fdd">    this-&gt;PaintCells(glyphGenerator-&gt;GetOutput(),</span>
                     renderer-&gt;GetCurrentWorldPlaneGeometry(),
                     trafo,
                     renderer,
                     nullptr /*vtkLut*/,
                     color,
                     lwidth,
                     spacing);

<span style = "background-color:#fdd">    vectorMagnitudes-&gt;Delete();
    glyphSource-&gt;Delete();
    glyphGenerator-&gt;Delete();
    trafo-&gt;Delete();
  }</span>
  else
  {
<span style = "background-color:#fdd">    std::cout &lt;&lt; "  no points cutted!" &lt;&lt; std::endl;</span>
  }
  // std::cout &lt;&lt; "...done!" &lt;&lt; std::endl;
<span style = "background-color:#fdd">}</span>

void mitk::VectorImageMapper2D::PaintCells(vtkPolyData *glyphs,
                                           const PlaneGeometry * /*worldGeometry*/,
                                           vtkLinearTransform *vtktransform,
                                           mitk::BaseRenderer *renderer,
                                           vtkScalarsToColors *lut,
                                           mitk::Color color,
                                           float lwidth,
                                           double *spacing)
<span style = "background-color:#fdd">{
  vtkPoints *points = glyphs-&gt;GetPoints();
  vtkPointData *vpointdata = glyphs-&gt;GetPointData();
  vtkDataArray *vpointscalars = vpointdata-&gt;GetArray("vectorMagnitudes");</span>
  // vtkDataArray* vpointpositions = vpointdata-&gt;GetArray("pointPositions");
<span style = "background-color:#fdd">  assert(vpointscalars != nullptr);</span>
  // std::cout &lt;&lt; "  Scalars range 2d:" &lt;&lt; vpointscalars-&gt;GetRange()[0] &lt;&lt; " " &lt;&lt; vpointscalars-&gt;GetRange()[0] &lt;&lt;
  // std::endl;

<span style = "background-color:#fdd">  Point3D p;
  Point2D p2d;</span>
  vtkIdList *idList;
  vtkCell *cell;

  double offset[3];
<span style = "background-color:#fdd">  for (auto &amp;elem : offset)</span>
  {
<span style = "background-color:#fdd">    elem = 0;
  }</span>

<span style = "background-color:#fdd">  vtkIdType numCells = glyphs-&gt;GetNumberOfCells();
  for (vtkIdType cellId = 0; cellId &lt; numCells; ++cellId)</span>
  {
    double vp[3];

<span style = "background-color:#fdd">    cell = glyphs-&gt;GetCell(cellId);
    idList = cell-&gt;GetPointIds();</span>

<span style = "background-color:#fdd">    int numPoints = idList-&gt;GetNumberOfIds();</span>

<span style = "background-color:#fdd">    if (numPoints == 1)</span>
    {
      // take transformation via vtktransform into account
      double pos[3], vp_raster[3];
<span style = "background-color:#fdd">      points-&gt;GetPoint(idList-&gt;GetId(0), vp);
      vp_raster[0] = vtkMath::Round(vp[0] / spacing[0]) * spacing[0];
      vp_raster[1] = vtkMath::Round(vp[1] / spacing[1]) * spacing[1];
      vp_raster[2] = vtkMath::Round(vp[2] / spacing[2]) * spacing[2];
      vtktransform-&gt;TransformPoint(vp_raster, pos);
      offset[0] = pos[0] - vp[0];
      offset[1] = pos[1] - vp[1];
      offset[2] = pos[2] - vp[2];
    }</span>
    else
    {
<span style = "background-color:#fdd">      glLineWidth(lwidth);
      glBegin(GL_LINE_LOOP);</span>

<span style = "background-color:#fdd">      for (int pointNr = 0; pointNr &lt; numPoints; ++pointNr)</span>
      {
<span style = "background-color:#fdd">        points-&gt;GetPoint(idList-&gt;GetId(pointNr), vp);</span>

<span style = "background-color:#fdd">        vp[0] = vp[0] + offset[0];
        vp[1] = vp[1] + offset[1];
        vp[2] = vp[2] + offset[2];</span>

        double tmp[3];
<span style = "background-color:#fdd">        vtktransform-&gt;TransformPoint(vp, tmp);</span>

<span style = "background-color:#fdd">        vtk2itk(vp, p);</span>

        // convert 3D point (in mm) to display coordinates (units )
<span style = "background-color:#fdd">        renderer-&gt;WorldToDisplay(p, p2d);</span>

<span style = "background-color:#fdd">        if (lut != nullptr)</span>
        {
          // color each point according to point data
          double *color;

<span style = "background-color:#fdd">          if (vpointscalars != nullptr)</span>
          {
<span style = "background-color:#fdd">            vpointscalars-&gt;GetComponent(pointNr, 0);
            color = lut-&gt;GetColor(vpointscalars-&gt;GetComponent(idList-&gt;GetId(pointNr), 0));
            glColor3f(color[0], color[1], color[2]);</span>
          }
<span style = "background-color:#fdd">        }</span>
        else
        {
<span style = "background-color:#fdd">          glColor3f(color.GetRed(), color.GetGreen(), color.GetBlue());</span>
        }

        // std::cout &lt;&lt;  idList-&gt;GetId( pointNr )&lt;&lt; ": " &lt;&lt; p2d[0]&lt;&lt; " "&lt;&lt; p2d[1] &lt;&lt; std::endl;
        // draw the line
<span style = "background-color:#fdd">        glVertex2f(p2d[0], p2d[1]);
      }
      glEnd();</span>
    }
<span style = "background-color:#fdd">  }
}</span>

mitk::VectorImageMapper2D::VectorImageMapper2D()
<span style = "background-color:#fdd">{
  m_LUT = nullptr;
  m_Plane = vtkPlane::New();
  m_Cutter = vtkCutter::New();</span>

<span style = "background-color:#fdd">  m_Cutter-&gt;SetCutFunction(m_Plane);
  m_Cutter-&gt;GenerateValues(1, 0, 1);
}</span>

mitk::VectorImageMapper2D::~VectorImageMapper2D()
<span style = "background-color:#fdd">{
  if (m_LUT != nullptr)
    m_LUT-&gt;Delete();
  if (m_Plane != nullptr)
    m_Plane-&gt;Delete();
  if (m_Cutter != nullptr)
    m_Cutter-&gt;Delete();
}</span>

int mitk::VectorImageMapper2D::GetCurrentTimeStep(mitk::BaseData *data, mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{</span>
  //
  // get the TimeGeometry of the input object
  //
<span style = "background-color:#fdd">  const TimeGeometry *dataTimeGeometry = data-&gt;GetUpdatedTimeGeometry();
  if ((dataTimeGeometry == nullptr) || (dataTimeGeometry-&gt;CountTimeSteps() == 0))</span>
  {
<span style = "background-color:#fdd">    itkWarningMacro(&lt;&lt; "The given object is missing a mitk::TimeGeometry, or the number of time steps is 0!");
    return 0;</span>
  }

  //
  // get the world time
  //
<span style = "background-color:#fdd">  ScalarType time = renderer-&gt;GetTime();</span>
  //
  // convert the world time to time steps of the input object
  //
<span style = "background-color:#fdd">  int timestep = 0;
  if (time &gt; itk::NumericTraits&lt;mitk::ScalarType&gt;::NonpositiveMin())
    timestep = dataTimeGeometry-&gt;TimePointToTimeStep(time);
  if (dataTimeGeometry-&gt;IsValidTimeStep(timestep) == false)</span>
  {
<span style = "background-color:#fdd">    itkWarningMacro(&lt;&lt; timestep &lt;&lt; " is not a valid time of the given data object!");
    return 0;</span>
  }
<span style = "background-color:#fdd">  return timestep;
}</span></pre>
	</body>
</html>