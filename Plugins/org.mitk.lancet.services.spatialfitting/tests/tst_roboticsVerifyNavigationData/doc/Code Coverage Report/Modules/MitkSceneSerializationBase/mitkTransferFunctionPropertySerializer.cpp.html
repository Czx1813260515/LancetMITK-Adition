<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkTransferFunctionPropertySerializer.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkTransferFunctionPropertySerializer.h"
#include &lt;mitkLexicalCast.h&gt;
#include &lt;mitkLocaleSwitch.h&gt;
#include &lt;tinyxml2.h&gt;

namespace mitk
{
<span style = "background-color:#fdd">  mitk::TransferFunctionPropertySerializer::TransferFunctionPropertySerializer() {}
  mitk::TransferFunctionPropertySerializer::~TransferFunctionPropertySerializer() {}</span>
  tinyxml2::XMLElement *mitk::TransferFunctionPropertySerializer::Serialize(tinyxml2::XMLDocument &amp;doc)
<span style = "background-color:#fdd">  {
    if (const auto *prop =</span>
          dynamic_cast&lt;const TransferFunctionProperty *&gt;(mitk::BasePropertySerializer::m_Property.GetPointer()))
    {
<span style = "background-color:#fdd">      LocaleSwitch localeSwitch("C");</span>

<span style = "background-color:#fdd">      TransferFunction *transferfunction = prop-&gt;GetValue();
      if (!transferfunction)
        return nullptr;</span>

<span style = "background-color:#fdd">      auto *element = doc.NewElement("TransferFunction");</span>

      // serialize scalar opacity function
<span style = "background-color:#fdd">      auto *scalarOpacityPointlist = doc.NewElement("ScalarOpacity");</span>

<span style = "background-color:#fdd">      TransferFunction::ControlPoints scalarOpacityPoints = transferfunction-&gt;GetScalarOpacityPoints();
      for (auto iter = scalarOpacityPoints.begin(); iter != scalarOpacityPoints.end(); ++iter)</span>
      {
<span style = "background-color:#fdd">        auto *pointel = doc.NewElement("point");
        pointel-&gt;SetAttribute("x", boost::lexical_cast&lt;std::string&gt;(iter-&gt;first).c_str());
        pointel-&gt;SetAttribute("y", boost::lexical_cast&lt;std::string&gt;(iter-&gt;second).c_str());
        scalarOpacityPointlist-&gt;InsertEndChild(pointel);
      }
      element-&gt;InsertEndChild(scalarOpacityPointlist);</span>
      // serialize gradient opacity function
<span style = "background-color:#fdd">      auto *gradientOpacityPointlist = doc.NewElement("GradientOpacity");
      TransferFunction::ControlPoints gradientOpacityPoints = transferfunction-&gt;GetGradientOpacityPoints();
      for (auto iter = gradientOpacityPoints.begin(); iter != gradientOpacityPoints.end(); ++iter)</span>
      {
<span style = "background-color:#fdd">        auto *pointel = doc.NewElement("point");
        pointel-&gt;SetAttribute("x", boost::lexical_cast&lt;std::string&gt;(iter-&gt;first).c_str());
        pointel-&gt;SetAttribute("y", boost::lexical_cast&lt;std::string&gt;(iter-&gt;second).c_str());
        gradientOpacityPointlist-&gt;InsertEndChild(pointel);
      }
      element-&gt;InsertEndChild(gradientOpacityPointlist);</span>

      // serialize color function
<span style = "background-color:#fdd">      vtkColorTransferFunction *ctf = transferfunction-&gt;GetColorTransferFunction();
      if (ctf == nullptr)
        return nullptr;
      auto *pointlist = doc.NewElement("Color");
      for (int i = 0; i &lt; ctf-&gt;GetSize(); i++)</span>
      {
        double myVal[6];
<span style = "background-color:#fdd">        ctf-&gt;GetNodeValue(i, myVal);
        auto *pointel = doc.NewElement("point");
        pointel-&gt;SetAttribute("x", boost::lexical_cast&lt;std::string&gt;(myVal[0]).c_str());
        pointel-&gt;SetAttribute("r", boost::lexical_cast&lt;std::string&gt;(myVal[1]).c_str());
        pointel-&gt;SetAttribute("g", boost::lexical_cast&lt;std::string&gt;(myVal[2]).c_str());
        pointel-&gt;SetAttribute("b", boost::lexical_cast&lt;std::string&gt;(myVal[3]).c_str());
        pointel-&gt;SetAttribute("midpoint", boost::lexical_cast&lt;std::string&gt;(myVal[4]).c_str());
        pointel-&gt;SetAttribute("sharpness", boost::lexical_cast&lt;std::string&gt;(myVal[5]).c_str());
        pointlist-&gt;InsertEndChild(pointel);
      }
      element-&gt;InsertEndChild(pointlist);
      return element;
    }</span>
    else
<span style = "background-color:#fdd">      return nullptr;
  }</span>

  bool mitk::TransferFunctionPropertySerializer::SerializeTransferFunction(const char *filename,
                                                                           TransferFunction::Pointer tf)
<span style = "background-color:#fdd">  {
    TransferFunctionPropertySerializer::Pointer tfps = TransferFunctionPropertySerializer::New();
    tfps-&gt;SetProperty(TransferFunctionProperty::New(tf));</span>

<span style = "background-color:#fdd">    tinyxml2::XMLDocument doc;
    auto *s = tfps-&gt;Serialize(doc);</span>

<span style = "background-color:#fdd">    if (!s)</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "cant serialize transfer function";</span>

<span style = "background-color:#fdd">      return false;</span>
    }

<span style = "background-color:#fdd">    tinyxml2::XMLDocument doc2;
    doc2.InsertEndChild(doc2.NewDeclaration());</span>

<span style = "background-color:#fdd">    auto *version = doc2.NewElement("Version");
    version-&gt;SetAttribute("TransferfunctionVersion", 1);</span>

<span style = "background-color:#fdd">    doc2.InsertEndChild(version);
    doc2.InsertEndChild(s-&gt;DeepClone(&amp;doc2));</span>

<span style = "background-color:#fdd">    if (tinyxml2::XML_SUCCESS != doc2.SaveFile(filename))</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Could not write scene to " &lt;&lt; filename &lt;&lt; "\nTinyXML reports '" &lt;&lt; doc2.ErrorStr() &lt;&lt; "'";
      return false;</span>
    }
<span style = "background-color:#fdd">    return true;
  }</span>

  BaseProperty::Pointer mitk::TransferFunctionPropertySerializer::Deserialize(const tinyxml2::XMLElement *element)
<span style = "background-color:#fdd">  {
    if (!element)
      return nullptr;</span>

<span style = "background-color:#fdd">    mitk::LocaleSwitch localeSwitch("C");</span>

<span style = "background-color:#fdd">    TransferFunction::Pointer tf = TransferFunction::New();</span>

    // deserialize scalar opacity function
<span style = "background-color:#fdd">    auto *scalarOpacityPointlist = element-&gt;FirstChildElement("ScalarOpacity");
    if (scalarOpacityPointlist == nullptr)</span>
    {
<span style = "background-color:#fdd">      return nullptr;</span>
    }

<span style = "background-color:#fdd">    tf-&gt;ClearScalarOpacityPoints();</span>

    try
    {
<span style = "background-color:#fdd">      for (auto *pointElement = scalarOpacityPointlist-&gt;FirstChildElement("point"); pointElement != nullptr;
           pointElement = pointElement-&gt;NextSiblingElement("point"))</span>
      {
<span style = "background-color:#fdd">        const char* x = pointElement-&gt;Attribute("x");
        const char* y = pointElement-&gt;Attribute("y");
        if (nullptr == x || nullptr == y)
          return nullptr;
        tf-&gt;AddScalarOpacityPoint(boost::lexical_cast&lt;double&gt;(x), boost::lexical_cast&lt;double&gt;(y));
      }</span>

<span style = "background-color:#fdd">      auto *gradientOpacityPointlist = element-&gt;FirstChildElement("GradientOpacity");
      if (gradientOpacityPointlist == nullptr)</span>
      {
<span style = "background-color:#fdd">        return nullptr;</span>
      }

<span style = "background-color:#fdd">      tf-&gt;ClearGradientOpacityPoints();</span>

<span style = "background-color:#fdd">      for (auto *pointElement = gradientOpacityPointlist-&gt;FirstChildElement("point"); pointElement != nullptr;
           pointElement = pointElement-&gt;NextSiblingElement("point"))</span>
      {
<span style = "background-color:#fdd">        const char* x = pointElement-&gt;Attribute("x");
        const char* y = pointElement-&gt;Attribute("y");
        if (nullptr == x || nullptr == y)
          return nullptr;
        tf-&gt;AddGradientOpacityPoint(boost::lexical_cast&lt;double&gt;(x), boost::lexical_cast&lt;double&gt;(y));
      }</span>

<span style = "background-color:#fdd">      auto *rgbPointlist = element-&gt;FirstChildElement("Color");
      if (rgbPointlist == nullptr)</span>
      {
<span style = "background-color:#fdd">        return nullptr;</span>
      }
<span style = "background-color:#fdd">      vtkColorTransferFunction *ctf = tf-&gt;GetColorTransferFunction();
      if (ctf == nullptr)</span>
      {
<span style = "background-color:#fdd">        return nullptr;</span>
      }

<span style = "background-color:#fdd">      ctf-&gt;RemoveAllPoints();</span>

<span style = "background-color:#fdd">      for (auto *pointElement = rgbPointlist-&gt;FirstChildElement("point"); pointElement != nullptr;
           pointElement = pointElement-&gt;NextSiblingElement("point"))</span>
      {
<span style = "background-color:#fdd">        const char* x = pointElement-&gt;Attribute("x");
        const char* r = pointElement-&gt;Attribute("r");
        const char* g = pointElement-&gt;Attribute("g");
        const char* b = pointElement-&gt;Attribute("b");
        const char* midpoint = pointElement-&gt;Attribute("midpoint");
        const char* sharpness = pointElement-&gt;Attribute("sharpness");
        if (nullptr == x || nullptr == r || nullptr == g || nullptr == b || nullptr == midpoint || nullptr == sharpness)
          return nullptr;
        ctf-&gt;AddRGBPoint(boost::lexical_cast&lt;double&gt;(x),</span>
                         boost::lexical_cast&lt;double&gt;(r),
                         boost::lexical_cast&lt;double&gt;(g),
                         boost::lexical_cast&lt;double&gt;(b),
                         boost::lexical_cast&lt;double&gt;(midpoint),
                         boost::lexical_cast&lt;double&gt;(sharpness));
<span style = "background-color:#fdd">      }</span>
    }
    catch (boost::bad_lexical_cast &amp;e)
<span style = "background-color:#fdd">    {
      MITK_ERROR &lt;&lt; "Could not parse string as number: " &lt;&lt; e.what();</span>

<span style = "background-color:#fdd">      return nullptr;
    }</span>

<span style = "background-color:#fdd">    return TransferFunctionProperty::New(tf).GetPointer();
  }</span>

  mitk::TransferFunction::Pointer mitk::TransferFunctionPropertySerializer::DeserializeTransferFunction(
    const char *filePath)
<span style = "background-color:#fdd">  {
    tinyxml2::XMLDocument document;</span>

<span style = "background-color:#fdd">    if (tinyxml2::XML_SUCCESS != document.LoadFile(filePath))</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Could not open/read/parse " &lt;&lt; filePath &lt;&lt; "\nTinyXML reports: " &lt;&lt; document.ErrorStr()</span>
                 &lt;&lt; std::endl;
<span style = "background-color:#fdd">      return nullptr;</span>
    }

    // find version node --&gt; note version in some variable
<span style = "background-color:#fdd">    int fileVersion = 1;
    auto *versionObject = document.FirstChildElement("Version");
    if (versionObject)</span>
    {
<span style = "background-color:#fdd">      if (versionObject-&gt;QueryIntAttribute("TransferfunctionVersion", &amp;fileVersion) != tinyxml2::XML_SUCCESS)</span>
      {
<span style = "background-color:#fdd">        MITK_WARN &lt;&lt; "Transferfunction file " &lt;&lt; filePath</span>
                  &lt;&lt; " does not contain version information! Trying version 1 format.";
      }
    }

<span style = "background-color:#fdd">    auto *input = document.FirstChildElement("TransferFunction");</span>

<span style = "background-color:#fdd">    TransferFunctionPropertySerializer::Pointer tfpd = TransferFunctionPropertySerializer::New();
    BaseProperty::Pointer bp = tfpd-&gt;Deserialize(input);
    TransferFunctionProperty::Pointer tfp = dynamic_cast&lt;TransferFunctionProperty *&gt;(bp.GetPointer());</span>

<span style = "background-color:#fdd">    if (tfp.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      TransferFunction::Pointer tf = tfp-&gt;GetValue();
      return tf;</span>
    }
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Can't deserialize transfer function";
    return nullptr;
  }</span>

} // namespace

// important to put this into the GLOBAL namespace (because it starts with 'namespace mitk')
<span style = "background-color:#dfd">MITK_REGISTER_SERIALIZER(TransferFunctionPropertySerializer);</span></pre>
	</body>
</html>