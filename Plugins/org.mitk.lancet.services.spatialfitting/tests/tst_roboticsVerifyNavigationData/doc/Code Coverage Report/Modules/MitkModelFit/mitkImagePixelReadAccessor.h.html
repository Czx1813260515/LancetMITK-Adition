<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImagePixelReadAccessor.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKIMAGEPIXELREADACCESSOR_H
#define MITKIMAGEPIXELREADACCESSOR_H

#include "mitkImagePixelAccessor.h"
#include "mitkImageReadAccessor.h"

namespace mitk
{
  class Image;

  /**
   * @brief Gives locked and index-based read access for a particular image part.
   * The class provides several set- and get-methods, which allow an easy pixel access.
   * It needs to know about pixel type and dimension of its image at compile time.
   * @tparam TPixel defines the PixelType
   * @tparam VDimension defines the dimension for accessing data
   * @ingroup Data
   */
  template &lt;class TPixel, unsigned int VDimension = 3&gt;
  class ImagePixelReadAccessor : public ImagePixelAccessor&lt;TPixel, VDimension&gt;
  {
    friend class Image;

  public:
    typedef ImagePixelAccessor&lt;TPixel, VDimension&gt; ImagePixelAccessorType;
    typedef itk::SmartPointer&lt;mitk::Image&gt; ImagePointer;
    typedef itk::SmartPointer&lt;const mitk::Image&gt; ImageConstPointer;

    /** \brief Instantiates a mitk::ImageReadAccessor (see its doxygen page for more details)
     *  \param iP specifies the associated Image
     *  \param iDI specifies the allocated image part
     *  \param OptionFlags properties from mitk::ImageAccessorBase::Options can be chosen and assembled with bitwise
     * unification.
     *  \throws mitk::Exception if the Constructor was created inappropriately
     *  \throws mitk::MemoryIsLockedException if requested image area is exclusively locked and
     * mitk::ImageAccessorBase::ExceptionIfLocked is set in OptionFlags
     *
     *   Includes a check if typeid of PixelType coincides with templated TPixel
     *   and a check if VDimension equals to the Dimension of the Image.
     */
    ImagePixelReadAccessor(ImageConstPointer iP,
                           const ImageDataItem *iDI = nullptr,
                           int OptionFlags = ImageAccessorBase::DefaultBehavior)
<span style = "background-color:#fdd">      : ImagePixelAccessor&lt;TPixel, VDimension&gt;(iP, iDI), m_ReadAccessor(iP, iDI, OptionFlags)
    {
    }</span>

    ImagePixelReadAccessor(ImagePointer iP,
                           const ImageDataItem *iDI = nullptr,
                           int OptionFlags = ImageAccessorBase::DefaultBehavior)
<span style = "background-color:#fdd">      : ImagePixelAccessor&lt;TPixel, VDimension&gt;(iP.GetPointer(), iDI), m_ReadAccessor(iP, iDI, OptionFlags)
    {
    }</span>

    ImagePixelReadAccessor(Image *iP,
                           const ImageDataItem *iDI = nullptr,
                           int OptionFlags = ImageAccessorBase::DefaultBehavior)
<span style = "background-color:#fdd">      : ImagePixelAccessor&lt;TPixel, VDimension&gt;(iP, iDI), m_ReadAccessor(mitk::Image::ConstPointer(iP), iDI, OptionFlags)
    {
    }</span>

    ImagePixelReadAccessor(const Image *iP,
                           const ImageDataItem *iDI = nullptr,
                           int OptionFlags = ImageAccessorBase::DefaultBehavior)
<span style = "background-color:#fdd">      : ImagePixelAccessor&lt;TPixel, VDimension&gt;(iP, iDI), m_ReadAccessor(iP, iDI, OptionFlags)
    {
    }</span>

    /** Destructor informs Image to unlock memory. */
<span style = "background-color:#fdd">    ~ImagePixelReadAccessor() override {}</span>
    /** Returns a const reference to the pixel at given index. */
    const TPixel &amp;GetPixelByIndex(const itk::Index&lt;VDimension&gt; &amp;idx) const
<span style = "background-color:#fdd">    {
      unsigned int offset = ImagePixelAccessorType::GetOffset(idx);</span>

<span style = "background-color:#fdd">      return *(((TPixel *)m_ReadAccessor.m_AddressBegin) + offset);
    }</span>

    itk::VariableLengthVector&lt;TPixel&gt; GetConsecutivePixelsAsVector(const itk::Index&lt;VDimension&gt; &amp;idx,
                                                                   int nrComponents) const
<span style = "background-color:#fdd">    {
      return itk::VariableLengthVector&lt;TPixel&gt;(</span>
        (TPixel *)m_ReadAccessor.m_AddressBegin +
          ImagePixelAccessorType::GetOffset(idx) * m_ReadAccessor.GetImage()-&gt;GetPixelType().GetNumberOfComponents(),
        nrComponents);
<span style = "background-color:#fdd">    }</span>

    /** Extends GetPixel by integrating index validation to prevent overflow.
      * \throws mitk::Exception in case of overflow
      */
    const TPixel &amp;GetPixelByIndexSafe(const itk::Index&lt;VDimension&gt; &amp;idx) const
    {
      unsigned int offset = ImagePixelAccessorType::GetOffset(idx);

      TPixel *targetAddress = ((TPixel *)m_ReadAccessor.m_AddressBegin) + offset;

      if (!(targetAddress &gt;= m_ReadAccessor.m_AddressBegin &amp;&amp; targetAddress &lt; m_ReadAccessor.m_AddressEnd))
      {
        mitkThrow() &lt;&lt; "ImageAccessor Overflow: image access exceeds the requested image area at " &lt;&lt; idx &lt;&lt; ".";
      }

      return *targetAddress;
    }

    /** Returns a const reference to the pixel at given world coordinate - works only with three-dimensional
     * ImageAccessor
     */
    const TPixel &amp;GetPixelByWorldCoordinates(mitk::Point3D position)
    {
      itk::Index&lt;3&gt; itkIndex;
      m_ReadAccessor.GetImage()-&gt;GetGeometry()-&gt;WorldToIndex(position, itkIndex);

      return GetPixelByIndex(itkIndex);
    }

    /** Returns a const reference to the pixel at given world coordinate - works only with four-dimensional
     * ImageAccessor
     */
    const TPixel &amp;GetPixelByWorldCoordinates(mitk::Point3D position, unsigned int timestep)
    {
      itk::Index&lt;3&gt; itkIndex;
      m_ReadAccessor.GetImage()-&gt;GetGeometry()-&gt;WorldToIndex(position, itkIndex);
      if (m_ReadAccessor.GetImage()-&gt;GetTimeSteps() &lt; timestep)
      {
        timestep = m_ReadAccessor.GetImage()-&gt;GetTimeSteps();
      }
      itk::Index&lt;4&gt; itk4Index;
      for (int i = 0; i &lt; 3; ++i)
        itk4Index[i] = itkIndex[i];

      itk4Index[3] = timestep;
      return GetPixelByIndex(itk4Index);
    }

    /** \brief Gives const access to the data. */
<span style = "background-color:#fdd">    inline const TPixel *GetData() const { return static_cast&lt;const TPixel *&gt;(m_ReadAccessor.m_AddressBegin); }</span>
  protected:
    // protected members

  private:
    ImageReadAccessor m_ReadAccessor;

    ImagePixelReadAccessor &amp;operator=(const ImagePixelReadAccessor &amp;); // Not implemented on purpose.
    ImagePixelReadAccessor(const ImagePixelReadAccessor &amp;);
  };

  /** Static method that gets direct access to a single pixel value.
   *  The value is not guaranteed to be in a well-defined state and is automatically casted to mitk::ScalarType
   *  The method can be called by the macros in mitkPixelTypeMultiplex.h
   */
  template &lt;class TPixel&gt;
  mitk::ScalarType FastSinglePixelAccess(mitk::PixelType,
                                         mitk::Image::Pointer im,
                                         ImageDataItem *item,
                                         itk::Index&lt;3&gt; idx,
                                         mitk::ScalarType &amp;val,
                                         int component = 0)
<span style = "background-color:#fdd">  {
    ImagePixelReadAccessor&lt;TPixel, 3&gt; imAccess(im, item, mitk::ImageAccessorBase::IgnoreLock);
    val = imAccess.GetConsecutivePixelsAsVector(idx, component + 1).GetElement(component);
    return val;
  }</span>

  /** Const overload of FastSinglePixelAccess*/
  template &lt;class TPixel&gt;
  mitk::ScalarType FastSinglePixelAccess(mitk::PixelType,
    mitk::Image::ConstPointer im,
    const ImageDataItem* item,
    itk::Index&lt;3&gt; idx,
    mitk::ScalarType&amp; val,
    int component = 0)
  {
    ImagePixelReadAccessor&lt;TPixel, 3&gt; imAccess(im, item, mitk::ImageAccessorBase::IgnoreLock);
    val = imAccess.GetConsecutivePixelsAsVector(idx, component + 1).GetElement(component);
    return val;
  }

}

#endif // MITKIMAGEPIXELREADACCESSOR_H</pre>
	</body>
</html>