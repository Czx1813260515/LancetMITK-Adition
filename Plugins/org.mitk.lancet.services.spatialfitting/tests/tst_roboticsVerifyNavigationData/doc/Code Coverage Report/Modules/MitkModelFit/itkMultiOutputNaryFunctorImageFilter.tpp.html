<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>itkMultiOutputNaryFunctorImageFilter.tpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef __itkMultiOutputNaryFunctorImageFilter_hxx
#define __itkMultiOutputNaryFunctorImageFilter_hxx

#include "itkMultiOutputNaryFunctorImageFilter.h"
#include "itkImageRegionIterator.h"
#include "itkProgressReporter.h"

namespace itk
{
  /**
  * Constructor
  */
  template&lt; class TInputImage, class TOutputImage, class TFunction, class TMaskImage &gt;
  MultiOutputNaryFunctorImageFilter&lt; TInputImage, TOutputImage, TFunction, TMaskImage &gt;
    ::MultiOutputNaryFunctorImageFilter()
<span style = "background-color:#fdd">  {
    this-&gt;DynamicMultiThreadingOff();</span>

    // This number will be incremented each time an image
    // is added over the two minimum required
<span style = "background-color:#fdd">    this-&gt;SetNumberOfRequiredInputs(1);</span>

<span style = "background-color:#fdd">    this-&gt;ActualizeOutputs();
  }</span>

  template&lt; class TInputImage, class TOutputImage, class TFunction, class TMaskImage &gt;
  void
    MultiOutputNaryFunctorImageFilter&lt; TInputImage, TOutputImage, TFunction, TMaskImage &gt;
    ::ActualizeOutputs()
<span style = "background-color:#fdd">  {
    this-&gt;SetNumberOfRequiredOutputs(m_Functor.GetNumberOfOutputs());</span>

<span style = "background-color:#fdd">    for (typename Superclass::DataObjectPointerArraySizeType i = this-&gt;GetNumberOfIndexedOutputs(); i&lt; m_Functor.GetNumberOfOutputs(); ++i)</span>
    {
<span style = "background-color:#fdd">      this-&gt;SetNthOutput( i, this-&gt;MakeOutput(i) );
    }</span>

<span style = "background-color:#fdd">    while(this-&gt;GetNumberOfIndexedOutputs() &gt; m_Functor.GetNumberOfOutputs())</span>
    {
<span style = "background-color:#fdd">      this-&gt;RemoveOutput(this-&gt;GetNumberOfIndexedOutputs()-1);
    }
  };</span>

  /**
  * ThreadedGenerateData Performs the pixel-wise addition
  */
  template&lt; class TInputImage, class TOutputImage, class TFunction, class TMaskImage &gt;
  void
    MultiOutputNaryFunctorImageFilter&lt; TInputImage, TOutputImage, TFunction, TMaskImage &gt;
    ::ThreadedGenerateData(const OutputImageRegionType &amp; outputRegionForThread,
    ThreadIdType threadId)
<span style = "background-color:#fdd">  {
    ProgressReporter progress( this, threadId,</span>
      outputRegionForThread.GetNumberOfPixels() );

<span style = "background-color:#fdd">    const unsigned int numberOfInputImages =</span>
      static_cast&lt; unsigned int &gt;( this-&gt;GetNumberOfIndexedInputs() );

<span style = "background-color:#fdd">    const unsigned int numberOfOutputImages =</span>
      static_cast&lt; unsigned int &gt;( this-&gt;GetNumberOfIndexedOutputs() );

    typedef ImageRegionConstIterator&lt; TInputImage &gt; ImageRegionConstIteratorType;
<span style = "background-color:#fdd">    std::vector&lt; ImageRegionConstIteratorType * &gt; inputItrVector;
    inputItrVector.reserve(numberOfInputImages);</span>

    typedef ImageRegionIterator&lt; TOutputImage &gt; OutputImageRegionIteratorType;
<span style = "background-color:#fdd">    std::vector&lt; OutputImageRegionIteratorType * &gt; outputItrVector;
    outputItrVector.reserve(numberOfOutputImages);</span>

    //check if mask image is set and generate iterator if mask is valid
    typedef ImageRegionConstIterator&lt; TMaskImage &gt; MaskImageRegionIteratorType;
<span style = "background-color:#fdd">    MaskImageRegionIteratorType* pMaskIterator = nullptr;</span>

<span style = "background-color:#fdd">    if (m_Mask.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      if (!m_Mask-&gt;GetLargestPossibleRegion().IsInside(outputRegionForThread))</span>
      {
<span style = "background-color:#fdd">        itkExceptionMacro("Mask of filter is set but does not cover region of thread. Mask region: "&lt;&lt; m_Mask-&gt;GetLargestPossibleRegion() &lt;&lt;"Thread region: "&lt;&lt;outputRegionForThread)</span>
      }
<span style = "background-color:#fdd">      pMaskIterator = new MaskImageRegionIteratorType(m_Mask,outputRegionForThread);</span>
    }

    // go through the inputs and add iterators for non-null inputs
<span style = "background-color:#fdd">    for ( unsigned int i = 0; i &lt; numberOfInputImages; ++i )</span>
    {
<span style = "background-color:#fdd">      InputImagePointer inputPtr =</span>
        dynamic_cast&lt; TInputImage * &gt;( ProcessObject::GetInput(i) );

<span style = "background-color:#fdd">      if ( inputPtr )</span>
      {
<span style = "background-color:#fdd">        inputItrVector.push_back( new ImageRegionConstIteratorType(inputPtr, outputRegionForThread) );</span>
      }

<span style = "background-color:#fdd">    }</span>

    // go through the outputs and add iterators for non-null outputs
<span style = "background-color:#fdd">    for ( unsigned int i = 0; i &lt; numberOfOutputImages; ++i )</span>
    {
<span style = "background-color:#fdd">      OutputImagePointer outputPtr =</span>
        dynamic_cast&lt; TOutputImage * &gt;( ProcessObject::GetOutput(i) );

<span style = "background-color:#fdd">      if ( outputPtr )</span>
      {
<span style = "background-color:#fdd">        outputItrVector.push_back( new OutputImageRegionIteratorType(outputPtr, outputRegionForThread) );</span>
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    typename std::vector&lt; ImageRegionConstIteratorType * &gt;::iterator regionInputIterators;
    const typename std::vector&lt; ImageRegionConstIteratorType * &gt;::const_iterator regionInputItEnd =</span>
      inputItrVector.end();

<span style = "background-color:#fdd">    typename std::vector&lt; OutputImageRegionIteratorType * &gt;::iterator regionOutputIterators;
    const typename std::vector&lt; OutputImageRegionIteratorType * &gt;::const_iterator regionOutputItEnd =</span>
      outputItrVector.end();

<span style = "background-color:#fdd">    const unsigned int numberOfValidInputImages = inputItrVector.size();
    const unsigned int numberOfValidOutputImages = outputItrVector.size();</span>

<span style = "background-color:#fdd">    if ( (numberOfValidInputImages != 0) &amp;&amp; ( numberOfValidOutputImages != 0))</span>
    {
      try
      {

<span style = "background-color:#fdd">        while ( !(outputItrVector.front()-&gt;IsAtEnd()) )</span>
        {
<span style = "background-color:#fdd">          typename NaryInputArrayType::iterator arrayInIt;
          typename NaryOutputArrayType::iterator arrayOutIt;
          NaryInputArrayType naryInputArray(numberOfValidInputImages);
          NaryOutputArrayType naryOutputArray(numberOfValidOutputImages);</span>

<span style = "background-color:#fdd">          bool isValid = true;</span>

<span style = "background-color:#fdd">          if (pMaskIterator)</span>
          {
<span style = "background-color:#fdd">            isValid = pMaskIterator-&gt;Get() &gt; 0;
            ++(*pMaskIterator);</span>
          }

<span style = "background-color:#fdd">          arrayInIt = naryInputArray.begin();
          regionInputIterators = inputItrVector.begin();</span>

          typename ImageRegionConstIteratorType::IndexType currentIndex;
<span style = "background-color:#fdd">          if(regionInputIterators != regionInputItEnd)</span>
          {
<span style = "background-color:#fdd">            currentIndex = ( *regionInputIterators )-&gt;GetIndex();</span>
          }

<span style = "background-color:#fdd">          while ( regionInputIterators != regionInputItEnd )</span>
          {
<span style = "background-color:#fdd">            *arrayInIt++ = ( *regionInputIterators )-&gt;Get();
            ++( *( *regionInputIterators ) );
            ++regionInputIterators;
          }</span>

<span style = "background-color:#fdd">          if (isValid)</span>
          {
<span style = "background-color:#fdd">            naryOutputArray = m_Functor(naryInputArray, currentIndex);</span>

<span style = "background-color:#fdd">            if (numberOfValidOutputImages != naryOutputArray.size())</span>
            {
<span style = "background-color:#fdd">              itkExceptionMacro("Error. Number of valid output images do not equal number of outputs required by functor. Number of valid outputs: "&lt;&lt; numberOfValidOutputImages &lt;&lt; "; needed output number:" &lt;&lt; this-&gt;m_Functor.GetNumberOfOutputs());</span>
            }
<span style = "background-color:#fdd">          }</span>
          else
          {
<span style = "background-color:#fdd">            for (typename NaryOutputArrayType::iterator pos = naryOutputArray.begin(); pos!= naryOutputArray.end(); ++pos)</span>
            {
<span style = "background-color:#fdd">                *pos = 0.0;
            }</span>
          }

<span style = "background-color:#fdd">          arrayOutIt = naryOutputArray.begin();
          regionOutputIterators = outputItrVector.begin();
          while ( regionOutputIterators != regionOutputItEnd )</span>
          {
<span style = "background-color:#fdd">            ( *regionOutputIterators )-&gt;Set(*arrayOutIt++);
            ++( *( *regionOutputIterators ) );
            ++regionOutputIterators;
          }</span>

<span style = "background-color:#fdd">          progress.CompletedPixel();
        }</span>
      }
      catch(...)
<span style = "background-color:#fdd">      {</span>
        // Free memory in case of exceptions
<span style = "background-color:#fdd">        regionInputIterators = inputItrVector.begin();
        while ( regionInputIterators != regionInputItEnd )</span>
        {
<span style = "background-color:#fdd">          delete ( *regionInputIterators++ );
        }</span>

<span style = "background-color:#fdd">        regionOutputIterators = outputItrVector.begin();
        while ( regionOutputIterators != regionOutputItEnd )</span>
        {
<span style = "background-color:#fdd">          delete ( *regionOutputIterators++ );
        }</span>

<span style = "background-color:#fdd">        delete pMaskIterator;
        throw;
      }</span>
    }

    // Free memory regulary
<span style = "background-color:#fdd">    regionInputIterators = inputItrVector.begin();
    while ( regionInputIterators != regionInputItEnd )</span>
    {
<span style = "background-color:#fdd">      delete ( *regionInputIterators++ );
    }</span>

<span style = "background-color:#fdd">    regionOutputIterators = outputItrVector.begin();
    while ( regionOutputIterators != regionOutputItEnd )</span>
    {
<span style = "background-color:#fdd">      delete ( *regionOutputIterators++ );
    }</span>

<span style = "background-color:#fdd">    delete pMaskIterator;
  }</span>
} // end namespace itk

#endif</pre>
	</body>
</html>