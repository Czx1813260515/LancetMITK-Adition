<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSimpleHistogram.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKSIMPLEHISTOGRAM_H
#define MITKSIMPLEHISTOGRAM_H

#ifndef __itkHistogram_h
#include &lt;itkHistogram.h&gt;
#endif

#include "MitkAlgorithmsExtExports.h"

#include &lt;mitkImage.h&gt;
#include &lt;mitkWeakPointer.h&gt;

#include &lt;itkImageRegionIterator.h&gt;
#include &lt;itkImageRegionIteratorWithIndex.h&gt;

namespace mitk
{
  //##Documentation
  //## @brief Abstract superclass for histograms with double values.
  //##        Classes which are deriving from this class can be cached
  //##        in the same way.
  class MITKALGORITHMSEXT_EXPORT SimpleHistogram
  {
  public:
    /** @brief Returns the minimal value of the histogram. */
    virtual double GetMin() const = 0;
    /** @brief Returns the maximum value of the histogram. */
    virtual double GetMax() const = 0;
    /** @brief Creates a new histogram out the source. */
    virtual void ComputeFromBaseData(BaseData *source) = 0;
    /** @brief TODO: (What should this method do?)*/
    virtual float GetRelativeBin(double start, double end) const = 0;
  };

  class MITKALGORITHMSEXT_EXPORT SimpleImageHistogram : public SimpleHistogram
  {
  public:
    typedef itk::Statistics::Histogram&lt;double&gt; HistogramType;

<span style = "background-color:#fdd">    SimpleImageHistogram()</span>
    {
<span style = "background-color:#fdd">      valid = false;
      histogram = nullptr;
    }</span>

    ~SimpleImageHistogram()
<span style = "background-color:#fdd">    {
      if (histogram)
        delete histogram;
    }</span>

    /** @return Returns if the current histogram is valid, false if not. */
    bool GetValid();

    typedef itk::Image&lt;short, 3&gt; CTImage;
    typedef itk::ImageRegionIterator&lt;CTImage&gt; CTIteratorType;
    typedef itk::ImageRegionIteratorWithIndex&lt;CTImage&gt; CTIteratorIndexType;

    typedef itk::Image&lt;unsigned char, 3&gt; BinImage;
    typedef itk::ImageRegionIterator&lt;BinImage&gt; BinIteratorType;
    typedef itk::ImageRegionIteratorWithIndex&lt;BinImage&gt; BinIteratorIndexType;

    typedef unsigned long CountType;

  protected:
    CountType *histogram;

    bool valid;

    int first;
    int last;
    int min;
    int max;
    CountType highest;
    double invLogHighest;

  public:
    double GetMin() const override
<span style = "background-color:#fdd">    {
      if (!valid)
        return 0;</span>

<span style = "background-color:#fdd">      return min;
    }</span>

    double GetMax() const override
<span style = "background-color:#fdd">    {
      if (!valid)
        return 1;</span>

<span style = "background-color:#fdd">      return max;
    }</span>

    /** @brief Creates a new histogram out the source which must be an image. Method does nothing if the image is
     * invalid, nullptr, etc.. */
    void ComputeFromBaseData(BaseData *source) override;
    float GetRelativeBin(double start, double end) const override;
  };

  class MITKALGORITHMSEXT_EXPORT SimpleHistogramCache
  {
  public:
    static const unsigned int maxCacheSize = 64;

    class MITKALGORITHMSEXT_EXPORT Element
    {
    public:
      mitk::WeakPointer&lt;BaseData&gt; baseData;
      itk::TimeStamp m_LastUpdateTime;

      virtual ~Element();

      virtual void ComputeFromBaseData(BaseData *baseData) = 0;
      virtual SimpleHistogram *GetHistogram() = 0;
    };

    typedef std::list&lt;Element *&gt; CacheContainer;

    CacheContainer cache;

<span style = "background-color:#fdd">    SimpleHistogramCache() {}
    ~SimpleHistogramCache() { TrimCache(true); }</span>
    SimpleHistogram *operator[](BaseData::Pointer sp_BaseData);

  protected:
    void TrimCache(bool full = false)
<span style = "background-color:#fdd">    {
      unsigned int targetSize = full ? 0 : maxCacheSize;</span>

<span style = "background-color:#fdd">      while (cache.size() &gt; targetSize)</span>
      {
<span style = "background-color:#fdd">        delete cache.back();
        cache.pop_back();
      }
    }</span>
  };
}

#endif // MITKSIMPLEHISTOGRAM_H</pre>
	</body>
</html>