<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNonBlockingAlgorithm.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITK_NON_BLOCKING_ALGORITHM_H_INCLUDED_DFARdfWN1tr
#define MITK_NON_BLOCKING_ALGORITHM_H_INCLUDED_DFARdfWN1tr

#include "MitkAlgorithmsExtExports.h"
#include &lt;itkImage.h&gt;
#include &lt;itkMacro.h&gt;
#include &lt;itkObjectFactory.h&gt;

#include "mitkCommon.h"
#include "mitkDataStorage.h"
#include "mitkProperties.h"
#include "mitkPropertyList.h"
#include "mitkSmartPointerProperty.h"
#include "mitkWeakPointer.h"

#include "mitkImage.h"
#include "mitkSurface.h"

#include &lt;mutex&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

/// from itkNewMacro(), additionally calls Initialize(), because this couldn't be done from the constructor of
/// NonBlockingAlgorithm
/// (you can't call virtual functions from the constructor of the superclass)
#define mitkAlgorithmNewMacro(classname)                                                                               \
  \
static Pointer                                                                                                         \
    New(void)                                                                                                          \
  {                                                                                                                    \
    classname *rawPtr = new classname();                                                                               \
    Pointer smartPtr = rawPtr;                                                                                         \
    rawPtr-&gt;UnRegister();                                                                                              \
    rawPtr-&gt;Initialize();                                                                                              \
    return smartPtr;                                                                                                   \
  \
}                                                                                                                 \
  \
virtual::itk::LightObject::Pointer                                                                                     \
    CreateAnother(void) const override                                                                                 \
  \
{                                                                                                                 \
    Pointer smartPtr = classname::New();                                                                               \
    ::itk::LightObject::Pointer lightPtr = smartPtr.GetPointer();                                                      \
    smartPtr-&gt;Initialize(this);                                                                                        \
    return lightPtr;                                                                                                   \
  \
}

namespace mitk
{
  /*!
      Invokes ResultsAvailable with each new result

      &lt;b&gt;done&lt;/b&gt; centralize use of itk::MultiThreader in this class
      @todo do the property-handling in this class
      @todo process "incoming" events in this class
      @todo sollen segmentierungs-dinger von mitk::ImageSource erben? Ivo fragen, wie das mit AllocateOutputs, etc.
     gehen soll
            eine ImageSourceAlgorithm koennte dann die noetigen Methoden wie GenerateData(), GetOutput() ueberschreiben,
     so
            dass von dort aus die Methoden von NonBlockingAlgorithm aufgerufen werden.
            Erben v.a. um die Output-Sachen zu uebernehmen, die Anpassungen das einfuehren einer Zwischenklasse, um die
     Interaces zu verheiraten.
  */
  class MITKALGORITHMSEXT_EXPORT NonBlockingAlgorithm : public itk::Object
  {
  public:
<span style = "background-color:#fdd">    mitkClassMacroItkParent(NonBlockingAlgorithm, itk::Object);</span>

    void SetDataStorage(DataStorage &amp;storage);
    DataStorage *GetDataStorage();

    // parameter setting

    /// For any kind of normal types
    template &lt;typename T&gt;
    void SetParameter(const char *parameter, const T &amp;value)
<span style = "background-color:#fdd">    {</span>
      // MITK_INFO &lt;&lt; "SetParameter(" &lt;&lt; parameter &lt;&lt; ") " &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
      // m_ParameterListMutex-&gt;Lock();
<span style = "background-color:#fdd">      m_Parameters-&gt;SetProperty(parameter, GenericProperty&lt;T&gt;::New(value));</span>
      // m_ParameterListMutex-&gt;Unlock();
<span style = "background-color:#fdd">    }</span>

    /// For any kind of smart pointers
    template &lt;typename T&gt;
    void SetPointerParameter(const char *parameter, const itk::SmartPointer&lt;T&gt; &amp;value)
<span style = "background-color:#fdd">    {</span>
      // MITK_INFO &lt;&lt; this &lt;&lt; "-&gt;SetParameter smartpointer(" &lt;&lt; parameter &lt;&lt; ") " &lt;&lt; typeid(itk::SmartPointer&lt;T&gt;).name()
      // &lt;&lt; std::endl;
<span style = "background-color:#fdd">      m_ParameterListMutex.lock();
      m_Parameters-&gt;SetProperty(parameter, SmartPointerProperty::New(value.GetPointer()));
      m_ParameterListMutex.unlock();
    }</span>
    // virtual void SetParameter( const char*, mitk::BaseProperty* ); // for "number of iterations", ...
    // create some property observing to inform algorithm object about changes
    // perhaps some TriggerParameter(string) macro that creates an observer for changes in a specific property like
    // "2ndPoint" for LineAlgorithms

    /// For any kind of BaseData, like Image, Surface, etc. Will be stored inside some SmartPointerProperty
    void SetPointerParameter(const char *parameter, BaseData *value);

    /// For any kind of ITK images (C pointers)
    template &lt;typename TPixel, unsigned int VImageDimension&gt;
    void SetItkImageAsMITKImagePointerParameter(const char *parameter, itk::Image&lt;TPixel, VImageDimension&gt; *itkImage)
    {
      // MITK_INFO &lt;&lt; "SetParameter ITK image(" &lt;&lt; parameter &lt;&lt; ") " &lt;&lt; typeid(itk::Image&lt;TPixel,
      // VImageDimension&gt;).name() &lt;&lt; std::endl;
      // create an MITK image for that
      mitk::Image::Pointer mitkImage = mitk::Image::New();
      mitkImage = ImportItkImage(itkImage);
      SetPointerParameter(parameter, mitkImage);
    }

    /// For any kind of ITK images (smartpointers)
    template &lt;typename TPixel, unsigned int VImageDimension&gt;
    void SetItkImageAsMITKImagePointerParameter(const char *parameter,
                                                const itk::SmartPointer&lt;itk::Image&lt;TPixel, VImageDimension&gt;&gt; &amp;itkImage)
    {
      // MITK_INFO &lt;&lt; "SetParameter ITK image(" &lt;&lt; parameter &lt;&lt; ") " &lt;&lt; typeid(itk::SmartPointer&lt;itk::Image&lt;TPixel,
      // VImageDimension&gt; &gt;).name() &lt;&lt; std::endl;
      // create an MITK image for that
      mitk::Image::Pointer mitkImage = mitk::Image::New();
      mitkImage = ImportItkImage(itkImage);
      SetPointerParameter(parameter, mitkImage);
    }

    // parameter getting

    template &lt;typename T&gt;
    void GetParameter(const char *parameter, T &amp;value) const
<span style = "background-color:#fdd">    {</span>
      // MITK_INFO &lt;&lt; "GetParameter normal(" &lt;&lt; parameter &lt;&lt; ") " &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
      // m_ParameterListMutex-&gt;Lock();
<span style = "background-color:#fdd">      BaseProperty *p = m_Parameters-&gt;GetProperty(parameter);
      GenericProperty&lt;T&gt; *gp = dynamic_cast&lt;GenericProperty&lt;T&gt; *&gt;(p);
      if (gp)</span>
      {
<span style = "background-color:#fdd">        value = gp-&gt;GetValue();</span>
        // m_ParameterListMutex-&gt;Unlock();
<span style = "background-color:#fdd">        return;</span>
      }
      // m_ParameterListMutex-&gt;Unlock();

<span style = "background-color:#fdd">      std::string error("There is no parameter \"");
      error += parameter;
      error += '"';
      throw std::invalid_argument(error);
    }</span>

    template &lt;typename T&gt;
    void GetPointerParameter(const char *parameter, itk::SmartPointer&lt;T&gt; &amp;value) const
<span style = "background-color:#fdd">    {</span>
      // MITK_INFO &lt;&lt; this &lt;&lt; "-&gt;GetParameter smartpointer(" &lt;&lt; parameter &lt;&lt; ") " &lt;&lt; typeid(itk::SmartPointer&lt;T&gt;).name()
      // &lt;&lt; std::endl;
      // m_ParameterListMutex-&gt;Lock();
<span style = "background-color:#fdd">      BaseProperty *p = m_Parameters-&gt;GetProperty(parameter);
      if (p)</span>
      {
<span style = "background-color:#fdd">        SmartPointerProperty *spp = dynamic_cast&lt;SmartPointerProperty *&gt;(p);
        if (spp)</span>
        {
<span style = "background-color:#fdd">          T *t = dynamic_cast&lt;T *&gt;(spp-&gt;GetSmartPointer().GetPointer());
          value = t;</span>
          // m_ParameterListMutex-&gt;Unlock();
<span style = "background-color:#fdd">          return;</span>
        }
      }
      // m_ParameterListMutex-&gt;Unlock();

<span style = "background-color:#fdd">      std::string error("There is no parameter \"");
      error += parameter;
      error += '"';
      throw std::invalid_argument(error);
    }</span>

    // start/stop functions

    virtual void Reset();

    void StartAlgorithm();         // for those who want to trigger calculations on their own
                                   // --&gt; need for an OPTION: manual/automatic starting
    void StartBlockingAlgorithm(); // for those who want to trigger calculations on their own
    void StopAlgorithm();

    void TriggerParameterModified(const itk::EventObject &amp;);

    void ThreadedUpdateSuccessful(const itk::EventObject &amp;);
    void ThreadedUpdateFailed(const itk::EventObject &amp;);

  protected:
    NonBlockingAlgorithm(); // use smart pointers
    ~NonBlockingAlgorithm() override;

    void DefineTriggerParameter(const char *);
    void UnDefineTriggerParameter(const char *);

    virtual void Initialize(const NonBlockingAlgorithm *other = nullptr);
    virtual bool ReadyToRun();

    virtual bool ThreadedUpdateFunction();   // will be called from a thread after calling StartAlgorithm
    virtual void ThreadedUpdateSuccessful(); // will be called after the ThreadedUpdateFunction() returned
    virtual void ThreadedUpdateFailed();     // will when ThreadedUpdateFunction() returns false

    PropertyList::Pointer m_Parameters;

    WeakPointer&lt;DataStorage&gt; m_DataStorage;

  private:
    static void StaticNonBlockingAlgorithmThread(NonBlockingAlgorithm* algorithm);

    typedef std::map&lt;std::string, unsigned long&gt; MapTypeStringUInt;

    MapTypeStringUInt m_TriggerPropertyConnections;

    std::mutex m_ParameterListMutex;

    int m_UpdateRequests;
    std::thread m_Thread;

    bool m_KillRequest;
  };

} // namespace

#include "mitkNonBlockingAlgorithmEvents.h"

#endif</pre>
	</body>
</html>