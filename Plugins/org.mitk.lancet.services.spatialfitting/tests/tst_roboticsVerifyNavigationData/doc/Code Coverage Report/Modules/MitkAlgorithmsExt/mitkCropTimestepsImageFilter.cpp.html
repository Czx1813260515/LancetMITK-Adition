<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkCropTimestepsImageFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkCropTimestepsImageFilter.h"

#include &lt;mitkImage.h&gt;
#include &lt;mitkArbitraryTimeGeometry.h&gt;
#include &lt;mitkImageTimeSelector.h&gt;
#include &lt;mitkImageReadAccessor.h&gt;


  void mitk::CropTimestepsImageFilter::VerifyInputImage(const mitk::Image* inputImage) const
<span style = "background-color:#fdd">  {
    if (!inputImage-&gt;IsInitialized())
      mitkThrow() &lt;&lt; "Input image is not initialized.";</span>

<span style = "background-color:#fdd">    if (!inputImage-&gt;IsVolumeSet())
      mitkThrow() &lt;&lt; "Input image volume is not set.";</span>

<span style = "background-color:#fdd">    auto geometry = inputImage-&gt;GetGeometry();</span>

<span style = "background-color:#fdd">    if (nullptr == geometry || !geometry-&gt;IsValid())
      mitkThrow() &lt;&lt; "Input image has invalid geometry.";</span>

<span style = "background-color:#fdd">    if (inputImage-&gt;GetDimension() != 4) {
      mitkThrow() &lt;&lt; "CropTimestepsImageFilter only works with 2D+t and 3D+t images.";</span>
    }

<span style = "background-color:#fdd">    if (inputImage-&gt;GetTimeSteps() ==1) {
      mitkThrow() &lt;&lt; "Input image has only one timestep.";</span>
    }

<span style = "background-color:#fdd">    if (!geometry-&gt;GetImageGeometry())
      mitkThrow() &lt;&lt; "Geometry of input image is not an image geometry.";
  }</span>

  void mitk::CropTimestepsImageFilter::GenerateOutputInformation()
<span style = "background-color:#fdd">  {
    Image::ConstPointer input = this-&gt;GetInput();
    Image::Pointer output = this-&gt;GetOutput();
    if (m_LowerBoundaryTimestep &gt; m_UpperBoundaryTimestep) {
      mitkThrow() &lt;&lt; "lower timestep is larger than upper timestep.";</span>
    }
<span style = "background-color:#fdd">    if (m_UpperBoundaryTimestep == std::numeric_limits&lt;unsigned int&gt;::max()) {
      m_UpperBoundaryTimestep = input-&gt;GetTimeSteps();
    }
    else if (m_UpperBoundaryTimestep &gt; input-&gt;GetTimeSteps()) {
      m_UpperBoundaryTimestep = input-&gt;GetTimeSteps();
      MITK_WARN &lt;&lt; "upper boundary timestep set to " &lt;&lt; m_UpperBoundaryTimestep;</span>
    }
<span style = "background-color:#fdd">    m_DesiredRegion = ComputeDesiredRegion();
    unsigned int dimension = input-&gt;GetDimension();
    auto dimensions = new unsigned int[dimension];
    itk2vtk(m_DesiredRegion.GetSize(), dimensions);
    if (dimension &gt; 3)
      memcpy(dimensions + 3, input-&gt;GetDimensions() + 3, (dimension - 3) * sizeof(unsigned int));</span>

<span style = "background-color:#fdd">    dimensions[3] = m_UpperBoundaryTimestep - m_LowerBoundaryTimestep;</span>

    // create basic slicedGeometry that will be initialized below
<span style = "background-color:#fdd">    output-&gt;Initialize(mitk::PixelType(input-&gt;GetPixelType()), dimension, dimensions);
    delete[] dimensions;
    auto newTimeGeometry = AdaptTimeGeometry(input-&gt;GetTimeGeometry(), m_LowerBoundaryTimestep, m_UpperBoundaryTimestep);
    output-&gt;SetTimeGeometry(newTimeGeometry);
    output-&gt;SetPropertyList(input-&gt;GetPropertyList());
  }</span>

  mitk::SlicedData::RegionType mitk::CropTimestepsImageFilter::ComputeDesiredRegion() const
<span style = "background-color:#fdd">  {
    auto desiredRegion = this-&gt;GetInput()-&gt;GetLargestPossibleRegion();
    auto index = desiredRegion.GetIndex();
    auto size = desiredRegion.GetSize();
    unsigned int timeDimension = 3;
    index[timeDimension] = m_LowerBoundaryTimestep;
    size[timeDimension] = m_UpperBoundaryTimestep - m_LowerBoundaryTimestep;
    desiredRegion.SetIndex(index);
    desiredRegion.SetSize(size);
    return desiredRegion;
  }</span>

  mitk::TimeGeometry::Pointer mitk::CropTimestepsImageFilter::AdaptTimeGeometry(mitk::TimeGeometry::ConstPointer sourceGeometry, unsigned int startTimestep, unsigned int endTimestep) const
<span style = "background-color:#fdd">  {
    auto newTimeGeometry = mitk::ArbitraryTimeGeometry::New();
    newTimeGeometry-&gt;ClearAllGeometries();
    for (unsigned int timestep = startTimestep; timestep &lt; endTimestep; timestep++)</span>
    {
<span style = "background-color:#fdd">      auto geometryForTimePoint = sourceGeometry-&gt;GetGeometryForTimeStep(timestep);
      auto minTP = sourceGeometry-&gt;GetMinimumTimePoint(timestep);
      auto maxTP = sourceGeometry-&gt;GetMaximumTimePoint(timestep);</span>
      ///////////////////////////////////////
      // Workarround T27883. See https://phabricator.mitk.org/T27883#219473 for more details.
      // This workarround should be removed as soon as T28262 is solved!
<span style = "background-color:#fdd">      if (timestep + 1 == sourceGeometry-&gt;CountTimeSteps() &amp;&amp; minTP == maxTP)</span>
      {
<span style = "background-color:#fdd">        maxTP = minTP + 1.;</span>
      }
      // End of workarround for T27883
      //////////////////////////////////////

<span style = "background-color:#fdd">      newTimeGeometry-&gt;AppendNewTimeStepClone(geometryForTimePoint, minTP, maxTP);
    }
    return newTimeGeometry.GetPointer();
  }</span>

void mitk::CropTimestepsImageFilter::GenerateData()
<span style = "background-color:#fdd">{
  const auto* inputImage = this-&gt;GetInput();
  mitk::Image::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  if ((output-&gt;IsInitialized() == false))
    return;</span>

<span style = "background-color:#fdd">  auto timeSelector = mitk::ImageTimeSelector::New();</span>

<span style = "background-color:#fdd">  timeSelector-&gt;SetInput(inputImage);</span>

<span style = "background-color:#fdd">  unsigned int timeStart = m_DesiredRegion.GetIndex(3);
  unsigned int timeEnd = timeStart + m_DesiredRegion.GetSize(3);
  for (unsigned int timestep = timeStart; timestep &lt; timeEnd; ++timestep)</span>
  {
<span style = "background-color:#fdd">    timeSelector-&gt;SetTimeNr(timestep);
    timeSelector-&gt;UpdateLargestPossibleRegion();
    mitk::ImageReadAccessor imageAccessorWithOneTimestep(timeSelector-&gt;GetOutput());
    output-&gt;SetVolume(imageAccessorWithOneTimestep.GetData(), timestep-timeStart);
  }
}</span>

void mitk::CropTimestepsImageFilter::SetInput(const InputImageType* image)
<span style = "background-color:#fdd">{
  if (this-&gt;GetInput() == image)
    return;</span>

<span style = "background-color:#fdd">  Superclass::SetInput(image);
}</span>

void mitk::CropTimestepsImageFilter::SetInput(unsigned int index, const InputImageType* image)
<span style = "background-color:#fdd">{
  if (0 != index)
    mitkThrow() &lt;&lt; "Input index " &lt;&lt; index &lt;&lt; " is invalid.";</span>

<span style = "background-color:#fdd">  this-&gt;SetInput(image);
}</span>

void mitk::CropTimestepsImageFilter::VerifyInputInformation() const
<span style = "background-color:#fdd">{
  Superclass::VerifyInputInformation();</span>

<span style = "background-color:#fdd">  VerifyInputImage(this-&gt;GetInput());
}</span></pre>
	</body>
</html>