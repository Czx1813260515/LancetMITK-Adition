<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkHeightFieldSurfaceClipImageFilter.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKHEIGHTFIELDSURFACECLIPIMAGEFILTER_H_HEADER_INCLUDED
#define MITKHEIGHTFIELDSURFACECLIPIMAGEFILTER_H_HEADER_INCLUDED

#include "MitkAlgorithmsExtExports.h"
#include "mitkCommon.h"
#include "mitkGeometry3D.h"
#include "mitkImageTimeSelector.h"
#include "mitkImageToImageFilter.h"
#include "mitkSurface.h"

namespace itk
{
  template &lt;class TPixel, unsigned int VImageDimension&gt;
  class ITK_EXPORT Image;
}

namespace mitk
{
  /**
   * \brief Filter for clipping an image with an height-field represented by
   * an mitk::Surface.
   *
   * The filter assumes that the surface represents a height field as seen from
   * the plane defined by (1.0/0.0/0.0), (0.0/1.0/0.0). All voxels lying on one
   * side of the height field will be clipped, i.e., set to 0. In addition, any
   * voxels which are out of bounds when projected on this plane will be clipped
   * as well.
   *
   * \ingroup Process
   */
  class MITKALGORITHMSEXT_EXPORT HeightFieldSurfaceClipImageFilter : public ImageToImageFilter
  {
  public:
    typedef std::vector&lt;mitk::Surface *&gt; ClippingPlaneList;

<span style = "background-color:#fdd">    mitkClassMacro(HeightFieldSurfaceClipImageFilter, ImageToImageFilter);</span>

<span style = "background-color:#fdd">    itkFactorylessNewMacro(Self);</span>

<span style = "background-color:#fdd">    itkCloneMacro(Self);</span>

      /** \brief Set/Get the surface defining a height field as a triangle mesh */
      void SetClippingSurface(Surface *clippingSurface);

    /** \brief Set/Get the surfaces defining a height field as a triangle mesh */
    void SetClippingSurfaces(ClippingPlaneList planeList);

    /** \brief Set/Get the surface defining a height field as a triangle mesh */
    const Surface *GetClippingSurface() const;

    enum
    {
      CLIPPING_MODE_CONSTANT = 0,
      CLIPPING_MODE_MULTIPLYBYFACTOR,
      CLIPPING_MODE_MULTIPLANE
    };

    /** \brief Specifies whether clipped part of the image shall be replaced
     * by a constant or multiplied by a user-set factor */
    void SetClippingMode(int mode);

    /** \brief Specifies whether clipped part of the image shall be replaced
    * by a constant or multiplied by a user-set factor */
    int GetClippingMode();

    /** \brief Specifies whether clipped part of the image shall be replaced
    * by a constant or multiplied by a user-set factor */
    void SetClippingModeToConstant();

    /** \brief Specifies whether clipped part of the image shall be replaced
    * by a constant or multiplied by a user-set factor */
    void SetClippingModeToMultiplyByFactor();

    void SetClippingModeToMultiPlaneValue();

    /** \brief Set/Get constant gray-value for clipping in CONSTANT mode */
<span style = "background-color:#fdd">    itkSetMacro(ClippingConstant, ScalarType);</span>

    /** \brief Set/Get constant gray-value for clipping in CONSTANT mode */
<span style = "background-color:#fdd">    itkGetConstMacro(ClippingConstant, ScalarType);</span>

    /** \brief Set/Get multiplaction factor for clipping in MULTIPLYBYFACTOR mode */
<span style = "background-color:#fdd">    itkSetMacro(MultiplicationFactor, ScalarType);</span>

    /** \brief Set/Get multiplaction factor for clipping in MULTIPLYBYFACTOR mode */
<span style = "background-color:#fdd">    itkGetConstMacro(MultiplicationFactor, ScalarType);</span>

    /** \brief Set/Get x-resolution of height-field sampling (default: 256). */
<span style = "background-color:#fdd">    itkSetMacro(HeightFieldResolutionX, unsigned int);</span>

    /** \brief Set/Get x-resolution of height-field sampling (default: 256). */
<span style = "background-color:#fdd">    itkGetConstMacro(HeightFieldResolutionX, unsigned int);</span>

    /** \brief Set/Get y-resolution of height-field sampling (default: 256). */
<span style = "background-color:#fdd">    itkSetMacro(HeightFieldResolutionY, unsigned int);</span>

    /** \brief Set/Get y-resolution of height-field sampling (default: 256). */
<span style = "background-color:#fdd">    itkGetConstMacro(HeightFieldResolutionY, unsigned int);</span>

  protected:
    HeightFieldSurfaceClipImageFilter();

    ~HeightFieldSurfaceClipImageFilter() override;

    void GenerateInputRequestedRegion() override;

    void GenerateOutputInformation() override;

    void GenerateData() override;

    template &lt;typename TPixel, unsigned int VImageDimension&gt;
    void _InternalComputeClippedImage(itk::Image&lt;TPixel, VImageDimension&gt; *itkImage,
                                      HeightFieldSurfaceClipImageFilter *clipImageFilter,
                                      vtkPolyData *clippingPolyData,
                                      AffineTransform3D *imageToPlaneTransform);

    ImageTimeSelector::Pointer m_InputTimeSelector;
    ImageTimeSelector::Pointer m_OutputTimeSelector;

    int m_ClippingMode;

    ScalarType m_ClippingConstant;
    ScalarType m_MultiplicationFactor;
    unsigned m_MultiPlaneValue;

    unsigned int m_HeightFieldResolutionX;
    unsigned int m_HeightFieldResolutionY;

    double m_MaxHeight;

    /** \brief Time when Header was last initialized */
    itk::TimeStamp m_TimeOfHeaderInitialization;
  };

} // namespace mitk

#endif /* MITKHEIGHTFIELDSURFACECLIPIMAGEFILTER_H_HEADER_INCLUDED */</pre>
	</body>
</html>