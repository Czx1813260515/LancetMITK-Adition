<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkBoundingObjectCutter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkBoundingObjectCutter.h"
#include "mitkBoundingObject.h"
#include "mitkBoundingObjectCutter.txx"
#include "mitkGeometry3D.h"
#include "mitkImageAccessByItk.h"
#include "mitkTimeHelper.h"

#include &lt;cmath&gt;

namespace mitk
{
  void BoundingObjectCutter::SetBoundingObject(const mitk::BoundingObject *boundingObject)
<span style = "background-color:#fdd">  {
    m_BoundingObject = const_cast&lt;mitk::BoundingObject *&gt;(boundingObject);</span>
    // Process object is not const-correct so the const_cast is required here
<span style = "background-color:#fdd">    this-&gt;ProcessObject::SetNthInput(1, const_cast&lt;mitk::BoundingObject *&gt;(boundingObject));
  }</span>

<span style = "background-color:#fdd">  const mitk::BoundingObject *BoundingObjectCutter::GetBoundingObject() const { return m_BoundingObject.GetPointer(); }</span>
  BoundingObjectCutter::BoundingObjectCutter()
<span style = "background-color:#fdd">    : m_BoundingObject(nullptr),
      m_InsideValue(1),
      m_OutsideValue(0),
      m_AutoOutsideValue(false),
      m_UseInsideValue(false),
      m_OutsidePixelCount(0),
      m_InsidePixelCount(0),
      m_UseWholeInputRegion(false)
  {
    this-&gt;SetNumberOfIndexedInputs(2);
    this-&gt;SetNumberOfRequiredInputs(2);
    m_InputTimeSelector = mitk::ImageTimeSelector::New();
    m_OutputTimeSelector = mitk::ImageTimeSelector::New();
  }</span>

<span style = "background-color:#fdd">  BoundingObjectCutter::~BoundingObjectCutter() {}
  const mitk::PixelType BoundingObjectCutter::GetOutputPixelType() { return this-&gt;GetInput()-&gt;GetPixelType(); }</span>
  void BoundingObjectCutter::GenerateInputRequestedRegion()
<span style = "background-color:#fdd">  {
    mitk::Image *output = this-&gt;GetOutput();
    if ((output-&gt;IsInitialized() == false) || (m_BoundingObject.IsNull()) ||</span>
        (m_BoundingObject-&gt;GetTimeGeometry()-&gt;CountTimeSteps() == 0))
<span style = "background-color:#fdd">      return;</span>
    // we have already calculated the spatial part of the
    // input-requested-region in m_InputRequestedRegion in
    // GenerateOutputInformation (which is called before
    // GenerateInputRequestedRegion).
<span style = "background-color:#fdd">    GenerateTimeInInputRegion(output, this-&gt;GetInput());
    GenerateTimeInInputRegion(output, m_BoundingObject.GetPointer());
  }</span>

  void BoundingObjectCutter::GenerateOutputInformation()
<span style = "background-color:#fdd">  {
    mitk::Image::Pointer output = this-&gt;GetOutput();
    if ((output-&gt;IsInitialized()) &amp;&amp; (output-&gt;GetPipelineMTime() &lt;= m_TimeOfHeaderInitialization.GetMTime()))
      return;</span>

<span style = "background-color:#fdd">    mitk::Image::Pointer input = this-&gt;GetInput();</span>

<span style = "background-color:#fdd">    if (input.IsNull())</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Input is not a mitk::Image";</span>
    }
<span style = "background-color:#fdd">    itkDebugMacro(&lt;&lt; "GenerateOutputInformation()");
    unsigned int dimension = input-&gt;GetDimension();</span>

<span style = "background-color:#fdd">    if (dimension &lt; 3)</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "ImageCropper cannot handle 1D or 2D Objects.";</span>
    }

<span style = "background-color:#fdd">    if ((m_BoundingObject.IsNull()) || (m_BoundingObject-&gt;GetTimeGeometry()-&gt;CountTimeSteps() == 0))
      return;</span>

<span style = "background-color:#fdd">    mitk::BaseGeometry *boGeometry = m_BoundingObject-&gt;GetGeometry();
    mitk::BaseGeometry *inputImageGeometry = input-&gt;GetSlicedGeometry();</span>
    // calculate bounding box of bounding-object relative to the geometry
    // of the input image. The result is in pixel coordinates of the input
    // image (because the m_IndexToWorldTransform includes the spacing).
<span style = "background-color:#fdd">    mitk::BoundingBox::Pointer boBoxRelativeToImage =</span>
      boGeometry-&gt;CalculateBoundingBoxRelativeToTransform(inputImageGeometry-&gt;GetIndexToWorldTransform());

    // PART I: initialize input requested region. We do this already here (and not
    // later when GenerateInputRequestedRegion() is called), because we
    // also need the information to setup the output.

    // pre-initialize input-requested-region to largest-possible-region
    // and correct time-region; spatial part will be cropped by
    // bounding-box of bounding-object below
<span style = "background-color:#fdd">    m_InputRequestedRegion = input-&gt;GetLargestPossibleRegion();</span>

    // build region out of bounding-box of bounding-object
<span style = "background-color:#fdd">    mitk::SlicedData::IndexType index = m_InputRequestedRegion.GetIndex(); // init times and channels
    mitk::BoundingBox::PointType min = boBoxRelativeToImage-&gt;GetMinimum();
    index[0] = (mitk::SlicedData::IndexType::IndexValueType)(std::ceil(min[0]));
    index[1] = (mitk::SlicedData::IndexType::IndexValueType)(std::ceil(min[1]));
    index[2] = (mitk::SlicedData::IndexType::IndexValueType)(std::ceil(min[2]));</span>

<span style = "background-color:#fdd">    mitk::SlicedData::SizeType size = m_InputRequestedRegion.GetSize(); // init times and channels
    mitk::BoundingBox::PointType max = boBoxRelativeToImage-&gt;GetMaximum();
    size[0] = (mitk::SlicedData::SizeType::SizeValueType)(std::ceil(max[0]) - index[0]);
    size[1] = (mitk::SlicedData::SizeType::SizeValueType)(std::ceil(max[1]) - index[1]);
    size[2] = (mitk::SlicedData::SizeType::SizeValueType)(std::ceil(max[2]) - index[2]);</span>

<span style = "background-color:#fdd">    mitk::SlicedData::RegionType boRegion(index, size);</span>

<span style = "background-color:#fdd">    if (m_UseWholeInputRegion == false)</span>
    {
      // crop input-requested-region with region of bounding-object
<span style = "background-color:#fdd">      if (m_InputRequestedRegion.Crop(boRegion) == false)</span>
      {
        // crop not possible =&gt; do nothing: set time size to 0.
<span style = "background-color:#fdd">        size.Fill(0);
        m_InputRequestedRegion.SetSize(size);
        boRegion.SetSize(size);
        m_BoundingObject-&gt;SetRequestedRegion(&amp;boRegion);
        mitkThrow() &lt;&lt; "No overlap of the image and the cropping object.";</span>
      }
    }

    // set input-requested-region, because we access it later in
    // GenerateInputRequestedRegion (there we just set the time)
<span style = "background-color:#fdd">    input-&gt;SetRequestedRegion(&amp;m_InputRequestedRegion);</span>

    // PART II: initialize output image

<span style = "background-color:#fdd">    auto dimensions = new unsigned int[dimension];
    itk2vtk(m_InputRequestedRegion.GetSize(), dimensions);
    if (dimension &gt; 3)
      memcpy(dimensions + 3, input-&gt;GetDimensions() + 3, (dimension - 3) * sizeof(unsigned int));
    output-&gt;Initialize(mitk::PixelType(GetOutputPixelType()), dimension, dimensions);
    delete[] dimensions;</span>

    // now we have everything to initialize the transform of the output
<span style = "background-color:#fdd">    mitk::SlicedGeometry3D *slicedGeometry = output-&gt;GetSlicedGeometry();</span>

    // set the transform: use the transform of the input;
    // the origin will be replaced afterwards
<span style = "background-color:#fdd">    AffineTransform3D::Pointer indexToWorldTransform = AffineTransform3D::New();
    indexToWorldTransform-&gt;SetParameters(input-&gt;GetSlicedGeometry()-&gt;GetIndexToWorldTransform()-&gt;GetParameters());
    slicedGeometry-&gt;SetIndexToWorldTransform(indexToWorldTransform);</span>

    // Position the output Image to match the corresponding region of the input image
<span style = "background-color:#fdd">    const mitk::SlicedData::IndexType &amp;start = m_InputRequestedRegion.GetIndex();
    mitk::Point3D origin;
    vtk2itk(start, origin);
    inputImageGeometry-&gt;IndexToWorld(origin, origin);
    slicedGeometry-&gt;SetOrigin(origin);</span>

<span style = "background-color:#fdd">    m_TimeOfHeaderInitialization.Modified();
  }</span>

  void BoundingObjectCutter::ComputeData(mitk::Image *input3D, int boTimeStep)
<span style = "background-color:#fdd">  {
    if (input3D != nullptr &amp;&amp; input3D-&gt;GetPixelType().GetNumberOfComponents() == 1)</span>
    {
<span style = "background-color:#fdd">      AccessFixedDimensionByItk_2(input3D, CutImage, 3, this, boTimeStep);
    }</span>
    else
    {
<span style = "background-color:#fdd">      AccessVectorFixedDimensionByItk_n(input3D, CutImage, 3, (this, boTimeStep));</span>
    }
<span style = "background-color:#fdd">  }</span>

  void BoundingObjectCutter::GenerateData()
<span style = "background-color:#fdd">  {
    mitk::Image::ConstPointer input = this-&gt;GetInput();
    mitk::Image::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">    if (input.IsNull())
      return;</span>

<span style = "background-color:#fdd">    if ((output-&gt;IsInitialized() == false) || (m_BoundingObject.IsNull()) ||</span>
        (m_BoundingObject-&gt;GetTimeGeometry()-&gt;CountTimeSteps() == 0))
<span style = "background-color:#fdd">      return;</span>

<span style = "background-color:#fdd">    m_InputTimeSelector-&gt;SetInput(input);
    m_OutputTimeSelector-&gt;SetInput(this-&gt;GetOutput());</span>

<span style = "background-color:#fdd">    mitk::Surface::RegionType outputRegion = output-&gt;GetRequestedRegion();
    const mitk::TimeGeometry *outputTimeGeometry = output-&gt;GetTimeGeometry();
    const mitk::TimeGeometry *inputTimeGeometry = input-&gt;GetTimeGeometry();
    const mitk::TimeGeometry *boundingObjectTimeGeometry = m_BoundingObject-&gt;GetTimeGeometry();</span>
    TimePointType timeInMS;

<span style = "background-color:#fdd">    int timestep = 0;
    int tstart = outputRegion.GetIndex(3);
    int tmax = tstart + outputRegion.GetSize(3);</span>

    int t;
<span style = "background-color:#fdd">    for (t = tstart; t &lt; tmax; ++t)</span>
    {
<span style = "background-color:#fdd">      timeInMS = outputTimeGeometry-&gt;TimeStepToTimePoint(t);
      timestep = inputTimeGeometry-&gt;TimePointToTimeStep(timeInMS);</span>

<span style = "background-color:#fdd">      m_InputTimeSelector-&gt;SetTimeNr(timestep);
      m_InputTimeSelector-&gt;UpdateLargestPossibleRegion();
      m_OutputTimeSelector-&gt;SetTimeNr(t);
      m_OutputTimeSelector-&gt;UpdateLargestPossibleRegion();</span>

<span style = "background-color:#fdd">      timestep = boundingObjectTimeGeometry-&gt;TimePointToTimeStep(timeInMS);</span>

<span style = "background-color:#fdd">      ComputeData(m_InputTimeSelector-&gt;GetOutput(), timestep);
    }</span>

<span style = "background-color:#fdd">    m_InputTimeSelector-&gt;SetInput(nullptr);
    m_OutputTimeSelector-&gt;SetInput(nullptr);</span>

<span style = "background-color:#fdd">    m_TimeOfHeaderInitialization.Modified();
  }</span>

} // of namespace mitk</pre>
	</body>
</html>