<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPointLocator.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPointLocator.h"
#include &lt;ANN/ANN.h&gt;
#include &lt;vtkPointSet.h&gt;

mitk::PointLocator::PointLocator()
<span style = "background-color:#fdd">  : m_SearchTreeInitialized(false),
    m_VtkPoints(nullptr),
    m_MitkPoints(nullptr),
    m_ItkPoints(nullptr),
    m_ANNK(1),
    m_ANNDimension(3),
    m_ANNEpsilon(0),
    m_ANNDataPoints(nullptr),
    m_ANNQueryPoint(nullptr),
    m_ANNPointIndexes(nullptr),
    m_ANNDistances(nullptr),
    m_ANNTree(nullptr)
{
}</span>

mitk::PointLocator::~PointLocator()
<span style = "background-color:#fdd">{
  if (m_SearchTreeInitialized)
    DestroyANN();
}</span>

void mitk::PointLocator::SetPoints(vtkPointSet *pointSet)
<span style = "background-color:#fdd">{
  if (pointSet == nullptr)</span>
  {
<span style = "background-color:#fdd">    itkWarningMacro("Points are nullptr!");
    return;</span>
  }
<span style = "background-color:#fdd">  vtkPoints *points = pointSet-&gt;GetPoints();</span>

<span style = "background-color:#fdd">  if (m_VtkPoints)</span>
  {
<span style = "background-color:#fdd">    if ((m_VtkPoints == points) &amp;&amp; (m_VtkPoints-&gt;GetMTime() == points-&gt;GetMTime()))</span>
    {
<span style = "background-color:#fdd">      return; // no need to recalculate search tree</span>
    }
  }
<span style = "background-color:#fdd">  m_VtkPoints = points;</span>

<span style = "background-color:#fdd">  size_t size = points-&gt;GetNumberOfPoints();
  if (m_ANNDataPoints != nullptr)
    delete[] m_ANNDataPoints;
  m_ANNDataPoints = annAllocPts(size, m_ANNDimension);
  m_IndexToPointIdContainer.clear();
  m_IndexToPointIdContainer.resize(size);
  for (vtkIdType i = 0; (unsigned)i &lt; size; ++i)</span>
  {
<span style = "background-color:#fdd">    double *currentPoint = points-&gt;GetPoint(i);
    (m_ANNDataPoints[i])[0] = currentPoint[0];
    (m_ANNDataPoints[i])[1] = currentPoint[1];
    (m_ANNDataPoints[i])[2] = currentPoint[2];
    m_IndexToPointIdContainer[i] = i;
  }
  InitANN();
}</span>

void mitk::PointLocator::SetPoints(mitk::PointSet *points)
<span style = "background-color:#fdd">{
  if (points == nullptr)</span>
  {
<span style = "background-color:#fdd">    itkWarningMacro("Points are nullptr!");
    return;</span>
  }

<span style = "background-color:#fdd">  if (m_MitkPoints)</span>
  {
<span style = "background-color:#fdd">    if ((m_MitkPoints == points) &amp;&amp; (m_MitkPoints-&gt;GetMTime() == points-&gt;GetMTime()))</span>
    {
<span style = "background-color:#fdd">      return; // no need to recalculate search tree</span>
    }
  }
<span style = "background-color:#fdd">  m_MitkPoints = points;</span>

<span style = "background-color:#fdd">  size_t size = points-&gt;GetSize();
  if (m_ANNDataPoints != nullptr)
    delete[] m_ANNDataPoints;
  m_ANNDataPoints = annAllocPts(size, m_ANNDimension);
  m_IndexToPointIdContainer.clear();
  m_IndexToPointIdContainer.resize(size);
  size_t counter = 0;
  mitk::PointSet::PointsContainer *pointsContainer = points-&gt;GetPointSet()-&gt;GetPoints();
  mitk::PointSet::PointsContainer::Iterator it;
  mitk::PointSet::PointType currentPoint;</span>
  mitk::PointSet::PointsContainer::ElementIdentifier currentId;
<span style = "background-color:#fdd">  for (it = pointsContainer-&gt;Begin(); it != pointsContainer-&gt;End(); ++it, ++counter)</span>
  {
<span style = "background-color:#fdd">    currentPoint = it-&gt;Value();
    currentId = it-&gt;Index();
    (m_ANNDataPoints[counter])[0] = currentPoint[0];
    (m_ANNDataPoints[counter])[1] = currentPoint[1];
    (m_ANNDataPoints[counter])[2] = currentPoint[2];
    m_IndexToPointIdContainer[counter] = currentId;
  }
  InitANN();
}</span>

void mitk::PointLocator::SetPoints(ITKPointSet *pointSet)
<span style = "background-color:#fdd">{
  if (pointSet == nullptr)</span>
  {
<span style = "background-color:#fdd">    itkWarningMacro("Points are nullptr!");
    return;</span>
  }

<span style = "background-color:#fdd">  if (m_ItkPoints)</span>
  {
<span style = "background-color:#fdd">    if ((m_ItkPoints == pointSet) &amp;&amp; (m_ItkPoints-&gt;GetMTime() == pointSet-&gt;GetMTime()))</span>
    {
<span style = "background-color:#fdd">      return; // no need to recalculate search tree</span>
    }
  }
<span style = "background-color:#fdd">  m_ItkPoints = pointSet;</span>

<span style = "background-color:#fdd">  size_t size = pointSet-&gt;GetNumberOfPoints();
  if (m_ANNDataPoints != nullptr)
    delete[] m_ANNDataPoints;
  m_ANNDataPoints = annAllocPts(size, m_ANNDimension);
  m_IndexToPointIdContainer.clear();
  m_IndexToPointIdContainer.resize(size);
  size_t counter = 0;
  ITKPointSet::PointsContainerConstPointer pointsContainer = pointSet-&gt;GetPoints();
  ITKPointSet::PointsContainer::ConstIterator it;</span>
  ITKPointSet::PointType currentPoint;
  ITKPointSet::PointsContainer::ElementIdentifier currentId;
<span style = "background-color:#fdd">  for (it = pointsContainer-&gt;Begin(); it != pointsContainer-&gt;End(); ++it, ++counter)</span>
  {
<span style = "background-color:#fdd">    currentPoint = it-&gt;Value();
    currentId = it-&gt;Index();
    (m_ANNDataPoints[counter])[0] = currentPoint[0];
    (m_ANNDataPoints[counter])[1] = currentPoint[1];
    (m_ANNDataPoints[counter])[2] = currentPoint[2];
    m_IndexToPointIdContainer[counter] = currentId;
  }
  InitANN();
}</span>

mitk::PointLocator::IdType mitk::PointLocator::FindClosestPoint(const double point[3])
<span style = "background-color:#fdd">{
  m_ANNQueryPoint[0] = point[0];
  m_ANNQueryPoint[1] = point[1];
  m_ANNQueryPoint[2] = point[2];
  return FindClosestANNPoint(m_ANNQueryPoint);
}</span>

mitk::PointLocator::IdType mitk::PointLocator::FindClosestPoint(double x, double y, double z)
<span style = "background-color:#fdd">{
  m_ANNQueryPoint[0] = x;
  m_ANNQueryPoint[1] = y;
  m_ANNQueryPoint[2] = z;
  return FindClosestANNPoint(m_ANNQueryPoint);
}</span>

mitk::PointLocator::IdType mitk::PointLocator::FindClosestPoint(mitk::PointSet::PointType point)
<span style = "background-color:#fdd">{
  m_ANNQueryPoint[0] = point[0];
  m_ANNQueryPoint[1] = point[1];
  m_ANNQueryPoint[2] = point[2];
  return FindClosestANNPoint(m_ANNQueryPoint);
}</span>

mitk::PointLocator::IdType mitk::PointLocator::FindClosestANNPoint(const ANNpoint &amp;point)
<span style = "background-color:#fdd">{
  if (!m_SearchTreeInitialized)
    return -1;
  m_ANNTree-&gt;annkSearch(point, m_ANNK, m_ANNPointIndexes, m_ANNDistances);
  return m_IndexToPointIdContainer[m_ANNPointIndexes[0]];
}</span>

mitk::PointLocator::DistanceType mitk::PointLocator::GetMinimalDistance(mitk::PointSet::PointType point)
<span style = "background-color:#fdd">{
  m_ANNQueryPoint[0] = point[0];
  m_ANNQueryPoint[1] = point[1];
  m_ANNQueryPoint[2] = point[2];
  return GetMinimalDistance(m_ANNQueryPoint);
}</span>

mitk::PointLocator::DistanceType mitk::PointLocator::GetMinimalDistance(const MyANNpoint &amp;point)
<span style = "background-color:#fdd">{
  if (!m_SearchTreeInitialized)
    return -1;
  m_ANNTree-&gt;annkSearch(point, m_ANNK, m_ANNPointIndexes, m_ANNDistances);
  return m_ANNDistances[0];
}</span>

void mitk::PointLocator::InitANN()
<span style = "background-color:#fdd">{
  if (m_SearchTreeInitialized)
    DestroyANN();</span>

<span style = "background-color:#fdd">  m_ANNQueryPoint = annAllocPt(m_ANNDimension);
  m_ANNPointIndexes = new ANNidx[m_ANNK];
  m_ANNDistances = new ANNdist[m_ANNK];
  m_ANNTree = new ANNkd_tree(m_ANNDataPoints, m_IndexToPointIdContainer.size(), m_ANNDimension);</span>

<span style = "background-color:#fdd">  m_SearchTreeInitialized = true;
}</span>

void mitk::PointLocator::DestroyANN()
<span style = "background-color:#fdd">{
  m_SearchTreeInitialized = false;
  if (m_ANNQueryPoint != nullptr)
    annDeallocPt(m_ANNQueryPoint);
  if (m_ANNDataPoints != nullptr)
    annDeallocPts(m_ANNDataPoints);
  if (m_ANNPointIndexes != nullptr)
    delete[] m_ANNPointIndexes;
  if (m_ANNDistances != nullptr)
    delete[] m_ANNDistances;
  if (m_ANNTree != nullptr)
    delete m_ANNTree;
}</span>

bool mitk::PointLocator::FindClosestPointAndDistance(mitk::PointSet::PointType point, IdType *id, DistanceType *dist)
<span style = "background-color:#fdd">{
  m_ANNQueryPoint[0] = point[0];
  m_ANNQueryPoint[1] = point[1];
  m_ANNQueryPoint[2] = point[2];</span>

<span style = "background-color:#fdd">  m_ANNTree-&gt;annkSearch(m_ANNQueryPoint, m_ANNK, m_ANNPointIndexes, m_ANNDistances);</span>

<span style = "background-color:#fdd">  *id = m_IndexToPointIdContainer[m_ANNPointIndexes[0]];
  *dist = m_ANNDistances[0];
  return true;
}</span></pre>
	</body>
</html>