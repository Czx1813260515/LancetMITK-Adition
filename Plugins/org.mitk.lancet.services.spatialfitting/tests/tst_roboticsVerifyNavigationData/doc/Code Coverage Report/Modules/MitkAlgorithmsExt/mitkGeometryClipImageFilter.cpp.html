<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkGeometryClipImageFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkGeometryClipImageFilter.h"
#include "mitkImageTimeSelector.h"
#include "mitkProperties.h"
#include "mitkTimeHelper.h"

#include "mitkImageToItk.h"

#include "itkImageRegionConstIterator.h"
#include "itkImageRegionIteratorWithIndex.h"

#include &lt;limits&gt;

mitk::GeometryClipImageFilter::GeometryClipImageFilter()
<span style = "background-color:#fdd">  : m_ClippingGeometry(nullptr),
    m_ClipPartAboveGeometry(true),
    m_OutsideValue(0),
    m_AutoOutsideValue(false),
    m_LabelBothSides(false),
    m_AutoOrientLabels(false),
    m_AboveGeometryLabel(1),
    m_BelowGeometryLabel(2)
{
  this-&gt;SetNumberOfIndexedInputs(2);
  this-&gt;SetNumberOfRequiredInputs(2);
  m_InputTimeSelector = mitk::ImageTimeSelector::New();
  m_OutputTimeSelector = mitk::ImageTimeSelector::New();
  m_ClippingGeometryData = mitk::GeometryData::New();
}</span>

mitk::GeometryClipImageFilter::~GeometryClipImageFilter()
<span style = "background-color:#fdd">{
}</span>

void mitk::GeometryClipImageFilter::SetClippingGeometry(const mitk::TimeGeometry *timeClippingGeometry)
<span style = "background-color:#fdd">{
  m_TimeClippingGeometry = timeClippingGeometry;
  SetClippingGeometry(timeClippingGeometry-&gt;GetGeometryForTimeStep(0));
}</span>

void mitk::GeometryClipImageFilter::SetClippingGeometry(const mitk::BaseGeometry *aClippingGeometry)
<span style = "background-color:#fdd">{
  if (aClippingGeometry != m_ClippingGeometry.GetPointer())</span>
  {
<span style = "background-color:#fdd">    m_ClippingGeometry = aClippingGeometry;
    m_ClippingGeometryData-&gt;SetGeometry(const_cast&lt;mitk::BaseGeometry *&gt;(aClippingGeometry));
    SetNthInput(1, m_ClippingGeometryData);
    Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

const mitk::BaseGeometry *mitk::GeometryClipImageFilter::GetClippingGeometry() const
<span style = "background-color:#fdd">{
  return m_ClippingGeometry;
}</span>

const mitk::TimeGeometry *mitk::GeometryClipImageFilter::GetClippingTimeGeometry() const
<span style = "background-color:#fdd">{
  return m_TimeClippingGeometry;
}</span>

void mitk::GeometryClipImageFilter::GenerateInputRequestedRegion()
<span style = "background-color:#fdd">{
  Superclass::GenerateInputRequestedRegion();</span>

<span style = "background-color:#fdd">  mitk::Image *output = this-&gt;GetOutput();
  mitk::Image *input = this-&gt;GetInput();
  if ((output-&gt;IsInitialized() == false) || (m_ClippingGeometry.IsNull()))
    return;</span>

<span style = "background-color:#fdd">  input-&gt;SetRequestedRegionToLargestPossibleRegion();</span>

<span style = "background-color:#fdd">  GenerateTimeInInputRegion(output, input);
}</span>

void mitk::GeometryClipImageFilter::GenerateOutputInformation()
<span style = "background-color:#fdd">{
  mitk::Image::ConstPointer input = this-&gt;GetInput();
  mitk::Image::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  if ((output-&gt;IsInitialized()) &amp;&amp; (this-&gt;GetMTime() &lt;= m_TimeOfHeaderInitialization.GetMTime()))
    return;</span>

<span style = "background-color:#fdd">  itkDebugMacro(&lt;&lt; "GenerateOutputInformation()");</span>

  unsigned int i;
<span style = "background-color:#fdd">  auto tmpDimensions = new unsigned int[input-&gt;GetDimension()];</span>

<span style = "background-color:#fdd">  for (i = 0; i &lt; input-&gt;GetDimension(); ++i)
    tmpDimensions[i] = input-&gt;GetDimension(i);</span>

<span style = "background-color:#fdd">  output-&gt;Initialize(input-&gt;GetPixelType(), input-&gt;GetDimension(), tmpDimensions, input-&gt;GetNumberOfChannels());</span>

<span style = "background-color:#fdd">  delete[] tmpDimensions;</span>

<span style = "background-color:#fdd">  output-&gt;SetGeometry(static_cast&lt;mitk::BaseGeometry *&gt;(input-&gt;GetGeometry()-&gt;Clone().GetPointer()));</span>

<span style = "background-color:#fdd">  output-&gt;SetPropertyList(input-&gt;GetPropertyList()-&gt;Clone());</span>

<span style = "background-color:#fdd">  m_TimeOfHeaderInitialization.Modified();
}</span>

template &lt;typename TPixel, unsigned int VImageDimension&gt;
void mitk::GeometryClipImageFilter::_InternalComputeClippedImage(itk::Image&lt;TPixel, VImageDimension&gt; *inputItkImage,
                                                                 mitk::GeometryClipImageFilter *geometryClipper,
                                                                 const mitk::PlaneGeometry *clippingPlaneGeometry)
<span style = "background-color:#fdd">{</span>
  typedef itk::Image&lt;TPixel, VImageDimension&gt; ItkInputImageType;
  typedef itk::Image&lt;TPixel, VImageDimension&gt; ItkOutputImageType;

  typedef itk::ImageRegionConstIteratorWithIndex&lt;ItkInputImageType&gt; ItkInputImageIteratorType;
  typedef itk::ImageRegionIteratorWithIndex&lt;ItkOutputImageType&gt; ItkOutputImageIteratorType;

<span style = "background-color:#fdd">  typename mitk::ImageToItk&lt;ItkOutputImageType&gt;::Pointer outputimagetoitk = mitk::ImageToItk&lt;ItkOutputImageType&gt;::New();
  outputimagetoitk-&gt;SetInput(geometryClipper-&gt;m_OutputTimeSelector-&gt;GetOutput());
  outputimagetoitk-&gt;Update();
  typename ItkOutputImageType::Pointer outputItkImage = outputimagetoitk-&gt;GetOutput();</span>

  // create the iterators
<span style = "background-color:#fdd">  typename ItkInputImageType::RegionType inputRegionOfInterest = inputItkImage-&gt;GetLargestPossibleRegion();
  ItkInputImageIteratorType inputIt(inputItkImage, inputRegionOfInterest);
  ItkOutputImageIteratorType outputIt(outputItkImage, inputRegionOfInterest);</span>

  typename ItkOutputImageType::PixelType outsideValue;
<span style = "background-color:#fdd">  if (geometryClipper-&gt;m_AutoOutsideValue)
    outsideValue = itk::NumericTraits&lt;typename ItkOutputImageType::PixelType&gt;::min();</span>
  else
<span style = "background-color:#fdd">    outsideValue = (typename ItkOutputImageType::PixelType)geometryClipper-&gt;m_OutsideValue;</span>

<span style = "background-color:#fdd">  mitk::BaseGeometry *inputGeometry = geometryClipper-&gt;m_InputTimeSelector-&gt;GetOutput()-&gt;GetGeometry();</span>
  typedef itk::Index&lt;VImageDimension&gt; IndexType;
<span style = "background-color:#fdd">  Point3D indexPt;
  indexPt.Fill(0);
  int i, dim = IndexType::GetIndexDimension();
  Point3D pointInMM;
  bool above = geometryClipper-&gt;m_ClipPartAboveGeometry;
  bool labelBothSides = geometryClipper-&gt;GetLabelBothSides();</span>

<span style = "background-color:#fdd">  if (geometryClipper-&gt;GetAutoOrientLabels())</span>
  {
<span style = "background-color:#fdd">    Point3D leftMostPoint;
    leftMostPoint.Fill(std::numeric_limits&lt;float&gt;::min() / 2.0);
    if (clippingPlaneGeometry-&gt;IsAbove(pointInMM) != above)</span>
    {
      // invert meaning of above --&gt; left is always the "above" side
<span style = "background-color:#fdd">      above = !above;
      MITK_INFO &lt;&lt; leftMostPoint &lt;&lt; " is BELOW geometry. Inverting meaning of above" &lt;&lt; std::endl;
    }</span>
    else
<span style = "background-color:#fdd">      MITK_INFO &lt;&lt; leftMostPoint &lt;&lt; " is above geometry" &lt;&lt; std::endl;</span>
  }

<span style = "background-color:#fdd">  auto aboveLabel =</span>
    (typename ItkOutputImageType::PixelType)geometryClipper-&gt;GetAboveGeometryLabel();
<span style = "background-color:#fdd">  auto belowLabel =</span>
    (typename ItkOutputImageType::PixelType)geometryClipper-&gt;GetBelowGeometryLabel();

<span style = "background-color:#fdd">  for (inputIt.GoToBegin(), outputIt.GoToBegin(); !inputIt.IsAtEnd(); ++inputIt, ++outputIt)</span>
  {
<span style = "background-color:#fdd">    if ((typename ItkOutputImageType::PixelType)inputIt.Get() == outsideValue)</span>
    {
<span style = "background-color:#fdd">      outputIt.Set(outsideValue);
    }</span>
    else
    {
<span style = "background-color:#fdd">      for (i = 0; i &lt; dim; ++i)
        indexPt[i] = (mitk::ScalarType)inputIt.GetIndex()[i];
      inputGeometry-&gt;IndexToWorld(indexPt, pointInMM);
      if (clippingPlaneGeometry-&gt;IsAbove(pointInMM) == above)</span>
      {
<span style = "background-color:#fdd">        if (labelBothSides)
          outputIt.Set(aboveLabel);</span>
        else
<span style = "background-color:#fdd">          outputIt.Set(outsideValue);
      }</span>
      else
      {
<span style = "background-color:#fdd">        if (labelBothSides)
          outputIt.Set(belowLabel);</span>
        else
<span style = "background-color:#fdd">          outputIt.Set(inputIt.Get());</span>
      }
    }
<span style = "background-color:#fdd">  }
}</span>

#include "mitkImageAccessByItk.h"

void mitk::GeometryClipImageFilter::GenerateData()
<span style = "background-color:#fdd">{
  Image::ConstPointer input = this-&gt;GetInput();
  Image::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  if ((output-&gt;IsInitialized() == false) || (m_ClippingGeometry.IsNull()))
    return;</span>

<span style = "background-color:#fdd">  const PlaneGeometry *clippingGeometryOfCurrentTimeStep = nullptr;</span>

<span style = "background-color:#fdd">  if (m_TimeClippingGeometry.IsNull())</span>
  {
<span style = "background-color:#fdd">    clippingGeometryOfCurrentTimeStep = dynamic_cast&lt;const PlaneGeometry *&gt;(m_ClippingGeometry.GetPointer());
  }</span>
  else
  {
<span style = "background-color:#fdd">    clippingGeometryOfCurrentTimeStep =</span>
      dynamic_cast&lt;const PlaneGeometry *&gt;(m_TimeClippingGeometry-&gt;GetGeometryForTimeStep(0).GetPointer());
  }

<span style = "background-color:#fdd">  if (clippingGeometryOfCurrentTimeStep == nullptr)
    return;</span>

<span style = "background-color:#fdd">  m_InputTimeSelector-&gt;SetInput(input);
  m_OutputTimeSelector-&gt;SetInput(this-&gt;GetOutput());</span>

<span style = "background-color:#fdd">  mitk::Image::RegionType outputRegion = output-&gt;GetRequestedRegion();
  const mitk::TimeGeometry *outputTimeGeometry = output-&gt;GetTimeGeometry();
  const mitk::TimeGeometry *inputTimeGeometry = input-&gt;GetTimeGeometry();</span>
  ScalarType timeInMS;

<span style = "background-color:#fdd">  int timestep = 0;
  int tstart = outputRegion.GetIndex(3);
  int tmax = tstart + outputRegion.GetSize(3);</span>

  int t;
<span style = "background-color:#fdd">  for (t = tstart; t &lt; tmax; ++t)</span>
  {
<span style = "background-color:#fdd">    timeInMS = outputTimeGeometry-&gt;TimeStepToTimePoint(t);
    timestep = inputTimeGeometry-&gt;TimePointToTimeStep(timeInMS);</span>

<span style = "background-color:#fdd">    m_InputTimeSelector-&gt;SetTimeNr(timestep);
    m_InputTimeSelector-&gt;UpdateLargestPossibleRegion();
    m_OutputTimeSelector-&gt;SetTimeNr(t);
    m_OutputTimeSelector-&gt;UpdateLargestPossibleRegion();</span>

<span style = "background-color:#fdd">    if (m_TimeClippingGeometry.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      timestep = m_TimeClippingGeometry-&gt;TimePointToTimeStep(timeInMS);
      if (m_TimeClippingGeometry-&gt;IsValidTimeStep(timestep) == false)
        continue;</span>

<span style = "background-color:#fdd">      clippingGeometryOfCurrentTimeStep =</span>
        dynamic_cast&lt;const PlaneGeometry *&gt;(m_TimeClippingGeometry-&gt;GetGeometryForTimeStep(timestep).GetPointer());
    }

<span style = "background-color:#fdd">    AccessByItk_2(</span>
      m_InputTimeSelector-&gt;GetOutput(), _InternalComputeClippedImage, this, clippingGeometryOfCurrentTimeStep);
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  m_TimeOfHeaderInitialization.Modified();
}</span></pre>
	</body>
</html>