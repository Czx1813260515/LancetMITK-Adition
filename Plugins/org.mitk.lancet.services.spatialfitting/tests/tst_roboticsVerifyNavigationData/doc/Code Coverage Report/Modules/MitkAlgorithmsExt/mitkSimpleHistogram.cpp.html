<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSimpleHistogram.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkSimpleHistogram.h"

#include "mitkImageReadAccessor.h"
#include "mitkSimpleUnstructuredGridHistogram.h"
#include "mitkUnstructuredGrid.h"

namespace mitk
{
  void SimpleImageHistogram::ComputeFromBaseData(BaseData *src)
<span style = "background-color:#fdd">  {
    valid = false;</span>

    // check if input is valid
<span style = "background-color:#fdd">    if (src == nullptr)
      return;
    auto *source = dynamic_cast&lt;Image *&gt;(src);
    if (source == nullptr)
      return;
    else if (source-&gt;IsEmpty())
      return;</span>

    // dummy histogram
    {
<span style = "background-color:#fdd">      min = 0;
      max = 1;
      first = 0;
      last = 1;</span>
    }

    {
<span style = "background-color:#fdd">      int typInt = 0;</span>
      {
<span style = "background-color:#fdd">        auto typ = source-&gt;GetPixelType().GetComponentType();
        if (typ == itk::IOComponentEnum::UCHAR)
          typInt = 0;
        else if (typ == itk::IOComponentEnum::CHAR)
          typInt = 1;
        else if (typ == itk::IOComponentEnum::USHORT)
          typInt = 2;
        else if (typ == itk::IOComponentEnum::SHORT)
          typInt = 3;
        else if (typ == itk::IOComponentEnum::INT)
          typInt = 4;
        else if (typ == itk::IOComponentEnum::UINT)
          typInt = 5;
        else if (typ == itk::IOComponentEnum::LONG)
          typInt = 6;
        else if (typ == itk::IOComponentEnum::ULONG)
          typInt = 7;
        else if (typ == itk::IOComponentEnum::FLOAT)
          typInt = 8;
        else if (typ == itk::IOComponentEnum::DOUBLE)
          typInt = 9;</span>
        else
        {
<span style = "background-color:#fdd">          MITK_WARN &lt;&lt; "Pixel type not supported by SimpleImageHistogram";
          return;</span>
        }
      }

<span style = "background-color:#fdd">      first = -32768;
      last = 65535; // support at least full signed and unsigned short range</span>

<span style = "background-color:#fdd">      if (histogram)
        delete histogram;</span>

<span style = "background-color:#fdd">      histogram = new CountType[last - first + 1];
      memset(histogram, 0, sizeof(CountType) * (last - first + 1));
      highest = 0;
      max = first - 1;
      min = last + 1;</span>

<span style = "background-color:#fdd">      unsigned int num = 1;
      for (unsigned int r = 0; r &lt; source-&gt;GetDimension(); r++)
        num *= source-&gt;GetDimension(r);</span>

      // MITK_INFO &lt;&lt; "building histogramm of integer image: 0=" &lt;&lt; source-&gt;GetDimension(0) &lt;&lt; " 1=" &lt;&lt;
      // source-&gt;GetDimension(1) &lt;&lt; " 2=" &lt;&lt; source-&gt;GetDimension(2) &lt;&lt; " 3=" &lt;&lt;  source-&gt;GetDimension(3);

<span style = "background-color:#fdd">      ImageReadAccessor sourceAcc(source);
      const void *src = sourceAcc.GetData();</span>

      do
      {
<span style = "background-color:#fdd">        int value = 0;</span>

<span style = "background-color:#fdd">        switch (typInt)</span>
        {
          case 0:
          {
<span style = "background-color:#fdd">            auto *t = (unsigned char *)src;
            value = *t++;
            src = (void *)t;</span>
          }
<span style = "background-color:#fdd">          break;</span>
          case 1:
          {
<span style = "background-color:#fdd">            auto *t = (signed char *)src;
            value = *t++;
            src = (void *)t;</span>
          }
<span style = "background-color:#fdd">          break;</span>
          case 2:
          {
<span style = "background-color:#fdd">            auto *t = (unsigned short *)src;
            value = *t++;
            src = (void *)t;</span>
          }
<span style = "background-color:#fdd">          break;</span>
          case 3:
          {
<span style = "background-color:#fdd">            auto *t = (signed short *)src;
            value = *t++;
            src = (void *)t;</span>
          }
<span style = "background-color:#fdd">          break;</span>
          case 4:
          {
<span style = "background-color:#fdd">            auto *t = (signed int *)src;
            value = *t++;
            src = (void *)t;</span>
          }
<span style = "background-color:#fdd">          break;</span>
          case 5:
          {
<span style = "background-color:#fdd">            auto *t = (unsigned int *)src;
            value = *t++;
            src = (void *)t;</span>
          }
<span style = "background-color:#fdd">          break;</span>
          case 6:
          {
<span style = "background-color:#fdd">            auto *t = (signed long *)src;
            value = *t++;
            src = (void *)t;</span>
          }
<span style = "background-color:#fdd">          break;</span>
          case 7:
          {
<span style = "background-color:#fdd">            auto *t = (unsigned long *)src;
            value = *t++;
            src = (void *)t;</span>
          }
<span style = "background-color:#fdd">          break;</span>
          case 8:
          {
<span style = "background-color:#fdd">            auto *t = (float *)src;
            value = *t++;
            src = (void *)t;</span>
          }
<span style = "background-color:#fdd">          break;</span>
          case 9:
          {
<span style = "background-color:#fdd">            auto *t = (double *)src;
            value = *t++;
            src = (void *)t;</span>
          }
          break;
        }

<span style = "background-color:#fdd">        if (value &gt;= first &amp;&amp; value &lt;= last)</span>
        {
<span style = "background-color:#fdd">          if (value &lt; min)
            min = value;
          if (value &gt; max)
            max = value;
          CountType tmp = ++histogram[value - first];
          if (tmp &gt; highest)
            highest = tmp;</span>
        }
<span style = "background-color:#fdd">      } while (--num);</span>

<span style = "background-color:#fdd">      MITK_INFO &lt;&lt; "histogramm computed: min=" &lt;&lt; min &lt;&lt; " max=" &lt;&lt; max &lt;&lt; " highestBin=" &lt;&lt; highest</span>
                &lt;&lt; " samples=" &lt;&lt; num;
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    invLogHighest = 1.0 / log(double(highest));
    valid = true;
  }</span>

<span style = "background-color:#fdd">  bool SimpleImageHistogram::GetValid() { return valid; }</span>
  float SimpleImageHistogram::GetRelativeBin(double left, double right) const
<span style = "background-color:#fdd">  {
    if (!valid)
      return 0.0f;</span>

<span style = "background-color:#fdd">    int iLeft = floorf(left);
    int iRight = ceilf(right);</span>

    /*
     double sum = 0;

     for( int r = 0 ; r &lt; 256 ; r++)
     {
       int pos = left + (right-left) * r/255.0;
       int posInArray = floorf(pos+0.5f) - first;
       sum += float(log(double(histogram[posInArray])));
     }

     sum /= 256.0;
     return float(sum*invLogHighest);
    */

<span style = "background-color:#fdd">    CountType maximum = 0;</span>

<span style = "background-color:#fdd">    for (int i = iLeft; i &lt;= iRight; i++)</span>
    {
<span style = "background-color:#fdd">      int posInArray = i - first;
      if (histogram[posInArray] &gt; maximum)
        maximum = histogram[posInArray];
    }</span>

<span style = "background-color:#fdd">    return float(log(double(maximum)) * invLogHighest);
  }</span>

  class ImageHistogramCacheElement : public SimpleHistogramCache::Element
  {
  public:
<span style = "background-color:#fdd">    void ComputeFromBaseData(BaseData *baseData) override { histogram.ComputeFromBaseData(baseData); }
    SimpleHistogram *GetHistogram() override { return &amp;histogram; }</span>
    SimpleImageHistogram histogram;
  };

  class UnstructuredGridHistogramCacheElement : public SimpleHistogramCache::Element
  {
  public:
<span style = "background-color:#fdd">    void ComputeFromBaseData(BaseData *baseData) override { histogram.ComputeFromBaseData(baseData); }
    SimpleHistogram *GetHistogram() override { return &amp;histogram; }</span>
    SimpleUnstructuredGridHistogram histogram;
  };

  SimpleHistogram *SimpleHistogramCache::operator[](BaseData::Pointer sp_BaseData)
<span style = "background-color:#fdd">  {
    BaseData *p_BaseData = sp_BaseData.GetPointer();</span>

<span style = "background-color:#fdd">    if (!p_BaseData)</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "SimpleHistogramCache::operator[] with null base data called";
      return nullptr;</span>
    }

<span style = "background-color:#fdd">    Element *elementToUpdate = nullptr;</span>

<span style = "background-color:#fdd">    bool first = true;</span>

<span style = "background-color:#fdd">    for (auto iter = cache.begin(); iter != cache.end(); iter++)</span>
    {
<span style = "background-color:#fdd">      Element *e = *iter;
      BaseData *p_tmp = e-&gt;baseData.Lock();</span>

<span style = "background-color:#fdd">      if (p_tmp == p_BaseData)</span>
      {
<span style = "background-color:#fdd">        if (!first)</span>
        {
<span style = "background-color:#fdd">          cache.erase(iter);
          cache.push_front(e);</span>
        }
<span style = "background-color:#fdd">        if (p_BaseData-&gt;GetMTime() &gt; e-&gt;m_LastUpdateTime.GetMTime())</span>
        {
<span style = "background-color:#fdd">          elementToUpdate = e;
          goto recomputeElement;</span>
        }

        // MITK_INFO &lt;&lt; "using a cached histogram";

<span style = "background-color:#fdd">        return e-&gt;GetHistogram();</span>
      }

<span style = "background-color:#fdd">      first = false;
    }</span>

<span style = "background-color:#fdd">    if (dynamic_cast&lt;Image *&gt;(p_BaseData))</span>
    {
<span style = "background-color:#fdd">      elementToUpdate = new ImageHistogramCacheElement();
    }
    else if (dynamic_cast&lt;UnstructuredGrid *&gt;(p_BaseData))</span>
    {
<span style = "background-color:#fdd">      elementToUpdate = new UnstructuredGridHistogramCacheElement();
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "not supported: " &lt;&lt; p_BaseData-&gt;GetNameOfClass();</span>
    }

<span style = "background-color:#fdd">    elementToUpdate-&gt;baseData = p_BaseData;
    cache.push_front(elementToUpdate);
    TrimCache();</span>

<span style = "background-color:#fdd">  recomputeElement:</span>

    // MITK_INFO &lt;&lt; "computing a new histogram";

<span style = "background-color:#fdd">    elementToUpdate-&gt;ComputeFromBaseData(p_BaseData);
    elementToUpdate-&gt;m_LastUpdateTime.Modified();
    return elementToUpdate-&gt;GetHistogram();
  }</span>

<span style = "background-color:#fdd">  SimpleHistogramCache::Element::~Element() {}</span>
}</pre>
	</body>
</html>