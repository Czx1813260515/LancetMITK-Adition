<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>usModuleAbstractTracked.tpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

  Library: CppMicroServices

  Copyright (c) German Cancer Research Center (DKFZ)
  All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

============================================================================*/

#include &lt;usUtils_p.h&gt;
#include &lt;iterator&gt;

US_BEGIN_NAMESPACE

template&lt;class S, class TTT, class R&gt;
const bool ModuleAbstractTracked&lt;S,TTT,R&gt;::DEBUG_OUTPUT = false;

template&lt;class S, class TTT, class R&gt;
ModuleAbstractTracked&lt;S,TTT,R&gt;::ModuleAbstractTracked()
<span style = "background-color:#dfd">{
  closed = false;
}</span>

template&lt;class S, class TTT, class R&gt;
ModuleAbstractTracked&lt;S,TTT,R&gt;::~ModuleAbstractTracked()
<span style = "background-color:#dfd">{</span>

<span style = "background-color:#dfd">}</span>

template&lt;class S, class TTT, class R&gt;
void ModuleAbstractTracked&lt;S,TTT,R&gt;::SetInitial(const std::vector&lt;S&gt;&amp; initiallist)
<span style = "background-color:#dfd">{
  std::copy(initiallist.begin(), initiallist.end(), std::back_inserter(initial));</span>

<span style = "background-color:#dfd">  if (DEBUG_OUTPUT)</span>
  {
<span style = "background-color:#fdd">    for(typename std::list&lt;S&gt;::const_iterator item = initial.begin();
      item != initial.end(); ++item)</span>
    {
<span style = "background-color:#fdd">      US_DEBUG &lt;&lt; "ModuleAbstractTracked::setInitial: " &lt;&lt; (*item);
    }</span>
  }
<span style = "background-color:#dfd">}</span>

template&lt;class S, class TTT, class R&gt;
void ModuleAbstractTracked&lt;S,TTT,R&gt;::TrackInitial()
<span style = "background-color:#dfd">{
  while (true)</span>
  {
<span style = "background-color:#dfd">    S item;</span>
    {
<span style = "background-color:#dfd">      US_UNUSED(Lock(this));
      if (closed || (initial.size() == 0))</span>
      {
        /*
         * if there are no more initial items
         */
<span style = "background-color:#dfd">        return; /* we are done */</span>
      }
      /*
       * move the first item from the initial list to the adding list
       * within this synchronized block.
       */
<span style = "background-color:#fdd">      item = initial.front();
      initial.pop_front();
      if (TTT::IsValid(tracked[item]))</span>
      {
        /* if we are already tracking this item */
<span style = "background-color:#fdd">        US_DEBUG(DEBUG_OUTPUT) &lt;&lt; "ModuleAbstractTracked::trackInitial[already tracked]: " &lt;&lt; item;
        continue; /* skip this item */</span>
      }
<span style = "background-color:#fdd">      if (std::find(adding.begin(), adding.end(), item) != adding.end())</span>
      {
        /*
         * if this item is already in the process of being added.
         */
<span style = "background-color:#fdd">        US_DEBUG(DEBUG_OUTPUT) &lt;&lt; "ModuleAbstractTracked::trackInitial[already adding]: " &lt;&lt; item;
        continue; /* skip this item */</span>
      }
<span style = "background-color:#fdd">      adding.push_back(item);</span>
    }
<span style = "background-color:#fdd">    US_DEBUG(DEBUG_OUTPUT) &lt;&lt; "ModuleAbstractTracked::trackInitial: " &lt;&lt; item;
    TrackAdding(item, R());</span>
    /*
     * Begin tracking it. We call trackAdding
     * since we have already put the item in the
     * adding list.
     */
<span style = "background-color:#fdd">  }</span>
<span style = "background-color:#dfd">}</span>

template&lt;class S, class TTT, class R&gt;
void ModuleAbstractTracked&lt;S,TTT,R&gt;::Close()
<span style = "background-color:#dfd">{
  closed = true;
}</span>

template&lt;class S, class TTT, class R&gt;
void ModuleAbstractTracked&lt;S,TTT,R&gt;::Track(S item, R related)
<span style = "background-color:#dfd">{
  T object = TTT::DefaultValue();</span>
  {
<span style = "background-color:#dfd">    US_UNUSED(Lock(this));
    if (closed)</span>
    {
<span style = "background-color:#fdd">      return;</span>
    }
<span style = "background-color:#dfd">    object = tracked[item];
    if (!TTT::IsValid(object))</span>
    { /* we are not tracking the item */
<span style = "background-color:#dfd">      if (std::find(adding.begin(), adding.end(),item) != adding.end())</span>
      {
        /* if this item is already in the process of being added. */
<span style = "background-color:#fdd">        US_DEBUG(DEBUG_OUTPUT) &lt;&lt; "ModuleAbstractTracked::track[already adding]: " &lt;&lt; item;
        return;</span>
      }
<span style = "background-color:#dfd">      adding.push_back(item); /* mark this item is being added */
    }</span>
    else
    { /* we are currently tracking this item */
<span style = "background-color:#fdd">      US_DEBUG(DEBUG_OUTPUT) &lt;&lt; "ModuleAbstractTracked::track[modified]: " &lt;&lt; item;
      Modified(); /* increment modification count */</span>
    }
  }

<span style = "background-color:#dfd">  if (!TTT::IsValid(object))</span>
  { /* we are not tracking the item */
<span style = "background-color:#dfd">    TrackAdding(item, related);
  }</span>
  else
  {
    /* Call customizer outside of synchronized region */
<span style = "background-color:#fdd">    CustomizerModified(item, related, object);</span>
    /*
     * If the customizer throws an unchecked exception, it is safe to
     * let it propagate
     */
  }
<span style = "background-color:#dfd">}</span>

template&lt;class S, class TTT, class R&gt;
void ModuleAbstractTracked&lt;S,TTT,R&gt;::Untrack(S item, R related)
<span style = "background-color:#dfd">{
  T object = TTT::DefaultValue();</span>
  {
<span style = "background-color:#dfd">    US_UNUSED(Lock(this));
    std::size_t initialSize = initial.size();
    initial.remove(item);
    if (initialSize != initial.size())</span>
    { /* if this item is already in the list
       * of initial references to process
       */
<span style = "background-color:#fdd">      US_DEBUG(DEBUG_OUTPUT) &lt;&lt; "ModuleAbstractTracked::untrack[removed from initial]: " &lt;&lt; item;
      return; /* we have removed it from the list and it will not be</span>
               * processed
               */
    }

<span style = "background-color:#dfd">    std::size_t addingSize = adding.size();
    adding.remove(item);
    if (addingSize != adding.size())</span>
    { /* if the item is in the process of
       * being added
       */
<span style = "background-color:#fdd">      US_DEBUG(DEBUG_OUTPUT) &lt;&lt; "ModuleAbstractTracked::untrack[being added]: " &lt;&lt; item;
      return; /*</span>
           * in case the item is untracked while in the process of
           * adding
           */
    }
<span style = "background-color:#dfd">    object = tracked[item];</span>
    /*
     * must remove from tracker before
     * calling customizer callback
     */
<span style = "background-color:#dfd">    tracked.erase(item);
    if (!TTT::IsValid(object))</span>
    { /* are we actually tracking the item */
<span style = "background-color:#fdd">      return;</span>
    }
<span style = "background-color:#dfd">    Modified(); /* increment modification count */</span>
  }
<span style = "background-color:#dfd">  US_DEBUG(DEBUG_OUTPUT) &lt;&lt; "ModuleAbstractTracked::untrack[removed]: " &lt;&lt; item;</span>
  /* Call customizer outside of synchronized region */
<span style = "background-color:#dfd">  CustomizerRemoved(item, related, object);</span>
  /*
   * If the customizer throws an unchecked exception, it is safe to let it
   * propagate
   */
<span style = "background-color:#dfd">}</span>

template&lt;class S, class TTT, class R&gt;
std::size_t ModuleAbstractTracked&lt;S,TTT,R&gt;::Size() const
<span style = "background-color:#dfd">{
  return tracked.size();
}</span>

template&lt;class S, class TTT, class R&gt;
bool ModuleAbstractTracked&lt;S,TTT,R&gt;::IsEmpty() const
<span style = "background-color:#fdd">{
  return tracked.empty();
}</span>

template&lt;class S, class TTT, class R&gt;
typename ModuleAbstractTracked&lt;S,TTT,R&gt;::T
ModuleAbstractTracked&lt;S,TTT,R&gt;::GetCustomizedObject(S item) const
<span style = "background-color:#fdd">{
  typename TrackingMap::const_iterator i = tracked.find(item);
  if (i != tracked.end()) return i-&gt;second;
  return T();
}</span>

template&lt;class S, class TTT, class R&gt;
void ModuleAbstractTracked&lt;S,TTT,R&gt;::GetTracked(std::vector&lt;S&gt;&amp; items) const
<span style = "background-color:#dfd">{
  for (typename TrackingMap::const_iterator i = tracked.begin();
       i != tracked.end(); ++i)</span>
  {
<span style = "background-color:#dfd">    items.push_back(i-&gt;first);
  }
}</span>

template&lt;class S, class TTT, class R&gt;
void ModuleAbstractTracked&lt;S,TTT,R&gt;::Modified()
<span style = "background-color:#dfd">{
  trackingCount.Ref();
}</span>

template&lt;class S, class TTT, class R&gt;
int ModuleAbstractTracked&lt;S,TTT,R&gt;::GetTrackingCount() const
<span style = "background-color:#fdd">{
  return trackingCount;
}</span>

template&lt;class S, class TTT, class R&gt;
void ModuleAbstractTracked&lt;S,TTT,R&gt;::CopyEntries(TrackingMap&amp; map) const
<span style = "background-color:#fdd">{
  map.insert(tracked.begin(), tracked.end());
}</span>

template&lt;class S, class TTT, class R&gt;
bool ModuleAbstractTracked&lt;S,TTT,R&gt;::CustomizerAddingFinal(S item, const T&amp; custom)
<span style = "background-color:#dfd">{
  US_UNUSED(Lock(this));
  std::size_t addingSize = adding.size();
  adding.remove(item);
  if (addingSize != adding.size() &amp;&amp; !closed)</span>
  {
    /*
     * if the item was not untracked during the customizer
     * callback
     */
<span style = "background-color:#dfd">    if (TTT::IsValid(custom))</span>
    {
<span style = "background-color:#dfd">      tracked[item] = custom;
      Modified(); /* increment modification count */
      this-&gt;NotifyAll(); /* notify any waiters */</span>
    }
<span style = "background-color:#dfd">    return false;</span>
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    return true;</span>
  }
<span style = "background-color:#fdd">}</span>

template&lt;class S, class TTT, class R&gt;
void ModuleAbstractTracked&lt;S,TTT,R&gt;::TrackAdding(S item, R related)
<span style = "background-color:#dfd">{
  US_DEBUG(DEBUG_OUTPUT) &lt;&lt; "ModuleAbstractTracked::trackAdding:" &lt;&lt; item;
  T object = TTT::DefaultValue();
  bool becameUntracked = false;</span>
  /* Call customizer outside of synchronized region */
  try
  {
<span style = "background-color:#dfd">    object = CustomizerAdding(item, related);
    becameUntracked = this-&gt;CustomizerAddingFinal(item, object);</span>
  }
  catch (...)
<span style = "background-color:#fdd">  {</span>
    /*
     * If the customizer throws an exception, it will
     * propagate after the cleanup code.
     */
<span style = "background-color:#fdd">    this-&gt;CustomizerAddingFinal(item, object);
    throw;
  }</span>

  /*
   * The item became untracked during the customizer callback.
   */
<span style = "background-color:#dfd">  if (becameUntracked &amp;&amp; TTT::IsValid(object))</span>
  {
<span style = "background-color:#fdd">    US_DEBUG(DEBUG_OUTPUT) &lt;&lt; "ModuleAbstractTracked::trackAdding[removed]: " &lt;&lt; item;</span>
    /* Call customizer outside of synchronized region */
<span style = "background-color:#fdd">    CustomizerRemoved(item, related, object);</span>
    /*
     * If the customizer throws an unchecked exception, it is safe to
     * let it propagate
     */
  }
<span style = "background-color:#dfd">}</span>

US_END_NAMESPACE</pre>
	</body>
</html>