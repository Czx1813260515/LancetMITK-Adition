<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>usUtils.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

  Library: CppMicroServices

  Copyright (c) German Cancer Research Center (DKFZ)
  All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

============================================================================*/

#include "usUtils_p.h"

#include "usLog_p.h"
#include "usModuleInfo.h"
#include "usModuleSettings.h"

#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;algorithm&gt;
#include &lt;typeinfo&gt;

#ifdef US_PLATFORM_POSIX
  #include &lt;cerrno&gt;
  #include &lt;cstring&gt;
  #include &lt;dlfcn.h&gt;
  #include &lt;dirent.h&gt;
#else
  #ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
  #endif
  #include &lt;windows.h&gt;
  #include &lt;crtdbg.h&gt;
  #include "dirent_win32.h"
#endif

//-------------------------------------------------------------------
// Module auto-loading
//-------------------------------------------------------------------

namespace {

#if !defined(US_PLATFORM_LINUX)
std::string library_suffix()
<span style = "background-color:#dfd">{</span>
#ifdef US_PLATFORM_WINDOWS
<span style = "background-color:#dfd">  return ".dll";</span>
#elif defined(US_PLATFORM_APPLE)
  return ".dylib";
#else
  return ".so";
#endif
<span style = "background-color:#dfd">}</span>
#endif

#ifdef US_PLATFORM_POSIX

const char DIR_SEP = '/';

bool load_impl(const std::string&amp; modulePath)
{
  void* handle = dlopen(modulePath.c_str(), RTLD_NOW | RTLD_LOCAL);
  if (handle == nullptr)
  {
    US_WARN &lt;&lt; dlerror();
  }
  return (handle != nullptr);
}

#elif defined(US_PLATFORM_WINDOWS)

const char DIR_SEP = '\\';

bool load_impl(const std::string&amp; modulePath)
<span style = "background-color:#dfd">{
  void* handle = LoadLibrary(modulePath.c_str());
  if (handle == nullptr)</span>
  {
<span style = "background-color:#fdd">    US_WARN &lt;&lt; us::GetLastErrorStr();</span>
  }
<span style = "background-color:#dfd">  return (handle != nullptr);
}</span>

#else

  #ifdef US_ENABLE_AUTOLOADING_SUPPORT
    #error "Missing load_impl implementation for this platform."
  #else
bool load_impl(const std::string&amp;) { return false; }
  #endif

#endif

}

US_BEGIN_NAMESPACE

std::vector&lt;std::string&gt; AutoLoadModulesFromPath(const std::string&amp; absoluteBasePath, const std::string&amp; subDir)
<span style = "background-color:#dfd">{
  std::vector&lt;std::string&gt; loadedModules;</span>

<span style = "background-color:#dfd">  std::string loadPath = absoluteBasePath + DIR_SEP + subDir;</span>

<span style = "background-color:#dfd">  DIR* dir = opendir(loadPath.c_str());</span>
#ifdef CMAKE_INTDIR
  // Try intermediate output directories
<span style = "background-color:#dfd">  if (dir == nullptr)</span>
  {
<span style = "background-color:#dfd">    std::size_t indexOfLastSeparator = absoluteBasePath.find_last_of(DIR_SEP);
    if (indexOfLastSeparator != std::string::npos)</span>
    {
<span style = "background-color:#dfd">      std::string intermediateDir = absoluteBasePath.substr(indexOfLastSeparator+1);
      bool equalSubDir = intermediateDir.size() == std::strlen(CMAKE_INTDIR);
      for (std::size_t i = 0; equalSubDir &amp;&amp; i &lt; intermediateDir.size(); ++i)</span>
      {
<span style = "background-color:#dfd">        if (std::tolower(intermediateDir[i]) != std::tolower(CMAKE_INTDIR[i]))</span>
        {
<span style = "background-color:#fdd">          equalSubDir = false;</span>
        }
<span style = "background-color:#dfd">      }
      if (equalSubDir)</span>
      {
<span style = "background-color:#dfd">        loadPath = absoluteBasePath.substr(0, indexOfLastSeparator+1) + subDir + DIR_SEP + CMAKE_INTDIR;
        dir = opendir(loadPath.c_str());</span>
      }
<span style = "background-color:#dfd">    }</span>
  }
#endif

<span style = "background-color:#dfd">  if (dir != nullptr)</span>
  {
<span style = "background-color:#dfd">    struct dirent *ent = nullptr;
    while ((ent = readdir(dir)) != nullptr)</span>
    {
<span style = "background-color:#dfd">      bool loadFile = true;</span>
#ifdef _DIRENT_HAVE_D_TYPE
<span style = "background-color:#dfd">      if (ent-&gt;d_type != DT_UNKNOWN &amp;&amp; ent-&gt;d_type != DT_REG)</span>
      {
<span style = "background-color:#dfd">        loadFile = false;</span>
      }
#endif

<span style = "background-color:#dfd">      std::string entryFileName(ent-&gt;d_name);</span>

      // On Linux, library file names can have version numbers appended. On other platforms, we
      // check the file ending. This could be refined for Linux in the future.
#if !defined(US_PLATFORM_LINUX)
<span style = "background-color:#dfd">      if (entryFileName.rfind(library_suffix()) != (entryFileName.size() - library_suffix().size()))</span>
      {
<span style = "background-color:#dfd">        loadFile = false;</span>
      }
#endif
<span style = "background-color:#dfd">      if (!loadFile) continue;</span>

<span style = "background-color:#dfd">      std::string libPath = loadPath;
      if (!libPath.empty() &amp;&amp; libPath.find_last_of(DIR_SEP) != libPath.size() -1)</span>
      {
<span style = "background-color:#dfd">        libPath += DIR_SEP;</span>
      }
<span style = "background-color:#dfd">      libPath += entryFileName;
      US_DEBUG &lt;&lt; "Auto-loading module " &lt;&lt; libPath;</span>

<span style = "background-color:#dfd">      if (!load_impl(libPath))</span>
      {
<span style = "background-color:#fdd">        US_WARN &lt;&lt; "Auto-loading of module " &lt;&lt; libPath &lt;&lt; " failed.";
      }</span>
      else
      {
<span style = "background-color:#dfd">        loadedModules.push_back(libPath);</span>
      }
<span style = "background-color:#dfd">    }
    closedir(dir);</span>
  }
<span style = "background-color:#dfd">  return loadedModules;
}</span>

std::vector&lt;std::string&gt; AutoLoadModules(const ModuleInfo&amp; moduleInfo)
<span style = "background-color:#dfd">{
  std::vector&lt;std::string&gt; loadedModules;</span>

<span style = "background-color:#dfd">  if (moduleInfo.autoLoadDir.empty())</span>
  {
<span style = "background-color:#fdd">    return loadedModules;</span>
  }

<span style = "background-color:#dfd">  ModuleSettings::PathList autoLoadPaths = ModuleSettings::GetAutoLoadPaths();</span>

<span style = "background-color:#dfd">  std::size_t indexOfLastSeparator = moduleInfo.location.find_last_of(DIR_SEP);
  std::string moduleBasePath = moduleInfo.location.substr(0, indexOfLastSeparator);</span>

<span style = "background-color:#dfd">  for (ModuleSettings::PathList::iterator i = autoLoadPaths.begin();
       i != autoLoadPaths.end(); ++i)</span>
  {
<span style = "background-color:#dfd">    if (*i == ModuleSettings::CURRENT_MODULE_PATH())</span>
    {
      // Load all modules from a directory located relative to this modules location
      // and named after this modules library name.
<span style = "background-color:#dfd">      *i = moduleBasePath;
    }
  }</span>

  // We could have introduced a duplicate above, so remove it.
<span style = "background-color:#dfd">  std::sort(autoLoadPaths.begin(), autoLoadPaths.end());
  autoLoadPaths.erase(std::unique(autoLoadPaths.begin(), autoLoadPaths.end()), autoLoadPaths.end());
  for (ModuleSettings::PathList::iterator i = autoLoadPaths.begin();
       i != autoLoadPaths.end(); ++i)</span>
  {
<span style = "background-color:#dfd">    if (i-&gt;empty()) continue;
    std::vector&lt;std::string&gt; paths = AutoLoadModulesFromPath(*i, moduleInfo.autoLoadDir);
    loadedModules.insert(loadedModules.end(), paths.begin(), paths.end());
  }
  return loadedModules;
}</span>

US_END_NAMESPACE

//-------------------------------------------------------------------
// Error handling
//-------------------------------------------------------------------

US_BEGIN_NAMESPACE

std::string GetLastErrorStr()
<span style = "background-color:#fdd">{</span>
#ifdef US_PLATFORM_POSIX
  return std::string(strerror(errno));
#else
  // Retrieve the system error message for the last-error code
  LPVOID lpMsgBuf;
<span style = "background-color:#fdd">  DWORD dw = GetLastError();</span>

<span style = "background-color:#fdd">  FormatMessage(</span>
    FORMAT_MESSAGE_ALLOCATE_BUFFER |
    FORMAT_MESSAGE_FROM_SYSTEM |
    FORMAT_MESSAGE_IGNORE_INSERTS,
    nullptr,
    dw,
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
    (LPTSTR) &amp;lpMsgBuf,
    0, nullptr );

<span style = "background-color:#fdd">  std::string errMsg((LPCTSTR)lpMsgBuf);</span>

<span style = "background-color:#fdd">  LocalFree(lpMsgBuf);</span>

<span style = "background-color:#fdd">  return errMsg;</span>
#endif
<span style = "background-color:#fdd">}</span>

static MsgHandler handler = nullptr;

MsgHandler installMsgHandler(MsgHandler h)
<span style = "background-color:#dfd">{
  MsgHandler old = handler;
  handler = h;
  return old;
}</span>

void message_output(MsgType msgType, const char *buf)
<span style = "background-color:#fdd">{
  if (handler)</span>
  {
<span style = "background-color:#fdd">    (*handler)(msgType, buf);
  }</span>
  else
  {
<span style = "background-color:#fdd">    fprintf(stderr, "%s\n", buf);
    fflush(stderr);</span>
  }

<span style = "background-color:#fdd">  if (msgType == ErrorMsg)</span>
  {
  #if defined(_MSC_VER) &amp;&amp; !defined(NDEBUG) &amp;&amp; defined(_DEBUG) &amp;&amp; defined(_CRT_ERROR)
    // get the current report mode
<span style = "background-color:#fdd">    int reportMode = _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW);
    _CrtSetReportMode(_CRT_ERROR, reportMode);
    int ret = _CrtDbgReport(_CRT_ERROR, __FILE__, __LINE__, CppMicroServices_VERSION_STR, buf);
    if (ret == 0  &amp;&amp; reportMode &amp; _CRTDBG_MODE_WNDW)
      return; // ignore
    else if (ret == 1)
      _CrtDbgBreak();</span>
  #endif

  #ifdef US_PLATFORM_POSIX
    abort(); // trap; generates core dump
  #else
<span style = "background-color:#fdd">    exit(1); // goodbye cruel world</span>
  #endif
  }
<span style = "background-color:#fdd">}</span>

#ifdef US_HAVE_CXXABI_H
#include &lt;cxxabi.h&gt;
#endif

US_Core_EXPORT ::std::string GetDemangledName(const ::std::type_info&amp; typeInfo)
<span style = "background-color:#dfd">{
  ::std::string result;</span>
#ifdef US_HAVE_CXXABI_H
  int status = 0;
  char* demangled = abi::__cxa_demangle(typeInfo.name(), nullptr, nullptr, &amp;status);
  if (demangled &amp;&amp; status == 0)
  {
    result = demangled;
    free(demangled);
  }
#elif defined(US_PLATFORM_WINDOWS)
<span style = "background-color:#dfd">  const char* demangled = typeInfo.name();
  if (demangled != nullptr)</span>
  {
<span style = "background-color:#dfd">    result = demangled;</span>
    // remove "struct" qualifiers
<span style = "background-color:#dfd">    std::size_t pos = 0;
    while (pos != std::string::npos)</span>
    {
<span style = "background-color:#dfd">      if ((pos = result.find("struct ", pos)) != std::string::npos)</span>
      {
<span style = "background-color:#dfd">        result = result.substr(0, pos) + result.substr(pos + 7);
        pos += 8;</span>
      }
<span style = "background-color:#dfd">    }</span>
    // remove "class" qualifiers
<span style = "background-color:#dfd">    pos = 0;
    while (pos != std::string::npos)</span>
    {
<span style = "background-color:#dfd">      if ((pos = result.find("class ", pos)) != std::string::npos)</span>
      {
<span style = "background-color:#dfd">        result = result.substr(0, pos) + result.substr(pos + 6);
        pos += 7;</span>
      }
<span style = "background-color:#dfd">    }</span>
  }
#else
  (void)typeInfo;
#endif
<span style = "background-color:#dfd">  return result;
}</span>

US_END_NAMESPACE</pre>
	</body>
</html>