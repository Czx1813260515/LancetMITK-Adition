<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDataStorage.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkDataStorage.h"

#include "itkCommand.h"
#include "mitkDataNode.h"
#include "mitkGroupTagProperty.h"
#include "mitkImage.h"
#include "mitkNodePredicateBase.h"
#include "mitkNodePredicateProperty.h"
#include "mitkProperties.h"
#include "mitkArbitraryTimeGeometry.h"

<span style = "background-color:#fdd">mitk::DataStorage::DataStorage() : itk::Object(), m_BlockNodeModifiedEvents(false)
{
}</span>

mitk::DataStorage::~DataStorage()
<span style = "background-color:#fdd">{</span>
  ///// we can not call GetAll() in destructor, because it is implemented in a subclass
  // SetOfObjects::ConstPointer all = this-&gt;GetAll();
  // for (SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)
  //  this-&gt;RemoveListeners(it-&gt;Value());
  // m_NodeModifiedObserverTags.clear();
  // m_NodeDeleteObserverTags.clear();
<span style = "background-color:#fdd">}</span>

void mitk::DataStorage::Add(DataNode *node, DataNode *parent)
<span style = "background-color:#fdd">{
  DataStorage::SetOfObjects::Pointer parents = DataStorage::SetOfObjects::New();
  if (parent != nullptr) //&lt; Return empty set if parent is null
    parents-&gt;InsertElement(0, parent);
  this-&gt;Add(node, parents);
}</span>

void mitk::DataStorage::Remove(const DataStorage::SetOfObjects *nodes)
<span style = "background-color:#fdd">{
  if (nodes == nullptr)
    return;
  for (DataStorage::SetOfObjects::ConstIterator it = nodes-&gt;Begin(); it != nodes-&gt;End(); it++)
    this-&gt;Remove(it.Value());
}</span>

mitk::DataStorage::SetOfObjects::ConstPointer mitk::DataStorage::GetSubset(const NodePredicateBase *condition) const
<span style = "background-color:#fdd">{
  DataStorage::SetOfObjects::ConstPointer result = this-&gt;FilterSetOfObjects(this-&gt;GetAll(), condition);
  return result;
}</span>

mitk::DataNode *mitk::DataStorage::GetNamedNode(const char *name) const

<span style = "background-color:#fdd">{
  if (name == nullptr)
    return nullptr;</span>

<span style = "background-color:#fdd">  StringProperty::Pointer s(StringProperty::New(name));
  NodePredicateProperty::Pointer p = NodePredicateProperty::New("name", s);
  DataStorage::SetOfObjects::ConstPointer rs = this-&gt;GetSubset(p);
  if (rs-&gt;Size() &gt;= 1)
    return rs-&gt;GetElement(0);</span>
  else
<span style = "background-color:#fdd">    return nullptr;
}</span>

mitk::DataNode *mitk::DataStorage::GetNode(const NodePredicateBase *condition) const
<span style = "background-color:#fdd">{
  if (condition == nullptr)
    return nullptr;</span>

<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer rs = this-&gt;GetSubset(condition);
  if (rs-&gt;Size() &gt;= 1)
    return rs-&gt;GetElement(0);</span>
  else
<span style = "background-color:#fdd">    return nullptr;
}</span>

mitk::DataNode *mitk::DataStorage::GetNamedDerivedNode(const char *name,
                                                       const DataNode *sourceNode,
                                                       bool onlyDirectDerivations) const
<span style = "background-color:#fdd">{
  if (name == nullptr)
    return nullptr;</span>

<span style = "background-color:#fdd">  StringProperty::Pointer s(StringProperty::New(name));
  NodePredicateProperty::Pointer p = NodePredicateProperty::New("name", s);
  DataStorage::SetOfObjects::ConstPointer rs = this-&gt;GetDerivations(sourceNode, p, onlyDirectDerivations);
  if (rs-&gt;Size() &gt;= 1)
    return rs-&gt;GetElement(0);</span>
  else
<span style = "background-color:#fdd">    return nullptr;
}</span>

void mitk::DataStorage::PrintSelf(std::ostream &amp;os, itk::Indent indent) const
<span style = "background-color:#fdd">{</span>
  // Superclass::PrintSelf(os, indent);
<span style = "background-color:#fdd">  DataStorage::SetOfObjects::ConstPointer all = this-&gt;GetAll();
  os &lt;&lt; indent &lt;&lt; "DataStorage " &lt;&lt; this &lt;&lt; " is managing " &lt;&lt; all-&gt;Size() &lt;&lt; " objects. List of objects:" &lt;&lt; std::endl;
  for (DataStorage::SetOfObjects::ConstIterator allIt = all-&gt;Begin(); allIt != all-&gt;End(); allIt++)</span>
  {
<span style = "background-color:#fdd">    std::string name;
    allIt.Value()-&gt;GetName(name);
    std::string datatype;
    if (allIt.Value()-&gt;GetData() != nullptr)
      datatype = allIt.Value()-&gt;GetData()-&gt;GetNameOfClass();
    os &lt;&lt; indent &lt;&lt; " " &lt;&lt; allIt.Value().GetPointer() &lt;&lt; "&lt;" &lt;&lt; datatype &lt;&lt; "&gt;: " &lt;&lt; name &lt;&lt; std::endl;
    DataStorage::SetOfObjects::ConstPointer parents = this-&gt;GetSources(allIt.Value());
    if (parents-&gt;Size() &gt; 0)</span>
    {
<span style = "background-color:#fdd">      os &lt;&lt; indent &lt;&lt; "  Direct sources: ";
      for (DataStorage::SetOfObjects::ConstIterator parentIt = parents-&gt;Begin(); parentIt != parents-&gt;End();
           parentIt++)
        os &lt;&lt; parentIt.Value().GetPointer() &lt;&lt; ", ";
      os &lt;&lt; std::endl;</span>
    }
<span style = "background-color:#fdd">    DataStorage::SetOfObjects::ConstPointer derivations = this-&gt;GetDerivations(allIt.Value());
    if (derivations-&gt;Size() &gt; 0)</span>
    {
<span style = "background-color:#fdd">      os &lt;&lt; indent &lt;&lt; "  Direct derivations: ";
      for (DataStorage::SetOfObjects::ConstIterator derivationIt = derivations-&gt;Begin();
           derivationIt != derivations-&gt;End();
           derivationIt++)
        os &lt;&lt; derivationIt.Value().GetPointer() &lt;&lt; ", ";
      os &lt;&lt; std::endl;</span>
    }
<span style = "background-color:#fdd">  }
  os &lt;&lt; std::endl;
}</span>

mitk::DataStorage::SetOfObjects::ConstPointer mitk::DataStorage::FilterSetOfObjects(const SetOfObjects *set,
                                                                                    const NodePredicateBase *condition) const
<span style = "background-color:#fdd">{
  if (set == nullptr)
    return nullptr;</span>

<span style = "background-color:#fdd">  DataStorage::SetOfObjects::Pointer result = DataStorage::SetOfObjects::New();
  for (DataStorage::SetOfObjects::ConstIterator it = set-&gt;Begin(); it != set-&gt;End(); it++)
    if (condition == nullptr ||</span>
        condition-&gt;CheckNode(it.Value()) ==
          true) // alway copy the set, otherwise the iterator in DataStorage::Remove() will crash
<span style = "background-color:#fdd">      result-&gt;InsertElement(result-&gt;Size(), it.Value());</span>

<span style = "background-color:#fdd">  return DataStorage::SetOfObjects::ConstPointer(result);
}</span>

const mitk::DataNode::GroupTagList mitk::DataStorage::GetGroupTags() const
<span style = "background-color:#fdd">{
  DataNode::GroupTagList result;
  SetOfObjects::ConstPointer all = this-&gt;GetAll();
  if (all.IsNull())
    return result;</span>

<span style = "background-color:#fdd">  for (DataStorage::SetOfObjects::ConstIterator nodeIt = all-&gt;Begin(); nodeIt != all-&gt;End();
       nodeIt++) // for each node</span>
  {
<span style = "background-color:#fdd">    PropertyList *pl = nodeIt.Value()-&gt;GetPropertyList();
    for (auto propIt = pl-&gt;GetMap()-&gt;begin(); propIt != pl-&gt;GetMap()-&gt;end();
         ++propIt)
      if (dynamic_cast&lt;GroupTagProperty *&gt;(propIt-&gt;second.GetPointer()) != nullptr)
        result.insert(propIt-&gt;first);
  }</span>

<span style = "background-color:#fdd">  return result;
}</span>

void mitk::DataStorage::EmitAddNodeEvent(const DataNode *node)
<span style = "background-color:#fdd">{
  AddNodeEvent.Send(node);
}</span>

void mitk::DataStorage::EmitRemoveNodeEvent(const DataNode *node)
<span style = "background-color:#fdd">{
  RemoveNodeEvent.Send(node);
}</span>

void mitk::DataStorage::OnNodeInteractorChanged(itk::Object *caller, const itk::EventObject &amp;)
<span style = "background-color:#fdd">{
  const auto *_Node = dynamic_cast&lt;const DataNode *&gt;(caller);
  if (_Node)</span>
  {
<span style = "background-color:#fdd">    InteractorChangedNodeEvent.Send(_Node);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::DataStorage::OnNodeModifiedOrDeleted(const itk::Object *caller, const itk::EventObject &amp;event)
<span style = "background-color:#fdd">{
  if (m_BlockNodeModifiedEvents)
    return;</span>

<span style = "background-color:#fdd">  const auto *_Node = dynamic_cast&lt;const DataNode *&gt;(caller);
  if (_Node)</span>
  {
<span style = "background-color:#fdd">    const auto *modEvent = dynamic_cast&lt;const itk::ModifiedEvent *&gt;(&amp;event);
    if (modEvent)
      ChangedNodeEvent.Send(_Node);</span>
    else
<span style = "background-color:#fdd">      DeleteNodeEvent.Send(_Node);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::DataStorage::AddListeners(const DataNode *_Node)
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; locked(m_MutexOne);</span>
  // node must not be 0 and must not be yet registered
<span style = "background-color:#fdd">  auto *NonConstNode = const_cast&lt;DataNode *&gt;(_Node);
  if (_Node &amp;&amp; m_NodeModifiedObserverTags.find(NonConstNode) == m_NodeModifiedObserverTags.end())</span>
  {
<span style = "background-color:#fdd">    itk::MemberCommand&lt;DataStorage&gt;::Pointer nodeModifiedCommand = itk::MemberCommand&lt;DataStorage&gt;::New();
    nodeModifiedCommand-&gt;SetCallbackFunction(this, &amp;DataStorage::OnNodeModifiedOrDeleted);
    m_NodeModifiedObserverTags[NonConstNode] = NonConstNode-&gt;AddObserver(itk::ModifiedEvent(), nodeModifiedCommand);</span>

<span style = "background-color:#fdd">    itk::MemberCommand&lt;DataStorage&gt;::Pointer interactorChangedCommand =</span>
      itk::MemberCommand&lt;DataStorage&gt;::New();
<span style = "background-color:#fdd">    interactorChangedCommand-&gt;SetCallbackFunction(this, &amp;DataStorage::OnNodeInteractorChanged);
    m_NodeInteractorChangedObserverTags[NonConstNode] =</span>
      NonConstNode-&gt;AddObserver(InteractorChangedEvent(), interactorChangedCommand);

    // add itk delete listener on datastorage
<span style = "background-color:#fdd">    itk::MemberCommand&lt;DataStorage&gt;::Pointer deleteCommand = itk::MemberCommand&lt;DataStorage&gt;::New();
    deleteCommand-&gt;SetCallbackFunction(this, &amp;DataStorage::OnNodeModifiedOrDeleted);</span>
    // add observer
<span style = "background-color:#fdd">    m_NodeDeleteObserverTags[NonConstNode] = NonConstNode-&gt;AddObserver(itk::DeleteEvent(), deleteCommand);
  }
}</span>

void mitk::DataStorage::RemoveListeners(const DataNode *_Node)
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; locked(m_MutexOne);</span>
  // node must not be 0 and must be registered
<span style = "background-color:#fdd">  auto *NonConstNode = const_cast&lt;DataNode *&gt;(_Node);
  if (_Node &amp;&amp; m_NodeModifiedObserverTags.find(NonConstNode) != m_NodeModifiedObserverTags.end())</span>
  {
    // const cast is bad! but sometimes it is necessary. removing an observer does not really
    // touch the internal state
<span style = "background-color:#fdd">    NonConstNode-&gt;RemoveObserver(m_NodeModifiedObserverTags.find(NonConstNode)-&gt;second);
    NonConstNode-&gt;RemoveObserver(m_NodeDeleteObserverTags.find(NonConstNode)-&gt;second);
    NonConstNode-&gt;RemoveObserver(m_NodeInteractorChangedObserverTags.find(NonConstNode)-&gt;second);</span>

<span style = "background-color:#fdd">    m_NodeModifiedObserverTags.erase(NonConstNode);
    m_NodeDeleteObserverTags.erase(NonConstNode);
    m_NodeInteractorChangedObserverTags.erase(NonConstNode);</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::TimeGeometry::ConstPointer mitk::DataStorage::ComputeBoundingGeometry3D(const SetOfObjects *input,
                                                                              const char *boolPropertyKey,
                                                                              const BaseRenderer *renderer,
                                                                              const char *boolPropertyKey2) const
<span style = "background-color:#fdd">{
  if (input == nullptr)
    throw std::invalid_argument("DataStorage: input is invalid");</span>

<span style = "background-color:#fdd">  BoundingBox::PointsContainer::Pointer pointscontainer = BoundingBox::PointsContainer::New();</span>

<span style = "background-color:#fdd">  BoundingBox::PointIdentifier pointid = 0;
  Point3D point;</span>

<span style = "background-color:#fdd">  Vector3D minSpacing;
  minSpacing.Fill(itk::NumericTraits&lt;ScalarType&gt;::max());</span>

<span style = "background-color:#fdd">  ScalarType stmax = itk::NumericTraits&lt;ScalarType&gt;::max();
  ScalarType stmin = itk::NumericTraits&lt;ScalarType&gt;::NonpositiveMin();</span>

<span style = "background-color:#fdd">  std::set&lt;ScalarType&gt; existingTimePoints;
  ScalarType maximalTime = 0;</span>

  // Needed for check of zero bounding boxes
<span style = "background-color:#fdd">  ScalarType nullpoint[] = {0, 0, 0, 0, 0, 0};
  BoundingBox::BoundsArrayType itkBoundsZero(nullpoint);</span>

<span style = "background-color:#fdd">  for (SetOfObjects::ConstIterator it = input-&gt;Begin(); it != input-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = it-&gt;Value();</span>
    if ((node.IsNotNull()) &amp;&amp; (node-&gt;GetData() != nullptr) &amp;&amp; (node-&gt;GetData()-&gt;IsEmpty() == false) &amp;&amp;
<span style = "background-color:#fdd">        node-&gt;IsOn(boolPropertyKey, renderer) &amp;&amp; node-&gt;IsOn(boolPropertyKey2, renderer))</span>
    {
<span style = "background-color:#fdd">      const TimeGeometry *timeGeometry = node-&gt;GetData()-&gt;GetUpdatedTimeGeometry();</span>

<span style = "background-color:#fdd">      if (timeGeometry != nullptr)</span>
      {
        // bounding box (only if non-zero)
<span style = "background-color:#fdd">        BoundingBox::BoundsArrayType itkBounds = timeGeometry-&gt;GetBoundingBoxInWorld()-&gt;GetBounds();
        if (itkBounds == itkBoundsZero)</span>
        {
<span style = "background-color:#fdd">          continue;</span>
        }

        unsigned char i;
<span style = "background-color:#fdd">        for (i = 0; i &lt; 8; ++i)</span>
        {
<span style = "background-color:#fdd">          point = timeGeometry-&gt;GetCornerPointInWorld(i);
          if (point[0] * point[0] + point[1] * point[1] + point[2] * point[2] &lt; large)
            pointscontainer-&gt;InsertElement(pointid++, point);</span>
          else
          {
<span style = "background-color:#fdd">            itkGenericOutputMacro(&lt;&lt; "Unrealistically distant corner point encountered. Ignored. Node: " &lt;&lt; node);</span>
          }
<span style = "background-color:#fdd">        }</span>
        try
        {
          // time bounds
          // iterate over all time steps
          // Attention: Objects with zero bounding box are not respected in time bound calculation
<span style = "background-color:#fdd">          for (TimeStepType i = 0; i &lt; timeGeometry-&gt;CountTimeSteps(); i++)</span>
          {
            // We must not use 'node-&gt;GetData()-&gt;GetGeometry(i)-&gt;GetSpacing()' here, as it returns the spacing
            // in its original space, which, in case of an image geometry, can have the values in different
            // order than in world space. For the further calculations, we need to have the spacing values
            // in world coordinate order (sag-cor-ax).
<span style = "background-color:#fdd">            Vector3D spacing;
            spacing.Fill(1.0);
            node-&gt;GetData()-&gt;GetGeometry(i)-&gt;IndexToWorld(spacing, spacing);
            for (int axis = 0; axis &lt; 3; ++ axis)</span>
            {
<span style = "background-color:#fdd">              ScalarType space = std::abs(spacing[axis]);
              if (space &lt; minSpacing[axis])</span>
              {
<span style = "background-color:#fdd">                minSpacing[axis] = space;</span>
              }
<span style = "background-color:#fdd">            }</span>

<span style = "background-color:#fdd">            const auto curTimeBounds = timeGeometry-&gt;GetTimeBounds(i);
            if ((curTimeBounds[0] &gt; stmin) &amp;&amp; (curTimeBounds[0] &lt; stmax))</span>
            {
<span style = "background-color:#fdd">              existingTimePoints.insert(curTimeBounds[0]);</span>
            }
<span style = "background-color:#fdd">            if ((curTimeBounds[1] &gt; maximalTime) &amp;&amp; (curTimeBounds[1] &lt; stmax))</span>
            {
<span style = "background-color:#fdd">               maximalTime = curTimeBounds[1];</span>
            }
<span style = "background-color:#fdd">          }</span>
        }
        catch ( const itk::ExceptionObject &amp;e )
<span style = "background-color:#fdd">        {
          MITK_ERROR &lt;&lt; e.GetDescription() &lt;&lt; std::endl;
        }</span>
      }
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  BoundingBox::Pointer result = BoundingBox::New();
  result-&gt;SetPoints(pointscontainer);
  result-&gt;ComputeBoundingBox();</span>

  // compute the number of time steps
<span style = "background-color:#fdd">  if (existingTimePoints.empty()) // make sure that there is at least one time sliced geometry in the data storage</span>
  {
<span style = "background-color:#fdd">    existingTimePoints.insert(0.0);
    maximalTime = 1.0;</span>
  }

<span style = "background-color:#fdd">  ArbitraryTimeGeometry::Pointer timeGeometry = nullptr;
  if (result-&gt;GetPoints()-&gt;Size() &gt; 0)</span>
  {
    // Initialize a geometry of a single time step
<span style = "background-color:#fdd">    Geometry3D::Pointer geometry = Geometry3D::New();
    geometry-&gt;Initialize();</span>
    // correct bounding-box (is now in mm, should be in index-coordinates)
    // according to spacing
<span style = "background-color:#fdd">    BoundingBox::BoundsArrayType bounds = result-&gt;GetBounds();</span>
    AffineTransform3D::OutputVectorType offset;
<span style = "background-color:#fdd">    for (int i = 0; i &lt; 3; ++i)</span>
    {
<span style = "background-color:#fdd">      offset[i] = bounds[i * 2];
      bounds[i * 2] = 0.0;
      bounds[i * 2 + 1] = (bounds[i * 2 + 1] - offset[i]) / minSpacing[i];
    }
    geometry-&gt;GetIndexToWorldTransform()-&gt;SetOffset(offset);
    geometry-&gt;SetBounds(bounds);
    geometry-&gt;SetSpacing(minSpacing);</span>

    // Initialize the time sliced geometry
<span style = "background-color:#fdd">    auto tsIterator = existingTimePoints.cbegin();
    auto tsPredecessor = tsIterator++;
    auto tsEnd = existingTimePoints.cend();
    timeGeometry = ArbitraryTimeGeometry::New();
    for (; tsIterator != tsEnd; ++tsIterator, ++tsPredecessor)</span>
    {
<span style = "background-color:#fdd">      timeGeometry-&gt;AppendNewTimeStep(geometry, *tsPredecessor, *tsIterator);
    }
    timeGeometry-&gt;AppendNewTimeStep(geometry, *tsPredecessor, maximalTime);</span>

<span style = "background-color:#fdd">    timeGeometry-&gt;Update();
  }
  return timeGeometry.GetPointer();
}</span>

mitk::TimeGeometry::ConstPointer mitk::DataStorage::ComputeBoundingGeometry3D(const char *boolPropertyKey,
                                                                              const BaseRenderer *renderer,
                                                                              const char *boolPropertyKey2) const
<span style = "background-color:#fdd">{
  return this-&gt;ComputeBoundingGeometry3D(this-&gt;GetAll(), boolPropertyKey, renderer, boolPropertyKey2);
}</span>

mitk::TimeGeometry::ConstPointer mitk::DataStorage::ComputeVisibleBoundingGeometry3D(const BaseRenderer *renderer,
                                                                                     const char *boolPropertyKey)
<span style = "background-color:#fdd">{
  return ComputeBoundingGeometry3D("visible", renderer, boolPropertyKey);
}</span>

mitk::BoundingBox::Pointer mitk::DataStorage::ComputeBoundingBox(const char *boolPropertyKey,
                                                                 const BaseRenderer *renderer,
                                                                 const char *boolPropertyKey2)
<span style = "background-color:#fdd">{
  BoundingBox::PointsContainer::Pointer pointscontainer = BoundingBox::PointsContainer::New();</span>

<span style = "background-color:#fdd">  BoundingBox::PointIdentifier pointid = 0;
  Point3D point;</span>

  // Needed for check of zero bounding boxes
<span style = "background-color:#fdd">  ScalarType nullpoint[] = {0, 0, 0, 0, 0, 0};
  BoundingBox::BoundsArrayType itkBoundsZero(nullpoint);</span>

<span style = "background-color:#fdd">  SetOfObjects::ConstPointer all = this-&gt;GetAll();
  for (SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = it-&gt;Value();</span>
    if ((node.IsNotNull()) &amp;&amp; (node-&gt;GetData() != nullptr) &amp;&amp; (node-&gt;GetData()-&gt;IsEmpty() == false) &amp;&amp;
<span style = "background-color:#fdd">        node-&gt;IsOn(boolPropertyKey, renderer) &amp;&amp; node-&gt;IsOn(boolPropertyKey2, renderer))</span>
    {
<span style = "background-color:#fdd">      const TimeGeometry *geometry = node-&gt;GetData()-&gt;GetUpdatedTimeGeometry();
      if (geometry != nullptr)</span>
      {
        // bounding box (only if non-zero)
<span style = "background-color:#fdd">        BoundingBox::BoundsArrayType itkBounds = geometry-&gt;GetBoundingBoxInWorld()-&gt;GetBounds();
        if (itkBounds == itkBoundsZero)</span>
        {
<span style = "background-color:#fdd">          continue;</span>
        }

        unsigned char i;
<span style = "background-color:#fdd">        for (i = 0; i &lt; 8; ++i)</span>
        {
<span style = "background-color:#fdd">          point = geometry-&gt;GetCornerPointInWorld(i);
          if (point[0] * point[0] + point[1] * point[1] + point[2] * point[2] &lt; large)
            pointscontainer-&gt;InsertElement(pointid++, point);</span>
          else
          {
<span style = "background-color:#fdd">            itkGenericOutputMacro(&lt;&lt; "Unrealistically distant corner point encountered. Ignored. Node: " &lt;&lt; node);</span>
          }
<span style = "background-color:#fdd">        }</span>
      }
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  BoundingBox::Pointer result = BoundingBox::New();
  result-&gt;SetPoints(pointscontainer);
  result-&gt;ComputeBoundingBox();</span>

<span style = "background-color:#fdd">  return result;
}</span>

mitk::TimeBounds mitk::DataStorage::ComputeTimeBounds(const char *boolPropertyKey,
                                                      const BaseRenderer *renderer,
                                                      const char *boolPropertyKey2)
<span style = "background-color:#fdd">{</span>
  TimeBounds timeBounds;

  ScalarType stmin, stmax, cur;

<span style = "background-color:#fdd">  stmin = itk::NumericTraits&lt;ScalarType&gt;::NonpositiveMin();
  stmax = itk::NumericTraits&lt;ScalarType&gt;::max();</span>

<span style = "background-color:#fdd">  timeBounds[0] = stmax;
  timeBounds[1] = stmin;</span>

<span style = "background-color:#fdd">  SetOfObjects::ConstPointer all = this-&gt;GetAll();
  for (SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)</span>
  {
<span style = "background-color:#fdd">    DataNode::Pointer node = it-&gt;Value();</span>
    if ((node.IsNotNull()) &amp;&amp; (node-&gt;GetData() != nullptr) &amp;&amp; (node-&gt;GetData()-&gt;IsEmpty() == false) &amp;&amp;
<span style = "background-color:#fdd">        node-&gt;IsOn(boolPropertyKey, renderer) &amp;&amp; node-&gt;IsOn(boolPropertyKey2, renderer))</span>
    {
<span style = "background-color:#fdd">      const TimeGeometry *geometry = node-&gt;GetData()-&gt;GetUpdatedTimeGeometry();
      if (geometry != nullptr)</span>
      {
<span style = "background-color:#fdd">        const TimeBounds &amp;curTimeBounds = geometry-&gt;GetTimeBounds();
        cur = curTimeBounds[0];</span>
        // is it after -infinity, but before everything else that we found until now?
<span style = "background-color:#fdd">        if ((cur &gt; stmin) &amp;&amp; (cur &lt; timeBounds[0]))
          timeBounds[0] = cur;</span>

<span style = "background-color:#fdd">        cur = curTimeBounds[1];</span>
        // is it before infinity, but after everything else that we found until now?
<span style = "background-color:#fdd">        if ((cur &lt; stmax) &amp;&amp; (cur &gt; timeBounds[1]))
          timeBounds[1] = cur;</span>
      }
    }
<span style = "background-color:#fdd">  }
  if (!(timeBounds[0] &lt; stmax))</span>
  {
<span style = "background-color:#fdd">    timeBounds[0] = stmin;
    timeBounds[1] = stmax;</span>
  }
<span style = "background-color:#fdd">  return timeBounds;
}</span>

void mitk::DataStorage::BlockNodeModifiedEvents(bool block)
<span style = "background-color:#fdd">{
  m_BlockNodeModifiedEvents = block;
}</span>

mitk::DataNode::Pointer mitk::FindTopmostVisibleNode(const DataStorage::SetOfObjects::ConstPointer nodes,
                                                     const Point3D worldPosition,
                                                     const TimePointType timePoint,
                                                     const BaseRenderer* baseRender)
<span style = "background-color:#fdd">{
   if (nodes.IsNull())</span>
  {
<span style = "background-color:#fdd">    return nullptr;</span>
  }

<span style = "background-color:#fdd">  mitk::DataNode::Pointer topLayerNode = nullptr;
  int maxLayer = std::numeric_limits&lt;int&gt;::min();</span>

<span style = "background-color:#fdd">  for (const auto &amp;node : *nodes)</span>
  {
<span style = "background-color:#fdd">    if (node.IsNull())</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    bool isHelperObject = false;
    node-&gt;GetBoolProperty("helper object", isHelperObject);
    if (isHelperObject)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    auto data = node-&gt;GetData();
    if (nullptr == data)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    auto geometry = data-&gt;GetGeometry();
    if (nullptr == geometry || !geometry-&gt;IsInside(worldPosition))</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    auto timeGeometry = data-&gt;GetUpdatedTimeGeometry();
    if (nullptr == timeGeometry)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    if (!timeGeometry-&gt;IsValidTimePoint(timePoint))</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    int layer = 0;
    if (!node-&gt;GetIntProperty("layer", layer, baseRender))</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    if (layer &lt;= maxLayer)</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    if (!node-&gt;IsVisible(baseRender))</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    topLayerNode = node;
    maxLayer = layer;
  }</span>

<span style = "background-color:#fdd">  return topLayerNode;
}</span></pre>
	</body>
</html>