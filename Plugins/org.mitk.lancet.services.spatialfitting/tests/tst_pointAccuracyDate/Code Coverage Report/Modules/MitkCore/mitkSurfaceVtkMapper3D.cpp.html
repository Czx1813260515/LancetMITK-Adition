<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkSurfaceVtkMapper3D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkSurfaceVtkMapper3D.h"
#include &lt;mitkClippingProperty.h&gt;
#include &lt;mitkColorProperty.h&gt;
#include &lt;mitkCoreServices.h&gt;
#include &lt;mitkDataNode.h&gt;
#include &lt;mitkExtractSliceFilter.h&gt;
#include &lt;mitkIPropertyAliases.h&gt;
#include &lt;mitkIPropertyDescriptions.h&gt;
#include &lt;mitkImageSliceSelector.h&gt;
#include &lt;mitkLookupTableProperty.h&gt;
#include &lt;mitkProperties.h&gt;
#include &lt;mitkSmartPointerProperty.h&gt;
#include &lt;mitkTransferFunctionProperty.h&gt;
#include &lt;mitkVtkInterpolationProperty.h&gt;
#include &lt;mitkVtkRepresentationProperty.h&gt;
#include &lt;mitkVtkScalarModeProperty.h&gt;

// VTK
#include &lt;vtkActor.h&gt;
#include &lt;vtkPlaneCollection.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkPolyDataNormals.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkTexture.h&gt;

const mitk::Surface *mitk::SurfaceVtkMapper3D::GetInput()
<span style = "background-color:#fdd">{
  return static_cast&lt;const mitk::Surface *&gt;(GetDataNode()-&gt;GetData());
}</span>

mitk::SurfaceVtkMapper3D::SurfaceVtkMapper3D()
<span style = "background-color:#fdd">{
  m_GenerateNormals = false;
}</span>

mitk::SurfaceVtkMapper3D::~SurfaceVtkMapper3D()
<span style = "background-color:#fdd">{
}</span>

void mitk::SurfaceVtkMapper3D::GenerateDataForRenderer(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  LocalStorage *ls = m_LSH.GetLocalStorage(renderer);</span>

<span style = "background-color:#fdd">  bool visible = true;
  GetDataNode()-&gt;GetVisibility(visible, renderer, "visible");</span>

<span style = "background-color:#fdd">  if (!visible)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_Actor-&gt;VisibilityOff();
    return;</span>
  }

  //
  // set the input-object at time t for the mapper
  //
<span style = "background-color:#fdd">  mitk::Surface::ConstPointer input = this-&gt;GetInput();</span>

<span style = "background-color:#fdd">  const auto* worldGeometry = renderer-&gt;GetWorldTimeGeometry();
  const auto timeBounds = worldGeometry-&gt;GetTimeBounds(renderer-&gt;GetTimeStep());</span>

<span style = "background-color:#fdd">  if (!input-&gt;GetTimeGeometry()-&gt;IsValidTimePoint(timeBounds[0]))</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_Actor-&gt;VisibilityOff();
    return;</span>
  }

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPolyData&gt; polydata = input-&gt;GetVtkPolyData(this-&gt;GetTimestep());
  if (polydata == nullptr)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_Actor-&gt;VisibilityOff();
    return;</span>
  }
<span style = "background-color:#fdd">  if (m_GenerateNormals)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataNormals-&gt;SetInputData(polydata);
    ls-&gt;m_VtkPolyDataMapper-&gt;SetInputConnection(ls-&gt;m_VtkPolyDataNormals-&gt;GetOutputPort());
  }</span>
  else
  {
<span style = "background-color:#fdd">    bool depthsorting = false;
    GetDataNode()-&gt;GetBoolProperty("Depth Sorting", depthsorting);</span>

<span style = "background-color:#fdd">    if (depthsorting)</span>
    {
<span style = "background-color:#fdd">      ls-&gt;m_DepthSort-&gt;SetInputData(polydata);
      ls-&gt;m_DepthSort-&gt;SetCamera(renderer-&gt;GetVtkRenderer()-&gt;GetActiveCamera());
      ls-&gt;m_DepthSort-&gt;SetDirectionToBackToFront();
      ls-&gt;m_DepthSort-&gt;Update();
      ls-&gt;m_VtkPolyDataMapper-&gt;SetInputConnection(ls-&gt;m_DepthSort-&gt;GetOutputPort());
    }</span>
    else
    {
<span style = "background-color:#fdd">      ls-&gt;m_VtkPolyDataMapper-&gt;SetInputData(polydata);</span>
    }
  }

  //
  // apply properties read from the PropertyList
  //
<span style = "background-color:#fdd">  ApplyAllProperties(renderer, ls-&gt;m_Actor);</span>

<span style = "background-color:#fdd">  if (visible)
    ls-&gt;m_Actor-&gt;VisibilityOn();
}</span>

void mitk::SurfaceVtkMapper3D::ResetMapper(BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  LocalStorage *ls = m_LSH.GetLocalStorage(renderer);
  ls-&gt;m_Actor-&gt;VisibilityOff();
}</span>

void mitk::SurfaceVtkMapper3D::ApplyMitkPropertiesToVtkProperty(mitk::DataNode *node,
                                                                vtkProperty *property,
                                                                mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{</span>
  // Backface culling
  {
<span style = "background-color:#fdd">    mitk::BoolProperty::Pointer p;
    node-&gt;GetProperty(p, "Backface Culling", renderer);
    bool useCulling = false;
    if (p.IsNotNull())
      useCulling = p-&gt;GetValue();
    property-&gt;SetBackfaceCulling(useCulling);
  }</span>

  // Colors
  {
<span style = "background-color:#fdd">    double ambient[3] = {0.5, 0.5, 0.0};
    double diffuse[3] = {0.5, 0.5, 0.0};
    double specular[3] = {1.0, 1.0, 1.0};</span>

<span style = "background-color:#fdd">    float coeff_ambient = 0.5f;
    float coeff_diffuse = 0.5f;
    float coeff_specular = 0.5f;
    float power_specular = 10.0f;</span>

    // Color
    {
<span style = "background-color:#fdd">      mitk::ColorProperty::Pointer p;
      node-&gt;GetProperty(p, "color", renderer);
      if (p.IsNotNull())</span>
      {
<span style = "background-color:#fdd">        mitk::Color c = p-&gt;GetColor();
        ambient[0] = c.GetRed();
        ambient[1] = c.GetGreen();
        ambient[2] = c.GetBlue();
        diffuse[0] = c.GetRed();
        diffuse[1] = c.GetGreen();
        diffuse[2] = c.GetBlue();</span>
        // Setting specular color to the same, make physically no real sense, however vtk rendering slows down, if these
        // colors are different.
<span style = "background-color:#fdd">        specular[0] = c.GetRed();
        specular[1] = c.GetGreen();
        specular[2] = c.GetBlue();</span>
      }
<span style = "background-color:#fdd">    }</span>

    // Ambient
    {
<span style = "background-color:#fdd">      mitk::ColorProperty::Pointer p;
      node-&gt;GetProperty(p, "material.ambientColor", renderer);
      if (p.IsNotNull())</span>
      {
<span style = "background-color:#fdd">        mitk::Color c = p-&gt;GetColor();
        ambient[0] = c.GetRed();
        ambient[1] = c.GetGreen();
        ambient[2] = c.GetBlue();</span>
      }
<span style = "background-color:#fdd">    }</span>

    // Diffuse
    {
<span style = "background-color:#fdd">      mitk::ColorProperty::Pointer p;
      node-&gt;GetProperty(p, "material.diffuseColor", renderer);
      if (p.IsNotNull())</span>
      {
<span style = "background-color:#fdd">        mitk::Color c = p-&gt;GetColor();
        diffuse[0] = c.GetRed();
        diffuse[1] = c.GetGreen();
        diffuse[2] = c.GetBlue();</span>
      }
<span style = "background-color:#fdd">    }</span>

    // Specular
    {
<span style = "background-color:#fdd">      mitk::ColorProperty::Pointer p;
      node-&gt;GetProperty(p, "material.specularColor", renderer);
      if (p.IsNotNull())</span>
      {
<span style = "background-color:#fdd">        mitk::Color c = p-&gt;GetColor();
        specular[0] = c.GetRed();
        specular[1] = c.GetGreen();
        specular[2] = c.GetBlue();</span>
      }
<span style = "background-color:#fdd">    }</span>

    // Ambient coeff
    {
<span style = "background-color:#fdd">      node-&gt;GetFloatProperty("material.ambientCoefficient", coeff_ambient, renderer);</span>
    }

    // Diffuse coeff
    {
<span style = "background-color:#fdd">      node-&gt;GetFloatProperty("material.diffuseCoefficient", coeff_diffuse, renderer);</span>
    }

    // Specular coeff
    {
<span style = "background-color:#fdd">      node-&gt;GetFloatProperty("material.specularCoefficient", coeff_specular, renderer);</span>
    }

    // Specular power
    {
<span style = "background-color:#fdd">      node-&gt;GetFloatProperty("material.specularPower", power_specular, renderer);</span>
    }

<span style = "background-color:#fdd">    property-&gt;SetAmbient(coeff_ambient);
    property-&gt;SetDiffuse(coeff_diffuse);
    property-&gt;SetSpecular(coeff_specular);
    property-&gt;SetSpecularPower(power_specular);</span>

<span style = "background-color:#fdd">    property-&gt;SetAmbientColor(ambient);
    property-&gt;SetDiffuseColor(diffuse);
    property-&gt;SetSpecularColor(specular);</span>
  }

  // Render mode
  {
    // Opacity
    {
<span style = "background-color:#fdd">      float opacity = 1.0f;
      if (node-&gt;GetOpacity(opacity, renderer))
        property-&gt;SetOpacity(opacity);</span>
    }

    // Wireframe line width
    {
<span style = "background-color:#fdd">      float lineWidth = 1;
      node-&gt;GetFloatProperty("material.wireframeLineWidth", lineWidth, renderer);
      property-&gt;SetLineWidth(lineWidth);</span>
    }

    // Point size
    {
<span style = "background-color:#fdd">      float pointSize = 1.0f;
      node-&gt;GetFloatProperty("material.pointSize", pointSize, renderer);
      property-&gt;SetPointSize(pointSize);</span>
    }

    // Representation
    {
<span style = "background-color:#fdd">      mitk::VtkRepresentationProperty::Pointer p;
      node-&gt;GetProperty(p, "material.representation", renderer);
      if (p.IsNotNull())
        property-&gt;SetRepresentation(p-&gt;GetVtkRepresentation());
    }</span>

    // Interpolation
    {
<span style = "background-color:#fdd">      mitk::VtkInterpolationProperty::Pointer p;
      node-&gt;GetProperty(p, "material.interpolation", renderer);
      if (p.IsNotNull())
        property-&gt;SetInterpolation(p-&gt;GetVtkInterpolation());
    }</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::SurfaceVtkMapper3D::ApplyAllProperties(mitk::BaseRenderer *renderer, vtkActor * /*actor*/)
<span style = "background-color:#fdd">{
  LocalStorage *ls = m_LSH.GetLocalStorage(renderer);</span>

<span style = "background-color:#fdd">  Superclass::ApplyColorAndOpacityProperties(renderer, ls-&gt;m_Actor);</span>
  // VTK Properties
<span style = "background-color:#fdd">  ApplyMitkPropertiesToVtkProperty(this-&gt;GetDataNode(), ls-&gt;m_Actor-&gt;GetProperty(), renderer);</span>

<span style = "background-color:#fdd">  mitk::TransferFunctionProperty::Pointer transferFuncProp;
  this-&gt;GetDataNode()-&gt;GetProperty(transferFuncProp, "Surface.TransferFunction", renderer);
  if (transferFuncProp.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataMapper-&gt;SetLookupTable(transferFuncProp-&gt;GetValue()-&gt;GetColorTransferFunction());</span>
  }

<span style = "background-color:#fdd">  mitk::LookupTableProperty::Pointer lookupTableProp;
  this-&gt;GetDataNode()-&gt;GetProperty(lookupTableProp, "LookupTable", renderer);
  if (lookupTableProp.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataMapper-&gt;SetLookupTable(lookupTableProp-&gt;GetLookupTable()-&gt;GetVtkLookupTable());</span>
  }

<span style = "background-color:#fdd">  mitk::LevelWindow levelWindow;
  if (this-&gt;GetDataNode()-&gt;GetLevelWindow(levelWindow, renderer, "levelWindow"))</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataMapper-&gt;SetScalarRange(levelWindow.GetLowerWindowBound(), levelWindow.GetUpperWindowBound());
  }
  else if (this-&gt;GetDataNode()-&gt;GetLevelWindow(levelWindow, renderer))</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataMapper-&gt;SetScalarRange(levelWindow.GetLowerWindowBound(), levelWindow.GetUpperWindowBound());</span>
  }

<span style = "background-color:#fdd">  bool scalarVisibility = false;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("scalar visibility", scalarVisibility);
  ls-&gt;m_VtkPolyDataMapper-&gt;SetScalarVisibility((scalarVisibility ? 1 : 0));</span>

<span style = "background-color:#fdd">  if (scalarVisibility)</span>
  {
    mitk::VtkScalarModeProperty *scalarMode;
<span style = "background-color:#fdd">    if (this-&gt;GetDataNode()-&gt;GetProperty(scalarMode, "scalar mode", renderer))
      ls-&gt;m_VtkPolyDataMapper-&gt;SetScalarMode(scalarMode-&gt;GetVtkScalarMode());</span>
    else
<span style = "background-color:#fdd">      ls-&gt;m_VtkPolyDataMapper-&gt;SetScalarModeToDefault();</span>

<span style = "background-color:#fdd">    bool colorMode = false;
    this-&gt;GetDataNode()-&gt;GetBoolProperty("color mode", colorMode);
    ls-&gt;m_VtkPolyDataMapper-&gt;SetColorMode((colorMode ? 1 : 0));</span>

<span style = "background-color:#fdd">    double scalarsMin = 0;
    this-&gt;GetDataNode()-&gt;GetDoubleProperty("ScalarsRangeMinimum", scalarsMin, renderer);</span>

<span style = "background-color:#fdd">    double scalarsMax = 1.0;
    this-&gt;GetDataNode()-&gt;GetDoubleProperty("ScalarsRangeMaximum", scalarsMax, renderer);</span>

<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataMapper-&gt;SetScalarRange(scalarsMin, scalarsMax);</span>
  }

<span style = "background-color:#fdd">  mitk::SmartPointerProperty::Pointer imagetextureProp =</span>
    dynamic_cast&lt;mitk::SmartPointerProperty *&gt;(GetDataNode()-&gt;GetProperty("Surface.Texture", renderer));

<span style = "background-color:#fdd">  if (imagetextureProp.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    mitk::Image *miktTexture = dynamic_cast&lt;mitk::Image *&gt;(imagetextureProp-&gt;GetSmartPointer().GetPointer());
    vtkSmartPointer&lt;vtkTexture&gt; vtkTxture = vtkSmartPointer&lt;vtkTexture&gt;::New();</span>
    // Either select the first slice of a volume
<span style = "background-color:#fdd">    if (miktTexture-&gt;GetDimension(2) &gt; 1)</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "3D Textures are not supported by VTK and MITK. The first slice of the volume will be used instead!";
      mitk::ImageSliceSelector::Pointer sliceselector = mitk::ImageSliceSelector::New();
      sliceselector-&gt;SetSliceNr(0);
      sliceselector-&gt;SetChannelNr(0);
      sliceselector-&gt;SetTimeNr(0);
      sliceselector-&gt;SetInput(miktTexture);
      sliceselector-&gt;Update();
      vtkTxture-&gt;SetInputData(sliceselector-&gt;GetOutput()-&gt;GetVtkImageData());
    }</span>
    else // or just use the 2D image
    {
<span style = "background-color:#fdd">      vtkTxture-&gt;SetInputData(miktTexture-&gt;GetVtkImageData());</span>

      // Lancet modification: manipulate texture colormap
<span style = "background-color:#fdd">      double scalarsMin = 0;
      GetDataNode()-&gt;GetDoubleProperty("Texture minimum", scalarsMin, renderer);</span>

<span style = "background-color:#fdd">      double scalarsMax = 1.0;
      GetDataNode()-&gt;GetDoubleProperty("Texture maximum", scalarsMax, renderer);</span>

<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
      lut-&gt;SetRampToLinear();
      lut-&gt;SetTableRange(scalarsMin, scalarsMax);
      lut-&gt;SetSaturationRange(0.0, 0.0);
      lut-&gt;SetHueRange(0.0, 0.0);
      lut-&gt;SetValueRange(0.0, 1.0);
      lut-&gt;Build();</span>

<span style = "background-color:#fdd">      vtkTxture-&gt;SetColorModeToMapScalars();
      vtkTxture-&gt;SetLookupTable(lut);</span>
      
<span style = "background-color:#fdd">    }</span>
    // pass the texture to the actor
<span style = "background-color:#fdd">    ls-&gt;m_Actor-&gt;SetTexture(vtkTxture);
    if (ls-&gt;m_VtkPolyDataMapper-&gt;GetInput()-&gt;GetPointData()-&gt;GetTCoords() == nullptr)</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Surface.Texture property was set, but there are no texture coordinates. Please provide texture "</span>
                    "coordinates for the vtkPolyData via vtkPolyData-&gt;GetPointData()-&gt;SetTCoords().";
    }
    // if no texture is set, this will also remove a previously used texture
    // and reset the actor to it's default behaviour
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    ls-&gt;m_Actor-&gt;SetTexture(nullptr);</span>
  }

  // deprecated settings
<span style = "background-color:#fdd">  bool deprecatedUseCellData = false;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("deprecated useCellDataForColouring", deprecatedUseCellData);</span>

<span style = "background-color:#fdd">  bool deprecatedUsePointData = false;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("deprecated usePointDataForColouring", deprecatedUsePointData);</span>

<span style = "background-color:#fdd">  if (deprecatedUseCellData)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataMapper-&gt;SetColorModeToDefault();
    ls-&gt;m_VtkPolyDataMapper-&gt;SetScalarRange(0, 255);
    ls-&gt;m_VtkPolyDataMapper-&gt;ScalarVisibilityOn();
    ls-&gt;m_VtkPolyDataMapper-&gt;SetScalarModeToUseCellData();
    ls-&gt;m_Actor-&gt;GetProperty()-&gt;SetSpecular(1);
    ls-&gt;m_Actor-&gt;GetProperty()-&gt;SetSpecularPower(50);
    ls-&gt;m_Actor-&gt;GetProperty()-&gt;SetInterpolationToPhong();
  }
  else if (deprecatedUsePointData)</span>
  {
<span style = "background-color:#fdd">    float scalarsMin = 0;
    if (dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("ScalarsRangeMinimum")) != nullptr)
      scalarsMin =</span>
        dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("ScalarsRangeMinimum"))-&gt;GetValue();

<span style = "background-color:#fdd">    float scalarsMax = 0.1;
    if (dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("ScalarsRangeMaximum")) != nullptr)
      scalarsMax =</span>
        dynamic_cast&lt;mitk::FloatProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("ScalarsRangeMaximum"))-&gt;GetValue();

<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataMapper-&gt;SetScalarRange(scalarsMin, scalarsMax);
    ls-&gt;m_VtkPolyDataMapper-&gt;SetColorModeToMapScalars();
    ls-&gt;m_VtkPolyDataMapper-&gt;ScalarVisibilityOn();
    ls-&gt;m_Actor-&gt;GetProperty()-&gt;SetSpecular(1);
    ls-&gt;m_Actor-&gt;GetProperty()-&gt;SetSpecularPower(50);
    ls-&gt;m_Actor-&gt;GetProperty()-&gt;SetInterpolationToPhong();</span>
  }

<span style = "background-color:#fdd">  int deprecatedScalarMode = VTK_COLOR_MODE_DEFAULT;
  if (this-&gt;GetDataNode()-&gt;GetIntProperty("deprecated scalar mode", deprecatedScalarMode, renderer))</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataMapper-&gt;SetScalarMode(deprecatedScalarMode);
    ls-&gt;m_VtkPolyDataMapper-&gt;ScalarVisibilityOn();
    ls-&gt;m_Actor-&gt;GetProperty()-&gt;SetSpecular(1);
    ls-&gt;m_Actor-&gt;GetProperty()-&gt;SetSpecularPower(50);</span>
  }

  // Check whether one or more ClippingProperty objects have been defined for
  // this node. Check both renderer specific and global property lists, since
  // properties in both should be considered.
<span style = "background-color:#fdd">  const PropertyList::PropertyMap *rendererProperties = this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetMap();
  const PropertyList::PropertyMap *globalProperties = this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetMap();</span>

  // Add clipping planes (if any)
<span style = "background-color:#fdd">  ls-&gt;m_ClippingPlaneCollection-&gt;RemoveAllItems();</span>

<span style = "background-color:#fdd">  PropertyList::PropertyMap::const_iterator it;
  for (it = rendererProperties-&gt;begin(); it != rendererProperties-&gt;end(); ++it)</span>
  {
<span style = "background-color:#fdd">    this-&gt;CheckForClippingProperty(renderer, (*it).second.GetPointer());
  }</span>

<span style = "background-color:#fdd">  for (it = globalProperties-&gt;begin(); it != globalProperties-&gt;end(); ++it)</span>
  {
<span style = "background-color:#fdd">    this-&gt;CheckForClippingProperty(renderer, (*it).second.GetPointer());
  }</span>

<span style = "background-color:#fdd">  if (ls-&gt;m_ClippingPlaneCollection-&gt;GetNumberOfItems() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataMapper-&gt;SetClippingPlanes(ls-&gt;m_ClippingPlaneCollection);
  }</span>
  else
  {
<span style = "background-color:#fdd">    ls-&gt;m_VtkPolyDataMapper-&gt;RemoveAllClippingPlanes();</span>
  }
<span style = "background-color:#fdd">}</span>

vtkProp *mitk::SurfaceVtkMapper3D::GetVtkProp(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  LocalStorage *ls = m_LSH.GetLocalStorage(renderer);
  return ls-&gt;m_Actor;
}</span>

void mitk::SurfaceVtkMapper3D::CheckForClippingProperty(mitk::BaseRenderer *renderer, mitk::BaseProperty *property)
<span style = "background-color:#fdd">{
  LocalStorage *ls = m_LSH.GetLocalStorage(renderer);</span>

<span style = "background-color:#fdd">  auto *clippingProperty = dynamic_cast&lt;ClippingProperty *&gt;(property);</span>

<span style = "background-color:#fdd">  if ((clippingProperty != nullptr) &amp;&amp; (clippingProperty-&gt;GetClippingEnabled()))</span>
  {
<span style = "background-color:#fdd">    const Point3D &amp;origin = clippingProperty-&gt;GetOrigin();
    const Vector3D &amp;normal = clippingProperty-&gt;GetNormal();</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPlane&gt; clippingPlane = vtkSmartPointer&lt;vtkPlane&gt;::New();
    clippingPlane-&gt;SetOrigin(origin[0], origin[1], origin[2]);
    clippingPlane-&gt;SetNormal(normal[0], normal[1], normal[2]);</span>

<span style = "background-color:#fdd">    ls-&gt;m_ClippingPlaneCollection-&gt;AddItem(clippingPlane);
  }
}</span>

void mitk::SurfaceVtkMapper3D::SetDefaultPropertiesForVtkProperty(mitk::DataNode *node,
                                                                  mitk::BaseRenderer *renderer,
                                                                  bool overwrite)
<span style = "background-color:#fdd">{</span>
  // Shading
  {
<span style = "background-color:#fdd">    node-&gt;AddProperty("material.wireframeLineWidth", mitk::FloatProperty::New(1.0f), renderer, overwrite);
    node-&gt;AddProperty("material.pointSize", mitk::FloatProperty::New(1.0f), renderer, overwrite);</span>

<span style = "background-color:#fdd">    node-&gt;AddProperty("material.ambientCoefficient", mitk::FloatProperty::New(0.05f), renderer, overwrite);
    node-&gt;AddProperty("material.diffuseCoefficient", mitk::FloatProperty::New(0.9f), renderer, overwrite);
    node-&gt;AddProperty("material.specularCoefficient", mitk::FloatProperty::New(1.0f), renderer, overwrite);
    node-&gt;AddProperty("material.specularPower", mitk::FloatProperty::New(16.0f), renderer, overwrite);</span>

<span style = "background-color:#fdd">    node-&gt;AddProperty("material.representation", mitk::VtkRepresentationProperty::New(), renderer, overwrite);
    node-&gt;AddProperty("material.interpolation", mitk::VtkInterpolationProperty::New(), renderer, overwrite);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::SurfaceVtkMapper3D::SetDefaultProperties(mitk::DataNode *node, mitk::BaseRenderer *renderer, bool overwrite)
<span style = "background-color:#fdd">{
  node-&gt;AddProperty("color", mitk::ColorProperty::New(1.0f, 1.0f, 1.0f), renderer, overwrite);
  node-&gt;AddProperty("opacity", mitk::FloatProperty::New(1.0), renderer, overwrite);</span>

<span style = "background-color:#fdd">  mitk::SurfaceVtkMapper3D::SetDefaultPropertiesForVtkProperty(node, renderer, overwrite); // Shading</span>

<span style = "background-color:#fdd">  node-&gt;AddProperty("scalar visibility", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("color mode", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("scalar mode", mitk::VtkScalarModeProperty::New(), renderer, overwrite);
  mitk::Surface::Pointer surface = dynamic_cast&lt;Surface *&gt;(node-&gt;GetData());
  if (surface.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    if ((surface-&gt;GetVtkPolyData() != nullptr) &amp;&amp; (surface-&gt;GetVtkPolyData()-&gt;GetPointData() != nullptr) &amp;&amp;</span>
        (surface-&gt;GetVtkPolyData()-&gt;GetPointData()-&gt;GetScalars() != nullptr))
    {
<span style = "background-color:#fdd">      node-&gt;AddProperty("scalar visibility", mitk::BoolProperty::New(true), renderer, overwrite);
      node-&gt;AddProperty("color mode", mitk::BoolProperty::New(true), renderer, overwrite);</span>
    }
  }

  // Backface culling
<span style = "background-color:#fdd">  node-&gt;AddProperty("Backface Culling", mitk::BoolProperty::New(false), renderer, overwrite);</span>

<span style = "background-color:#fdd">  node-&gt;AddProperty("Depth Sorting", mitk::BoolProperty::New(false), renderer, overwrite);
  mitk::CoreServicePointer&lt;mitk::IPropertyDescriptions&gt; propDescService(mitk::CoreServices::GetPropertyDescriptions());
  propDescService-&gt;AddDescription(</span>
    "Depth Sorting",
    "Enables correct rendering for transparent objects by ordering polygons according to the distance "
    "to the camera. It is not recommended to enable this property for large surfaces (rendering might "
    "be slow).");
<span style = "background-color:#fdd">  Superclass::SetDefaultProperties(node, renderer, overwrite);
}</span></pre>
	</body>
</html>