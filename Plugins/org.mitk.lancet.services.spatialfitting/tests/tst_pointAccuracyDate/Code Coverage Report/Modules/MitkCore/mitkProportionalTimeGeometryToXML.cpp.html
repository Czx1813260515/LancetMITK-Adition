<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkProportionalTimeGeometryToXML.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkProportionalTimeGeometryToXML.h"

#include "mitkGeometry3DToXML.h"

#include &lt;mitkLexicalCast.h&gt;

#include &lt;tinyxml2.h&gt;

tinyxml2::XMLElement *mitk::ProportionalTimeGeometryToXML::ToXML(tinyxml2::XMLDocument&amp; doc, const ProportionalTimeGeometry *timeGeom)
<span style = "background-color:#fdd">{
  assert(timeGeom);</span>

<span style = "background-color:#fdd">  auto *timeGeomElem = doc.NewElement("ProportionalTimeGeometry");
  timeGeomElem-&gt;SetAttribute("NumberOfTimeSteps", static_cast&lt;int&gt;(timeGeom-&gt;CountTimeSteps()));</span>
  // TinyXML cannot serialize infinity (default value for time step)
  // So we guard this value and the first time point against serialization problems
  // by not writing them. The reader can then tell that absence of those values
  // means "keep the default values"
<span style = "background-color:#fdd">  if (timeGeom-&gt;GetFirstTimePoint() != -std::numeric_limits&lt;TimePointType&gt;::max())
    timeGeomElem-&gt;SetAttribute("FirstTimePoint", boost::lexical_cast&lt;std::string&gt;(timeGeom-&gt;GetFirstTimePoint()).c_str());
  if (timeGeom-&gt;GetStepDuration() != std::numeric_limits&lt;TimePointType&gt;::infinity())
    timeGeomElem-&gt;SetAttribute("StepDuration", boost::lexical_cast&lt;std::string&gt;(timeGeom-&gt;GetStepDuration()).c_str());</span>

<span style = "background-color:#fdd">  for (TimeStepType t = 0; t &lt; timeGeom-&gt;CountTimeSteps(); ++t)</span>
  {
    // add a node for the geometry of each time step
<span style = "background-color:#fdd">    const Geometry3D *geom3D(nullptr);
    if ((geom3D = dynamic_cast&lt;const Geometry3D *&gt;(timeGeom-&gt;GetGeometryForTimeStep(t).GetPointer())))</span>
    {
<span style = "background-color:#fdd">      auto *geom3DElement = Geometry3DToXML::ToXML(doc, geom3D);
      geom3DElement-&gt;SetAttribute("TimeStep", static_cast&lt;int&gt;(t)); // mark order for us
      timeGeomElem-&gt;InsertEndChild(geom3DElement);
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Serializing a ProportionalTimeGeometry that contains something other than Geometry3D!"</span>
                &lt;&lt; " (in time step " &lt;&lt; t &lt;&lt; ")"
                &lt;&lt; " File will miss information!";
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return timeGeomElem;
}</span>

mitk::ProportionalTimeGeometry::Pointer mitk::ProportionalTimeGeometryToXML::FromXML(const tinyxml2::XMLElement *timeGeometryElement)
<span style = "background-color:#fdd">{
  if (!timeGeometryElement)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "Cannot deserialize ProportionalTimeGeometry from nullptr.";
    return nullptr;</span>
  }

<span style = "background-color:#fdd">  int numberOfTimeSteps = 0;</span>

<span style = "background-color:#fdd">  if (tinyxml2::XML_SUCCESS != timeGeometryElement-&gt;QueryIntAttribute("NumberOfTimeSteps", &amp;numberOfTimeSteps))</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "&lt;ProportionalTimeGeometry&gt; found without NumberOfTimeSteps attribute. Counting...";</span>
  }

  // might be missing!
  TimePointType firstTimePoint;
<span style = "background-color:#fdd">  const char* firstTimePoint_s = nullptr;</span>
  TimePointType stepDuration;
<span style = "background-color:#fdd">  const char* stepDuration_s = nullptr;</span>
  try
  {
<span style = "background-color:#fdd">    firstTimePoint_s = timeGeometryElement-&gt;Attribute("FirstTimePoint");
    if (nullptr != firstTimePoint_s)</span>
    {
<span style = "background-color:#fdd">      firstTimePoint = boost::lexical_cast&lt;double&gt;(firstTimePoint_s);
    }</span>
    else
    {
<span style = "background-color:#fdd">      firstTimePoint = -std::numeric_limits&lt;TimePointType&gt;::max();</span>
    }

<span style = "background-color:#fdd">    stepDuration_s = timeGeometryElement-&gt;Attribute("StepDuration");
    if (nullptr != stepDuration_s)</span>
    {
<span style = "background-color:#fdd">      stepDuration = boost::lexical_cast&lt;double&gt;(stepDuration_s);
    }</span>
    else
    {
<span style = "background-color:#fdd">      stepDuration = std::numeric_limits&lt;TimePointType&gt;::infinity();</span>
    }
  }
  catch ( const boost::bad_lexical_cast &amp;e )
<span style = "background-color:#fdd">  {
    MITK_ERROR &lt;&lt; "Could not parse string as number: " &lt;&lt; e.what();
    return nullptr;
  }</span>

  // list of all geometries with their time steps
<span style = "background-color:#fdd">  std::multimap&lt;TimeStepType, BaseGeometry::Pointer&gt; allReadGeometries;</span>

<span style = "background-color:#fdd">  int indexForUnlabeledTimeStep(-1);
  for (auto *currentElement = timeGeometryElement-&gt;FirstChildElement(); currentElement != nullptr;
       currentElement = currentElement-&gt;NextSiblingElement())</span>
  {
    // different geometries could have been inside a ProportionalTimeGeometry.
    // By now, we only support Geometry3D
<span style = "background-color:#fdd">    std::string tagName = currentElement-&gt;Value();
    if (tagName == "Geometry3D")</span>
    {
<span style = "background-color:#fdd">      Geometry3D::Pointer restoredGeometry = Geometry3DToXML::FromXML(currentElement);
      if (restoredGeometry.IsNotNull())</span>
      {
<span style = "background-color:#fdd">        int timeStep(-1);
        if (tinyxml2::XML_SUCCESS != currentElement-&gt;QueryIntAttribute("TimeStep", &amp;timeStep))</span>
        {
<span style = "background-color:#fdd">          timeStep = indexForUnlabeledTimeStep--; // decrement index for next one
          MITK_WARN &lt;&lt; "Found &lt;Geometry3D&gt; without 'TimeStep' attribute in &lt;ProportionalTimeGeometry&gt;. No guarantees "</span>
                       "on order anymore.";
        }

<span style = "background-color:#fdd">        if (allReadGeometries.count(static_cast&lt;TimeStepType&gt;(timeStep)) &gt; 0)</span>
        {
<span style = "background-color:#fdd">          MITK_WARN &lt;&lt; "Found &lt;Geometry3D&gt; tags with identical 'TimeStep' attribute in &lt;ProportionalTimeGeometry&gt;. No "</span>
                       "guarantees on order anymore.";
        }

<span style = "background-color:#fdd">        allReadGeometries.insert(std::make_pair(static_cast&lt;TimeStepType&gt;(timeStep), restoredGeometry.GetPointer()));</span>
      }
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Found unsupported tag &lt;" &lt;&lt; tagName &lt;&lt; "&gt; inside &lt;ProportionalTimeGeometry&gt;. Ignoring.";</span>
    }
<span style = "background-color:#fdd">  }</span>

  // now add all BaseGeometries that were read to a new instance
  // of ProportionalTimeGeometry
<span style = "background-color:#fdd">  ProportionalTimeGeometry::Pointer newTimeGeometry = ProportionalTimeGeometry::New();
  newTimeGeometry-&gt;SetFirstTimePoint(firstTimePoint);
  newTimeGeometry-&gt;SetStepDuration(stepDuration);
  newTimeGeometry-&gt;ReserveSpaceForGeometries(allReadGeometries.size());</span>

<span style = "background-color:#fdd">  TimeStepType t(0);
  for (const auto &amp;entry : allReadGeometries)</span>
  {
    // We add items with newly assigned time steps.
    // This avoids great confusion when a file contains
    // bogus numbers.
<span style = "background-color:#fdd">    newTimeGeometry-&gt;SetTimeStepGeometry(entry.second, t++);
  }</span>

  // Need to re-calculate global bounding box.
  // This is neither stored in a file, nor done by SetTimeStepGeometry
<span style = "background-color:#fdd">  newTimeGeometry-&gt;UpdateBoundingBox();</span>

<span style = "background-color:#fdd">  return newTimeGeometry;
}</span></pre>
	</body>
</html>