<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageReadAccessor.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkImageReadAccessor.h"

#include "mitkImage.h"

mitk::ImageReadAccessor::ImageReadAccessor(ImageConstPointer image, const mitk::ImageDataItem *iDI, int OptionFlags)
<span style = "background-color:#fdd">  : ImageAccessorBase(image, iDI, OptionFlags), m_Image(image)
{
  if (!(OptionFlags &amp; ImageAccessorBase::IgnoreLock))</span>
  {
    try
    {
<span style = "background-color:#fdd">      OrganizeReadAccess();</span>
    }
    catch (...)
<span style = "background-color:#fdd">    {
      delete m_WaitLock;
      throw;
    }</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::ImageReadAccessor::ImageReadAccessor(ImagePointer image, const mitk::ImageDataItem *iDI, int OptionFlags)
<span style = "background-color:#fdd">  : ImageAccessorBase(image.GetPointer(), iDI, OptionFlags), m_Image(image.GetPointer())
{
  if (!(OptionFlags &amp; ImageAccessorBase::IgnoreLock))</span>
  {
    try
    {
<span style = "background-color:#fdd">      OrganizeReadAccess();</span>
    }
    catch (...)
<span style = "background-color:#fdd">    {
      delete m_WaitLock;
      throw;
    }</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::ImageReadAccessor::ImageReadAccessor(const mitk::Image *image, const ImageDataItem *iDI)
<span style = "background-color:#fdd">  : ImageAccessorBase(image, iDI, ImageAccessorBase::DefaultBehavior), m_Image(image)
{
  OrganizeReadAccess();
}</span>

mitk::ImageReadAccessor::~ImageReadAccessor()
<span style = "background-color:#fdd">{
  if (!(m_Options &amp; ImageAccessorBase::IgnoreLock))</span>
  {
    // Future work: In case of non-coherent memory, copied area needs to be deleted

<span style = "background-color:#fdd">    m_Image-&gt;m_ReadWriteLock.lock();</span>

    // delete self from list of ImageReadAccessors in Image
<span style = "background-color:#fdd">    auto it = std::find(m_Image-&gt;m_Readers.begin(), m_Image-&gt;m_Readers.end(), this);
    m_Image-&gt;m_Readers.erase(it);</span>

    // delete lock, if there are no waiting ImageAccessors
<span style = "background-color:#fdd">    if (m_WaitLock-&gt;m_WaiterCount &lt;= 0)</span>
    {
<span style = "background-color:#fdd">      m_WaitLock-&gt;m_Mutex.unlock();
      delete m_WaitLock;
    }</span>
    else
    {
<span style = "background-color:#fdd">      m_WaitLock-&gt;m_Mutex.unlock();</span>
    }

<span style = "background-color:#fdd">    m_Image-&gt;m_ReadWriteLock.unlock();
  }</span>
  else
  {
<span style = "background-color:#fdd">    delete m_WaitLock;</span>
  }
<span style = "background-color:#fdd">}</span>

const mitk::Image *mitk::ImageReadAccessor::GetImage() const
<span style = "background-color:#fdd">{
  return m_Image.GetPointer();
}</span>

void mitk::ImageReadAccessor::OrganizeReadAccess()
<span style = "background-color:#fdd">{
  m_Image-&gt;m_ReadWriteLock.lock();</span>

  // Check, if there is any Write-Access going on
<span style = "background-color:#fdd">  if (m_Image-&gt;m_Writers.size() &gt; 0)</span>
  {
    // Check for every WriteAccessors, if the Region of this ImageAccessors overlaps
    // make sure this iterator is not used, when m_ReadWriteLock is Unlocked!
<span style = "background-color:#fdd">    auto it = m_Image-&gt;m_Writers.begin();</span>

<span style = "background-color:#fdd">    for (; it != m_Image-&gt;m_Writers.end(); ++it)</span>
    {
<span style = "background-color:#fdd">      ImageAccessorBase *w = *it;
      if (Overlap(w))</span>
      {
        // An Overlap was detected. There are two possibilities to deal with this situation:
        // Throw an exception or wait for the WriteAccessor w until it is released and start again with the request
        // afterwards.
<span style = "background-color:#fdd">        if (!(m_Options &amp; ExceptionIfLocked))</span>
        {
<span style = "background-color:#fdd">          PreventRecursiveMutexLock(w);</span>

          // WAIT
<span style = "background-color:#fdd">          w-&gt;Increment();
          m_Image-&gt;m_ReadWriteLock.unlock();
          ImageAccessorBase::WaitForReleaseOf(w-&gt;m_WaitLock);</span>

          // after waiting for the WriteAccessor w, start this method again
<span style = "background-color:#fdd">          OrganizeReadAccess();
          return;
        }</span>
        else
        {
          // THROW EXCEPTION
<span style = "background-color:#fdd">          m_Image-&gt;m_ReadWriteLock.unlock();
          mitkThrowException(mitk::MemoryIsLockedException)</span>
            &lt;&lt; "The image part being ordered by the ImageAccessor is already in use and locked";
<span style = "background-color:#fdd">          return;</span>
        }
      } // if
<span style = "background-color:#fdd">    }   // for
  }     // if</span>

  // Now, we know, that there is no conflict with a Write-Access
  // Lock the Mutex in ImageAccessorBase, to make sure that every other ImageAccessor has to wait if it locks the mutex
<span style = "background-color:#fdd">  m_WaitLock-&gt;m_Mutex.lock();</span>

  // insert self into readers list in Image
<span style = "background-color:#fdd">  m_Image-&gt;m_Readers.push_back(this);</span>

  // printf("ReadAccess %d %d\n",(int) m_Image-&gt;m_Readers.size(),(int) m_Image-&gt;m_Writers.size());
  // fflush(0);
<span style = "background-color:#fdd">  m_Image-&gt;m_ReadWriteLock.unlock();
}</span></pre>
	</body>
</html>