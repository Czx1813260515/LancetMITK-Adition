<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPropertyKeyPath.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;algorithm&gt;
#include &lt;utility&gt;

#include &lt;mitkExceptionMacro.h&gt;
#include &lt;mitkPropertyKeyPath.h&gt;

#include &lt;regex&gt;

namespace mitk
{
<span style = "background-color:#fdd">  PropertyKeyPath::NodeInfo::NodeInfo() : type(NodeType::Invalid), selection(0){};</span>

  PropertyKeyPath::NodeInfo::NodeInfo(const ElementNameType &amp;name, NodeType type, ItemSelectionIndex index)
<span style = "background-color:#dfd">    : type(type), name(name), selection(index){};</span>

  bool PropertyKeyPath::NodeInfo::operator==(const NodeInfo &amp;right) const
<span style = "background-color:#fdd">  {
    if (this-&gt;name != right.name)
      return false;
    if (this-&gt;type != right.type)
      return false;
    if (this-&gt;selection != right.selection)
      return false;</span>

<span style = "background-color:#fdd">    return true;
  };</span>

  bool PropertyKeyPath::NodeInfo::Matches(const NodeInfo &amp;right) const
<span style = "background-color:#fdd">  {
    if (type == NodeType::Invalid || right.type == NodeType::Invalid)</span>
    {
<span style = "background-color:#fdd">      return false;
    }
    else if (type == NodeType::AnyElement || right.type == NodeType::AnyElement)</span>
    {
<span style = "background-color:#fdd">      return true;
    }
    else if (name == right.name)</span>
    {
<span style = "background-color:#fdd">      if (type == NodeType::Element &amp;&amp; right.type == NodeType::Element)</span>
      {
<span style = "background-color:#fdd">        return true;
      }
      else if (selection == right.selection || type == NodeType::AnySelection || right.type == NodeType::AnySelection)</span>
      {
<span style = "background-color:#fdd">        return true;</span>
      }
    }
<span style = "background-color:#fdd">    return false;
  };</span>

<span style = "background-color:#fdd">  bool PropertyKeyPath::IsEmpty() const { return m_NodeInfos.empty(); };</span>

  bool PropertyKeyPath::IsExplicit() const
<span style = "background-color:#dfd">  {
    for (const auto &amp;pos : m_NodeInfos)</span>
    {
<span style = "background-color:#dfd">      if ((pos.type == NodeInfo::NodeType::AnySelection) || (pos.type == NodeInfo::NodeType::AnyElement))</span>
      {
<span style = "background-color:#dfd">        return false;</span>
      }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    return true;
  };</span>

  bool PropertyKeyPath::HasItemSelectionWildcardsOnly() const
<span style = "background-color:#fdd">  {
    bool result = false;
    for (const auto &amp;pos : m_NodeInfos)</span>
    {
<span style = "background-color:#fdd">      if (pos.type == NodeInfo::NodeType::AnyElement)</span>
      {
<span style = "background-color:#fdd">        return false;</span>
      }
<span style = "background-color:#fdd">      result = result || pos.type == NodeInfo::NodeType::AnySelection;
    }</span>

<span style = "background-color:#fdd">    return result;
  };</span>

<span style = "background-color:#fdd">  PropertyKeyPath::PathIndexType PropertyKeyPath::GetSize() const { return m_NodeInfos.size(); }</span>

  PropertyKeyPath::PathIndexType PropertyKeyPath::AddNode(const NodeInfo &amp;newNode)
<span style = "background-color:#fdd">  {
    m_NodeInfos.push_back(newNode);
    return m_NodeInfos.size() - 1;
  };</span>

  const PropertyKeyPath::NodeInfo &amp;PropertyKeyPath::GetNode(const PathIndexType &amp;index) const
<span style = "background-color:#fdd">  {
    if (index &gt;= GetSize())</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(InvalidPathNodeException)</span>
        &lt;&lt; "Error. Cannot return info of path node. Node index is out of bounds. Index: " &lt;&lt; index
        &lt;&lt; "; Path: " &lt;&lt; PropertyKeyPathToPropertyName(*this);
    }

<span style = "background-color:#fdd">    return m_NodeInfos[index];
  };</span>

  PropertyKeyPath::NodeInfo &amp;PropertyKeyPath::GetNode(const PathIndexType &amp;index)
<span style = "background-color:#fdd">  {
    if (index &gt;= this-&gt;GetSize())</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(InvalidPathNodeException)</span>
        &lt;&lt; "Error. Cannot return info of path node. Node index is out of bounds. Index: " &lt;&lt; index
        &lt;&lt; "; Path: " &lt;&lt; PropertyKeyPathToPropertyName(*this);
    }

<span style = "background-color:#fdd">    return m_NodeInfos[index];
  };</span>

  const PropertyKeyPath::NodeInfo &amp;PropertyKeyPath::GetFirstNode() const
<span style = "background-color:#fdd">  {
    if (m_NodeInfos.empty())</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(InvalidPathNodeException) &lt;&lt; "Error. Cannot return first path node. Path is empty.";</span>
    }
<span style = "background-color:#fdd">    return this-&gt;GetNode(0);
  };</span>

  PropertyKeyPath::NodeInfo &amp;PropertyKeyPath::GetFirstNode()
<span style = "background-color:#fdd">  {
    if (m_NodeInfos.empty())</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(InvalidPathNodeException) &lt;&lt; "Error. Cannot return first path node. Path is empty.";</span>
    }
<span style = "background-color:#fdd">    return this-&gt;GetNode(0);
  };</span>

  const PropertyKeyPath::NodeInfo &amp;PropertyKeyPath::GetLastNode() const
<span style = "background-color:#fdd">  {
    if (m_NodeInfos.empty())</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(InvalidPathNodeException) &lt;&lt; "Error. Cannot return last path node. Path is empty.";</span>
    }
<span style = "background-color:#fdd">    return this-&gt;GetNode(GetSize() - 1);
  };</span>

  PropertyKeyPath::NodeInfo &amp;PropertyKeyPath::GetLastNode()
<span style = "background-color:#fdd">  {
    if (m_NodeInfos.empty())</span>
    {
<span style = "background-color:#fdd">      mitkThrowException(InvalidPathNodeException) &lt;&lt; "Error. Cannot return last path node. Path is empty.";</span>
    }
<span style = "background-color:#fdd">    return this-&gt;GetNode(GetSize() - 1);
  };</span>

<span style = "background-color:#dfd">  const PropertyKeyPath::NodeInfoVectorType &amp;PropertyKeyPath::GetNodes() const { return m_NodeInfos; };</span>

<span style = "background-color:#fdd">  bool PropertyKeyPath::operator==(const PropertyKeyPath &amp;path) const { return m_NodeInfos == path.m_NodeInfos; };</span>

  bool PropertyKeyPath::operator&lt;(const PropertyKeyPath &amp;right) const
<span style = "background-color:#fdd">  {
    auto rightIter = right.m_NodeInfos.cbegin();
    const auto rightEnd = right.m_NodeInfos.cend();
    for (const auto &amp;leftPos : m_NodeInfos)</span>
    {
<span style = "background-color:#fdd">      if (rightIter == rightEnd)</span>
      {
<span style = "background-color:#fdd">        return false;</span>
      }

<span style = "background-color:#fdd">      if (leftPos.name &lt; rightIter-&gt;name)</span>
      {
<span style = "background-color:#fdd">        return true;</span>
      }
<span style = "background-color:#fdd">      if (rightIter-&gt;name &lt; leftPos.name)</span>
      {
<span style = "background-color:#fdd">        return false;</span>
      }

<span style = "background-color:#fdd">      if (leftPos.type &lt; rightIter-&gt;type)</span>
      {
<span style = "background-color:#fdd">        return true;</span>
      }
<span style = "background-color:#fdd">      if (rightIter-&gt;type &lt; leftPos.type)</span>
      {
<span style = "background-color:#fdd">        return false;</span>
      }

<span style = "background-color:#fdd">      if (leftPos.selection &lt; rightIter-&gt;selection)</span>
      {
<span style = "background-color:#fdd">        return true;</span>
      }
<span style = "background-color:#fdd">      if (rightIter-&gt;selection &lt; leftPos.selection)</span>
      {
<span style = "background-color:#fdd">        return false;</span>
      }

<span style = "background-color:#fdd">      ++rightIter;
    }
    return rightIter != rightEnd;
  }</span>

  bool PropertyKeyPath::operator&gt;(const PropertyKeyPath &amp;right) const
<span style = "background-color:#fdd">  {
    auto rightIter = right.m_NodeInfos.cbegin();
    const auto rightEnd = right.m_NodeInfos.cend();
    for (const auto &amp;leftPos : m_NodeInfos)</span>
    {
<span style = "background-color:#fdd">      if (rightIter == rightEnd)
        return false;</span>

<span style = "background-color:#fdd">      if (leftPos.name &gt; rightIter-&gt;name)
        return true;
      if (rightIter-&gt;name &gt; leftPos.name)
        return false;</span>

<span style = "background-color:#fdd">      if (leftPos.type &gt; rightIter-&gt;type)
        return true;
      if (rightIter-&gt;type &gt; leftPos.type)
        return false;</span>

<span style = "background-color:#fdd">      if (leftPos.selection &gt; rightIter-&gt;selection)
        return true;
      if (rightIter-&gt;selection &gt; leftPos.selection)
        return false;
      ++rightIter;
    }
    return rightIter != rightEnd;
  }</span>

<span style = "background-color:#fdd">  bool PropertyKeyPath::operator&gt;=(const PropertyKeyPath &amp;right) const { return !(*this &lt; right); }</span>

<span style = "background-color:#fdd">  bool PropertyKeyPath::operator&lt;=(const PropertyKeyPath &amp;right) const { return !(*this &gt; right); }</span>

<span style = "background-color:#fdd">  bool PropertyKeyPath::Equals(const PropertyKeyPath &amp;path) const { return PropertyKeyPathsMatch(*this, path); };</span>

  PropertyKeyPath &amp;PropertyKeyPath::operator=(const PropertyKeyPath &amp;path)
<span style = "background-color:#dfd">  {
    if (this != &amp;path)</span>
    {
<span style = "background-color:#dfd">      m_NodeInfos = path.m_NodeInfos;</span>
    }

<span style = "background-color:#dfd">    return *this;
  };</span>

  PropertyKeyPath &amp;PropertyKeyPath::AddAnyElement()
<span style = "background-color:#dfd">  {
    m_NodeInfos.emplace_back("", NodeInfo::NodeType::AnyElement);
    return *this;
  };</span>

  PropertyKeyPath &amp;PropertyKeyPath::AddElement(const ElementNameType &amp;name)
<span style = "background-color:#dfd">  {
    m_NodeInfos.emplace_back(name, NodeInfo::NodeType::Element);
    return *this;
  };</span>

  PropertyKeyPath &amp;PropertyKeyPath::AddAnySelection(const ElementNameType &amp;name)
<span style = "background-color:#fdd">  {
    m_NodeInfos.emplace_back(name, NodeInfo::NodeType::AnySelection);
    return *this;
  };</span>

  PropertyKeyPath &amp;PropertyKeyPath::AddSelection(const ElementNameType &amp;name, ItemSelectionIndex index)
<span style = "background-color:#fdd">  {
    m_NodeInfos.emplace_back(name, NodeInfo::NodeType::ElementSelection, index);
    return *this;
  };</span>

<span style = "background-color:#dfd">  PropertyKeyPath::PropertyKeyPath() { this-&gt;Reset(); };</span>

<span style = "background-color:#dfd">  PropertyKeyPath::PropertyKeyPath(const PropertyKeyPath &amp;path) { *this = path; };</span>

  PropertyKeyPath::PropertyKeyPath(const std::initializer_list&lt; ElementNameType &gt;&amp; list)
<span style = "background-color:#dfd">  {
    this-&gt;Reset();
    for (const auto&amp; name : list)</span>
    {
<span style = "background-color:#dfd">      this-&gt;AddElement(name);
    }
  }</span>

<span style = "background-color:#dfd">  PropertyKeyPath::~PropertyKeyPath(){};</span>

<span style = "background-color:#dfd">  void PropertyKeyPath::Reset() { m_NodeInfos.clear(); };</span>

  bool PropertyKeyPath::PropertyKeyPathsMatch(const PropertyKeyPath &amp;left, const PropertyKeyPath &amp;right)
<span style = "background-color:#fdd">  {
    auto leftPos = left.GetNodes().cbegin();
    auto rightPos = right.GetNodes().cbegin();
    auto leftEnd = left.GetNodes().cend();
    auto rightEnd = right.GetNodes().cend();</span>

<span style = "background-color:#fdd">    while (leftPos != leftEnd &amp;&amp; rightPos != rightEnd)</span>
    {
<span style = "background-color:#fdd">      if (!leftPos-&gt;Matches(*rightPos))</span>
      {
<span style = "background-color:#fdd">        break;</span>
      }
<span style = "background-color:#fdd">      ++leftPos;
      ++rightPos;
    }</span>

<span style = "background-color:#fdd">    if (leftPos == leftEnd &amp;&amp; rightPos == rightEnd)</span>
    {
<span style = "background-color:#fdd">      return true;
    }</span>
    else
    {
<span style = "background-color:#fdd">      return false;</span>
    }
<span style = "background-color:#fdd">  };</span>

  std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const PropertyKeyPath &amp;value)
<span style = "background-color:#fdd">  {
    os &lt;&lt; PropertyKeyPathToPropertyName(value);
    return os;
  };</span>

  std::string PropertyKeyPathToPropertyRegEx(const PropertyKeyPath &amp;tagPath)
<span style = "background-color:#dfd">  {
    std::ostringstream nameStream;</span>

<span style = "background-color:#dfd">    PropertyKeyPath::PathIndexType i = 0;</span>

<span style = "background-color:#dfd">    for (const auto &amp;node : tagPath.GetNodes())</span>
    {
<span style = "background-color:#dfd">      if (i)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; "\\.";</span>
      }
<span style = "background-color:#dfd">      ++i;</span>

<span style = "background-color:#dfd">      if (node.type == PropertyKeyPath::NodeInfo::NodeType::AnyElement)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; "([a-zA-Z0-9- ]+)";
      }
      else if (node.type != PropertyKeyPath::NodeInfo::NodeType::Invalid)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; node.name;</span>

<span style = "background-color:#dfd">        if (node.type == PropertyKeyPath::NodeInfo::NodeType::ElementSelection)</span>
        {
<span style = "background-color:#fdd">          nameStream &lt;&lt; "\\.\\[" &lt;&lt; node.selection &lt;&lt; "\\]";
        }</span>
<span style = "background-color:#dfd">        else if (node.type == PropertyKeyPath::NodeInfo::NodeType::AnySelection)</span>
        {
<span style = "background-color:#fdd">          nameStream &lt;&lt; "\\.\\[(\\d*)\\]";</span>
        }
<span style = "background-color:#dfd">      }</span>
      else
      {
<span style = "background-color:#fdd">        nameStream &lt;&lt; "INVALIDNODE";</span>
      }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    return nameStream.str();
  };</span>

  std::string PropertyKeyPathToPersistenceKeyRegEx(const PropertyKeyPath &amp;tagPath)
<span style = "background-color:#dfd">  {
    std::ostringstream nameStream;</span>

<span style = "background-color:#dfd">    PropertyKeyPath::PathIndexType i = 0;</span>

<span style = "background-color:#dfd">    for (const auto &amp;node : tagPath.GetNodes())</span>
    {
<span style = "background-color:#dfd">      if (i)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; "_";</span>
      }
<span style = "background-color:#dfd">      ++i;</span>

<span style = "background-color:#dfd">      if (node.type == PropertyKeyPath::NodeInfo::NodeType::AnyElement)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; "([a-zA-Z0-9- ]+)";
      }
      else if (node.type != PropertyKeyPath::NodeInfo::NodeType::Invalid)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; node.name;</span>

<span style = "background-color:#dfd">        if (node.type == PropertyKeyPath::NodeInfo::NodeType::ElementSelection)</span>
        {
<span style = "background-color:#fdd">          nameStream &lt;&lt; "_\\[" &lt;&lt; node.selection &lt;&lt; "\\]";
        }</span>
<span style = "background-color:#dfd">        else if (node.type == PropertyKeyPath::NodeInfo::NodeType::AnySelection)</span>
        {
<span style = "background-color:#fdd">          nameStream &lt;&lt; "_\\[(\\d*)\\]";</span>
        }
<span style = "background-color:#dfd">      }</span>
      else
      {
<span style = "background-color:#fdd">        nameStream &lt;&lt; "INVALIDNODE";</span>
      }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    return nameStream.str();
  };</span>

  std::string PropertyKeyPathToPersistenceKeyTemplate(const PropertyKeyPath &amp;tagPath)
<span style = "background-color:#dfd">  {
    std::ostringstream nameStream;</span>

<span style = "background-color:#dfd">    int captureGroup = 1;</span>

<span style = "background-color:#dfd">    PropertyKeyPath::PathIndexType i = 0;</span>

<span style = "background-color:#dfd">    for (const auto &amp;node : tagPath.GetNodes())</span>
    {
<span style = "background-color:#dfd">      if (i)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; "_";</span>
      }
<span style = "background-color:#dfd">      ++i;</span>

<span style = "background-color:#dfd">      if (node.type == PropertyKeyPath::NodeInfo::NodeType::AnyElement)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; "$" &lt;&lt; captureGroup++;
      }
      else if (node.type != PropertyKeyPath::NodeInfo::NodeType::Invalid)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; node.name;</span>

<span style = "background-color:#dfd">        if (node.type == PropertyKeyPath::NodeInfo::NodeType::ElementSelection)</span>
        {
<span style = "background-color:#fdd">          nameStream &lt;&lt; "_[" &lt;&lt; node.selection &lt;&lt; "]";
        }</span>
<span style = "background-color:#dfd">        else if (node.type == PropertyKeyPath::NodeInfo::NodeType::AnySelection)</span>
        {
<span style = "background-color:#fdd">          nameStream &lt;&lt; "_[$" &lt;&lt; captureGroup++ &lt;&lt; "]";</span>
        }
<span style = "background-color:#dfd">      }</span>
      else
      {
<span style = "background-color:#fdd">        nameStream &lt;&lt; "INVALID_NODE";</span>
      }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    return nameStream.str();
  };</span>

  std::string PropertyKeyPathToPersistenceNameTemplate(const PropertyKeyPath &amp;tagPath)
<span style = "background-color:#dfd">  {
    std::ostringstream nameStream;</span>

<span style = "background-color:#dfd">    int captureGroup = 1;</span>

<span style = "background-color:#dfd">    PropertyKeyPath::PathIndexType i = 0;</span>

<span style = "background-color:#dfd">    for (const auto &amp;node : tagPath.GetNodes())</span>
    {
<span style = "background-color:#dfd">      if (i)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; ".";</span>
      }
<span style = "background-color:#dfd">      ++i;</span>

<span style = "background-color:#dfd">      if (node.type == PropertyKeyPath::NodeInfo::NodeType::AnyElement)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; "$" &lt;&lt; captureGroup++;
      }
      else if (node.type != PropertyKeyPath::NodeInfo::NodeType::Invalid)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; node.name;</span>

<span style = "background-color:#dfd">        if (node.type == PropertyKeyPath::NodeInfo::NodeType::ElementSelection)</span>
        {
<span style = "background-color:#fdd">          nameStream &lt;&lt; ".[" &lt;&lt; node.selection &lt;&lt; "]";
        }</span>
<span style = "background-color:#dfd">        else if (node.type == PropertyKeyPath::NodeInfo::NodeType::AnySelection)</span>
        {
<span style = "background-color:#fdd">          nameStream &lt;&lt; ".[$" &lt;&lt; captureGroup++ &lt;&lt; "]";</span>
        }
<span style = "background-color:#dfd">      }</span>
      else
      {
<span style = "background-color:#fdd">        nameStream &lt;&lt; "INVALID_NODE";</span>
      }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    return nameStream.str();
  };</span>

  PropertyKeyPath PropertyNameToPropertyKeyPath(const std::string &amp;propertyName)
<span style = "background-color:#fdd">  {
    PropertyKeyPath result;</span>

<span style = "background-color:#fdd">    std::regex reg_element("([a-zA-Z0-9- ]+)");
    std::regex reg_anySelection("\\[\\*\\]");
    std::regex reg_Selection("\\[(\\d+)\\]");</span>

<span style = "background-color:#fdd">    std::istringstream f(propertyName);
    std::string subStr;</span>

<span style = "background-color:#fdd">    PropertyKeyPath::ElementNameType name = "";</span>

<span style = "background-color:#fdd">    while (getline(f, subStr, '.'))</span>
    {
<span style = "background-color:#fdd">      if (subStr == "*")</span>
      {
<span style = "background-color:#fdd">        if (!name.empty())</span>
        {
<span style = "background-color:#fdd">          result.AddElement(name);
          name.clear();</span>
        }

<span style = "background-color:#fdd">        result.AddAnyElement();
      }</span>
      else
      {
<span style = "background-color:#fdd">        std::smatch sm;
        if (std::regex_match(subStr, sm, reg_anySelection))</span>
        {
<span style = "background-color:#fdd">          if (!name.empty())</span>
          {
<span style = "background-color:#fdd">            result.AddAnySelection(name);
            name.clear();
          }</span>
          else
          { // invalid path
<span style = "background-color:#fdd">            return PropertyKeyPath();</span>
          }
<span style = "background-color:#fdd">        }
        else if (std::regex_match(subStr, sm, reg_Selection))</span>
        {
<span style = "background-color:#fdd">          if (!name.empty())</span>
          {
<span style = "background-color:#fdd">            result.AddSelection(name, std::stoi(sm[1]));
            name.clear();
          }</span>
          else
          { // invalid path
<span style = "background-color:#fdd">            return PropertyKeyPath();</span>
          }
<span style = "background-color:#fdd">        }
        else if (std::regex_match(subStr, sm, reg_element))</span>
        {
<span style = "background-color:#fdd">          if (!name.empty())</span>
          { // store the last element and start the next
<span style = "background-color:#fdd">            result.AddElement(name);</span>
          }
<span style = "background-color:#fdd">          name = sm[1];
        }</span>
        else
        {
<span style = "background-color:#fdd">          return PropertyKeyPath();</span>
        }
<span style = "background-color:#fdd">      }
    }</span>

<span style = "background-color:#fdd">    if (!name.empty())</span>
    { // add last element
<span style = "background-color:#fdd">      result.AddElement(name);</span>
    }

<span style = "background-color:#fdd">    return result;
  };</span>

  std::string PropertyKeyPathToPropertyName(const mitk::PropertyKeyPath &amp;tagPath)
<span style = "background-color:#dfd">  {
    std::ostringstream nameStream;</span>

<span style = "background-color:#dfd">    PropertyKeyPath::PathIndexType i = 0;</span>

<span style = "background-color:#dfd">    for (const auto &amp;node : tagPath.GetNodes())</span>
    {
<span style = "background-color:#dfd">      if (i)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; ".";</span>
      }
<span style = "background-color:#dfd">      ++i;</span>

<span style = "background-color:#dfd">      if (node.type == PropertyKeyPath::NodeInfo::NodeType::AnyElement)</span>
      {
<span style = "background-color:#fdd">        nameStream &lt;&lt; "*";
      }</span>
<span style = "background-color:#dfd">      else if (node.type != PropertyKeyPath::NodeInfo::NodeType::Invalid)</span>
      {
<span style = "background-color:#dfd">        nameStream &lt;&lt; node.name;</span>

<span style = "background-color:#dfd">        if (node.type == PropertyKeyPath::NodeInfo::NodeType::ElementSelection)</span>
        {
<span style = "background-color:#fdd">          nameStream &lt;&lt; ".[" &lt;&lt; node.selection &lt;&lt; "]";
        }</span>
<span style = "background-color:#dfd">        else if (node.type == PropertyKeyPath::NodeInfo::NodeType::AnySelection)</span>
        {
<span style = "background-color:#fdd">          nameStream &lt;&lt; ".[*]";</span>
        }
<span style = "background-color:#dfd">      }</span>
      else
      {
<span style = "background-color:#fdd">        nameStream &lt;&lt; "INVALID_NODE";</span>
      }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    return nameStream.str();
  };</span>
} // namespace mitk</pre>
	</body>
</html>