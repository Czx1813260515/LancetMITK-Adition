<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkLookupTable.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkLookupTable.h"
#include &lt;itkProcessObject.h&gt;

#include &lt;vtkColorTransferFunction.h&gt;
#include &lt;vtkPiecewiseFunction.h&gt;

#include &lt;Colortables/HotIron.h&gt;
#include &lt;Colortables/Jet.h&gt;
#include &lt;Colortables/Inferno.h&gt;
#include &lt;Colortables/Viridis.h&gt;
#include &lt;Colortables/Plasma.h&gt;
#include &lt;Colortables/Magma.h&gt;
#include &lt;Colortables/Multilabel.h&gt;
#include &lt;Colortables/PET20.h&gt;
#include &lt;Colortables/PETColor.h&gt;
#include &lt;mitkLookupTableProperty.h&gt;

<span style = "background-color:#dfd">std::vector&lt;std::string&gt; mitk::LookupTable::typenameList = {</span>
  "Grayscale",
  "Inverse Grayscale",
  "Hot Iron",
  "Jet",
  "Jet Transparent",
  "Plasma",
  "Inferno",
  "Viridis",
  "Magma",
  "Legacy Binary",
  "Legacy Rainbow Color",
  "Multilabel",
  "PET Color",
  "PET 20"
<span style = "background-color:#dfd">};</span>

mitk::LookupTable::LookupTable()
<span style = "background-color:#fdd">  : m_LookupTable(vtkSmartPointer&lt;vtkLookupTable&gt;::New())
  , m_Window(0.0)
  , m_Level(0.0)
  , m_Opacity(1.0)
  , m_Type(mitk::LookupTable::GRAYSCALE)
{
  this-&gt;BuildGrayScaleLookupTable();
}</span>

mitk::LookupTable::LookupTable(const LookupTable &amp;other)
<span style = "background-color:#fdd">  : itk::DataObject()
  , m_LookupTable(vtkSmartPointer&lt;vtkLookupTable&gt;::New())
  , m_Window(other.m_Window)
  , m_Level(other.m_Level)
  , m_Opacity(other.m_Opacity)
  , m_Type(other.m_Type)
{
  m_LookupTable-&gt;DeepCopy(other.m_LookupTable);
}</span>

mitk::LookupTable::~LookupTable()
<span style = "background-color:#fdd">{
}</span>

void mitk::LookupTable::SetVtkLookupTable(vtkSmartPointer&lt;vtkLookupTable&gt; lut)
<span style = "background-color:#fdd">{
  if ((!lut) || (m_LookupTable == lut))</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span>

void mitk::LookupTable::SetType(const mitk::LookupTable::LookupTableType type)
<span style = "background-color:#fdd">{
  if (m_Type == type)
    return;</span>

<span style = "background-color:#fdd">  switch (type)</span>
  {
    case (mitk::LookupTable::GRAYSCALE):
<span style = "background-color:#fdd">      this-&gt;BuildGrayScaleLookupTable();
      break;</span>
    case (mitk::LookupTable::INVERSE_GRAYSCALE):
<span style = "background-color:#fdd">      this-&gt;BuildInverseGrayScaleLookupTable();
      break;</span>
    case (mitk::LookupTable::HOT_IRON):
<span style = "background-color:#fdd">      this-&gt;BuildHotIronLookupTable();
      break;</span>
    case (mitk::LookupTable::JET):
<span style = "background-color:#fdd">      this-&gt;BuildJetLookupTable();
      break;</span>
    case (mitk::LookupTable::JET_TRANSPARENT):
<span style = "background-color:#fdd">      this-&gt;BuildJetLookupTable(true);
      break;</span>
    case (mitk::LookupTable::PLASMA):
<span style = "background-color:#fdd">	    this-&gt;BuildPlasmaLookupTable();
	    break;</span>
	  case (mitk::LookupTable::INFERNO):
<span style = "background-color:#fdd">	    this-&gt;BuildInfernoLookupTable();
      break;</span>
	  case (mitk::LookupTable::VIRIDIS):
<span style = "background-color:#fdd">	    this-&gt;BuildViridisLookupTable();
	    break;</span>
    case (mitk::LookupTable::MAGMA):
<span style = "background-color:#fdd">      this-&gt;BuildMagmaLookupTable();
      break;</span>
    case (mitk::LookupTable::LEGACY_BINARY):
<span style = "background-color:#fdd">      this-&gt;BuildLegacyBinaryLookupTable();
      break;</span>
    case (mitk::LookupTable::MULTILABEL):
<span style = "background-color:#fdd">      this-&gt;BuildMultiLabelLookupTable();
      break;</span>
    case (mitk::LookupTable::PET_COLOR):
<span style = "background-color:#fdd">      this-&gt;BuildPETColorLookupTable();
      break;</span>
    case (mitk::LookupTable::PET_20):
<span style = "background-color:#fdd">      this-&gt;BuildPET20LookupTable();
      break;</span>
    case (mitk::LookupTable::LEGACY_RAINBOW_COLOR):
<span style = "background-color:#fdd">      this-&gt;BuildLegacyRainbowColorLookupTable();
      break;</span>
    default:
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "non-existing colormap";
      return;</span>
  }

<span style = "background-color:#fdd">  m_Type = type;
}</span>

void mitk::LookupTable::SetType(const std::string &amp;typeName)
<span style = "background-color:#fdd">{
  for (size_t i = 0; i &lt; typenameList.size(); ++i)</span>
  {
<span style = "background-color:#fdd">    if (typenameList.at(i) == typeName)</span>
    {
<span style = "background-color:#fdd">      this-&gt;SetType(static_cast&lt;mitk::LookupTable::LookupTableType&gt;(i));</span>
    }
<span style = "background-color:#fdd">  }
}</span>

mitk::LookupTable::LookupTableType mitk::LookupTable::GetActiveType() const
<span style = "background-color:#fdd">{
  return m_Type;
}</span>

std::string mitk::LookupTable::GetActiveTypeAsString() const
<span style = "background-color:#fdd">{
  if (static_cast&lt;unsigned int&gt;(m_Type) &lt; typenameList.size())</span>
  {
<span style = "background-color:#fdd">    return typenameList.at(m_Type);</span>
  }

<span style = "background-color:#fdd">  return "";
}</span>

void mitk::LookupTable::ChangeOpacityForAll(float opacity)
<span style = "background-color:#fdd">{
  int noValues = m_LookupTable-&gt;GetNumberOfTableValues();</span>

  double rgba[4];

<span style = "background-color:#fdd">  for (int i = 0; i &lt; noValues; i++)</span>
  {
<span style = "background-color:#fdd">    m_LookupTable-&gt;GetTableValue(i, rgba);
    rgba[3] = opacity;
    m_LookupTable-&gt;SetTableValue(i, rgba);
  }
  this-&gt;Modified(); // need to call modified, since LookupTableProperty seems to be unchanged so no widget-update is</span>
                    // executed
<span style = "background-color:#fdd">}</span>

void mitk::LookupTable::ChangeOpacity(int index, float opacity)
<span style = "background-color:#fdd">{
  int noValues = m_LookupTable-&gt;GetNumberOfTableValues();
  if (index &gt; noValues)</span>
  {
<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "could not change opacity. index exceed size of lut ... " &lt;&lt; std::endl;
    return;</span>
  }

  double rgba[4];

<span style = "background-color:#fdd">  m_LookupTable-&gt;GetTableValue(index, rgba);
  rgba[3] = opacity;
  m_LookupTable-&gt;SetTableValue(index, rgba);</span>

<span style = "background-color:#fdd">  this-&gt;Modified(); // need to call modified, since LookupTableProperty seems to be unchanged so no widget-update is</span>
                    // executed
<span style = "background-color:#fdd">}</span>

void mitk::LookupTable::GetColor(double value, double rgb[3])
<span style = "background-color:#fdd">{
  this-&gt;GetVtkLookupTable()-&gt;GetColor(value, rgb);
}</span>

void mitk::LookupTable::GetTableValue(int index, double rgba[4])
<span style = "background-color:#fdd">{
  this-&gt;GetVtkLookupTable()-&gt;GetTableValue(index, rgba);
}</span>

void mitk::LookupTable::SetTableValue(int index, double rgba[4])
<span style = "background-color:#fdd">{
  this-&gt;GetVtkLookupTable()-&gt;SetTableValue(index, rgba);
}</span>

vtkSmartPointer&lt;vtkLookupTable&gt; mitk::LookupTable::GetVtkLookupTable() const
<span style = "background-color:#fdd">{
  return m_LookupTable;
}</span>

mitk::LookupTable::RawLookupTableType *mitk::LookupTable::GetRawLookupTable() const
<span style = "background-color:#fdd">{
  return m_LookupTable-&gt;GetPointer(0);
}</span>

bool mitk::LookupTable::operator==(const mitk::LookupTable &amp;other) const
<span style = "background-color:#fdd">{
  if (m_LookupTable == other.GetVtkLookupTable())
    return true;
  vtkLookupTable *olut = other.GetVtkLookupTable();
  if (olut == nullptr)
    return false;</span>

<span style = "background-color:#fdd">  bool equal = (m_LookupTable-&gt;GetNumberOfColors() == olut-&gt;GetNumberOfColors()) &amp;&amp;</span>
               (m_LookupTable-&gt;GetTableRange()[0] == olut-&gt;GetTableRange()[0]) &amp;&amp;
               (m_LookupTable-&gt;GetTableRange()[1] == olut-&gt;GetTableRange()[1]) &amp;&amp;
               (m_LookupTable-&gt;GetHueRange()[0] == olut-&gt;GetHueRange()[0]) &amp;&amp;
               (m_LookupTable-&gt;GetHueRange()[1] == olut-&gt;GetHueRange()[1]) &amp;&amp;
               (m_LookupTable-&gt;GetSaturationRange()[0] == olut-&gt;GetSaturationRange()[0]) &amp;&amp;
               (m_LookupTable-&gt;GetSaturationRange()[1] == olut-&gt;GetSaturationRange()[1]) &amp;&amp;
               (m_LookupTable-&gt;GetValueRange()[0] == olut-&gt;GetValueRange()[0]) &amp;&amp;
               (m_LookupTable-&gt;GetValueRange()[1] == olut-&gt;GetValueRange()[1]) &amp;&amp;
               (m_LookupTable-&gt;GetAlphaRange()[0] == olut-&gt;GetAlphaRange()[0]) &amp;&amp;
               (m_LookupTable-&gt;GetAlphaRange()[1] == olut-&gt;GetAlphaRange()[1]) &amp;&amp;
               (m_LookupTable-&gt;GetRamp() == olut-&gt;GetRamp()) &amp;&amp; (m_LookupTable-&gt;GetScale() == olut-&gt;GetScale()) &amp;&amp;
               (m_LookupTable-&gt;GetAlpha() == olut-&gt;GetAlpha()) &amp;&amp;
               (m_LookupTable-&gt;GetTable()-&gt;GetNumberOfTuples() == olut-&gt;GetTable()-&gt;GetNumberOfTuples());
<span style = "background-color:#fdd">  if (equal == false)
    return false;
  for (vtkIdType i = 0; i &lt; m_LookupTable-&gt;GetNumberOfTableValues(); i++)</span>
  {
<span style = "background-color:#fdd">    bool tvequal = (m_LookupTable-&gt;GetTableValue(i)[0] == olut-&gt;GetTableValue(i)[0]) &amp;&amp;</span>
                   (m_LookupTable-&gt;GetTableValue(i)[1] == olut-&gt;GetTableValue(i)[1]) &amp;&amp;
                   (m_LookupTable-&gt;GetTableValue(i)[2] == olut-&gt;GetTableValue(i)[2]) &amp;&amp;
                   (m_LookupTable-&gt;GetTableValue(i)[3] == olut-&gt;GetTableValue(i)[3]);
<span style = "background-color:#fdd">    if (tvequal == false)
      return false;
  }
  return true;
}</span>

bool mitk::LookupTable::operator!=(const mitk::LookupTable &amp;other) const
<span style = "background-color:#fdd">{
  return !(*this == other);
}</span>

mitk::LookupTable &amp;mitk::LookupTable::operator=(const mitk::LookupTable &amp;LookupTable)
<span style = "background-color:#fdd">{
  if (this == &amp;LookupTable)</span>
  {
<span style = "background-color:#fdd">    return *this;
  }</span>
  else
  {
<span style = "background-color:#fdd">    m_LookupTable = LookupTable.GetVtkLookupTable();
    return *this;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::LookupTable::UpdateOutputInformation()
<span style = "background-color:#fdd">{
  if (this-&gt;GetSource())</span>
  {
<span style = "background-color:#fdd">    this-&gt;GetSource()-&gt;UpdateOutputInformation();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::LookupTable::SetRequestedRegionToLargestPossibleRegion()
<span style = "background-color:#fdd">{
}</span>

bool mitk::LookupTable::RequestedRegionIsOutsideOfTheBufferedRegion()
<span style = "background-color:#fdd">{
  return false;
}</span>

bool mitk::LookupTable::VerifyRequestedRegion()
<span style = "background-color:#fdd">{</span>
  // normally we should check if the requested region lies within the
  // largest possible region. Since for lookup-tables we assume, that the
  // requested region is always the largest possible region, we can always
  // return true!
<span style = "background-color:#fdd">  return true;
}</span>

void mitk::LookupTable::SetRequestedRegion(const itk::DataObject *)
<span style = "background-color:#fdd">{</span>
  // not implemented, since we always want to have the RequestedRegion
  // to be set to LargestPossibleRegion
<span style = "background-color:#fdd">}</span>

vtkSmartPointer&lt;vtkColorTransferFunction&gt; mitk::LookupTable::CreateColorTransferFunction()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkColorTransferFunction&gt; colorFunction = vtkSmartPointer&lt;vtkColorTransferFunction&gt;::New();</span>

<span style = "background-color:#fdd">  mitk::LookupTable::RawLookupTableType *rawLookupTable = this-&gt;GetRawLookupTable();
  int num_of_values = m_LookupTable-&gt;GetNumberOfTableValues();</span>

<span style = "background-color:#fdd">  auto cols = new double[3 * num_of_values];
  double *colsHead = cols;</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; num_of_values; ++i)</span>
  {
<span style = "background-color:#fdd">    *cols = static_cast&lt;double&gt;(*rawLookupTable) / 255.0;
    ++cols;
    ++rawLookupTable;
    *cols = static_cast&lt;double&gt;(*rawLookupTable) / 255.0;
    ++cols;
    ++rawLookupTable;
    *cols = static_cast&lt;double&gt;(*rawLookupTable) / 255.0;
    ++cols;
    ++rawLookupTable;
    ++rawLookupTable;
  }
  colorFunction-&gt;BuildFunctionFromTable(</span>
    m_LookupTable-&gt;GetTableRange()[0], m_LookupTable-&gt;GetTableRange()[1], num_of_values, colsHead);
<span style = "background-color:#fdd">  return colorFunction;
}</span>

void mitk::LookupTable::CreateColorTransferFunction(vtkColorTransferFunction *&amp;colorFunction)
<span style = "background-color:#fdd">{
  colorFunction = this-&gt;CreateColorTransferFunction();
}</span>

vtkSmartPointer&lt;vtkPiecewiseFunction&gt; mitk::LookupTable::CreateOpacityTransferFunction()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkPiecewiseFunction&gt; opacityFunction = vtkSmartPointer&lt;vtkPiecewiseFunction&gt;::New();</span>

<span style = "background-color:#fdd">  mitk::LookupTable::RawLookupTableType *rgba = this-&gt;GetRawLookupTable();
  int num_of_values = m_LookupTable-&gt;GetNumberOfTableValues();</span>

<span style = "background-color:#fdd">  auto alphas = new double[num_of_values];
  double *alphasHead = alphas;</span>

<span style = "background-color:#fdd">  rgba += 3;
  for (int i = 0; i &lt; num_of_values; ++i)</span>
  {
<span style = "background-color:#fdd">    *alphas = static_cast&lt;double&gt;(*rgba) / 255.0;
    ++alphas;
    rgba += 4;
  }</span>

<span style = "background-color:#fdd">  opacityFunction-&gt;BuildFunctionFromTable(</span>
    m_LookupTable-&gt;GetTableRange()[0], m_LookupTable-&gt;GetTableRange()[1], num_of_values, alphasHead);
<span style = "background-color:#fdd">  return opacityFunction;
}</span>

void mitk::LookupTable::CreateOpacityTransferFunction(vtkPiecewiseFunction *&amp;opacityFunction)
<span style = "background-color:#fdd">{
  opacityFunction = this-&gt;CreateOpacityTransferFunction();
}</span>

vtkSmartPointer&lt;vtkPiecewiseFunction&gt; mitk::LookupTable::CreateGradientTransferFunction()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkPiecewiseFunction&gt; gradientFunction = vtkSmartPointer&lt;vtkPiecewiseFunction&gt;::New();</span>

<span style = "background-color:#fdd">  mitk::LookupTable::RawLookupTableType *rgba = this-&gt;GetRawLookupTable();
  int num_of_values = m_LookupTable-&gt;GetNumberOfTableValues();</span>

<span style = "background-color:#fdd">  auto alphas = new double[num_of_values];
  double *alphasHead = alphas;</span>

<span style = "background-color:#fdd">  rgba += 3;
  for (int i = 0; i &lt; num_of_values; ++i)</span>
  {
<span style = "background-color:#fdd">    *alphas = static_cast&lt;double&gt;(*rgba) / 255.0;
    ++alphas;
    rgba += 4;
  }</span>

<span style = "background-color:#fdd">  gradientFunction-&gt;BuildFunctionFromTable(</span>
    m_LookupTable-&gt;GetTableRange()[0], m_LookupTable-&gt;GetTableRange()[1], num_of_values, alphasHead);
<span style = "background-color:#fdd">  return gradientFunction;
}</span>

void mitk::LookupTable::CreateGradientTransferFunction(vtkPiecewiseFunction *&amp;gradientFunction)
<span style = "background-color:#fdd">{
  gradientFunction = this-&gt;CreateGradientTransferFunction();
}</span>

void mitk::LookupTable::PrintSelf(std::ostream &amp;os, itk::Indent indent) const
<span style = "background-color:#fdd">{
  os &lt;&lt; indent;
  m_LookupTable-&gt;PrintHeader(os, vtkIndent());
}</span>

itk::LightObject::Pointer mitk::LookupTable::InternalClone() const
<span style = "background-color:#fdd">{
  itk::LightObject::Pointer result(new Self(*this));
  result-&gt;UnRegister();
  return result;
}</span>

void mitk::LookupTable::BuildGrayScaleLookupTable()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
  lut-&gt;SetRampToLinear();
  lut-&gt;SetSaturationRange(0.0, 0.0);
  lut-&gt;SetHueRange(0.0, 0.0);
  lut-&gt;SetValueRange(0.0, 1.0);
  lut-&gt;Build();</span>

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildLegacyBinaryLookupTable()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
  lut-&gt;SetRampToLinear();
  lut-&gt;SetSaturationRange(0.0, 0.0);
  lut-&gt;SetHueRange(0.0, 0.0);
  lut-&gt;SetValueRange(0.0, 1.0);
  lut-&gt;Build();
  lut-&gt;SetTableValue(0, 0.0, 0.0, 0.0, 0.0);</span>

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildInverseGrayScaleLookupTable()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
  lut-&gt;SetTableRange(0, 1);
  lut-&gt;SetSaturationRange(0, 0);
  lut-&gt;SetHueRange(0, 0);
  lut-&gt;SetValueRange(1, 0);
  lut-&gt;SetAlphaRange(1, 0);
  lut-&gt;Build();</span>

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildHotIronLookupTable()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
  lut-&gt;SetNumberOfTableValues(256);
  lut-&gt;Build();</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; 256; i++)</span>
  {
<span style = "background-color:#fdd">    lut-&gt;SetTableValue(</span>
      i, (double)HotIron[i][0] / 255.0, (double)HotIron[i][1] / 255.0, (double)HotIron[i][2] / 255.0, 1.0);
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildJetLookupTable(bool transparent)
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
  lut-&gt;SetNumberOfTableValues(256);
  lut-&gt;Build();
  int i = 0;</span>

<span style = "background-color:#fdd">  if (transparent)</span>
  {
    // Lowest intensity is transparent
<span style = "background-color:#fdd">    lut-&gt;SetTableValue(0, (double)Jet[0][0] / 255.0, (double)Jet[0][1] / 255.0, (double)Jet[0][2] / 255.0, 0.0);
    i = 1;</span>
  }

<span style = "background-color:#fdd">  for (; i &lt; 256; i++)</span>
  {
<span style = "background-color:#fdd">    lut-&gt;SetTableValue(i, (double)Jet[i][0] / 255.0, (double)Jet[i][1] / 255.0, (double)Jet[i][2] / 255.0, 1.0);
  }</span>

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildPETColorLookupTable()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
  lut-&gt;SetNumberOfTableValues(256);
  lut-&gt;SetTableRange((m_Level - m_Window / 2.0), (m_Level + m_Window / 2.0));
  lut-&gt;Build();</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; 256; i++)</span>
  {
<span style = "background-color:#fdd">    lut-&gt;SetTableValue(</span>
      i, (double)PETColor[i][0] / 255.0, (double)PETColor[i][1] / 255.0, (double)PETColor[i][2] / 255.0, 1.0);
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildPET20LookupTable()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
  lut-&gt;SetNumberOfTableValues(256);
  lut-&gt;SetTableRange((m_Level - m_Window / 2.0), (m_Level + m_Window / 2.0));
  lut-&gt;Build();</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; 256; i++)</span>
  {
<span style = "background-color:#fdd">    lut-&gt;SetTableValue(i, (double)PET20[i][0] / 255.0, (double)PET20[i][1] / 255.0, (double)PET20[i][2] / 255.0, 1.0);
  }</span>

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildMultiLabelLookupTable()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
  lut-&gt;SetNumberOfTableValues(65536);
  lut-&gt;SetTableRange(0, 65536);
  lut-&gt;Build();</span>

<span style = "background-color:#fdd">  lut-&gt;SetTableValue(0, 0.0, 0.0, 0.0, 0.0); // background</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; 25; i++)</span>
  {
<span style = "background-color:#fdd">    lut-&gt;SetTableValue(i+1, Multilabel[i][0], Multilabel[i][1], Multilabel[i][2], 0.4);
  }</span>

<span style = "background-color:#fdd">  for (int i = 26; i &lt; 65536; i++)</span>
  {
<span style = "background-color:#fdd">    if (i % 12 == 0)
      lut-&gt;SetTableValue(i, 1.0, 0.0, 0.0, 0.4);
    else if (i % 12 == 1)
      lut-&gt;SetTableValue(i, 0.0, 1.0, 0.0, 0.4);
    else if (i % 12 == 2)
      lut-&gt;SetTableValue(i, 0.0, 0.0, 1.0, 0.4);
    else if (i % 12 == 3)
      lut-&gt;SetTableValue(i, 1.0, 1.0, 0.0, 0.4);
    else if (i % 12 == 4)
      lut-&gt;SetTableValue(i, 0.0, 1.0, 1.0, 0.4);
    else if (i % 12 == 5)
      lut-&gt;SetTableValue(i, 1.0, 0.0, 1.0, 0.4);
    else if (i % 12 == 6)
      lut-&gt;SetTableValue(i, 1.0, 0.5, 0.0, 0.4);
    else if (i % 12 == 7)
      lut-&gt;SetTableValue(i, 0.0, 1.0, 0.5, 0.4);
    else if (i % 12 == 8)
      lut-&gt;SetTableValue(i, 0.5, 0.0, 1.0, 0.4);
    else if (i % 12 == 9)
      lut-&gt;SetTableValue(i, 1.0, 1.0, 0.5, 0.4);
    else if (i % 12 == 10)
      lut-&gt;SetTableValue(i, 0.5, 1.0, 1.0, 0.4);
    else if (i % 12 == 11)
      lut-&gt;SetTableValue(i, 1.0, 0.5, 1.0, 0.4);
  }</span>

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildLegacyRainbowColorLookupTable()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
  lut-&gt;SetRampToLinear();
  lut-&gt;SetHueRange(0.6667, 0.0);
  lut-&gt;SetTableRange(0.0, 20.0);
  lut-&gt;Build();</span>

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildPlasmaLookupTable()
<span style = "background-color:#fdd">{
	vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
	lut-&gt;SetNumberOfTableValues(256);
	lut-&gt;Build();</span>

<span style = "background-color:#fdd">	for (int i = 0; i &lt; 256; i++)</span>
	{
<span style = "background-color:#fdd">		lut-&gt;SetTableValue(</span>
			i, (double)Plasma[i][0] / 255.0, (double)Plasma[i][1] / 255.0, (double)Plasma[i][2] / 255.0, 1.0);
<span style = "background-color:#fdd">	}</span>

<span style = "background-color:#fdd">	m_LookupTable = lut;
	this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildInfernoLookupTable()
<span style = "background-color:#fdd">{
	vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
	lut-&gt;SetNumberOfTableValues(256);
	lut-&gt;Build();</span>

<span style = "background-color:#fdd">	for (int i = 0; i &lt; 256; i++)</span>
	{
<span style = "background-color:#fdd">		lut-&gt;SetTableValue(</span>
			i, (double)Inferno[i][0] / 255.0, (double)Inferno[i][1] / 255.0, (double)Inferno[i][2] / 255.0, 1.0);
<span style = "background-color:#fdd">	}</span>

<span style = "background-color:#fdd">	m_LookupTable = lut;
	this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildViridisLookupTable()
<span style = "background-color:#fdd">{
	vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
	lut-&gt;SetNumberOfTableValues(256);
	lut-&gt;Build();</span>

<span style = "background-color:#fdd">	for (int i = 0; i &lt; 256; i++)</span>
	{
<span style = "background-color:#fdd">		lut-&gt;SetTableValue(</span>
			i, (double)Viridis[i][0] / 255.0, (double)Viridis[i][1] / 255.0, (double)Viridis[i][2] / 255.0, 1.0);
<span style = "background-color:#fdd">	}</span>

<span style = "background-color:#fdd">	m_LookupTable = lut;
	this-&gt;Modified();
}</span>

void mitk::LookupTable::BuildMagmaLookupTable()
<span style = "background-color:#fdd">{
  vtkSmartPointer&lt;vtkLookupTable&gt; lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
  lut-&gt;SetNumberOfTableValues(256);
  lut-&gt;Build();</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; 256; i++)</span>
  {
<span style = "background-color:#fdd">    lut-&gt;SetTableValue(</span>
      i, (double)Magma[i][0] / 255.0, (double)Magma[i][1] / 255.0, (double)Magma[i][2] / 255.0, 1.0);
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  m_LookupTable = lut;
  this-&gt;Modified();
}</span></pre>
	</body>
</html>