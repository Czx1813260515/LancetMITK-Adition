<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDisplayActionEventFunctions.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkDisplayActionEventFunctions.h"

// mitk core
#include "mitkBaseRenderer.h"
#include "mitkCameraController.h"
#include "mitkDisplayActionEvents.h"
#include "mitkInteractionPositionEvent.h"
#include "mitkLevelWindow.h"
#include "mitkLevelWindowProperty.h"
#include "mitkNodePredicateDataType.h"

//////////////////////////////////////////////////////////////////////////
// STANDARD FUNCTIONS
//////////////////////////////////////////////////////////////////////////
mitk::StdFunctionCommand::ActionFunction mitk::DisplayActionEventFunctions::MoveSenderCameraAction()
<span style = "background-color:#fdd">{
  mitk::StdFunctionCommand::ActionFunction actionFunction = [](const itk::EventObject&amp; displayInteractorEvent)
  {
    if (DisplayMoveEvent().CheckEvent(&amp;displayInteractorEvent))</span>
    {
<span style = "background-color:#fdd">      const DisplayMoveEvent* displayActionEvent = dynamic_cast&lt;const DisplayMoveEvent*&gt;(&amp;displayInteractorEvent);
      const BaseRenderer::Pointer sendingRenderer = displayActionEvent-&gt;GetSender();
      if (nullptr == sendingRenderer)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

<span style = "background-color:#fdd">      sendingRenderer-&gt;GetCameraController()-&gt;MoveBy(displayActionEvent-&gt;GetMoveVector());
      RenderingManager::GetInstance()-&gt;RequestUpdate(sendingRenderer-&gt;GetRenderWindow());
    }
  };</span>

<span style = "background-color:#fdd">  return actionFunction;
}</span>

mitk::StdFunctionCommand::ActionFunction mitk::DisplayActionEventFunctions::SetCrosshairAction()
<span style = "background-color:#fdd">{
  auto actionFunction = [](const itk::EventObject&amp; displayInteractorEvent)
  {
    if (DisplaySetCrosshairEvent().CheckEvent(&amp;displayInteractorEvent))</span>
    {
<span style = "background-color:#fdd">      const DisplaySetCrosshairEvent* displayActionEvent = dynamic_cast&lt;const DisplaySetCrosshairEvent*&gt;(&amp;displayInteractorEvent);
      const BaseRenderer::Pointer sendingRenderer = displayActionEvent-&gt;GetSender();
      if (nullptr == sendingRenderer)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

<span style = "background-color:#fdd">      BaseRenderer::GetInstance(sendingRenderer-&gt;GetRenderWindow())-&gt;GetSliceNavigationController()-&gt;SelectSliceByPoint(displayActionEvent-&gt;GetPosition());
    }
  };</span>

<span style = "background-color:#fdd">  return actionFunction;
}</span>

mitk::StdFunctionCommand::ActionFunction mitk::DisplayActionEventFunctions::ZoomSenderCameraAction()
<span style = "background-color:#fdd">{
  auto actionFunction = [](const itk::EventObject&amp; displayInteractorEvent)
  {
    if (DisplayZoomEvent().CheckEvent(&amp;displayInteractorEvent))</span>
    {
<span style = "background-color:#fdd">      const DisplayZoomEvent* displayActionEvent = dynamic_cast&lt;const DisplayZoomEvent*&gt;(&amp;displayInteractorEvent);
      const BaseRenderer::Pointer sendingRenderer = displayActionEvent-&gt;GetSender();
      if (nullptr == sendingRenderer)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

<span style = "background-color:#fdd">      if (1.0 != displayActionEvent-&gt;GetZoomFactor())</span>
      {
<span style = "background-color:#fdd">        sendingRenderer-&gt;GetCameraController()-&gt;Zoom(displayActionEvent-&gt;GetZoomFactor(), displayActionEvent-&gt;GetStartCoordinate());
        RenderingManager::GetInstance()-&gt;RequestUpdate(sendingRenderer-&gt;GetRenderWindow());</span>
      }
<span style = "background-color:#fdd">    }
  };</span>

<span style = "background-color:#fdd">  return actionFunction;
}</span>

mitk::StdFunctionCommand::ActionFunction mitk::DisplayActionEventFunctions::ScrollSliceStepperAction()
<span style = "background-color:#fdd">{
  auto actionFunction = [](const itk::EventObject&amp; displayInteractorEvent)
  {
    if (DisplayScrollEvent().CheckEvent(&amp;displayInteractorEvent))</span>
    {
<span style = "background-color:#fdd">      const DisplayScrollEvent* displayActionEvent = dynamic_cast&lt;const DisplayScrollEvent*&gt;(&amp;displayInteractorEvent);
      const BaseRenderer::Pointer sendingRenderer = displayActionEvent-&gt;GetSender();
      if (nullptr == sendingRenderer)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

<span style = "background-color:#fdd">      mitk::SliceNavigationController* sliceNavigationController = sendingRenderer-&gt;GetSliceNavigationController();
      if (nullptr == sliceNavigationController)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }
<span style = "background-color:#fdd">      if (sliceNavigationController-&gt;GetSliceLocked())</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }
<span style = "background-color:#fdd">      mitk::Stepper* sliceStepper = sliceNavigationController-&gt;GetSlice();
      if (nullptr == sliceStepper)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

      // if only a single slice image was loaded, scrolling will affect the time steps
<span style = "background-color:#fdd">      if (sliceStepper-&gt;GetSteps() &lt;= 1)</span>
      {
<span style = "background-color:#fdd">        sliceStepper = sliceNavigationController-&gt;GetTime();</span>
      }

<span style = "background-color:#fdd">      sliceStepper-&gt;SetAutoRepeat(displayActionEvent-&gt;GetAutoRepeat());
      sliceStepper-&gt;MoveSlice(displayActionEvent-&gt;GetSliceDelta());
    }
  };</span>

<span style = "background-color:#fdd">  return actionFunction;
}</span>

mitk::StdFunctionCommand::ActionFunction mitk::DisplayActionEventFunctions::SetLevelWindowAction()
<span style = "background-color:#fdd">{
  auto actionFunction = [](const itk::EventObject&amp; displayInteractorEvent)
  {
    if (DisplaySetLevelWindowEvent().CheckEvent(&amp;displayInteractorEvent))</span>
    {
<span style = "background-color:#fdd">      const DisplaySetLevelWindowEvent* displayActionEvent = dynamic_cast&lt;const DisplaySetLevelWindowEvent*&gt;(&amp;displayInteractorEvent);
      const BaseRenderer::Pointer sendingRenderer = displayActionEvent-&gt;GetSender();
      if (nullptr == sendingRenderer)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

      // get the the topmost visible image of the sending renderer
<span style = "background-color:#fdd">      DataStorage::Pointer storage = sendingRenderer-&gt;GetDataStorage();
      DataStorage::SetOfObjects::ConstPointer allImageNodes = storage-&gt;GetSubset(NodePredicateDataType::New("Image"));
      Point3D worldposition;
      const auto* positionEvent = dynamic_cast&lt;const InteractionPositionEvent*&gt;(displayActionEvent-&gt;GetInteractionEvent());
      sendingRenderer-&gt;DisplayToWorld(positionEvent-&gt;GetPointerPositionOnScreen(), worldposition);
      auto globalCurrentTimePoint = sendingRenderer-&gt;GetTime();
      DataNode::Pointer node = FindTopmostVisibleNode(allImageNodes, worldposition, globalCurrentTimePoint, sendingRenderer);
      if (node.IsNull())</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

<span style = "background-color:#fdd">      LevelWindow levelWindow = LevelWindow();
      node-&gt;GetLevelWindow(levelWindow);
      ScalarType level = levelWindow.GetLevel();
      ScalarType window = levelWindow.GetWindow();</span>

<span style = "background-color:#fdd">      level += displayActionEvent-&gt;GetLevel();
      window += displayActionEvent-&gt;GetWindow();</span>

<span style = "background-color:#fdd">      levelWindow.SetLevelWindow(level, window);
      auto* levelWindowProperty = dynamic_cast&lt;LevelWindowProperty*&gt;(node-&gt;GetProperty("levelwindow"));
      if (nullptr != levelWindowProperty)</span>
      {
<span style = "background-color:#fdd">        levelWindowProperty-&gt;SetLevelWindow(levelWindow);
        RenderingManager::GetInstance()-&gt;RequestUpdateAll();</span>
      }
<span style = "background-color:#fdd">    }
  };</span>

<span style = "background-color:#fdd">  return actionFunction;
}</span>

//////////////////////////////////////////////////////////////////////////
// SYNCHRONIZED FUNCTIONS
//////////////////////////////////////////////////////////////////////////
mitk::StdFunctionCommand::ActionFunction mitk::DisplayActionEventFunctions::MoveCameraSynchronizedAction()
<span style = "background-color:#fdd">{
  mitk::StdFunctionCommand::ActionFunction actionFunction = [](const itk::EventObject&amp; displayInteractorEvent)
  {
    if (DisplayMoveEvent().CheckEvent(&amp;displayInteractorEvent))</span>
    {
<span style = "background-color:#fdd">      const DisplayMoveEvent* displayActionEvent = dynamic_cast&lt;const DisplayMoveEvent*&gt;(&amp;displayInteractorEvent);
      const BaseRenderer::Pointer sendingRenderer = displayActionEvent-&gt;GetSender();
      if (nullptr == sendingRenderer)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

<span style = "background-color:#fdd">      auto renderingManager = RenderingManager::GetInstance();
      auto allRenderWindows = renderingManager-&gt;GetAllRegisteredRenderWindows();
      for (auto renderWindow : allRenderWindows)</span>
      {
<span style = "background-color:#fdd">        if (BaseRenderer::GetInstance(renderWindow)-&gt;GetMapperID() == BaseRenderer::Standard2D)</span>
        {
<span style = "background-color:#fdd">          BaseRenderer* currentRenderer = BaseRenderer::GetInstance(renderWindow);
          currentRenderer-&gt;GetCameraController()-&gt;MoveBy(displayActionEvent-&gt;GetMoveVector());
          renderingManager-&gt;RequestUpdate(currentRenderer-&gt;GetRenderWindow());</span>
        }
<span style = "background-color:#fdd">      }
    }
  };</span>

<span style = "background-color:#fdd">  return actionFunction;
}</span>

mitk::StdFunctionCommand::ActionFunction mitk::DisplayActionEventFunctions::SetCrosshairSynchronizedAction()
<span style = "background-color:#fdd">{
  auto actionFunction = [](const itk::EventObject&amp; displayInteractorEvent)
  {
    if (DisplaySetCrosshairEvent().CheckEvent(&amp;displayInteractorEvent))</span>
    {
<span style = "background-color:#fdd">      const DisplaySetCrosshairEvent* displayActionEvent = dynamic_cast&lt;const DisplaySetCrosshairEvent*&gt;(&amp;displayInteractorEvent);
      const BaseRenderer::Pointer sendingRenderer = displayActionEvent-&gt;GetSender();
      if (nullptr == sendingRenderer)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

<span style = "background-color:#fdd">      auto allRenderWindows = RenderingManager::GetInstance()-&gt;GetAllRegisteredRenderWindows();
      for (auto renderWindow : allRenderWindows)</span>
      {
<span style = "background-color:#fdd">        if (BaseRenderer::GetInstance(renderWindow)-&gt;GetMapperID() == BaseRenderer::Standard2D)</span>
        {
<span style = "background-color:#fdd">          BaseRenderer::GetInstance(renderWindow)-&gt;GetSliceNavigationController()-&gt;SelectSliceByPoint(displayActionEvent-&gt;GetPosition());</span>
        }
<span style = "background-color:#fdd">      }
    }
  };</span>

<span style = "background-color:#fdd">  return actionFunction;
}</span>

mitk::StdFunctionCommand::ActionFunction mitk::DisplayActionEventFunctions::ZoomCameraSynchronizedAction()
<span style = "background-color:#fdd">{
  auto actionFunction = [](const itk::EventObject&amp; displayInteractorEvent)
  {
    if (DisplayZoomEvent().CheckEvent(&amp;displayInteractorEvent))</span>
    {
<span style = "background-color:#fdd">      const DisplayZoomEvent* displayActionEvent = dynamic_cast&lt;const DisplayZoomEvent*&gt;(&amp;displayInteractorEvent);
      const BaseRenderer::Pointer sendingRenderer = displayActionEvent-&gt;GetSender();
      if (nullptr == sendingRenderer)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

<span style = "background-color:#fdd">      if (1.0 != displayActionEvent-&gt;GetZoomFactor())</span>
      {
<span style = "background-color:#fdd">        auto renderingManager = RenderingManager::GetInstance();
        auto allRenderWindows = renderingManager-&gt;GetAllRegisteredRenderWindows();
        for (auto renderWindow : allRenderWindows)</span>
        {
<span style = "background-color:#fdd">          if (BaseRenderer::GetInstance(renderWindow)-&gt;GetMapperID() == BaseRenderer::Standard2D)</span>
          {
<span style = "background-color:#fdd">            BaseRenderer* currentRenderer = BaseRenderer::GetInstance(renderWindow);
            currentRenderer-&gt;GetCameraController()-&gt;Zoom(displayActionEvent-&gt;GetZoomFactor(), displayActionEvent-&gt;GetStartCoordinate());
            renderingManager-&gt;RequestUpdate(currentRenderer-&gt;GetRenderWindow());</span>
          }
<span style = "background-color:#fdd">        }
      }
    }
  };</span>

<span style = "background-color:#fdd">  return actionFunction;
}</span>

mitk::StdFunctionCommand::ActionFunction mitk::DisplayActionEventFunctions::ScrollSliceStepperSynchronizedAction()
<span style = "background-color:#fdd">{
  auto actionFunction = [](const itk::EventObject&amp; displayInteractorEvent)
  {
    if (DisplayScrollEvent().CheckEvent(&amp;displayInteractorEvent))</span>
    {
<span style = "background-color:#fdd">      const DisplayScrollEvent* displayActionEvent = dynamic_cast&lt;const DisplayScrollEvent*&gt;(&amp;displayInteractorEvent);
      const BaseRenderer::Pointer sendingRenderer = displayActionEvent-&gt;GetSender();
      if (nullptr == sendingRenderer)</span>
      {
<span style = "background-color:#fdd">        return;</span>
      }

<span style = "background-color:#fdd">      auto allRenderWindows = RenderingManager::GetInstance()-&gt;GetAllRegisteredRenderWindows();
      for (auto renderWindow : allRenderWindows)</span>
      {
<span style = "background-color:#fdd">        if (BaseRenderer::GetInstance(renderWindow)-&gt;GetMapperID() == BaseRenderer::Standard2D)</span>
        {
<span style = "background-color:#fdd">          mitk::SliceNavigationController* sliceNavigationController = BaseRenderer::GetInstance(renderWindow)-&gt;GetSliceNavigationController();
          if (nullptr == sliceNavigationController)</span>
          {
<span style = "background-color:#fdd">            return;</span>
          }
<span style = "background-color:#fdd">          if (sliceNavigationController-&gt;GetSliceLocked())</span>
          {
<span style = "background-color:#fdd">            return;</span>
          }
<span style = "background-color:#fdd">          mitk::Stepper* sliceStepper = sliceNavigationController-&gt;GetSlice();
          if (nullptr == sliceStepper)</span>
          {
<span style = "background-color:#fdd">            return;</span>
          }

          // if only a single slice image was loaded, scrolling will affect the time steps
<span style = "background-color:#fdd">          if (sliceStepper-&gt;GetSteps() &lt;= 1)</span>
          {
<span style = "background-color:#fdd">            sliceStepper = sliceNavigationController-&gt;GetTime();</span>
          }

<span style = "background-color:#fdd">          sliceStepper-&gt;SetAutoRepeat(displayActionEvent-&gt;GetAutoRepeat());
          sliceStepper-&gt;MoveSlice(displayActionEvent-&gt;GetSliceDelta());</span>
        }
<span style = "background-color:#fdd">      }
    }
  };</span>

<span style = "background-color:#fdd">  return actionFunction;
}</span></pre>
	</body>
</html>