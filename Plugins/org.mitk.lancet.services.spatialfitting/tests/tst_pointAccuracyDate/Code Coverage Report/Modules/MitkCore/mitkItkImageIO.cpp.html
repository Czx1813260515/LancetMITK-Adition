<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkItkImageIO.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkItkImageIO.h"

#include &lt;mitkArbitraryTimeGeometry.h&gt;
#include &lt;mitkCoreServices.h&gt;
#include &lt;mitkCustomMimeType.h&gt;
#include &lt;mitkIOMimeTypes.h&gt;
#include &lt;mitkIPropertyPersistence.h&gt;
#include &lt;mitkImage.h&gt;
#include &lt;mitkImageReadAccessor.h&gt;
#include &lt;mitkLocaleSwitch.h&gt;
#include &lt;mitkUIDManipulator.h&gt;

#include &lt;itkImage.h&gt;
#include &lt;itkImageFileReader.h&gt;
#include &lt;itkImageIOFactory.h&gt;
#include &lt;itkImageIORegion.h&gt;
#include &lt;itkMetaDataObject.h&gt;

#include &lt;algorithm&gt;

namespace mitk
{
  const char *const PROPERTY_NAME_TIMEGEOMETRY_TYPE = "org.mitk.timegeometry.type";
  const char *const PROPERTY_NAME_TIMEGEOMETRY_TIMEPOINTS = "org.mitk.timegeometry.timepoints";
  const char *const PROPERTY_KEY_TIMEGEOMETRY_TYPE = "org_mitk_timegeometry_type";
  const char *const PROPERTY_KEY_TIMEGEOMETRY_TIMEPOINTS = "org_mitk_timegeometry_timepoints";
  const char* const PROPERTY_KEY_UID = "org_mitk_uid";

  ItkImageIO::ItkImageIO(const ItkImageIO &amp;other)
<span style = "background-color:#fdd">    : AbstractFileIO(other), m_ImageIO(dynamic_cast&lt;itk::ImageIOBase *&gt;(other.m_ImageIO-&gt;Clone().GetPointer()))
  {
    this-&gt;InitializeDefaultMetaDataKeys();
  }</span>

  std::vector&lt;std::string&gt; ItkImageIO::FixUpImageIOExtensions(const std::string &amp;imageIOName)
<span style = "background-color:#dfd">  {
    std::vector&lt;std::string&gt; extensions;</span>
    // Try to fix-up some known ITK image IO classes
<span style = "background-color:#dfd">    if (imageIOName == "GiplImageIO")</span>
    {
<span style = "background-color:#dfd">      extensions.push_back("gipl");
      extensions.push_back("gipl.gz");
    }
    else if (imageIOName == "GDCMImageIO")</span>
    {
<span style = "background-color:#fdd">      extensions.push_back("gdcm");
      extensions.push_back("dcm");
      extensions.push_back("DCM");
      extensions.push_back("dc3");
      extensions.push_back("DC3");
      extensions.push_back("ima");
      extensions.push_back("img");
    }</span>
<span style = "background-color:#dfd">    else if (imageIOName == "PNGImageIO")</span>
    {
<span style = "background-color:#fdd">      extensions.push_back("png");
      extensions.push_back("PNG");
    }</span>
<span style = "background-color:#dfd">    else if (imageIOName == "StimulateImageIO")</span>
    {
<span style = "background-color:#fdd">      extensions.push_back("spr");
    }</span>
<span style = "background-color:#dfd">    else if (imageIOName == "HDF5ImageIO")</span>
    {
<span style = "background-color:#fdd">      extensions.push_back("hdf");
      extensions.push_back("h4");
      extensions.push_back("hdf4");
      extensions.push_back("h5");
      extensions.push_back("hdf5");
      extensions.push_back("he4");
      extensions.push_back("he5");
      extensions.push_back("hd5");
    }</span>
<span style = "background-color:#dfd">    else if ("GE4ImageIO" == imageIOName || "GE5ImageIO" == imageIOName || "Bruker2dseqImageIO" == imageIOName)</span>
    {
<span style = "background-color:#dfd">      extensions.push_back("");</span>
    }

<span style = "background-color:#dfd">    if (!extensions.empty())</span>
    {
<span style = "background-color:#dfd">      MITK_DEBUG &lt;&lt; "Fixing up known extensions for " &lt;&lt; imageIOName;</span>
    }

<span style = "background-color:#dfd">    return extensions;
  }</span>

  void ItkImageIO::FixUpCustomMimeTypeName(const std::string &amp;imageIOName, CustomMimeType &amp;customMimeType)
<span style = "background-color:#dfd">  {
    if ("GE4ImageIO" == imageIOName)</span>
    {
<span style = "background-color:#dfd">      customMimeType.SetName(this-&gt;AbstractFileReader::GetMimeTypePrefix() + "ge4");
    }
    else if ("GE5ImageIO" == imageIOName)</span>
    {
<span style = "background-color:#dfd">      customMimeType.SetName(this-&gt;AbstractFileReader::GetMimeTypePrefix() + "ge5");
    }
    else if ("Bruker2dseqImageIO" == imageIOName)</span>
    {
<span style = "background-color:#dfd">      customMimeType.SetName(this-&gt;AbstractFileReader::GetMimeTypePrefix() + "bruker2dseq");</span>
    }
<span style = "background-color:#dfd">  }</span>

  ItkImageIO::ItkImageIO(itk::ImageIOBase::Pointer imageIO)
<span style = "background-color:#dfd">    : AbstractFileIO(Image::GetStaticNameOfClass()), m_ImageIO(imageIO)
  {
    if (m_ImageIO.IsNull())</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "ITK ImageIOBase argument must not be nullptr";</span>
    }

<span style = "background-color:#dfd">    this-&gt;AbstractFileReader::SetMimeTypePrefix(IOMimeTypes::DEFAULT_BASE_NAME() + ".image.");
    this-&gt;InitializeDefaultMetaDataKeys();</span>

<span style = "background-color:#dfd">    std::vector&lt;std::string&gt; readExtensions = m_ImageIO-&gt;GetSupportedReadExtensions();</span>

<span style = "background-color:#dfd">    if (readExtensions.empty())</span>
    {
<span style = "background-color:#dfd">      std::string imageIOName = m_ImageIO-&gt;GetNameOfClass();
      MITK_DEBUG &lt;&lt; "ITK ImageIOBase " &lt;&lt; imageIOName &lt;&lt; " does not provide read extensions";
      readExtensions = FixUpImageIOExtensions(imageIOName);
    }</span>

<span style = "background-color:#dfd">    CustomMimeType customReaderMimeType;
    customReaderMimeType.SetCategory("Images");
    for (std::vector&lt;std::string&gt;::const_iterator iter = readExtensions.begin(), endIter = readExtensions.end();
         iter != endIter;
         ++iter)</span>
    {
<span style = "background-color:#dfd">      std::string extension = *iter;
      if (!extension.empty() &amp;&amp; extension[0] == '.')</span>
      {
<span style = "background-color:#dfd">        extension.assign(iter-&gt;begin() + 1, iter-&gt;end());</span>
      }
<span style = "background-color:#dfd">      customReaderMimeType.AddExtension(extension);
    }</span>

<span style = "background-color:#dfd">    auto extensions = customReaderMimeType.GetExtensions();
    if (extensions.empty() || (extensions.size() == 1 &amp;&amp; extensions[0].empty()))</span>
    {
<span style = "background-color:#dfd">      std::string imageIOName = m_ImageIO-&gt;GetNameOfClass();
      FixUpCustomMimeTypeName(imageIOName, customReaderMimeType);
    }</span>

<span style = "background-color:#dfd">    this-&gt;AbstractFileReader::SetMimeType(customReaderMimeType);</span>

<span style = "background-color:#dfd">    std::vector&lt;std::string&gt; writeExtensions = imageIO-&gt;GetSupportedWriteExtensions();
    if (writeExtensions.empty())</span>
    {
<span style = "background-color:#dfd">      std::string imageIOName = imageIO-&gt;GetNameOfClass();
      MITK_DEBUG &lt;&lt; "ITK ImageIOBase " &lt;&lt; imageIOName &lt;&lt; " does not provide write extensions";
      writeExtensions = FixUpImageIOExtensions(imageIOName);
    }</span>

<span style = "background-color:#dfd">    if (writeExtensions != readExtensions)</span>
    {
<span style = "background-color:#dfd">      CustomMimeType customWriterMimeType;
      customWriterMimeType.SetCategory("Images");
      for (std::vector&lt;std::string&gt;::const_iterator iter = writeExtensions.begin(), endIter = writeExtensions.end();
           iter != endIter;
           ++iter)</span>
      {
<span style = "background-color:#dfd">        std::string extension = *iter;
        if (!extension.empty() &amp;&amp; extension[0] == '.')</span>
        {
<span style = "background-color:#dfd">          extension.assign(iter-&gt;begin() + 1, iter-&gt;end());</span>
        }
<span style = "background-color:#dfd">        customWriterMimeType.AddExtension(extension);
      }</span>

<span style = "background-color:#dfd">      auto extensions = customWriterMimeType.GetExtensions();
      if (extensions.empty() || (extensions.size() == 1 &amp;&amp; extensions[0].empty()))</span>
      {
<span style = "background-color:#fdd">        std::string imageIOName = m_ImageIO-&gt;GetNameOfClass();
        FixUpCustomMimeTypeName(imageIOName, customWriterMimeType);
      }</span>

<span style = "background-color:#dfd">      this-&gt;AbstractFileWriter::SetMimeType(customWriterMimeType);
    }</span>

<span style = "background-color:#dfd">    std::string description = std::string("ITK ") + imageIO-&gt;GetNameOfClass();
    this-&gt;SetReaderDescription(description);
    this-&gt;SetWriterDescription(description);</span>

<span style = "background-color:#dfd">    this-&gt;RegisterService();
  }</span>

  ItkImageIO::ItkImageIO(const CustomMimeType &amp;mimeType, itk::ImageIOBase::Pointer imageIO, int rank)
<span style = "background-color:#dfd">    : AbstractFileIO(Image::GetStaticNameOfClass(), mimeType, std::string("ITK ") + imageIO-&gt;GetNameOfClass()),
      m_ImageIO(imageIO)
  {
    if (m_ImageIO.IsNull())</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "ITK ImageIOBase argument must not be nullptr";</span>
    }

<span style = "background-color:#dfd">    this-&gt;AbstractFileReader::SetMimeTypePrefix(IOMimeTypes::DEFAULT_BASE_NAME() + ".image.");
    this-&gt;InitializeDefaultMetaDataKeys();</span>

<span style = "background-color:#dfd">    if (rank)</span>
    {
<span style = "background-color:#fdd">      this-&gt;AbstractFileReader::SetRanking(rank);
      this-&gt;AbstractFileWriter::SetRanking(rank);</span>
    }

<span style = "background-color:#dfd">    this-&gt;RegisterService();
  }</span>

  std::vector&lt;TimePointType&gt; ConvertMetaDataObjectToTimePointList(const itk::MetaDataObjectBase* data)
<span style = "background-color:#fdd">  {
    const auto* timeGeometryTimeData =</span>
      dynamic_cast&lt;const itk::MetaDataObject&lt;std::string&gt;*&gt;(data);
<span style = "background-color:#fdd">    std::vector&lt;TimePointType&gt; result;</span>

<span style = "background-color:#fdd">    if (timeGeometryTimeData)</span>
    {
<span style = "background-color:#fdd">      std::string dataStr = timeGeometryTimeData-&gt;GetMetaDataObjectValue();
      std::stringstream stream(dataStr);</span>
      TimePointType tp;
<span style = "background-color:#fdd">      while (stream &gt;&gt; tp)</span>
      {
<span style = "background-color:#fdd">        result.push_back(tp);
      }
    }</span>

<span style = "background-color:#fdd">    return result;
  };</span>

  itk::MetaDataObjectBase::Pointer ConvertTimePointListToMetaDataObject(const mitk::TimeGeometry* timeGeometry)
<span style = "background-color:#fdd">  {
    std::stringstream stream;
    stream &lt;&lt; timeGeometry-&gt;GetTimeBounds(0)[0];
    const auto maxTimePoints = timeGeometry-&gt;CountTimeSteps();
    for (TimeStepType pos = 0; pos &lt; maxTimePoints; ++pos)</span>
    {
<span style = "background-color:#fdd">      auto timeBounds = timeGeometry-&gt;GetTimeBounds(pos);</span>

      ///////////////////////////////////////
      // Workarround T27883. See https://phabricator.mitk.org/T27883#219473 for more details.
      // This workarround should be removed as soon as T28262 is solved!
<span style = "background-color:#fdd">      if (pos + 1 == maxTimePoints &amp;&amp; timeBounds[0]==timeBounds[1])</span>
      {
<span style = "background-color:#fdd">        timeBounds[1] = timeBounds[0] + 1.;</span>
      }
      // End of workarround for T27883
      //////////////////////////////////////

<span style = "background-color:#fdd">      stream &lt;&lt; " " &lt;&lt; timeBounds[1];
    }
    auto result = itk::MetaDataObject&lt;std::string&gt;::New();
    result-&gt;SetMetaDataObjectValue(stream.str());
    return result.GetPointer();
  };</span>

  std::vector&lt;BaseData::Pointer&gt; ItkImageIO::DoRead()
<span style = "background-color:#fdd">  {
    std::vector&lt;BaseData::Pointer&gt; result;
    mitk::LocaleSwitch localeSwitch("C");</span>

<span style = "background-color:#fdd">    Image::Pointer image = Image::New();</span>

<span style = "background-color:#fdd">    const unsigned int MINDIM = 2;
    const unsigned int MAXDIM = 4;</span>

<span style = "background-color:#fdd">    const std::string path = this-&gt;GetLocalFileName();</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "loading " &lt;&lt; path &lt;&lt; " via itk::ImageIOFactory... " &lt;&lt; std::endl;</span>

    // Check to see if we can read the file given the name or prefix
<span style = "background-color:#fdd">    if (path.empty())</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Empty filename in mitk::ItkImageIO ";</span>
    }

    // Got to allocate space for the image. Determine the characteristics of
    // the image.
<span style = "background-color:#fdd">    m_ImageIO-&gt;SetFileName(path);
    m_ImageIO-&gt;ReadImageInformation();</span>

<span style = "background-color:#fdd">    unsigned int ndim = m_ImageIO-&gt;GetNumberOfDimensions();
    if (ndim &lt; MINDIM || ndim &gt; MAXDIM)</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Sorry, only dimensions 2, 3 and 4 are supported. The given file has " &lt;&lt; ndim</span>
                &lt;&lt; " dimensions! Reading as 4D.";
<span style = "background-color:#fdd">      ndim = MAXDIM;</span>
    }

<span style = "background-color:#fdd">    itk::ImageIORegion ioRegion(ndim);
    itk::ImageIORegion::SizeType ioSize = ioRegion.GetSize();
    itk::ImageIORegion::IndexType ioStart = ioRegion.GetIndex();</span>

    unsigned int dimensions[MAXDIM];
<span style = "background-color:#fdd">    dimensions[0] = 0;
    dimensions[1] = 0;
    dimensions[2] = 0;
    dimensions[3] = 0;</span>

    ScalarType spacing[MAXDIM];
<span style = "background-color:#fdd">    spacing[0] = 1.0f;
    spacing[1] = 1.0f;
    spacing[2] = 1.0f;
    spacing[3] = 1.0f;</span>

<span style = "background-color:#fdd">    Point3D origin;
    origin.Fill(0);</span>

    unsigned int i;
<span style = "background-color:#fdd">    for (i = 0; i &lt; ndim; ++i)</span>
    {
<span style = "background-color:#fdd">      ioStart[i] = 0;
      ioSize[i] = m_ImageIO-&gt;GetDimensions(i);
      if (i &lt; MAXDIM)</span>
      {
<span style = "background-color:#fdd">        dimensions[i] = m_ImageIO-&gt;GetDimensions(i);
        spacing[i] = m_ImageIO-&gt;GetSpacing(i);
        if (spacing[i] &lt;= 0)
          spacing[i] = 1.0f;</span>
      }
<span style = "background-color:#fdd">      if (i &lt; 3)</span>
      {
<span style = "background-color:#fdd">        origin[i] = m_ImageIO-&gt;GetOrigin(i);</span>
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    ioRegion.SetSize(ioSize);
    ioRegion.SetIndex(ioStart);</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "ioRegion: " &lt;&lt; ioRegion &lt;&lt; std::endl;
    m_ImageIO-&gt;SetIORegion(ioRegion);
    void *buffer = new unsigned char[m_ImageIO-&gt;GetImageSizeInBytes()];
    m_ImageIO-&gt;Read(buffer);</span>

<span style = "background-color:#fdd">    image-&gt;Initialize(MakePixelType(m_ImageIO), ndim, dimensions);
    image-&gt;SetImportChannel(buffer, 0, Image::ManageMemory);</span>

<span style = "background-color:#fdd">    const itk::MetaDataDictionary &amp;dictionary = m_ImageIO-&gt;GetMetaDataDictionary();</span>

    // access direction of itk::Image and include spacing
<span style = "background-color:#fdd">    mitk::Matrix3D matrix;
    matrix.SetIdentity();
    unsigned int j, itkDimMax3 = (ndim &gt;= 3 ? 3 : ndim);
    for (i = 0; i &lt; itkDimMax3; ++i)
      for (j = 0; j &lt; itkDimMax3; ++j)
        matrix[i][j] = m_ImageIO-&gt;GetDirection(j)[i];</span>

    // re-initialize PlaneGeometry with origin and direction
<span style = "background-color:#fdd">    PlaneGeometry *planeGeometry = image-&gt;GetSlicedGeometry(0)-&gt;GetPlaneGeometry(0);
    planeGeometry-&gt;SetOrigin(origin);
    planeGeometry-&gt;GetIndexToWorldTransform()-&gt;SetMatrix(matrix);</span>

    // re-initialize SlicedGeometry3D
<span style = "background-color:#fdd">    SlicedGeometry3D *slicedGeometry = image-&gt;GetSlicedGeometry(0);
    slicedGeometry-&gt;InitializeEvenlySpaced(planeGeometry, image-&gt;GetDimension(2));
    slicedGeometry-&gt;SetSpacing(spacing);</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; slicedGeometry-&gt;GetCornerPoint(false, false, false);
    MITK_INFO &lt;&lt; slicedGeometry-&gt;GetCornerPoint(true, true, true);</span>

    // re-initialize TimeGeometry
<span style = "background-color:#fdd">    TimeGeometry::Pointer timeGeometry;</span>

<span style = "background-color:#fdd">    if (dictionary.HasKey(PROPERTY_NAME_TIMEGEOMETRY_TYPE) || dictionary.HasKey(PROPERTY_KEY_TIMEGEOMETRY_TYPE))</span>
    { // also check for the name because of backwards compatibility. Past code version stored with the name and not with
      // the key
<span style = "background-color:#fdd">      itk::MetaDataObject&lt;std::string&gt;::ConstPointer timeGeometryTypeData = nullptr;
      if (dictionary.HasKey(PROPERTY_NAME_TIMEGEOMETRY_TYPE))</span>
      {
<span style = "background-color:#fdd">        timeGeometryTypeData =</span>
          dynamic_cast&lt;const itk::MetaDataObject&lt;std::string&gt; *&gt;(dictionary.Get(PROPERTY_NAME_TIMEGEOMETRY_TYPE));
<span style = "background-color:#fdd">      }</span>
      else
      {
<span style = "background-color:#fdd">        timeGeometryTypeData =</span>
          dynamic_cast&lt;const itk::MetaDataObject&lt;std::string&gt; *&gt;(dictionary.Get(PROPERTY_KEY_TIMEGEOMETRY_TYPE));
      }

<span style = "background-color:#fdd">      if (timeGeometryTypeData-&gt;GetMetaDataObjectValue() == ArbitraryTimeGeometry::GetStaticNameOfClass())</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "used time geometry: " &lt;&lt; ArbitraryTimeGeometry::GetStaticNameOfClass();</span>
        typedef std::vector&lt;TimePointType&gt; TimePointVector;
<span style = "background-color:#fdd">        TimePointVector timePoints;</span>

<span style = "background-color:#fdd">        if (dictionary.HasKey(PROPERTY_NAME_TIMEGEOMETRY_TIMEPOINTS))</span>
        {
<span style = "background-color:#fdd">          timePoints = ConvertMetaDataObjectToTimePointList(dictionary.Get(PROPERTY_NAME_TIMEGEOMETRY_TIMEPOINTS));
        }
        else if (dictionary.HasKey(PROPERTY_KEY_TIMEGEOMETRY_TIMEPOINTS))</span>
        {
<span style = "background-color:#fdd">          timePoints = ConvertMetaDataObjectToTimePointList(dictionary.Get(PROPERTY_KEY_TIMEGEOMETRY_TIMEPOINTS));</span>
        }

<span style = "background-color:#fdd">        if (timePoints.empty())</span>
        {
<span style = "background-color:#fdd">          MITK_ERROR &lt;&lt; "Stored timepoints are empty. Meta information seems to bee invalid. Switch to ProportionalTimeGeometry fallback";
        }
        else if (timePoints.size() - 1 != image-&gt;GetDimension(3))</span>
        {
<span style = "background-color:#fdd">          MITK_ERROR &lt;&lt; "Stored timepoints (" &lt;&lt; timePoints.size() - 1 &lt;&lt; ") and size of image time dimension ("</span>
                     &lt;&lt; image-&gt;GetDimension(3) &lt;&lt; ") do not match. Switch to ProportionalTimeGeometry fallback";
<span style = "background-color:#fdd">        }</span>
        else
        {
<span style = "background-color:#fdd">          ArbitraryTimeGeometry::Pointer arbitraryTimeGeometry = ArbitraryTimeGeometry::New();
          TimePointVector::const_iterator pos = timePoints.begin();
          auto prePos = pos++;</span>

<span style = "background-color:#fdd">          for (; pos != timePoints.end(); ++prePos, ++pos)</span>
          {
<span style = "background-color:#fdd">            arbitraryTimeGeometry-&gt;AppendNewTimeStepClone(slicedGeometry, *prePos, *pos);
          }</span>

<span style = "background-color:#fdd">          timeGeometry = arbitraryTimeGeometry;
        }
      }
    }</span>

<span style = "background-color:#fdd">    if (timeGeometry.IsNull())</span>
    { // Fallback. If no other valid time geometry has been created, create a ProportionalTimeGeometry
<span style = "background-color:#fdd">      MITK_INFO &lt;&lt; "used time geometry: " &lt;&lt; ProportionalTimeGeometry::GetStaticNameOfClass();
      ProportionalTimeGeometry::Pointer propTimeGeometry = ProportionalTimeGeometry::New();
      propTimeGeometry-&gt;Initialize(slicedGeometry, image-&gt;GetDimension(3));
      timeGeometry = propTimeGeometry;
    }</span>

<span style = "background-color:#fdd">    image-&gt;SetTimeGeometry(timeGeometry);</span>

<span style = "background-color:#fdd">    buffer = nullptr;
    MITK_INFO &lt;&lt; "number of image components: " &lt;&lt; image-&gt;GetPixelType().GetNumberOfComponents();</span>

<span style = "background-color:#fdd">    for (auto iter = dictionary.Begin(), iterEnd = dictionary.End(); iter != iterEnd;
         ++iter)</span>
    {
<span style = "background-color:#fdd">      if (iter-&gt;second-&gt;GetMetaDataObjectTypeInfo() == typeid(std::string))</span>
      {
<span style = "background-color:#fdd">        const std::string &amp;key = iter-&gt;first;
        std::string assumedPropertyName = key;
        std::replace(assumedPropertyName.begin(), assumedPropertyName.end(), '_', '.');</span>

<span style = "background-color:#fdd">        std::string mimeTypeName = GetMimeType()-&gt;GetName();</span>

        // Check if there is already a info for the key and our mime type.
<span style = "background-color:#fdd">        mitk::CoreServicePointer&lt;IPropertyPersistence&gt; propPersistenceService(mitk::CoreServices::GetPropertyPersistence());
        IPropertyPersistence::InfoResultType infoList = propPersistenceService-&gt;GetInfoByKey(key);</span>

<span style = "background-color:#fdd">        auto predicate = [&amp;mimeTypeName](const PropertyPersistenceInfo::ConstPointer &amp;x) {
          return x.IsNotNull() &amp;&amp; x-&gt;GetMimeTypeName() == mimeTypeName;
        };
        auto finding = std::find_if(infoList.begin(), infoList.end(), predicate);</span>

<span style = "background-color:#fdd">        if (finding == infoList.end())</span>
        {
<span style = "background-color:#fdd">          auto predicateWild = [](const PropertyPersistenceInfo::ConstPointer &amp;x) {
            return x.IsNotNull() &amp;&amp; x-&gt;GetMimeTypeName() == PropertyPersistenceInfo::ANY_MIMETYPE_NAME();
          };
          finding = std::find_if(infoList.begin(), infoList.end(), predicateWild);</span>
        }

<span style = "background-color:#fdd">        PropertyPersistenceInfo::ConstPointer info;</span>

<span style = "background-color:#fdd">        if (finding != infoList.end())</span>
        {
<span style = "background-color:#fdd">          assumedPropertyName = (*finding)-&gt;GetName();
          info = *finding;
        }</span>
        else
        { // we have not found anything suitable so we generate our own info
<span style = "background-color:#fdd">          auto newInfo = PropertyPersistenceInfo::New();
          newInfo-&gt;SetNameAndKey(assumedPropertyName, key);
          newInfo-&gt;SetMimeTypeName(PropertyPersistenceInfo::ANY_MIMETYPE_NAME());
          info = newInfo;
        }</span>

<span style = "background-color:#fdd">        std::string value =</span>
          dynamic_cast&lt;itk::MetaDataObject&lt;std::string&gt; *&gt;(iter-&gt;second.GetPointer())-&gt;GetMetaDataObjectValue();

<span style = "background-color:#fdd">        mitk::BaseProperty::Pointer loadedProp = info-&gt;GetDeserializationFunction()(value);</span>

<span style = "background-color:#fdd">        if (loadedProp.IsNull())</span>
        {
<span style = "background-color:#fdd">          MITK_ERROR &lt;&lt; "Property cannot be correctly deserialized and is skipped. Check if data format is valid. Problematic property value string: \"" &lt;&lt; value &lt;&lt; "\"; Property info used to deserialized: " &lt;&lt; info;
          break;</span>
        }

<span style = "background-color:#fdd">        image-&gt;SetProperty(assumedPropertyName.c_str(), loadedProp);</span>

        // Read properties should be persisted unless they are default properties
        // which are written anyway
<span style = "background-color:#fdd">        bool isDefaultKey(false);</span>

<span style = "background-color:#fdd">        for (const auto &amp;defaultKey : m_DefaultMetaDataKeys)</span>
        {
<span style = "background-color:#fdd">          if (defaultKey.length() &lt;= assumedPropertyName.length())</span>
          {
            // does the start match the default key
<span style = "background-color:#fdd">            if (assumedPropertyName.substr(0, defaultKey.length()).find(defaultKey) != std::string::npos)</span>
            {
<span style = "background-color:#fdd">              isDefaultKey = true;
              break;</span>
            }
          }
<span style = "background-color:#fdd">        }</span>

<span style = "background-color:#fdd">        if (!isDefaultKey)</span>
        {
<span style = "background-color:#fdd">          propPersistenceService-&gt;AddInfo(info);</span>
        }
<span style = "background-color:#fdd">      }
    }</span>

    // Handle UID
<span style = "background-color:#fdd">    if (dictionary.HasKey(PROPERTY_KEY_UID))</span>
    {
<span style = "background-color:#fdd">      itk::MetaDataObject&lt;std::string&gt;::ConstPointer uidData = dynamic_cast&lt;const itk::MetaDataObject&lt;std::string&gt;*&gt;(dictionary.Get(PROPERTY_KEY_UID));
      if (uidData.IsNotNull())</span>
      {
<span style = "background-color:#fdd">        mitk::UIDManipulator uidManipulator(image);
        uidManipulator.SetUID(uidData-&gt;GetMetaDataObjectValue());
      }
    }</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "...finished!";</span>

<span style = "background-color:#fdd">    result.push_back(image.GetPointer());
    return result;
  }</span>

  AbstractFileIO::ConfidenceLevel ItkImageIO::GetReaderConfidenceLevel() const
<span style = "background-color:#fdd">  {
    return m_ImageIO-&gt;CanReadFile(GetLocalFileName().c_str()) ? IFileReader::Supported : IFileReader::Unsupported;
  }</span>

  void ItkImageIO::Write()
<span style = "background-color:#fdd">  {
    const auto *image = dynamic_cast&lt;const mitk::Image *&gt;(this-&gt;GetInput());</span>

<span style = "background-color:#fdd">    if (image == nullptr)</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot write non-image data";</span>
    }

    // Switch the current locale to "C"
<span style = "background-color:#fdd">    LocaleSwitch localeSwitch("C");</span>

    // Clone the image geometry, because we might have to change it
    // for writing purposes
<span style = "background-color:#fdd">    BaseGeometry::Pointer geometry = image-&gt;GetGeometry()-&gt;Clone();</span>

    // Check if geometry information will be lost
<span style = "background-color:#fdd">    if (image-&gt;GetDimension() == 2 &amp;&amp; !geometry-&gt;Is2DConvertable())</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Saving a 2D image with 3D geometry information. Geometry information will be lost! You might "</span>
                   "consider using Convert2Dto3DImageFilter before saving.";

      // set matrix to identity
<span style = "background-color:#fdd">      mitk::AffineTransform3D::Pointer affTrans = mitk::AffineTransform3D::New();
      affTrans-&gt;SetIdentity();
      mitk::Vector3D spacing = geometry-&gt;GetSpacing();
      mitk::Point3D origin = geometry-&gt;GetOrigin();
      geometry-&gt;SetIndexToWorldTransform(affTrans);
      geometry-&gt;SetSpacing(spacing);
      geometry-&gt;SetOrigin(origin);
    }</span>

<span style = "background-color:#fdd">    LocalFile localFile(this);
    const std::string path = localFile.GetFileName();</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "Writing image: " &lt;&lt; path &lt;&lt; std::endl;</span>

    try
    {
      // Implementation of writer using itkImageIO directly. This skips the use
      // of templated itkImageFileWriter, which saves the multiplexing on MITK side.

<span style = "background-color:#fdd">      const unsigned int dimension = image-&gt;GetDimension();
      const unsigned int *const dimensions = image-&gt;GetDimensions();
      const mitk::PixelType pixelType = image-&gt;GetPixelType();
      const mitk::Vector3D mitkSpacing = geometry-&gt;GetSpacing();
      const mitk::Point3D mitkOrigin = geometry-&gt;GetOrigin();</span>

      // Due to templating in itk, we are forced to save a 4D spacing and 4D Origin,
      // though they are not supported in MITK
      itk::Vector&lt;double, 4u&gt; spacing4D;
<span style = "background-color:#fdd">      spacing4D[0] = mitkSpacing[0];
      spacing4D[1] = mitkSpacing[1];
      spacing4D[2] = mitkSpacing[2];
      spacing4D[3] = 1; // There is no support for a 4D spacing. However, we should have a valid value here</span>

      itk::Vector&lt;double, 4u&gt; origin4D;
<span style = "background-color:#fdd">      origin4D[0] = mitkOrigin[0];
      origin4D[1] = mitkOrigin[1];
      origin4D[2] = mitkOrigin[2];
      origin4D[3] = 0; // There is no support for a 4D origin. However, we should have a valid value here</span>

      // Set the necessary information for imageIO
<span style = "background-color:#fdd">      m_ImageIO-&gt;SetNumberOfDimensions(dimension);
      m_ImageIO-&gt;SetPixelType(pixelType.GetPixelType());
      m_ImageIO-&gt;SetComponentType(static_cast&lt;int&gt;(pixelType.GetComponentType()) &lt; PixelComponentUserType</span>
                                    ? pixelType.GetComponentType()
                                    : itk::IOComponentEnum::UNKNOWNCOMPONENTTYPE);
<span style = "background-color:#fdd">      m_ImageIO-&gt;SetNumberOfComponents(pixelType.GetNumberOfComponents());</span>

<span style = "background-color:#fdd">      itk::ImageIORegion ioRegion(dimension);</span>

<span style = "background-color:#fdd">      for (unsigned int i = 0; i &lt; dimension; i++)</span>
      {
<span style = "background-color:#fdd">        m_ImageIO-&gt;SetDimensions(i, dimensions[i]);
        m_ImageIO-&gt;SetSpacing(i, spacing4D[i]);
        m_ImageIO-&gt;SetOrigin(i, origin4D[i]);</span>

<span style = "background-color:#fdd">        mitk::Vector3D mitkDirection(0.0);
        mitkDirection.SetVnlVector(geometry-&gt;GetIndexToWorldTransform()-&gt;GetMatrix().GetVnlMatrix().get_column(i).as_ref());</span>
        itk::Vector&lt;double, 4u&gt; direction4D;
<span style = "background-color:#fdd">        direction4D[0] = mitkDirection[0];
        direction4D[1] = mitkDirection[1];
        direction4D[2] = mitkDirection[2];</span>

        // MITK only supports a 3x3 direction matrix. Due to templating in itk, however, we must
        // save a 4x4 matrix for 4D images. in this case, add an homogneous component to the matrix.
<span style = "background-color:#fdd">        if (i == 3)</span>
        {
<span style = "background-color:#fdd">          direction4D[3] = 1; // homogenous component
        }</span>
        else
        {
<span style = "background-color:#fdd">          direction4D[3] = 0;</span>
        }
<span style = "background-color:#fdd">        vnl_vector&lt;double&gt; axisDirection(dimension);
        for (unsigned int j = 0; j &lt; dimension; j++)</span>
        {
<span style = "background-color:#fdd">          axisDirection[j] = direction4D[j] / spacing4D[i];
        }
        m_ImageIO-&gt;SetDirection(i, axisDirection);</span>

<span style = "background-color:#fdd">        ioRegion.SetSize(i, image-&gt;GetLargestPossibleRegion().GetSize(i));
        ioRegion.SetIndex(i, image-&gt;GetLargestPossibleRegion().GetIndex(i));
      }</span>

      // use compression if available
<span style = "background-color:#fdd">      m_ImageIO-&gt;UseCompressionOn();</span>

<span style = "background-color:#fdd">      m_ImageIO-&gt;SetIORegion(ioRegion);
      m_ImageIO-&gt;SetFileName(path);</span>

      // Handle time geometry
<span style = "background-color:#fdd">      const auto *arbitraryTG = dynamic_cast&lt;const ArbitraryTimeGeometry *&gt;(image-&gt;GetTimeGeometry());
      if (arbitraryTG)</span>
      {
<span style = "background-color:#fdd">        itk::EncapsulateMetaData&lt;std::string&gt;(m_ImageIO-&gt;GetMetaDataDictionary(),</span>
                                              PROPERTY_KEY_TIMEGEOMETRY_TYPE,
                                              ArbitraryTimeGeometry::GetStaticNameOfClass());

<span style = "background-color:#fdd">        auto metaTimePoints = ConvertTimePointListToMetaDataObject(arbitraryTG);
        m_ImageIO-&gt;GetMetaDataDictionary().Set(PROPERTY_KEY_TIMEGEOMETRY_TIMEPOINTS, metaTimePoints);
      }</span>

      // Handle properties
<span style = "background-color:#fdd">      mitk::PropertyList::Pointer imagePropertyList = image-&gt;GetPropertyList();</span>

<span style = "background-color:#fdd">      for (const auto &amp;property : *imagePropertyList-&gt;GetMap())</span>
      {
<span style = "background-color:#fdd">        mitk::CoreServicePointer&lt;IPropertyPersistence&gt; propPersistenceService(mitk::CoreServices::GetPropertyPersistence());
        IPropertyPersistence::InfoResultType infoList = propPersistenceService-&gt;GetInfo(property.first, GetMimeType()-&gt;GetName(), true);</span>

<span style = "background-color:#fdd">        if (infoList.empty())</span>
        {
<span style = "background-color:#fdd">          continue;</span>
        }

<span style = "background-color:#fdd">        std::string value = mitk::BaseProperty::VALUE_CANNOT_BE_CONVERTED_TO_STRING;</span>
        try
        {
<span style = "background-color:#fdd">          value = infoList.front()-&gt;GetSerializationFunction()(property.second);</span>
        }
        catch (const std::exception&amp; e)
<span style = "background-color:#fdd">        {
          MITK_ERROR &lt;&lt; "Error when serializing content of property. This often indicates the use of an out dated reader. Property will not be stored. Skipped property: " &lt;&lt; property.first &lt;&lt; ". Reason: " &lt;&lt; e.what();
        }</span>
        catch (...)
<span style = "background-color:#fdd">        {
          MITK_ERROR &lt;&lt; "Unkown error when serializing content of property. This often indicates the use of an out dated reader. Property will not be stored. Skipped property: " &lt;&lt; property.first;
        }</span>

<span style = "background-color:#fdd">        if (value == mitk::BaseProperty::VALUE_CANNOT_BE_CONVERTED_TO_STRING)</span>
        {
<span style = "background-color:#fdd">          continue;</span>
        }

<span style = "background-color:#fdd">        std::string key = infoList.front()-&gt;GetKey();</span>

<span style = "background-color:#fdd">        itk::EncapsulateMetaData&lt;std::string&gt;(m_ImageIO-&gt;GetMetaDataDictionary(), key, value);
      }</span>

      // Handle UID
<span style = "background-color:#fdd">      itk::EncapsulateMetaData&lt;std::string&gt;(m_ImageIO-&gt;GetMetaDataDictionary(), PROPERTY_KEY_UID, image-&gt;GetUID());</span>

<span style = "background-color:#fdd">      ImageReadAccessor imageAccess(image);
      LocaleSwitch localeSwitch2("C");
      m_ImageIO-&gt;Write(imageAccess.GetData());
    }</span>
    catch (const std::exception &amp;e)
<span style = "background-color:#fdd">    {
      mitkThrow() &lt;&lt; e.what();
    }
  }</span>

  AbstractFileIO::ConfidenceLevel ItkImageIO::GetWriterConfidenceLevel() const
<span style = "background-color:#fdd">  {</span>
    // Check if the image dimension is supported
<span style = "background-color:#fdd">    const auto *image = dynamic_cast&lt;const Image *&gt;(this-&gt;GetInput());
    if (image == nullptr)</span>
    {
      // We cannot write a null object, DUH!
<span style = "background-color:#fdd">      return IFileWriter::Unsupported;</span>
    }

<span style = "background-color:#fdd">    if (!m_ImageIO-&gt;SupportsDimension(image-&gt;GetDimension()))</span>
    {
      // okay, dimension is not supported. We have to look at a special case:
      // 3D-Image with one slice. We can treat that as a 2D image.
<span style = "background-color:#fdd">      if ((image-&gt;GetDimension() == 3) &amp;&amp; (image-&gt;GetSlicedGeometry()-&gt;GetSlices() == 1))
        return IFileWriter::Supported;</span>
      else
<span style = "background-color:#fdd">        return IFileWriter::Unsupported;</span>
    }

    // Check if geometry information will be lost
<span style = "background-color:#fdd">    if (image-&gt;GetDimension() == 2 &amp;&amp; !image-&gt;GetGeometry()-&gt;Is2DConvertable())</span>
    {
<span style = "background-color:#fdd">      return IFileWriter::PartiallySupported;</span>
    }
<span style = "background-color:#fdd">    return IFileWriter::Supported;
  }</span>

<span style = "background-color:#fdd">  ItkImageIO *ItkImageIO::IOClone() const { return new ItkImageIO(*this); }</span>
  void ItkImageIO::InitializeDefaultMetaDataKeys()
<span style = "background-color:#dfd">  {
    this-&gt;m_DefaultMetaDataKeys.push_back("NRRD.space");
    this-&gt;m_DefaultMetaDataKeys.push_back("NRRD.kinds");
    this-&gt;m_DefaultMetaDataKeys.push_back(PROPERTY_NAME_TIMEGEOMETRY_TYPE);
    this-&gt;m_DefaultMetaDataKeys.push_back(PROPERTY_NAME_TIMEGEOMETRY_TIMEPOINTS);
    this-&gt;m_DefaultMetaDataKeys.push_back("ITK.InputFilterName");
  }</span>
}</pre>
	</body>
</html>