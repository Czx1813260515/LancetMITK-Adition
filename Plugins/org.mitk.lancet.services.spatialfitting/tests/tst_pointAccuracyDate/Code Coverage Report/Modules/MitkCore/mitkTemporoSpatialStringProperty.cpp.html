<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkTemporoSpatialStringProperty.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;iterator&gt;
#include &lt;set&gt;

#include "mitkTemporoSpatialStringProperty.h"

#include &lt;boost/property_tree/json_parser.hpp&gt;
#include &lt;boost/property_tree/ptree.hpp&gt;
#include &lt;boost/type_traits/make_unsigned.hpp&gt;

mitk::TemporoSpatialStringProperty::TemporoSpatialStringProperty(const char *s)
<span style = "background-color:#fdd">{
  if (s)</span>
  {
<span style = "background-color:#fdd">    SliceMapType slices{{0, s}};</span>

<span style = "background-color:#fdd">    m_Values.insert(std::make_pair(0, slices));
  }
}</span>

mitk::TemporoSpatialStringProperty::TemporoSpatialStringProperty(const std::string &amp;s)
<span style = "background-color:#fdd">{
  SliceMapType slices{{0, s}};</span>

<span style = "background-color:#fdd">  m_Values.insert(std::make_pair(0, slices));
}</span>

mitk::TemporoSpatialStringProperty::TemporoSpatialStringProperty(const TemporoSpatialStringProperty &amp;other)
<span style = "background-color:#fdd">  : BaseProperty(other), m_Values(other.m_Values)
{
}</span>

bool mitk::TemporoSpatialStringProperty::IsEqual(const BaseProperty &amp;property) const
<span style = "background-color:#fdd">{
  return this-&gt;m_Values == static_cast&lt;const Self &amp;&gt;(property).m_Values;
}</span>

bool mitk::TemporoSpatialStringProperty::Assign(const BaseProperty &amp;property)
<span style = "background-color:#fdd">{
  this-&gt;m_Values = static_cast&lt;const Self &amp;&gt;(property).m_Values;
  return true;
}</span>

std::string mitk::TemporoSpatialStringProperty::GetValueAsString() const
<span style = "background-color:#fdd">{
  return GetValue();
}</span>

bool mitk::TemporoSpatialStringProperty::IsUniform() const
<span style = "background-color:#fdd">{
  auto refValue = this-&gt;GetValue();</span>

<span style = "background-color:#fdd">  for (const auto&amp; timeStep : m_Values)</span>
  {
<span style = "background-color:#fdd">    auto finding = std::find_if_not(timeStep.second.begin(), timeStep.second.end(), [&amp;refValue](const mitk::TemporoSpatialStringProperty::SliceMapType::value_type&amp; val) { return val.second == refValue; });
    if (finding != timeStep.second.end())</span>
    {
<span style = "background-color:#fdd">      return false;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return true;
}</span>

itk::LightObject::Pointer mitk::TemporoSpatialStringProperty::InternalClone() const
<span style = "background-color:#fdd">{
  itk::LightObject::Pointer result(new Self(*this));
  result-&gt;UnRegister();
  return result;
}</span>

mitk::TemporoSpatialStringProperty::ValueType mitk::TemporoSpatialStringProperty::GetValue() const
<span style = "background-color:#fdd">{
  std::string result = "";</span>

<span style = "background-color:#fdd">  if (!m_Values.empty())</span>
  {
<span style = "background-color:#fdd">    if (!m_Values.begin()-&gt;second.empty())</span>
    {
<span style = "background-color:#fdd">      result = m_Values.begin()-&gt;second.begin()-&gt;second;</span>
    }
  }
<span style = "background-color:#fdd">  return result;
};</span>

std::pair&lt;bool, mitk::TemporoSpatialStringProperty::ValueType&gt; mitk::TemporoSpatialStringProperty::CheckValue(
  const TimeStepType &amp;timeStep, const IndexValueType &amp;zSlice, bool allowCloseTime, bool allowCloseSlice) const
<span style = "background-color:#fdd">{
  std::string value = "";
  bool found = false;</span>

<span style = "background-color:#fdd">  auto timeIter = m_Values.find(timeStep);
  auto timeEnd = m_Values.end();
  if (timeIter == timeEnd &amp;&amp; allowCloseTime)</span>
  { // search for closest time step (earlier preverd)
<span style = "background-color:#fdd">    timeIter = m_Values.upper_bound(timeStep);
    if (timeIter != m_Values.begin())</span>
    { // there is a key lower than time step
<span style = "background-color:#fdd">      timeIter = std::prev(timeIter);</span>
    }
  }

<span style = "background-color:#fdd">  if (timeIter != timeEnd)</span>
  {
<span style = "background-color:#fdd">    const SliceMapType &amp;slices = timeIter-&gt;second;</span>

<span style = "background-color:#fdd">    auto sliceIter = slices.find(zSlice);
    auto sliceEnd = slices.end();
    if (sliceIter == sliceEnd &amp;&amp; allowCloseSlice)</span>
    { // search for closest slice (earlier preverd)
<span style = "background-color:#fdd">      sliceIter = slices.upper_bound(zSlice);
      if (sliceIter != slices.begin())</span>
      { // there is a key lower than slice
<span style = "background-color:#fdd">        sliceIter = std::prev(sliceIter);</span>
      }
    }

<span style = "background-color:#fdd">    if (sliceIter != sliceEnd)</span>
    {
<span style = "background-color:#fdd">      value = sliceIter-&gt;second;
      found = true;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return std::make_pair(found, value);
};</span>

mitk::TemporoSpatialStringProperty::ValueType mitk::TemporoSpatialStringProperty::GetValue(const TimeStepType &amp;timeStep,
                                                                                           const IndexValueType &amp;zSlice,
                                                                                           bool allowCloseTime,
                                                                                           bool allowCloseSlice) const
<span style = "background-color:#fdd">{
  return CheckValue(timeStep, zSlice, allowCloseTime, allowCloseSlice).second;
};</span>

mitk::TemporoSpatialStringProperty::ValueType mitk::TemporoSpatialStringProperty::GetValueBySlice(
  const IndexValueType &amp;zSlice, bool allowClose) const
<span style = "background-color:#fdd">{
  return GetValue(0, zSlice, true, allowClose);
};</span>

mitk::TemporoSpatialStringProperty::ValueType mitk::TemporoSpatialStringProperty::GetValueByTimeStep(
  const TimeStepType &amp;timeStep, bool allowClose) const
<span style = "background-color:#fdd">{
  return GetValue(timeStep, 0, allowClose, true);
};</span>

bool mitk::TemporoSpatialStringProperty::HasValue() const
<span style = "background-color:#fdd">{
  return !m_Values.empty();
};</span>

bool mitk::TemporoSpatialStringProperty::HasValue(const TimeStepType &amp;timeStep,
                                                  const IndexValueType &amp;zSlice,
                                                  bool allowCloseTime,
                                                  bool allowCloseSlice) const
<span style = "background-color:#fdd">{
  return CheckValue(timeStep, zSlice, allowCloseTime, allowCloseSlice).first;
};</span>

bool mitk::TemporoSpatialStringProperty::HasValueBySlice(const IndexValueType &amp;zSlice, bool allowClose) const
<span style = "background-color:#fdd">{
  return HasValue(0, zSlice, true, allowClose);
};</span>

bool mitk::TemporoSpatialStringProperty::HasValueByTimeStep(const TimeStepType &amp;timeStep, bool allowClose) const
<span style = "background-color:#fdd">{
  return HasValue(timeStep, 0, allowClose, true);
};</span>

std::vector&lt;mitk::TemporoSpatialStringProperty::IndexValueType&gt; mitk::TemporoSpatialStringProperty::GetAvailableSlices() const
<span style = "background-color:#fdd">{
  std::set&lt;IndexValueType&gt; uniqueSlices;</span>

<span style = "background-color:#fdd">  for (const auto&amp; timeStep : m_Values)</span>
  {
<span style = "background-color:#fdd">    for (const auto&amp; slice : timeStep.second)</span>
    {
<span style = "background-color:#fdd">      uniqueSlices.insert(slice.first);
    }
  }</span>

<span style = "background-color:#fdd">  return std::vector&lt;IndexValueType&gt;(std::begin(uniqueSlices), std::end(uniqueSlices));
}</span>

std::vector&lt;mitk::TemporoSpatialStringProperty::IndexValueType&gt; mitk::TemporoSpatialStringProperty::GetAvailableSlices(
  const TimeStepType &amp;timeStep) const
<span style = "background-color:#fdd">{
  std::vector&lt;IndexValueType&gt; result;</span>

<span style = "background-color:#fdd">  auto timeIter = m_Values.find(timeStep);
  auto timeEnd = m_Values.end();</span>

<span style = "background-color:#fdd">  if (timeIter != timeEnd)</span>
  {
<span style = "background-color:#fdd">    for (auto const &amp;element : timeIter-&gt;second)</span>
    {
<span style = "background-color:#fdd">      result.push_back(element.first);
    }</span>
  }

<span style = "background-color:#fdd">  return result;
};</span>

std::vector&lt;mitk::TimeStepType&gt; mitk::TemporoSpatialStringProperty::GetAvailableTimeSteps() const
<span style = "background-color:#fdd">{
  std::vector&lt;mitk::TimeStepType&gt; result;</span>

<span style = "background-color:#fdd">  for (auto const &amp;element : m_Values)</span>
  {
<span style = "background-color:#fdd">    result.push_back(element.first);
  }</span>

<span style = "background-color:#fdd">  return result;
};</span>

std::vector&lt;mitk::TimeStepType&gt; mitk::TemporoSpatialStringProperty::GetAvailableTimeSteps(const IndexValueType&amp; slice) const
<span style = "background-color:#fdd">{
  std::vector&lt;mitk::TimeStepType&gt; result;</span>

<span style = "background-color:#fdd">  for (const auto&amp; timeStep : m_Values)</span>
  {
<span style = "background-color:#fdd">    if (timeStep.second.find(slice) != std::end(timeStep.second))</span>
    {
<span style = "background-color:#fdd">      result.push_back(timeStep.first);</span>
    }
<span style = "background-color:#fdd">  }
  return result;
}</span>


void mitk::TemporoSpatialStringProperty::SetValue(const TimeStepType &amp;timeStep,
                                                  const IndexValueType &amp;zSlice,
                                                  const ValueType &amp;value)
<span style = "background-color:#fdd">{
  auto timeIter = m_Values.find(timeStep);
  auto timeEnd = m_Values.end();</span>

<span style = "background-color:#fdd">  if (timeIter == timeEnd)</span>
  {
<span style = "background-color:#fdd">    SliceMapType slices{{zSlice, value}};
    m_Values.insert(std::make_pair(timeStep, slices));
  }</span>
  else
  {
<span style = "background-color:#fdd">    timeIter-&gt;second[zSlice] = value;</span>
  }
<span style = "background-color:#fdd">  this-&gt;Modified();
};</span>

void mitk::TemporoSpatialStringProperty::SetValue(const ValueType &amp;value)
<span style = "background-color:#fdd">{
  this-&gt;Modified();
  m_Values.clear();
  this-&gt;SetValue(0, 0, value);
};</span>

// Create necessary escape sequences from illegal characters
// REMARK: This code is based upon code from boost::ptree::json_writer.
// The corresponding boost function was not used directly, because it is not part of
// the public interface of ptree::json_writer. :(
// A own serialization strategy was implemented instead of using boost::ptree::json_write because
// currently (&lt;= boost 1.60) everything (even numbers) are converted into string representations
// by the writer, so e.g. it becomes "t":"2" instaed of "t":2
template &lt;class Ch&gt;
std::basic_string&lt;Ch&gt; CreateJSONEscapes(const std::basic_string&lt;Ch&gt; &amp;s)
<span style = "background-color:#fdd">{
  std::basic_string&lt;Ch&gt; result;
  typename std::basic_string&lt;Ch&gt;::const_iterator b = s.begin();
  typename std::basic_string&lt;Ch&gt;::const_iterator e = s.end();
  while (b != e)</span>
  {
    typedef typename boost::make_unsigned&lt;Ch&gt;::type UCh;
<span style = "background-color:#fdd">    UCh c(*b);</span>
    // This assumes an ASCII superset.
    // We escape everything outside ASCII, because this code can't
    // handle high unicode characters.
<span style = "background-color:#fdd">    if (c == 0x20 || c == 0x21 || (c &gt;= 0x23 &amp;&amp; c &lt;= 0x2E) || (c &gt;= 0x30 &amp;&amp; c &lt;= 0x5B) || (c &gt;= 0x5D &amp;&amp; c &lt;= 0x7F))
      result += *b;
    else if (*b == Ch('\b'))
      result += Ch('\\'), result += Ch('b');
    else if (*b == Ch('\f'))
      result += Ch('\\'), result += Ch('f');
    else if (*b == Ch('\n'))
      result += Ch('\\'), result += Ch('n');
    else if (*b == Ch('\r'))
      result += Ch('\\'), result += Ch('r');
    else if (*b == Ch('\t'))
      result += Ch('\\'), result += Ch('t');
    else if (*b == Ch('/'))
      result += Ch('\\'), result += Ch('/');
    else if (*b == Ch('"'))
      result += Ch('\\'), result += Ch('"');
    else if (*b == Ch('\\'))
      result += Ch('\\'), result += Ch('\\');</span>
    else
    {
<span style = "background-color:#fdd">      const char *hexdigits = "0123456789ABCDEF";
      unsigned long u = (std::min)(static_cast&lt;unsigned long&gt;(static_cast&lt;UCh&gt;(*b)), 0xFFFFul);
      int d1 = u / 4096;
      u -= d1 * 4096;
      int d2 = u / 256;
      u -= d2 * 256;
      int d3 = u / 16;
      u -= d3 * 16;
      int d4 = u;
      result += Ch('\\');
      result += Ch('u');
      result += Ch(hexdigits[d1]);
      result += Ch(hexdigits[d2]);
      result += Ch(hexdigits[d3]);
      result += Ch(hexdigits[d4]);</span>
    }
<span style = "background-color:#fdd">    ++b;
  }
  return result;
}</span>

using CondensedTimeKeyType = std::pair&lt;mitk::TimeStepType, mitk::TimeStepType&gt;;
using CondensedTimePointsType = std::map&lt;CondensedTimeKeyType, std::string&gt;;

using CondensedSliceKeyType = std::pair&lt;mitk::TemporoSpatialStringProperty::IndexValueType, mitk::TemporoSpatialStringProperty::IndexValueType&gt;;
using CondensedSlicesType = std::map&lt;CondensedSliceKeyType, CondensedTimePointsType&gt;;

/** Helper function that checks if between an ID and a successing ID is no gap.*/
template&lt;typename TValue&gt;
bool isGap(const TValue&amp; value, const TValue&amp; successor)
<span style = "background-color:#fdd">{
  return value&lt;successor || value &gt; successor + 1;
}</span>


template&lt;typename TNewKey, typename TNewValue, typename TMasterKey, typename TMasterValue, typename TCondensedContainer&gt;
void CheckAndCondenseElement(const TNewKey&amp; newKeyMinID, const TNewValue&amp; newValue, TMasterKey&amp; masterKey, TMasterValue&amp; masterValue, TCondensedContainer&amp; condensedContainer)
<span style = "background-color:#fdd">{</span>
  if (newValue != masterValue
<span style = "background-color:#fdd">    || isGap(newKeyMinID, masterKey.second))</span>
  {
<span style = "background-color:#fdd">    condensedContainer[masterKey] = masterValue;
    masterValue = newValue;
    masterKey.first = newKeyMinID;</span>
  }
<span style = "background-color:#fdd">  masterKey.second = newKeyMinID;
}</span>

/** Helper function that tries to condense the values of time points for a slice as much as possible and returns all slices with condensed timepoint values.*/
CondensedSlicesType CondenseTimePointValuesOfProperty(const mitk::TemporoSpatialStringProperty* tsProp)
<span style = "background-color:#fdd">{
  CondensedSlicesType uncondensedSlices;</span>

<span style = "background-color:#fdd">  auto zs = tsProp-&gt;GetAvailableSlices();
  for (const auto z : zs)</span>
  {
<span style = "background-color:#fdd">    CondensedTimePointsType condensedTimePoints;
    auto timePointIDs = tsProp-&gt;GetAvailableTimeSteps(z);
    CondensedTimeKeyType condensedKey = { timePointIDs.front(),timePointIDs.front() };
    auto refValue = tsProp-&gt;GetValue(timePointIDs.front(), z);</span>

<span style = "background-color:#fdd">    for (const auto timePointID : timePointIDs)</span>
    {
<span style = "background-color:#fdd">      const auto&amp; newVal = tsProp-&gt;GetValue(timePointID, z);
      CheckAndCondenseElement(timePointID, newVal, condensedKey, refValue, condensedTimePoints);
    }
    condensedTimePoints[condensedKey] = refValue;
    uncondensedSlices[{ z, z }] = condensedTimePoints;
  }
  return uncondensedSlices;
}</span>

::std::string mitk::PropertyPersistenceSerialization::serializeTemporoSpatialStringPropertyToJSON(
  const mitk::BaseProperty *prop)
<span style = "background-color:#fdd">{</span>
  // REMARK: Implemented own serialization instead of using boost::ptree::json_write because
  // currently (&lt;= boost 1.60) everything (even numbers) are converted into string representations
  // by the writer, so e.g. it becomes "t":"2" instaed of "t":2
  // If this problem is fixed with boost, we shoud switch back to json_writer (and remove the custom
  // implementation of CreateJSONEscapes (see above)).
<span style = "background-color:#fdd">  const auto *tsProp = dynamic_cast&lt;const mitk::TemporoSpatialStringProperty *&gt;(prop);</span>

<span style = "background-color:#fdd">  if (!tsProp)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot serialize properties of types other than TemporoSpatialStringProperty.";</span>
  }

<span style = "background-color:#fdd">  std::ostringstream stream;
  stream.imbue(std::locale("C"));
  stream &lt;&lt; "{\"values\":[";</span>

  //we condense the content of the property to have a compact serialization.
  //we start with condensing time points and then slices (in difference to the
  //internal layout). Reason: There is more entropy in slices (looking at DICOM)
  //than across time points for one slice, so we can "compress" to a higher rate.
  //We don't wanted to change the internal structure of the property as it would
  //introduce API inconvinience and subtle changes in behavior.
<span style = "background-color:#fdd">  CondensedSlicesType uncondensedSlices = CondenseTimePointValuesOfProperty(tsProp);</span>

  //now condense the slices
<span style = "background-color:#fdd">  CondensedSlicesType condensedSlices;
  if(!uncondensedSlices.empty())</span>
  {
<span style = "background-color:#fdd">    CondensedTimePointsType&amp; masterSlice = uncondensedSlices.begin()-&gt;second;
    CondensedSliceKeyType masterSliceKey = uncondensedSlices.begin()-&gt;first;</span>

<span style = "background-color:#fdd">    for (const auto&amp; uncondensedSlice : uncondensedSlices)</span>
    {
<span style = "background-color:#fdd">      const auto&amp; uncondensedSliceID = uncondensedSlice.first.first;
      CheckAndCondenseElement(uncondensedSliceID, uncondensedSlice.second, masterSliceKey, masterSlice, condensedSlices);
    }
    condensedSlices[masterSliceKey] = masterSlice;</span>
  }


<span style = "background-color:#fdd">  bool first = true;
  for (const auto&amp; z : condensedSlices)</span>
  {
<span style = "background-color:#fdd">    for (const auto&amp; t : z.second)</span>
    {
<span style = "background-color:#fdd">      if (first)</span>
      {
<span style = "background-color:#fdd">        first = false;
      }</span>
      else
      {
<span style = "background-color:#fdd">        stream &lt;&lt; ", ";</span>
      }

<span style = "background-color:#fdd">      const auto&amp; minSliceID = z.first.first;
      const auto&amp; maxSliceID = z.first.second;
      const auto&amp; minTimePointID = t.first.first;
      const auto&amp; maxTimePointID = t.first.second;</span>

<span style = "background-color:#fdd">      stream &lt;&lt; "{\"z\":" &lt;&lt; minSliceID &lt;&lt; ", ";
      if (minSliceID != maxSliceID)</span>
      {
<span style = "background-color:#fdd">        stream &lt;&lt; "\"zmax\":" &lt;&lt; maxSliceID &lt;&lt; ", ";</span>
      }
<span style = "background-color:#fdd">      stream &lt;&lt; "\"t\":" &lt;&lt; minTimePointID &lt;&lt; ", ";
      if (minTimePointID != maxTimePointID)</span>
      {
<span style = "background-color:#fdd">        stream &lt;&lt; "\"tmax\":" &lt;&lt; maxTimePointID &lt;&lt; ", ";</span>
      }

<span style = "background-color:#fdd">      const auto&amp; value = t.second;
      stream &lt;&lt; "\"value\":\"" &lt;&lt; CreateJSONEscapes(value) &lt;&lt; "\"}";
    }
  }</span>

<span style = "background-color:#fdd">  stream &lt;&lt; "]}";</span>

<span style = "background-color:#fdd">  return stream.str();
}</span>

mitk::BaseProperty::Pointer mitk::PropertyPersistenceDeserialization::deserializeJSONToTemporoSpatialStringProperty(
  const std::string &amp;value)
<span style = "background-color:#fdd">{
  if (value.empty())
    return nullptr;</span>

<span style = "background-color:#fdd">  mitk::TemporoSpatialStringProperty::Pointer prop = mitk::TemporoSpatialStringProperty::New();</span>

<span style = "background-color:#fdd">  boost::property_tree::ptree root;</span>

<span style = "background-color:#fdd">  std::istringstream stream(value);
  stream.imbue(std::locale("C"));</span>

<span style = "background-color:#fdd">  boost::property_tree::read_json(stream, root);</span>

<span style = "background-color:#fdd">  for (boost::property_tree::ptree::value_type &amp;element : root.get_child("values"))</span>
  {
<span style = "background-color:#fdd">    std::string value = element.second.get("value", "");
    mitk::TemporoSpatialStringProperty::IndexValueType z =</span>
      element.second.get&lt;mitk::TemporoSpatialStringProperty::IndexValueType&gt;("z", 0);
<span style = "background-color:#fdd">    mitk::TemporoSpatialStringProperty::IndexValueType zmax =</span>
      element.second.get&lt;mitk::TemporoSpatialStringProperty::IndexValueType&gt;("zmax", z);
<span style = "background-color:#fdd">    TimeStepType t = element.second.get&lt;TimeStepType&gt;("t", 0);
    TimeStepType tmax = element.second.get&lt;TimeStepType&gt;("tmax", t);</span>

<span style = "background-color:#fdd">    for (auto currentT = t; currentT &lt;= tmax; ++currentT)</span>
    {
<span style = "background-color:#fdd">      for (auto currentZ = z; currentZ &lt;= zmax; ++currentZ)</span>
      {
<span style = "background-color:#fdd">        prop-&gt;SetValue(currentT, currentZ, value);
      }
    }
  }</span>

<span style = "background-color:#fdd">  return prop.GetPointer();
}</span></pre>
	</body>
</html>