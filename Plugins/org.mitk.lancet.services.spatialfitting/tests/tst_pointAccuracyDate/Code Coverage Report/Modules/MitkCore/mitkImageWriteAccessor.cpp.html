<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageWriteAccessor.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkImageWriteAccessor.h"

mitk::ImageWriteAccessor::ImageWriteAccessor(ImagePointer image, const mitk::ImageDataItem *iDI, int OptionFlags)
<span style = "background-color:#fdd">  : ImageAccessorBase(image.GetPointer(), iDI, OptionFlags), m_Image(image)</span>

<span style = "background-color:#fdd">{
  OrganizeWriteAccess();
}</span>

mitk::ImageWriteAccessor::~ImageWriteAccessor()
<span style = "background-color:#fdd">{</span>
  // In case of non-coherent memory, copied area needs to be written back
  // TODO

<span style = "background-color:#fdd">  m_Image-&gt;m_ReadWriteLock.lock();</span>

  // delete self from list of ImageReadAccessors in Image
<span style = "background-color:#fdd">  auto it = std::find(m_Image-&gt;m_Writers.begin(), m_Image-&gt;m_Writers.end(), this);
  m_Image-&gt;m_Writers.erase(it);</span>

  // delete lock, if there are no waiting ImageAccessors
<span style = "background-color:#fdd">  if (m_WaitLock-&gt;m_WaiterCount &lt;= 0)</span>
  {
<span style = "background-color:#fdd">    m_WaitLock-&gt;m_Mutex.unlock();
    delete m_WaitLock;
  }</span>
  else
  {
<span style = "background-color:#fdd">    m_WaitLock-&gt;m_Mutex.unlock();</span>
  }

<span style = "background-color:#fdd">  m_Image-&gt;m_ReadWriteLock.unlock();
}</span>

const mitk::Image *mitk::ImageWriteAccessor::GetImage() const
<span style = "background-color:#fdd">{
  return m_Image.GetPointer();
}</span>

void mitk::ImageWriteAccessor::OrganizeWriteAccess()
<span style = "background-color:#fdd">{
  m_Image-&gt;m_ReadWriteLock.lock();</span>

<span style = "background-color:#fdd">  bool readOverlap = false;
  bool writeOverlap = false;</span>

<span style = "background-color:#fdd">  ImageAccessorWaitLock *overlapLock = nullptr;</span>

  // Check, if there is any Read-Access going on
<span style = "background-color:#fdd">  if (m_Image-&gt;m_Readers.size() &gt; 0)</span>
  {
    // Check for every ReadAccessor, if the Region of this ImageAccessors overlaps
    // make sure this iterator is not used, when m_ReadWriteLock is Unlocked!
<span style = "background-color:#fdd">    auto it = m_Image-&gt;m_Readers.begin();</span>

<span style = "background-color:#fdd">    for (; it != m_Image-&gt;m_Readers.end(); ++it)</span>
    {
<span style = "background-color:#fdd">      ImageAccessorBase *r = *it;</span>

<span style = "background-color:#fdd">      if ((r-&gt;m_Options &amp; IgnoreLock) == 0 &amp;&amp; Overlap(r))</span>
      {
        // An Overlap was detected.

<span style = "background-color:#fdd">        PreventRecursiveMutexLock(r);</span>

<span style = "background-color:#fdd">        readOverlap = true;
        overlapLock = r-&gt;m_WaitLock;
        break;</span>
      } // if
<span style = "background-color:#fdd">    }   // for
  }     // if</span>

  // Check, if there is any Write-Access going on
<span style = "background-color:#fdd">  if (m_Image-&gt;m_Writers.size() &gt; 0)</span>
  {
    // Check for every WriteAccessor, if the Region of this ImageAccessors overlaps
    // make sure this iterator is not used, when m_ReadWriteLock is Unlocked!
<span style = "background-color:#fdd">    auto it = m_Image-&gt;m_Writers.begin();</span>

<span style = "background-color:#fdd">    for (; it != m_Image-&gt;m_Writers.end(); ++it)</span>
    {
<span style = "background-color:#fdd">      ImageAccessorBase *w = *it;</span>

<span style = "background-color:#fdd">      if ((w-&gt;m_Options &amp; IgnoreLock) == 0 &amp;&amp; Overlap(w))</span>
      {
        // An Overlap was detected.

<span style = "background-color:#fdd">        PreventRecursiveMutexLock(w);</span>

        // save overlapping Waitlock
<span style = "background-color:#fdd">        writeOverlap = true;
        overlapLock = w-&gt;m_WaitLock;
        break;</span>

      } // if
<span style = "background-color:#fdd">    }   // for
  }     // if</span>

<span style = "background-color:#fdd">  if (readOverlap || writeOverlap)</span>
  {
    // Throw an exception or wait for the WriteAccessor w until it is released and start again with the request
    // afterwards.
<span style = "background-color:#fdd">    if (!(m_Options &amp; ExceptionIfLocked))</span>
    {
      // WAIT
<span style = "background-color:#fdd">      overlapLock-&gt;m_WaiterCount += 1;
      m_Image-&gt;m_ReadWriteLock.unlock();
      ImageAccessorBase::WaitForReleaseOf(overlapLock);</span>

      // after waiting for the ImageAccessor, start this method again
<span style = "background-color:#fdd">      OrganizeWriteAccess();
      return;
    }</span>
    else
    {
      // THROW EXCEPTION
<span style = "background-color:#fdd">      m_Image-&gt;m_ReadWriteLock.unlock();
      mitkThrowException(mitk::MemoryIsLockedException)</span>
        &lt;&lt; "The image part being ordered by the ImageAccessor is already in use and locked";
      // MITK_ERROR("Speicherbereich belegt");
<span style = "background-color:#fdd">      return;</span>
    }
  }

  // Now, we know, that there is no conflict with a Read- or Write-Access
  // Lock the Mutex in ImageAccessorBase, to make sure that every other ImageAccessor has to wait
<span style = "background-color:#fdd">  m_WaitLock-&gt;m_Mutex.lock();</span>

  // insert self into Writers list in Image
<span style = "background-color:#fdd">  m_Image-&gt;m_Writers.push_back(this);</span>

  // printf("WriteAccess %d %d\n",(int) m_Image-&gt;m_Readers.size(),(int) m_Image-&gt;m_Writers.size());
  // fflush(0);
<span style = "background-color:#fdd">  m_Image-&gt;m_ReadWriteLock.unlock();
}</span></pre>
	</body>
</html>