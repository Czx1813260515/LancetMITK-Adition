<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>vtkMitkThickSlicesFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "vtkMitkThickSlicesFilter.h"

#include "vtkDataArray.h"
#include "vtkImageData.h"
#include "vtkInformation.h"
#include "vtkInformationVector.h"
#include "vtkObjectFactory.h"
#include "vtkPointData.h"
#include "vtkStreamingDemandDrivenPipeline.h"

#include &lt;cmath&gt;
#include &lt;sstream&gt;

<span style = "background-color:#fdd">vtkStandardNewMacro(vtkMitkThickSlicesFilter);</span>

//----------------------------------------------------------------------------
// Construct an instance of vtkMitkThickSlicesFilter filter.
vtkMitkThickSlicesFilter::vtkMitkThickSlicesFilter()
<span style = "background-color:#fdd">{
  this-&gt;HandleBoundaries = 1;
  this-&gt;Dimensionality = 2;</span>

<span style = "background-color:#fdd">  this-&gt;m_CurrentMode = MIP;</span>

  // by default process active point scalars
<span style = "background-color:#fdd">  this-&gt;SetInputArrayToProcess(0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, vtkDataSetAttributes::SCALARS);
}</span>

//----------------------------------------------------------------------------
void vtkMitkThickSlicesFilter::PrintSelf(ostream &amp;os, vtkIndent indent)
<span style = "background-color:#fdd">{
  this-&gt;Superclass::PrintSelf(os, indent);
  os &lt;&lt; indent &lt;&lt; "HandleBoundaries: " &lt;&lt; this-&gt;HandleBoundaries &lt;&lt; "\n";
  os &lt;&lt; indent &lt;&lt; "Dimensionality: " &lt;&lt; this-&gt;Dimensionality &lt;&lt; "\n";
}</span>

//----------------------------------------------------------------------------
int vtkMitkThickSlicesFilter::RequestInformation(vtkInformation *,
                                                 vtkInformationVector **inputVector,
                                                 vtkInformationVector *outputVector)
<span style = "background-color:#fdd">{</span>
  // Get input and output pipeline information.
<span style = "background-color:#fdd">  vtkInformation *outInfo = outputVector-&gt;GetInformationObject(0);
  vtkInformation *inInfo = inputVector[0]-&gt;GetInformationObject(0);</span>

  // Get the input whole extent.
  int extent[6];
<span style = "background-color:#fdd">  inInfo-&gt;Get(vtkStreamingDemandDrivenPipeline::WHOLE_EXTENT(), extent);</span>

  // Reduce 3D to 2D output
<span style = "background-color:#fdd">  extent[4] = extent[5] = 0;</span>

  // Store the new whole extent for the output.
<span style = "background-color:#fdd">  outInfo-&gt;Set(vtkStreamingDemandDrivenPipeline::WHOLE_EXTENT(), extent, 6);</span>

  /*
    // Set the number of point data componets to the number of
    // components in the gradient vector.
    vtkDataObject::SetPointDataActiveScalarInfo(outInfo, VTK_DOUBLE,
                                                this-&gt;Dimensionality);
    */
<span style = "background-color:#fdd">  return 1;
}</span>

//----------------------------------------------------------------------------
// This method computes the input extent necessary to generate the output.
int vtkMitkThickSlicesFilter::RequestUpdateExtent(vtkInformation *,
                                                  vtkInformationVector **inputVector,
                                                  vtkInformationVector *outputVector)
<span style = "background-color:#fdd">{</span>
  // Get input and output pipeline information.
<span style = "background-color:#fdd">  vtkInformation *outInfo = outputVector-&gt;GetInformationObject(0);
  vtkInformation *inInfo = inputVector[0]-&gt;GetInformationObject(0);</span>

  // Get the input whole extent.
  int wholeExtent[6];
<span style = "background-color:#fdd">  inInfo-&gt;Get(vtkStreamingDemandDrivenPipeline::WHOLE_EXTENT(), wholeExtent);</span>

  // Get the requested update extent from the output.
  int inUExt[6];
<span style = "background-color:#fdd">  outInfo-&gt;Get(vtkStreamingDemandDrivenPipeline::UPDATE_EXTENT(), inUExt);</span>

  /*inUExt[4] -= 5;
  inUExt[5] += 5;

<span style = "background-color:#fdd">  if (inUExt[4] &lt; wholeExtent[4]) */ inUExt[4] = wholeExtent[4];
  /*if (inUExt[5] &gt; wholeExtent[5]) */ inUExt[5] = wholeExtent[5];</span>

  // Store the update extent needed from the intput.
<span style = "background-color:#fdd">  inInfo-&gt;Set(vtkStreamingDemandDrivenPipeline::UPDATE_EXTENT(), inUExt, 6);</span>

<span style = "background-color:#fdd">  return 1;
}</span>

//----------------------------------------------------------------------------
// This execute method handles boundaries.
// it handles boundaries. Pixels are just replicated to get values
// out of extent.
template &lt;class T&gt;
void vtkMitkThickSlicesFilterExecute(vtkMitkThickSlicesFilter *self,
                                     vtkImageData *inData,
                                     T *inPtr,
                                     vtkImageData *outData,
                                     T *outPtr,
                                     int outExt[6],
                                     int /*id*/)
<span style = "background-color:#fdd">{</span>
  int idxX, idxY;
  int maxX, maxY;
  vtkIdType inIncX, inIncY, inIncZ;
  vtkIdType outIncX, outIncY, outIncZ;
  // int axesNum;
<span style = "background-color:#fdd">  int *inExt = inData-&gt;GetExtent();</span>
  int *wholeExtent;
  vtkIdType *inIncs;
  // int useYMin, useYMax, useXMin, useXMax;

  // find the region to loop over
<span style = "background-color:#fdd">  maxX = outExt[1] - outExt[0];
  maxY = outExt[3] - outExt[2];</span>

  //  maxZ = outExt[5] - outExt[4];

  // Get the dimensionality of the gradient.
  // axesNum = self-&gt;GetDimensionality();

  // Get increments to march through data
<span style = "background-color:#fdd">  inData-&gt;GetContinuousIncrements(outExt, inIncX, inIncY, inIncZ);
  outData-&gt;GetContinuousIncrements(outExt, outIncX, outIncY, outIncZ);</span>
  /*
// The data spacing is important for computing the gradient.
// central differences (2 * ratio).
// Negative because below we have (min - max) for dx ...
inData-&gt;GetSpacing(r);
r[0] = -0.5 / r[0];
r[1] = -0.5 / r[1];
r[2] = -0.5 / r[2];
    */
  // get some other info we need
<span style = "background-color:#fdd">  inIncs = inData-&gt;GetIncrements();
  wholeExtent = inData-&gt;GetExtent();</span>

  // Move the pointer to the correct starting position.
<span style = "background-color:#fdd">  inPtr += (outExt[0] - inExt[0]) * inIncs[0] + (outExt[2] - inExt[2]) * inIncs[1] + (outExt[4] - inExt[4]) * inIncs[2];</span>

  // Loop through ouput pixels

<span style = "background-color:#fdd">  int _minZ = /*-5 + outExt[4];  if( _minZ  &lt; wholeExtent[4]) _minZ=*/wholeExtent[4];
  int _maxZ = /* 5 + outExt[4];  if( _maxZ  &gt; wholeExtent[5]) _maxZ=*/wholeExtent[5];</span>

<span style = "background-color:#fdd">  if (_maxZ &lt; _minZ)
    return;</span>

<span style = "background-color:#fdd">  double invNum = 1.0 / (_maxZ - _minZ + 1);</span>

<span style = "background-color:#fdd">  switch (self-&gt;GetThickSliceMode())</span>
  {
    default:
    case vtkMitkThickSlicesFilter::MIP:
    {
      // MIP
<span style = "background-color:#fdd">      for (idxY = 0; idxY &lt;= maxY; idxY++)</span>
      {
        // useYMin = ((idxY + outExt[2]) &lt;= wholeExtent[2]) ? 0 : -inIncs[1];
        // useYMax = ((idxY + outExt[2]) &gt;= wholeExtent[3]) ? 0 : inIncs[1];
<span style = "background-color:#fdd">        for (idxX = 0; idxX &lt;= maxX; idxX++)</span>
        {
          // useXMin = ((idxX + outExt[0]) &lt;= wholeExtent[0]) ? 0 : -inIncs[0];
          // useXMax = ((idxX + outExt[0]) &gt;= wholeExtent[1]) ? 0 : inIncs[0];

<span style = "background-color:#fdd">          T mip = inPtr[_minZ * inIncs[2]];</span>

<span style = "background-color:#fdd">          for (int z = _minZ + 1; z &lt;= _maxZ; z++)</span>
          {
<span style = "background-color:#fdd">            T value = inPtr[z * inIncs[2]];
            if (value &gt; mip)
              mip = value;
          }</span>

          // do X axis
<span style = "background-color:#fdd">          *outPtr = mip;
          outPtr++;
          inPtr++;
        }
        outPtr += outIncY;
        inPtr += inIncY;
      }</span>
    }
<span style = "background-color:#fdd">    break;</span>

    case vtkMitkThickSlicesFilter::SUM:
    {
      // MIP
<span style = "background-color:#fdd">      for (idxY = 0; idxY &lt;= maxY; idxY++)</span>
      {
        // useYMin = ((idxY + outExt[2]) &lt;= wholeExtent[2]) ? 0 : -inIncs[1];
        // useYMax = ((idxY + outExt[2]) &gt;= wholeExtent[3]) ? 0 : inIncs[1];
<span style = "background-color:#fdd">        for (idxX = 0; idxX &lt;= maxX; idxX++)</span>
        {
          // useXMin = ((idxX + outExt[0]) &lt;= wholeExtent[0]) ? 0 : -inIncs[0];
          // useXMax = ((idxX + outExt[0]) &gt;= wholeExtent[1]) ? 0 : inIncs[0];

<span style = "background-color:#fdd">          double sum = 0;</span>

<span style = "background-color:#fdd">          for (int z = _minZ; z &lt;= _maxZ; z++)</span>
          {
<span style = "background-color:#fdd">            T value = inPtr[z * inIncs[2]];
            sum += value;
          }</span>

          // do X axis
<span style = "background-color:#fdd">          *outPtr = static_cast&lt;T&gt;(invNum * sum);
          outPtr++;
          inPtr++;
        }
        outPtr += outIncY;
        inPtr += inIncY;
      }</span>
    }
<span style = "background-color:#fdd">    break;</span>

    case vtkMitkThickSlicesFilter::WEIGHTED:
    {
<span style = "background-color:#fdd">      const int size = _maxZ - _minZ;
      std::vector&lt;double&gt; weights(size);
      double mean = 0.5 * double(_minZ + _maxZ);
      double sigma_sq = double(size) / 6.0;
      sigma_sq *= sigma_sq;
      double sum = 0;
      int i = 0;
      for (int z = _minZ + 1; z &lt;= _maxZ; z++)</span>
      {
<span style = "background-color:#fdd">        double val = exp(-(((double)z - mean) / sigma_sq));
        weights[i++] = val;
        sum += val;
      }
      for (i = 0; i &lt; size; i++)</span>
      {
<span style = "background-color:#fdd">        weights[i] /= sum;
      }</span>

<span style = "background-color:#fdd">      for (idxY = 0; idxY &lt;= maxY; idxY++)</span>
      {
        // useYMin = ((idxY + outExt[2]) &lt;= wholeExtent[2]) ? 0 : -inIncs[1];
        // useYMax = ((idxY + outExt[2]) &gt;= wholeExtent[3]) ? 0 : inIncs[1];
<span style = "background-color:#fdd">        for (idxX = 0; idxX &lt;= maxX; idxX++)</span>
        {
          // useXMin = ((idxX + outExt[0]) &lt;= wholeExtent[0]) ? 0 : -inIncs[0];
          // useXMax = ((idxX + outExt[0]) &gt;= wholeExtent[1]) ? 0 : inIncs[0];

<span style = "background-color:#fdd">          T mip = inPtr[_minZ * inIncs[2]];
          i = 0;
          double mymip = 0;
          for (int z = _minZ + 1; z &lt;= _maxZ; z++)</span>
          {
<span style = "background-color:#fdd">            double value = inPtr[z * inIncs[2]];
            mymip += value * weights[i++];
          }
          mip = static_cast&lt;T&gt;(mymip);</span>
          // do X axis
<span style = "background-color:#fdd">          *outPtr = mip;
          outPtr++;
          inPtr++;
        }
        outPtr += outIncY;
        inPtr += inIncY;
      }
    }
    break;</span>

    case vtkMitkThickSlicesFilter::MINIP:
    {
<span style = "background-color:#fdd">      for (idxY = 0; idxY &lt;= maxY; idxY++)</span>
      {
<span style = "background-color:#fdd">        for (idxX = 0; idxX &lt;= maxX; idxX++)</span>
        {
<span style = "background-color:#fdd">          T mip = inPtr[_minZ * inIncs[2]];</span>

<span style = "background-color:#fdd">          for (int z = _minZ + 1; z &lt;= _maxZ; z++)</span>
          {
<span style = "background-color:#fdd">            T value = inPtr[z * inIncs[2]];
            if (value &lt; mip)
              mip = value;
          }</span>

          // do X axis
<span style = "background-color:#fdd">          *outPtr = mip;
          outPtr++;
          inPtr++;
        }
        outPtr += outIncY;
        inPtr += inIncY;
      }</span>
    }
<span style = "background-color:#fdd">    break;</span>

    case vtkMitkThickSlicesFilter::MEAN:
    {
<span style = "background-color:#fdd">      const int size = _maxZ - _minZ;</span>

      // MEAN
<span style = "background-color:#fdd">      for (idxY = 0; idxY &lt;= maxY; idxY++)</span>
      {
<span style = "background-color:#fdd">        for (idxX = 0; idxX &lt;= maxX; idxX++)</span>
        {
<span style = "background-color:#fdd">          long double sum = 0;
          for (int z = _minZ; z &lt;= _maxZ; z++)</span>
          {
<span style = "background-color:#fdd">            T value = inPtr[z * inIncs[2]];
            sum += value;
          }</span>

<span style = "background-color:#fdd">          T mip = static_cast&lt;T&gt;(sum / size);</span>

          // do X axis
<span style = "background-color:#fdd">          *outPtr = mip;
          outPtr++;
          inPtr++;
        }
        outPtr += outIncY;
        inPtr += inIncY;
      }</span>
    }
    break;
  }
<span style = "background-color:#fdd">}</span>

int vtkMitkThickSlicesFilter::RequestData(vtkInformation *request,
                                          vtkInformationVector **inputVector,
                                          vtkInformationVector *outputVector)
<span style = "background-color:#fdd">{
  if (!this-&gt;Superclass::RequestData(request, inputVector, outputVector))</span>
  {
<span style = "background-color:#fdd">    return 0;</span>
  }
<span style = "background-color:#fdd">  vtkImageData *output = vtkImageData::GetData(outputVector);
  vtkDataArray *outArray = output-&gt;GetPointData()-&gt;GetScalars();
  std::ostringstream newname;
  newname &lt;&lt; (outArray-&gt;GetName() ? outArray-&gt;GetName() : "") &lt;&lt; "Gradient";
  outArray-&gt;SetName(newname.str().c_str());</span>
  // Why not pass the original array?
<span style = "background-color:#fdd">  if (this-&gt;GetInputArrayToProcess(0, inputVector))</span>
  {
<span style = "background-color:#fdd">    output-&gt;GetPointData()-&gt;AddArray(this-&gt;GetInputArrayToProcess(0, inputVector));</span>
  }
<span style = "background-color:#fdd">  return 1;
}</span>

//----------------------------------------------------------------------------
// This method contains a switch statement that calls the correct
// templated function for the input data type.  This method does handle
// boundary conditions.
void vtkMitkThickSlicesFilter::ThreadedRequestData(vtkInformation *,
                                                   vtkInformationVector **inputVector,
                                                   vtkInformationVector *,
                                                   vtkImageData ***inData,
                                                   vtkImageData **outData,
                                                   int outExt[6],
                                                   int threadId)
<span style = "background-color:#fdd">{</span>
  // Get the input and output data objects.
<span style = "background-color:#fdd">  vtkImageData *input = inData[0][0];
  vtkImageData *output = outData[0];</span>

  // The ouptut scalar type must be double to store proper gradients.
  /*
    if(output-&gt;GetScalarType() != VTK_DOUBLE)
      {
      vtkErrorMacro("Execute: output ScalarType is "
                    &lt;&lt; output-&gt;GetScalarType() &lt;&lt; "but must be double.");
      return;
      }
    */
<span style = "background-color:#fdd">  vtkDataArray *inputArray = this-&gt;GetInputArrayToProcess(0, inputVector);
  if (!inputArray)</span>
  {
<span style = "background-color:#fdd">    vtkErrorMacro("No input array was found. Cannot execute");
    return;</span>
  }

  // Gradient makes sense only with one input component.  This is not
  // a Jacobian filter.
<span style = "background-color:#fdd">  if (inputArray-&gt;GetNumberOfComponents() != 1)</span>
  {
<span style = "background-color:#fdd">    vtkErrorMacro("Execute: input has more than one component. "</span>
                  "The input to gradient should be a single component image. "
                  "Think about it. If you insist on using a color image then "
                  "run it though RGBToHSV then ExtractComponents to get the V "
                  "components. That's probably what you want anyhow.");
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  void *inPtr = inputArray-&gt;GetVoidPointer(0);
  void *outPtr = output-&gt;GetScalarPointerForExtent(outExt);</span>

<span style = "background-color:#fdd">  switch (inputArray-&gt;GetDataType())</span>
  {
<span style = "background-color:#fdd">    vtkTemplateMacro(vtkMitkThickSlicesFilterExecute(</span>
      this, input, static_cast&lt;VTK_TT *&gt;(inPtr), output, static_cast&lt;VTK_TT *&gt;(outPtr), outExt, threadId));
    default:
<span style = "background-color:#fdd">      vtkErrorMacro("Execute: Unknown ScalarType " &lt;&lt; input-&gt;GetScalarType());</span>
      return;
  }
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>