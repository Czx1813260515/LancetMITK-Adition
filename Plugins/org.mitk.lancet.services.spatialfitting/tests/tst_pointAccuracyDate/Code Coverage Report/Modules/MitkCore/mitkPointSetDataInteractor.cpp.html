<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPointSetDataInteractor.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPointSetDataInteractor.h"
#include "mitkMouseMoveEvent.h"

#include "mitkInteractionConst.h" // TODO: refactor file
#include "mitkInternalEvent.h"
#include "mitkOperationEvent.h"
#include "mitkRenderingManager.h"
#include &lt;mitkPointOperation.h&gt;
//
#include "mitkBaseRenderer.h"
#include "mitkDispatcher.h"

#include "mitkUndoController.h"

void mitk::PointSetDataInteractor::ConnectActionsAndFunctions()
<span style = "background-color:#fdd">{</span>
  // Condition which is evaluated before transition is taken
  // following actions in the statemachine are only executed if it returns TRUE
<span style = "background-color:#fdd">  CONNECT_CONDITION("isoverpoint", CheckSelection);
  CONNECT_FUNCTION("addpoint", AddPoint);
  CONNECT_FUNCTION("selectpoint", SelectPoint);
  CONNECT_FUNCTION("unselect", UnSelectPointAtPosition);
  CONNECT_FUNCTION("unselectAll", UnSelectAll);
  CONNECT_FUNCTION("initMove", InitMove);
  CONNECT_FUNCTION("movePoint", MovePoint);
  CONNECT_FUNCTION("finishMovement", FinishMove);
  CONNECT_FUNCTION("removePoint", RemovePoint);
}</span>

void mitk::PointSetDataInteractor::AddPoint(StateMachineAction *stateMachineAction, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  unsigned int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(GetDataNode()-&gt;GetData());
  ScalarType timeInMs = interactionEvent-&gt;GetSender()-&gt;GetTime();</span>

  // disallow adding of new points if maximum number of points is reached
<span style = "background-color:#fdd">  if (m_MaxNumberOfPoints &gt; 1 &amp;&amp; m_PointSet-&gt;GetSize(timeStep) &gt;= m_MaxNumberOfPoints)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }
  // To add a point the minimal information is the position, this method accepts all InteractionsPositionEvents
<span style = "background-color:#fdd">  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent != nullptr)</span>
  {
<span style = "background-color:#fdd">    mitk::Point3D itkPoint = positionEvent-&gt;GetPositionInWorld();</span>

<span style = "background-color:#fdd">    this-&gt;UnselectAll(timeStep, timeInMs);</span>

<span style = "background-color:#fdd">    int lastPosition = 0;
    mitk::PointSet::PointsIterator it, end;
    it = m_PointSet-&gt;Begin(timeStep);
    end = m_PointSet-&gt;End(timeStep);
    while (it != end)</span>
    {
<span style = "background-color:#fdd">      if (!m_PointSet-&gt;IndexExists(lastPosition, timeStep))
        break;
      ++it;
      ++lastPosition;
    }</span>

    // Insert a Point to the PointSet
    // 2) Create the Operation inserting the point
<span style = "background-color:#fdd">	if (m_PointSet-&gt;IsEmpty()) { lastPosition = 0; }
    auto *doOp = new mitk::PointOperation(OpINSERT, timeInMs, itkPoint, lastPosition);</span>

    // 3) If Undo is enabled, also create the inverse Operation
<span style = "background-color:#fdd">    if (m_UndoEnabled)</span>
    {
<span style = "background-color:#fdd">      auto *undoOp = new mitk::PointOperation(OpREMOVE, timeInMs, itkPoint, lastPosition);</span>
      // 4) Do and Undo Operations are combined in an Operation event which also contains the target of the operations
      // (here m_PointSet)
<span style = "background-color:#fdd">      OperationEvent *operationEvent = new OperationEvent(m_PointSet, doOp, undoOp, "Add point");</span>
      // 5) Store the Operation in the UndoController
<span style = "background-color:#fdd">      OperationEvent::IncCurrObjectEventId();
      m_UndoController-&gt;SetOperationEvent(operationEvent);</span>
    }

    // 6) Execute the Operation performs the actual insertion of the point into the PointSet
<span style = "background-color:#fdd">    m_PointSet-&gt;ExecuteOperation(doOp);</span>

    // 7) If Undo is not enabled the Do-Operation is to be dropped to prevent memory leaks.
<span style = "background-color:#fdd">    if (!m_UndoEnabled)
      delete doOp;</span>

<span style = "background-color:#fdd">    RenderingManager::GetInstance()-&gt;RequestUpdateAll();</span>

    // Check if points form a closed contour now, if so fire an InternalEvent
<span style = "background-color:#fdd">    IsClosedContour(stateMachineAction, interactionEvent);</span>

<span style = "background-color:#fdd">    if (m_MaxNumberOfPoints &gt; 0 &amp;&amp; m_PointSet-&gt;GetSize(timeStep) &gt;= m_MaxNumberOfPoints)</span>
    {
      // Signal that DataNode is fully filled
<span style = "background-color:#fdd">      this-&gt;NotifyResultReady();</span>
      // Send internal event that can be used by StateMachines to switch in a different state
<span style = "background-color:#fdd">      InternalEvent::Pointer event = InternalEvent::New(nullptr, this, "MaximalNumberOfPoints");
      positionEvent-&gt;GetSender()-&gt;GetDispatcher()-&gt;QueueEvent(event.GetPointer());
    }
  }
}</span>

void mitk::PointSetDataInteractor::SelectPoint(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  unsigned int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(GetDataNode()-&gt;GetData());
  ScalarType timeInMs = interactionEvent-&gt;GetSender()-&gt;GetTime();</span>

<span style = "background-color:#fdd">  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent != nullptr)</span>
  {
<span style = "background-color:#fdd">    Point3D point = positionEvent-&gt;GetPositionInWorld();</span>
    // iterate over point set and check if it contains a point close enough to the pointer to be selected
<span style = "background-color:#fdd">    int index = GetPointIndexByPosition(point, timeStep);
    if (index != -1)</span>
    {
      // first deselect the other points
      // undoable deselect of all points in the DataList
<span style = "background-color:#fdd">      this-&gt;UnselectAll(timeStep, timeInMs);</span>

<span style = "background-color:#fdd">      auto *doOp = new mitk::PointOperation(OpSELECTPOINT, timeInMs, point, index);</span>

      /*if (m_UndoEnabled)
      {
        PointOperation* undoOp = new mitk::PointOperation(OpDESELECTPOINT,timeInMs,point, index);
        OperationEvent *operationEvent = new OperationEvent(m_PointSet, doOp, undoOp, "Select Point");
        OperationEvent::IncCurrObjectEventId();
        m_UndoController-&gt;SetOperationEvent(operationEvent);
      }*/

      // execute the Operation
<span style = "background-color:#fdd">      m_PointSet-&gt;ExecuteOperation(doOp);</span>

<span style = "background-color:#fdd">      if (!m_UndoEnabled)
        delete doOp;</span>

<span style = "background-color:#fdd">      RenderingManager::GetInstance()-&gt;RequestUpdateAll();</span>
    }
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">mitk::PointSetDataInteractor::PointSetDataInteractor() : m_MaxNumberOfPoints(0), m_SelectionAccuracy(3.5)
{
}</span>

mitk::PointSetDataInteractor::~PointSetDataInteractor()
<span style = "background-color:#fdd">{
}</span>

void mitk::PointSetDataInteractor::RemovePoint(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  unsigned int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(GetDataNode()-&gt;GetData());
  ScalarType timeInMs = interactionEvent-&gt;GetSender()-&gt;GetTime();</span>

<span style = "background-color:#fdd">  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent != nullptr)</span>
  {
<span style = "background-color:#fdd">    mitk::Point3D itkPoint = positionEvent-&gt;GetPositionInWorld();</span>

    // search the point in the list
<span style = "background-color:#fdd">    int position = m_PointSet-&gt;SearchPoint(itkPoint, m_SelectionAccuracy, timeStep);
    if (position &gt;= 0) // found a point</span>
    {
<span style = "background-color:#fdd">      PointSet::PointType pt = m_PointSet-&gt;GetPoint(position, timeStep);
      itkPoint[0] = pt[0];
      itkPoint[1] = pt[1];
      itkPoint[2] = pt[2];</span>

<span style = "background-color:#fdd">      auto *doOp = new mitk::PointOperation(OpREMOVE, timeInMs, itkPoint, position);
      if (m_UndoEnabled) // write to UndoMechanism</span>
      {
<span style = "background-color:#fdd">        auto *undoOp = new mitk::PointOperation(OpINSERT, timeInMs, itkPoint, position);
        OperationEvent *operationEvent = new OperationEvent(m_PointSet, doOp, undoOp, "Remove point");
        mitk::OperationEvent::IncCurrObjectEventId();
        m_UndoController-&gt;SetOperationEvent(operationEvent);</span>
      }
      // execute the Operation
<span style = "background-color:#fdd">      m_PointSet-&gt;ExecuteOperation(doOp);</span>

<span style = "background-color:#fdd">      if (!m_UndoEnabled)
        delete doOp;</span>

      /*now select the point "position-1",
      and if it is the first in list,
      then continue at the last in list*/
      // only then a select of a point is possible!
<span style = "background-color:#fdd">      if (m_PointSet-&gt;GetSize(timeStep) &gt; 0)</span>
      {
<span style = "background-color:#fdd">        this-&gt;SelectPoint(m_PointSet-&gt;Begin(timeStep)-&gt;Index(), timeStep, timeInMs);</span>
      }
    }
<span style = "background-color:#fdd">    RenderingManager::GetInstance()-&gt;RequestUpdateAll();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::PointSetDataInteractor::IsClosedContour(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  unsigned int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(GetDataNode()-&gt;GetData());</span>

<span style = "background-color:#fdd">  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent != nullptr)</span>
  {
<span style = "background-color:#fdd">    Point3D point = positionEvent-&gt;GetPositionInWorld();</span>
    // iterate over point set and check if it contains a point close enough to the pointer to be selected
<span style = "background-color:#fdd">    if (GetPointIndexByPosition(point, timeStep) != -1 &amp;&amp; m_PointSet-&gt;GetSize(timeStep) &gt;= 3)</span>
    {
<span style = "background-color:#fdd">      InternalEvent::Pointer event = InternalEvent::New(nullptr, this, "ClosedContour");
      positionEvent-&gt;GetSender()-&gt;GetDispatcher()-&gt;QueueEvent(event.GetPointer());
    }</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::PointSetDataInteractor::MovePoint(StateMachineAction *stateMachineAction, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  unsigned int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(GetDataNode()-&gt;GetData());
  ScalarType timeInMs = interactionEvent-&gt;GetSender()-&gt;GetTime();
  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent != nullptr)</span>
  {
<span style = "background-color:#fdd">    IsClosedContour(stateMachineAction, interactionEvent);
    mitk::Point3D newPoint, resultPoint;
    newPoint = positionEvent-&gt;GetPositionInWorld();</span>

    // search the elements in the list that are selected then calculate the
    // vector, because only with the vector we can move several elements in
    // the same direction
    //   newPoint - lastPoint = vector
    // then move all selected and set the lastPoint = newPoint.
    // then add all vectors to a summeryVector (to be able to calculate the
    // startpoint for undoOperation)
<span style = "background-color:#fdd">    mitk::Vector3D dirVector = newPoint - m_LastPoint;</span>

    // sum up all Movement for Undo in FinishMovement
<span style = "background-color:#fdd">    m_SumVec = m_SumVec + dirVector;</span>

<span style = "background-color:#fdd">    mitk::PointSet::PointsIterator it, end;
    it = m_PointSet-&gt;Begin(timeStep);
    end = m_PointSet-&gt;End(timeStep);
    while (it != end)</span>
    {
<span style = "background-color:#fdd">      int position = it-&gt;Index();
      if (m_PointSet-&gt;GetSelectInfo(position, timeStep)) // if selected</span>
      {
<span style = "background-color:#fdd">        PointSet::PointType pt = m_PointSet-&gt;GetPoint(position, timeStep);
        mitk::Point3D sumVec;
        sumVec[0] = pt[0];
        sumVec[1] = pt[1];
        sumVec[2] = pt[2];
        resultPoint = sumVec + dirVector;
        auto *doOp = new mitk::PointOperation(OpMOVE, timeInMs, resultPoint, position);</span>
        // execute the Operation
        // here no undo is stored, because the movement-steps aren't interesting.
        // only the start and the end is interisting to store for undo.
<span style = "background-color:#fdd">        m_PointSet-&gt;ExecuteOperation(doOp);
        delete doOp;</span>
      }
<span style = "background-color:#fdd">      ++it;
    }
    m_LastPoint = newPoint; // for calculation of the direction vector</span>
    // Update the display
<span style = "background-color:#fdd">    RenderingManager::GetInstance()-&gt;RequestUpdateAll();
    IsClosedContour(stateMachineAction, interactionEvent);
  }
}</span>

void mitk::PointSetDataInteractor::UnSelectPointAtPosition(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  unsigned int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(GetDataNode()-&gt;GetData());
  ScalarType timeInMs = interactionEvent-&gt;GetSender()-&gt;GetTime();</span>

<span style = "background-color:#fdd">  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent != nullptr)</span>
  {
<span style = "background-color:#fdd">    Point3D point = positionEvent-&gt;GetPositionInWorld();</span>
    // iterate over point set and check if it contains a point close enough to the pointer to be selected
<span style = "background-color:#fdd">    int index = GetPointIndexByPosition(point, timeStep);</span>
    // here it is ensured that we don't switch from one point being selected to another one being selected,
    // without accepting the unselect of the current point
<span style = "background-color:#fdd">    if (index != -1)</span>
    {
<span style = "background-color:#fdd">      auto *doOp = new mitk::PointOperation(OpDESELECTPOINT, timeInMs, point, index);</span>

      /*if (m_UndoEnabled)
      {
        PointOperation* undoOp = new mitk::PointOperation(OpSELECTPOINT,timeInMs, point, index);
        OperationEvent *operationEvent = new OperationEvent(m_PointSet, doOp, undoOp, "Unselect Point");
        OperationEvent::IncCurrObjectEventId();
        m_UndoController-&gt;SetOperationEvent(operationEvent);
      }*/

<span style = "background-color:#fdd">      m_PointSet-&gt;ExecuteOperation(doOp);</span>

<span style = "background-color:#fdd">      if (!m_UndoEnabled)
        delete doOp;</span>

<span style = "background-color:#fdd">      RenderingManager::GetInstance()-&gt;RequestUpdateAll();</span>
    }
  }
<span style = "background-color:#fdd">}</span>

void mitk::PointSetDataInteractor::UnSelectAll(mitk::StateMachineAction *, mitk::InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  unsigned int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(GetDataNode()-&gt;GetData());
  ScalarType timeInMs = interactionEvent-&gt;GetSender()-&gt;GetTime();</span>

<span style = "background-color:#fdd">  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent != nullptr)</span>
  {
<span style = "background-color:#fdd">    Point3D positioninWorld = positionEvent-&gt;GetPositionInWorld();
    PointSet::PointsContainer::Iterator it, end;</span>

<span style = "background-color:#fdd">    PointSet::DataType *itkPointSet = m_PointSet-&gt;GetPointSet(timeStep);</span>

<span style = "background-color:#fdd">    end = itkPointSet-&gt;GetPoints()-&gt;End();</span>

<span style = "background-color:#fdd">    for (it = itkPointSet-&gt;GetPoints()-&gt;Begin(); it != end; it++)</span>
    {
<span style = "background-color:#fdd">      int position = it-&gt;Index();</span>
      // then declare an operation which unselects this point;
      // UndoOperation as well!
<span style = "background-color:#fdd">      if (m_PointSet-&gt;GetSelectInfo(position, timeStep))</span>
      {
<span style = "background-color:#fdd">        float distance = sqrt(positioninWorld.SquaredEuclideanDistanceTo(m_PointSet-&gt;GetPoint(position, timeStep)));
        if (distance &gt; m_SelectionAccuracy)</span>
        {
<span style = "background-color:#fdd">          mitk::Point3D noPoint;
          noPoint.Fill(0);
          auto *doOp = new mitk::PointOperation(OpDESELECTPOINT, timeInMs, noPoint, position);</span>

          /*if ( m_UndoEnabled )
          {
            mitk::PointOperation* undoOp = new mitk::PointOperation(OpSELECTPOINT, timeInMs,  noPoint, position);
            OperationEvent *operationEvent = new OperationEvent( m_PointSet, doOp, undoOp, "Unselect Point" );
            OperationEvent::IncCurrObjectEventId();
            m_UndoController-&gt;SetOperationEvent( operationEvent );
          }*/

<span style = "background-color:#fdd">          m_PointSet-&gt;ExecuteOperation(doOp);</span>

<span style = "background-color:#fdd">          if (!m_UndoEnabled)
            delete doOp;</span>
        }
      }
<span style = "background-color:#fdd">    }
  }</span>
  else
  {
<span style = "background-color:#fdd">    this-&gt;UnselectAll(timeStep, timeInMs);</span>
  }

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::PointSetDataInteractor::UpdatePointSet(mitk::StateMachineAction *, mitk::InteractionEvent *)
<span style = "background-color:#fdd">{
  auto *pointSet = dynamic_cast&lt;mitk::PointSet *&gt;(this-&gt;GetDataNode()-&gt;GetData());
  if (pointSet == nullptr)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "PointSetDataInteractor:: No valid point set .";
    return;</span>
  }

<span style = "background-color:#fdd">  m_PointSet = pointSet;
}</span>

void mitk::PointSetDataInteractor::Abort(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  InternalEvent::Pointer event = InternalEvent::New(nullptr, this, IntDeactivateMe);
  interactionEvent-&gt;GetSender()-&gt;GetDispatcher()-&gt;QueueEvent(event.GetPointer());
}</span>

/*
 * Check whether the DataNode contains a pointset, if not create one and add it.
 */
void mitk::PointSetDataInteractor::DataNodeChanged()
<span style = "background-color:#fdd">{
  if (GetDataNode() != nullptr)</span>
  {
<span style = "background-color:#fdd">    auto *points = dynamic_cast&lt;PointSet *&gt;(GetDataNode()-&gt;GetData());
    if (points == nullptr)</span>
    {
<span style = "background-color:#fdd">      m_PointSet = PointSet::New();
      GetDataNode()-&gt;SetData(m_PointSet);
    }</span>
    else
    {
<span style = "background-color:#fdd">      m_PointSet = points;</span>
    }
    // load config file parameter: maximal number of points
<span style = "background-color:#fdd">    mitk::PropertyList::Pointer properties = GetAttributes();
    std::string strNumber;
    if (properties-&gt;GetStringProperty("MaxPoints", strNumber))</span>
    {
<span style = "background-color:#fdd">      m_MaxNumberOfPoints = atoi(strNumber.c_str());</span>
    }
<span style = "background-color:#fdd">  }
}</span>

void mitk::PointSetDataInteractor::InitMove(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);</span>

<span style = "background-color:#fdd">  if (positionEvent == nullptr)
    return;</span>

  // start of the Movement is stored to calculate the undoKoordinate
  // in FinishMovement
<span style = "background-color:#fdd">  m_LastPoint = positionEvent-&gt;GetPositionInWorld();</span>

  // initialize a value to calculate the movement through all
  // MouseMoveEvents from MouseClick to MouseRelease
<span style = "background-color:#fdd">  m_SumVec.Fill(0);</span>

<span style = "background-color:#fdd">  GetDataNode()-&gt;SetProperty("contourcolor", ColorProperty::New(1.0, 1.0, 1.0));
}</span>

void mitk::PointSetDataInteractor::FinishMove(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  unsigned int timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(GetDataNode()-&gt;GetData());
  ScalarType timeInMs = interactionEvent-&gt;GetSender()-&gt;GetTime();</span>

<span style = "background-color:#fdd">  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);</span>

<span style = "background-color:#fdd">  if (positionEvent != nullptr)</span>
  {
    // finish the movement:
    // the final point is m_LastPoint
    // m_SumVec stores the movement in a vector
    // the operation would not be necessary, but we need it for the undo Operation.
    // m_LastPoint is for the Operation
    // the point for undoOperation calculates from all selected
    // elements (point) - m_SumVec

    // search all selected elements and move them with undo-functionality.

<span style = "background-color:#fdd">    mitk::PointSet::PointsIterator it, end;
    it = m_PointSet-&gt;Begin(timeStep);
    end = m_PointSet-&gt;End(timeStep);
    while (it != end)</span>
    {
<span style = "background-color:#fdd">      int position = it-&gt;Index();
      if (m_PointSet-&gt;GetSelectInfo(position, timeStep)) // if selected</span>
      {
<span style = "background-color:#fdd">        PointSet::PointType pt = m_PointSet-&gt;GetPoint(position, timeStep);
        Point3D itkPoint;
        itkPoint[0] = pt[0];
        itkPoint[1] = pt[1];
        itkPoint[2] = pt[2];
        auto *doOp = new mitk::PointOperation(OpMOVE, timeInMs, itkPoint, position);</span>

<span style = "background-color:#fdd">        if (m_UndoEnabled) //&amp;&amp; (posEvent-&gt;GetType() == mitk::Type_MouseButtonRelease)</span>
        {
          // set the undo-operation, so the final position is undo-able
          // calculate the old Position from the already moved position - m_SumVec
<span style = "background-color:#fdd">          mitk::Point3D undoPoint = (itkPoint - m_SumVec);
          auto *undoOp = new mitk::PointOperation(OpMOVE, timeInMs, undoPoint, position);
          OperationEvent *operationEvent = new OperationEvent(m_PointSet, doOp, undoOp, "Move point");
          OperationEvent::IncCurrObjectEventId();
          m_UndoController-&gt;SetOperationEvent(operationEvent);</span>
        }
        // execute the Operation
<span style = "background-color:#fdd">        m_PointSet-&gt;ExecuteOperation(doOp);</span>

<span style = "background-color:#fdd">        if (!m_UndoEnabled)
          delete doOp;</span>
      }
<span style = "background-color:#fdd">      ++it;
    }</span>

    // Update the display
<span style = "background-color:#fdd">    RenderingManager::GetInstance()-&gt;RequestUpdateAll();
  }</span>
  else
  {
<span style = "background-color:#fdd">    return;</span>
  }
<span style = "background-color:#fdd">  this-&gt;NotifyResultReady();
}</span>

void mitk::PointSetDataInteractor::SetAccuracy(float accuracy)
<span style = "background-color:#fdd">{
  m_SelectionAccuracy = accuracy;
}</span>

void mitk::PointSetDataInteractor::SetMaxPoints(unsigned int maxNumber)
<span style = "background-color:#fdd">{
  m_MaxNumberOfPoints = maxNumber;
}</span>

int mitk::PointSetDataInteractor::GetPointIndexByPosition(Point3D position, unsigned int time, float accuracy)
<span style = "background-color:#fdd">{</span>
  // iterate over point set and check if it contains a point close enough to the pointer to be selected
<span style = "background-color:#fdd">  auto *points = dynamic_cast&lt;PointSet *&gt;(GetDataNode()-&gt;GetData());
  int index = -1;
  if (points == nullptr)</span>
  {
<span style = "background-color:#fdd">    return index;</span>
  }

<span style = "background-color:#fdd">  if (points-&gt;GetPointSet(time) == nullptr)
    return -1;</span>

<span style = "background-color:#fdd">  PointSet::PointsContainer *pointsContainer = points-&gt;GetPointSet(time)-&gt;GetPoints();</span>

<span style = "background-color:#fdd">  float minDistance = m_SelectionAccuracy;
  if (accuracy != -1)
    minDistance = accuracy;</span>

<span style = "background-color:#fdd">  for (PointSet::PointsIterator it = pointsContainer-&gt;Begin(); it != pointsContainer-&gt;End(); it++)</span>
  {
<span style = "background-color:#fdd">    float distance = sqrt(position.SquaredEuclideanDistanceTo(points-&gt;GetPoint(it-&gt;Index(), time)));
    if (distance &lt;</span>
        minDistance) // if several points fall within the margin, choose the one with minimal distance to position
    {
<span style = "background-color:#fdd">      index = it-&gt;Index();
    }
  }
  return index;
}</span>

bool mitk::PointSetDataInteractor::CheckSelection(const mitk::InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  const auto *positionEvent = dynamic_cast&lt;const InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent != nullptr)</span>
  {
<span style = "background-color:#fdd">    const auto timeStep = interactionEvent-&gt;GetSender()-&gt;GetTimeStep(GetDataNode()-&gt;GetData());
    Point3D point = positionEvent-&gt;GetPositionInWorld();</span>
    // iterate over point set and check if it contains a point close enough to the pointer to be selected
<span style = "background-color:#fdd">    int index = GetPointIndexByPosition(point, timeStep);
    if (index != -1)
      return true;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

void mitk::PointSetDataInteractor::UnselectAll(unsigned int timeStep, ScalarType timeInMs)
<span style = "background-color:#fdd">{
  auto *pointSet = dynamic_cast&lt;mitk::PointSet *&gt;(GetDataNode()-&gt;GetData());
  if (pointSet == nullptr)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  mitk::PointSet::DataType *itkPointSet = pointSet-&gt;GetPointSet(timeStep);
  if (itkPointSet == nullptr)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

<span style = "background-color:#fdd">  mitk::PointSet::PointsContainer::Iterator it, end;
  end = itkPointSet-&gt;GetPoints()-&gt;End();</span>

<span style = "background-color:#fdd">  for (it = itkPointSet-&gt;GetPoints()-&gt;Begin(); it != end; it++)</span>
  {
<span style = "background-color:#fdd">    int position = it-&gt;Index();
    PointSet::PointDataType pointData = {0, false, PTUNDEFINED};
    itkPointSet-&gt;GetPointData(position, &amp;pointData);</span>

    // then declare an operation which unselects this point;
    // UndoOperation as well!
<span style = "background-color:#fdd">    if (pointData.selected)</span>
    {
<span style = "background-color:#fdd">      mitk::Point3D noPoint;
      noPoint.Fill(0);
      auto *doOp = new mitk::PointOperation(OpDESELECTPOINT, timeInMs, noPoint, position);</span>

      /*if ( m_UndoEnabled )
      {
        mitk::PointOperation *undoOp =
            new mitk::PointOperation(OpSELECTPOINT, timeInMs, noPoint, position);
        OperationEvent *operationEvent = new OperationEvent( pointSet, doOp, undoOp, "Unselect Point" );
        OperationEvent::IncCurrObjectEventId();
        m_UndoController-&gt;SetOperationEvent( operationEvent );
      }*/

<span style = "background-color:#fdd">      pointSet-&gt;ExecuteOperation(doOp);</span>

<span style = "background-color:#fdd">      if (!m_UndoEnabled)
        delete doOp;</span>
    }
<span style = "background-color:#fdd">  }
}</span>

void mitk::PointSetDataInteractor::SelectPoint(int position, unsigned int timeStep, ScalarType timeInMS)
<span style = "background-color:#fdd">{
  auto *pointSet = dynamic_cast&lt;mitk::PointSet *&gt;(this-&gt;GetDataNode()-&gt;GetData());</span>

  // if List is empty, then no selection of a point can be done!
<span style = "background-color:#fdd">  if ((pointSet == nullptr) || (pointSet-&gt;GetSize(timeStep) &lt;= 0))</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }

  // dummyPoint... not needed anyway
<span style = "background-color:#fdd">  mitk::Point3D noPoint;
  noPoint.Fill(0);</span>

<span style = "background-color:#fdd">  auto *doOp = new mitk::PointOperation(OpSELECTPOINT, timeInMS, noPoint, position);</span>

  /*if ( m_UndoEnabled )
  {
    mitk::PointOperation* undoOp = new mitk::PointOperation(OpDESELECTPOINT,timeInMS, noPoint, position);

    OperationEvent *operationEvent = new OperationEvent(pointSet, doOp, undoOp, "Select Point");
    OperationEvent::IncCurrObjectEventId();
    m_UndoController-&gt;SetOperationEvent(operationEvent);
  }*/

<span style = "background-color:#fdd">  pointSet-&gt;ExecuteOperation(doOp);</span>

<span style = "background-color:#fdd">  if (!m_UndoEnabled)
    delete doOp;
}</span></pre>
	</body>
</html>