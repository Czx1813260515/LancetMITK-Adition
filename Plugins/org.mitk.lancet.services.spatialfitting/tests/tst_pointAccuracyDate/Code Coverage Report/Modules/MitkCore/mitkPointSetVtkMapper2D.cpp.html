<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPointSetVtkMapper2D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPointSetVtkMapper2D.h"

// mitk includes
#include "mitkVtkPropRenderer.h"
#include &lt;mitkDataNode.h&gt;
#include &lt;mitkPlaneGeometry.h&gt;
#include &lt;mitkPointSet.h&gt;
#include &lt;mitkProperties.h&gt;

// vtk includes
#include &lt;vtkActor.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkFloatArray.h&gt;
#include &lt;vtkGlyph3D.h&gt;
#include &lt;vtkGlyphSource2D.h&gt;
#include &lt;vtkLine.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkPropAssembly.h&gt;
#include &lt;vtkTextActor.h&gt;
#include &lt;vtkTextProperty.h&gt;
#include &lt;vtkTransform.h&gt;
#include &lt;vtkTransformFilter.h&gt;

#include &lt;cstdlib&gt;

namespace
{
  double GetScreenResolution(const mitk::BaseRenderer* renderer)
<span style = "background-color:#fdd">  {
    if (nullptr == renderer)
      return 1.0;</span>

<span style = "background-color:#fdd">    mitk::Point2D pD1, pD2;
    pD1[0] = 0.0;
    pD1[1] = 0.0;
    pD2[0] = 0.0;
    pD2[1] = 1.0;</span>

    // Calculate world coordinates of in-plane screen pixels (0, 0) and (0, 1).
<span style = "background-color:#fdd">    mitk::Point3D pW1, pW2;
    renderer-&gt;DisplayToWorld(pD1, pW1);
    renderer-&gt;DisplayToWorld(pD2, pW2);</span>

    // For 2D renderers, the distance between these points is the screen resolution.
<span style = "background-color:#fdd">    return pW1.EuclideanDistanceTo(pW2);
  }</span>
}

// constructor LocalStorage
mitk::PointSetVtkMapper2D::LocalStorage::LocalStorage()
<span style = "background-color:#fdd">{</span>
  // points
<span style = "background-color:#fdd">  m_UnselectedPoints = vtkSmartPointer&lt;vtkPoints&gt;::New();
  m_SelectedPoints = vtkSmartPointer&lt;vtkPoints&gt;::New();
  m_ContourPoints = vtkSmartPointer&lt;vtkPoints&gt;::New();</span>

  // scales
<span style = "background-color:#fdd">  m_UnselectedScales = vtkSmartPointer&lt;vtkFloatArray&gt;::New();
  m_SelectedScales = vtkSmartPointer&lt;vtkFloatArray&gt;::New();</span>

  // distances
<span style = "background-color:#fdd">  m_DistancesBetweenPoints = vtkSmartPointer&lt;vtkFloatArray&gt;::New();</span>

  // lines
<span style = "background-color:#fdd">  m_ContourLines = vtkSmartPointer&lt;vtkCellArray&gt;::New();</span>

  // glyph source (provides the different shapes)
<span style = "background-color:#fdd">  m_UnselectedGlyphSource2D = vtkSmartPointer&lt;vtkGlyphSource2D&gt;::New();
  m_SelectedGlyphSource2D = vtkSmartPointer&lt;vtkGlyphSource2D&gt;::New();</span>

  // glyphs
<span style = "background-color:#fdd">  m_UnselectedGlyph3D = vtkSmartPointer&lt;vtkGlyph3D&gt;::New();
  m_SelectedGlyph3D = vtkSmartPointer&lt;vtkGlyph3D&gt;::New();</span>

  // polydata
<span style = "background-color:#fdd">  m_VtkUnselectedPointListPolyData = vtkSmartPointer&lt;vtkPolyData&gt;::New();
  m_VtkSelectedPointListPolyData = vtkSmartPointer&lt;vtkPolyData&gt;::New();
  m_VtkContourPolyData = vtkSmartPointer&lt;vtkPolyData&gt;::New();</span>

  // actors
<span style = "background-color:#fdd">  m_UnselectedActor = vtkSmartPointer&lt;vtkActor&gt;::New();
  m_SelectedActor = vtkSmartPointer&lt;vtkActor&gt;::New();
  m_ContourActor = vtkSmartPointer&lt;vtkActor&gt;::New();</span>

  // mappers
<span style = "background-color:#fdd">  m_VtkUnselectedPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
  m_VtkSelectedPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
  m_VtkContourPolyDataMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();</span>

  // propassembly
<span style = "background-color:#fdd">  m_PropAssembly = vtkSmartPointer&lt;vtkPropAssembly&gt;::New();
}</span>
// destructor LocalStorage
mitk::PointSetVtkMapper2D::LocalStorage::~LocalStorage()
<span style = "background-color:#fdd">{
}</span>

// input for this mapper ( = point set)
const mitk::PointSet *mitk::PointSetVtkMapper2D::GetInput() const
<span style = "background-color:#fdd">{
  return static_cast&lt;const mitk::PointSet *&gt;(GetDataNode()-&gt;GetData());
}</span>

// constructor PointSetVtkMapper2D
mitk::PointSetVtkMapper2D::PointSetVtkMapper2D()
<span style = "background-color:#fdd">  : m_ShowContour(false),
    m_CloseContour(false),
    m_ShowPoints(true),
    m_ShowDistances(false),
    m_DistancesDecimalDigits(1),
    m_ShowAngles(false),
    m_ShowDistantLines(false),
    m_LineWidth(1),
    m_PointLineWidth(1),
    m_Point2DSize(6),
    m_IDShapeProperty(mitk::PointSetShapeProperty::CROSS),
    m_FillShape(false),
    m_DistanceToPlane(4.0f),
    m_FixedSizeOnScreen(false)
{
}</span>

// destructor
mitk::PointSetVtkMapper2D::~PointSetVtkMapper2D()
<span style = "background-color:#fdd">{
}</span>

// reset mapper so that nothing is displayed e.g. toggle visiblity of the propassembly
void mitk::PointSetVtkMapper2D::ResetMapper(BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  LocalStorage *ls = m_LSH.GetLocalStorage(renderer);
  ls-&gt;m_PropAssembly-&gt;VisibilityOff();
}</span>

// returns propassembly
vtkProp *mitk::PointSetVtkMapper2D::GetVtkProp(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  LocalStorage *ls = m_LSH.GetLocalStorage(renderer);
  return ls-&gt;m_PropAssembly;
}</span>

static bool makePerpendicularVector2D(const mitk::Vector2D &amp;in, mitk::Vector2D &amp;out)
<span style = "background-color:#fdd">{</span>
  // The dot product of orthogonal vectors is zero.
  // In two dimensions the slopes of perpendicular lines are negative reciprocals.
<span style = "background-color:#fdd">  if ((fabs(in[0]) &gt; 0) &amp;&amp; ((fabs(in[0]) &gt; fabs(in[1])) || (in[1] == 0)))</span>
  {
    // negative reciprocal
<span style = "background-color:#fdd">    out[0] = -in[1] / in[0];
    out[1] = 1;
    out.Normalize();
    return true;
  }
  else if (fabs(in[1]) &gt; 0)</span>
  {
<span style = "background-color:#fdd">    out[0] = 1;</span>
    // negative reciprocal
<span style = "background-color:#fdd">    out[1] = -in[0] / in[1];
    out.Normalize();
    return true;
  }</span>
  else
<span style = "background-color:#fdd">    return false;
}</span>

void mitk::PointSetVtkMapper2D::CreateVTKRenderObjects(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  LocalStorage *ls = m_LSH.GetLocalStorage(renderer);</span>

<span style = "background-color:#fdd">  unsigned i = 0;</span>

  // The vtk text actors need to be removed manually from the propassembly
  // since the same vtk text actors are not overwriten within this function,
  // but new actors are added to the propassembly each time this function is executed.
  // Thus, the actors from the last call must be removed in the beginning.
<span style = "background-color:#fdd">  for (i = 0; i &lt; ls-&gt;m_VtkTextLabelActors.size(); i++)</span>
  {
<span style = "background-color:#fdd">    if (ls-&gt;m_PropAssembly-&gt;GetParts()-&gt;IsItemPresent(ls-&gt;m_VtkTextLabelActors.at(i)))
      ls-&gt;m_PropAssembly-&gt;RemovePart(ls-&gt;m_VtkTextLabelActors.at(i));
  }</span>

<span style = "background-color:#fdd">  for (i = 0; i &lt; ls-&gt;m_VtkTextDistanceActors.size(); i++)</span>
  {
<span style = "background-color:#fdd">    if (ls-&gt;m_PropAssembly-&gt;GetParts()-&gt;IsItemPresent(ls-&gt;m_VtkTextDistanceActors.at(i)))
      ls-&gt;m_PropAssembly-&gt;RemovePart(ls-&gt;m_VtkTextDistanceActors.at(i));
  }</span>

<span style = "background-color:#fdd">  for (i = 0; i &lt; ls-&gt;m_VtkTextAngleActors.size(); i++)</span>
  {
<span style = "background-color:#fdd">    if (ls-&gt;m_PropAssembly-&gt;GetParts()-&gt;IsItemPresent(ls-&gt;m_VtkTextAngleActors.at(i)))
      ls-&gt;m_PropAssembly-&gt;RemovePart(ls-&gt;m_VtkTextAngleActors.at(i));
  }</span>

  // initialize polydata here, otherwise we have update problems when
  // executing this function again
<span style = "background-color:#fdd">  ls-&gt;m_VtkUnselectedPointListPolyData = vtkSmartPointer&lt;vtkPolyData&gt;::New();
  ls-&gt;m_VtkSelectedPointListPolyData = vtkSmartPointer&lt;vtkPolyData&gt;::New();
  ls-&gt;m_VtkContourPolyData = vtkSmartPointer&lt;vtkPolyData&gt;::New();</span>

  // get input point set and update the PointSet
<span style = "background-color:#fdd">  mitk::PointSet::Pointer input = const_cast&lt;mitk::PointSet *&gt;(this-&gt;GetInput());</span>

  // only update the input data, if the property tells us to
<span style = "background-color:#fdd">  bool update = true;
  this-&gt;GetDataNode()-&gt;GetBoolProperty("updateDataOnRender", update);
  if (update == true)
    input-&gt;Update();</span>

<span style = "background-color:#fdd">  int timestep = this-&gt;GetTimestep();
  mitk::PointSet::DataType::Pointer itkPointSet = input-&gt;GetPointSet(timestep);</span>

<span style = "background-color:#fdd">  if (itkPointSet.GetPointer() == nullptr)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_PropAssembly-&gt;VisibilityOff();
    return;</span>
  }

  // iterator for point set
<span style = "background-color:#fdd">  mitk::PointSet::PointsContainer::Iterator pointsIter = itkPointSet-&gt;GetPoints()-&gt;Begin();</span>

  // PointDataContainer has additional information to each point, e.g. whether
  // it is selected or not
<span style = "background-color:#fdd">  mitk::PointSet::PointDataContainer::Iterator pointDataIter;
  pointDataIter = itkPointSet-&gt;GetPointData()-&gt;Begin();</span>

  // check if the list for the PointDataContainer is the same size as the PointsContainer.
  // If not, then the points were inserted manually and can not be visualized according to the PointData
  // (selected/unselected)
<span style = "background-color:#fdd">  bool pointDataBroken = (itkPointSet-&gt;GetPointData()-&gt;Size() != itkPointSet-&gt;GetPoints()-&gt;Size());</span>

<span style = "background-color:#fdd">  if (itkPointSet-&gt;GetPointData()-&gt;size() == 0 || pointDataBroken)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_PropAssembly-&gt;VisibilityOff();
    return;</span>
  }

<span style = "background-color:#fdd">  ls-&gt;m_PropAssembly-&gt;VisibilityOn();</span>

  // empty point sets, cellarrays, scalars
<span style = "background-color:#fdd">  ls-&gt;m_UnselectedPoints-&gt;Reset();
  ls-&gt;m_SelectedPoints-&gt;Reset();</span>

<span style = "background-color:#fdd">  ls-&gt;m_ContourPoints-&gt;Reset();
  ls-&gt;m_ContourLines-&gt;Reset();</span>

<span style = "background-color:#fdd">  ls-&gt;m_UnselectedScales-&gt;Reset();
  ls-&gt;m_SelectedScales-&gt;Reset();</span>

<span style = "background-color:#fdd">  ls-&gt;m_DistancesBetweenPoints-&gt;Reset();</span>

<span style = "background-color:#fdd">  ls-&gt;m_VtkTextLabelActors.clear();
  ls-&gt;m_VtkTextDistanceActors.clear();
  ls-&gt;m_VtkTextAngleActors.clear();</span>

<span style = "background-color:#fdd">  ls-&gt;m_UnselectedScales-&gt;SetNumberOfComponents(3);
  ls-&gt;m_SelectedScales-&gt;SetNumberOfComponents(3);</span>

<span style = "background-color:#fdd">  int NumberContourPoints = 0;
  bool pointsOnSameSideOfPlane = false;</span>

<span style = "background-color:#fdd">  const int text2dDistance = 10;</span>

  // initialize points with a random start value

  // current point in point set
<span style = "background-color:#fdd">  itk::Point&lt;ScalarType&gt; point = pointsIter-&gt;Value();</span>

<span style = "background-color:#fdd">  mitk::Point3D p = point;     // currently visited point
  mitk::Point3D lastP = point; // last visited point (predecessor in point set of "point")
  mitk::Vector3D vec;          // p - lastP
  mitk::Vector3D lastVec;      // lastP - point before lastP
  vec.Fill(0.0);
  lastVec.Fill(0.0);</span>

<span style = "background-color:#fdd">  mitk::Point2D pt2d;
  pt2d[0] = point[0]; // projected_p in display coordinates
  pt2d[1] = point[1];
  mitk::Point2D lastPt2d = pt2d;    // last projected_p in display coordinates (predecessor in point set of "pt2d")
  mitk::Point2D preLastPt2d = pt2d; // projected_p in display coordinates before lastPt2</span>

<span style = "background-color:#fdd">  const mitk::PlaneGeometry *geo2D = renderer-&gt;GetCurrentWorldPlaneGeometry();
  double resolution = GetScreenResolution(renderer);</span>

<span style = "background-color:#fdd">  vtkLinearTransform *dataNodeTransform = input-&gt;GetGeometry()-&gt;GetVtkTransform();</span>

<span style = "background-color:#fdd">  int count = 0;</span>

<span style = "background-color:#fdd">  for (pointsIter = itkPointSet-&gt;GetPoints()-&gt;Begin(); pointsIter != itkPointSet-&gt;GetPoints()-&gt;End(); pointsIter++)</span>
  {
<span style = "background-color:#fdd">    lastP = p;              // valid for number of points count &gt; 0
    preLastPt2d = lastPt2d; // valid only for count &gt; 1
    lastPt2d = pt2d;        // valid for number of points count &gt; 0</span>

<span style = "background-color:#fdd">    lastVec = vec; // valid only for counter &gt; 1</span>

    // get current point in point set
<span style = "background-color:#fdd">    point = pointsIter-&gt;Value();</span>

    // transform point
    {
      float vtkp[3];
<span style = "background-color:#fdd">      itk2vtk(point, vtkp);
      dataNodeTransform-&gt;TransformPoint(vtkp, vtkp);
      vtk2itk(vtkp, point);</span>
    }

<span style = "background-color:#fdd">    p[0] = point[0];
    p[1] = point[1];
    p[2] = point[2];</span>

<span style = "background-color:#fdd">    renderer-&gt;WorldToDisplay(p, pt2d);</span>

<span style = "background-color:#fdd">    vec = p - lastP; // valid only for counter &gt; 0</span>

    // compute distance to current plane
<span style = "background-color:#fdd">    float dist = geo2D-&gt;Distance(point);</span>
    // measure distance in screen pixel units if requested
<span style = "background-color:#fdd">    if (m_FixedSizeOnScreen)</span>
    {
<span style = "background-color:#fdd">      dist /= resolution;</span>
    }

    // draw markers on slices a certain distance away from the points
    // location according to the tolerance threshold (m_DistanceToPlane)
<span style = "background-color:#fdd">    if (dist &lt; m_DistanceToPlane)</span>
    {
      // is point selected or not?
<span style = "background-color:#fdd">      if (pointDataIter-&gt;Value().selected)</span>
      {
<span style = "background-color:#fdd">        ls-&gt;m_SelectedPoints-&gt;InsertNextPoint(point[0], point[1], point[2]);</span>
        // point is scaled according to its distance to the plane
<span style = "background-color:#fdd">        ls-&gt;m_SelectedScales-&gt;InsertNextTuple3(</span>
            std::max(0.0f, m_Point2DSize - (2 * dist)), 0, 0);
<span style = "background-color:#fdd">      }</span>
      else
      {
<span style = "background-color:#fdd">        ls-&gt;m_UnselectedPoints-&gt;InsertNextPoint(point[0], point[1], point[2]);</span>
        // point is scaled according to its distance to the plane
<span style = "background-color:#fdd">        ls-&gt;m_UnselectedScales-&gt;InsertNextTuple3(</span>
            std::max(0.0f, m_Point2DSize - (2 * dist)), 0, 0);
      }

      //---- LABEL -----//
      // paint label for each point if available
<span style = "background-color:#fdd">      if (dynamic_cast&lt;mitk::StringProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("label")) != nullptr)</span>
      {
<span style = "background-color:#fdd">        const char *pointLabel =</span>
          dynamic_cast&lt;mitk::StringProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("label"))-&gt;GetValue();
<span style = "background-color:#fdd">        std::string l = pointLabel;
        if (input-&gt;GetSize() &gt; 1)</span>
        {
<span style = "background-color:#fdd">          std::stringstream ss;
          ss &lt;&lt; pointsIter-&gt;Index();
          l.append(ss.str());
        }</span>

<span style = "background-color:#fdd">        ls-&gt;m_VtkTextActor = vtkSmartPointer&lt;vtkTextActor&gt;::New();</span>

<span style = "background-color:#fdd">        ls-&gt;m_VtkTextActor-&gt;SetDisplayPosition(pt2d[0] + text2dDistance, pt2d[1] + text2dDistance);
        ls-&gt;m_VtkTextActor-&gt;SetInput(l.c_str());
        ls-&gt;m_VtkTextActor-&gt;GetTextProperty()-&gt;SetOpacity(100);</span>

<span style = "background-color:#fdd">        float unselectedColor[4] = {1.0, 1.0, 0.0, 1.0};</span>

        // check if there is a color property
<span style = "background-color:#fdd">        GetDataNode()-&gt;GetColor(unselectedColor);</span>

<span style = "background-color:#fdd">        ls-&gt;m_VtkTextActor-&gt;GetTextProperty()-&gt;SetColor(unselectedColor[0], unselectedColor[1], unselectedColor[2]);</span>

<span style = "background-color:#fdd">        ls-&gt;m_VtkTextLabelActors.push_back(ls-&gt;m_VtkTextActor);
      }</span>
    }

    // draw contour, distance text and angle text in render window

    // lines between points, which intersect the current plane, are drawn
<span style = "background-color:#fdd">    if (m_ShowContour &amp;&amp; count &gt; 0)</span>
    {
<span style = "background-color:#fdd">      ScalarType distance = renderer-&gt;GetCurrentWorldPlaneGeometry()-&gt;SignedDistance(point);
      ScalarType lastDistance = renderer-&gt;GetCurrentWorldPlaneGeometry()-&gt;SignedDistance(lastP);</span>

<span style = "background-color:#fdd">      pointsOnSameSideOfPlane = (distance * lastDistance) &gt; 0.5;</span>

      // Points must be on different side of plane in order to draw a contour.
      // If "show distant lines" is enabled this condition is disregarded.
<span style = "background-color:#fdd">      if (!pointsOnSameSideOfPlane || m_ShowDistantLines)</span>
      {
<span style = "background-color:#fdd">        vtkSmartPointer&lt;vtkLine&gt; line = vtkSmartPointer&lt;vtkLine&gt;::New();</span>

<span style = "background-color:#fdd">        ls-&gt;m_ContourPoints-&gt;InsertNextPoint(lastP[0], lastP[1], lastP[2]);
        line-&gt;GetPointIds()-&gt;SetId(0, NumberContourPoints);
        NumberContourPoints++;</span>

<span style = "background-color:#fdd">        ls-&gt;m_ContourPoints-&gt;InsertNextPoint(point[0], point[1], point[2]);
        line-&gt;GetPointIds()-&gt;SetId(1, NumberContourPoints);
        NumberContourPoints++;</span>

<span style = "background-color:#fdd">        ls-&gt;m_ContourLines-&gt;InsertNextCell(line);</span>

<span style = "background-color:#fdd">        if (m_ShowDistances) // calculate and print distance between adjacent points</span>
        {
<span style = "background-color:#fdd">          float distancePoints = point.EuclideanDistanceTo(lastP);</span>

<span style = "background-color:#fdd">          std::stringstream buffer;
          buffer &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_DistancesDecimalDigits) &lt;&lt; distancePoints &lt;&lt; " mm";</span>

          // compute desired display position of text
<span style = "background-color:#fdd">          Vector2D vec2d = pt2d - lastPt2d;
          makePerpendicularVector2D(vec2d,</span>
                                    vec2d); // text is rendered within text2dDistance perpendicular to current line
<span style = "background-color:#fdd">          Vector2D pos2d = (lastPt2d.GetVectorFromOrigin() + pt2d.GetVectorFromOrigin()) * 0.5 + vec2d * text2dDistance;</span>

<span style = "background-color:#fdd">          ls-&gt;m_VtkTextActor = vtkSmartPointer&lt;vtkTextActor&gt;::New();</span>

<span style = "background-color:#fdd">          ls-&gt;m_VtkTextActor-&gt;SetDisplayPosition(pos2d[0], pos2d[1]);
          ls-&gt;m_VtkTextActor-&gt;SetInput(buffer.str().c_str());
          ls-&gt;m_VtkTextActor-&gt;GetTextProperty()-&gt;SetColor(0.0, 1.0, 0.0);</span>

<span style = "background-color:#fdd">          ls-&gt;m_VtkTextDistanceActors.push_back(ls-&gt;m_VtkTextActor);
        }</span>

<span style = "background-color:#fdd">        if (m_ShowAngles &amp;&amp; count &gt; 1) // calculate and print angle between connected lines</span>
        {
<span style = "background-color:#fdd">          std::stringstream buffer;
          buffer &lt;&lt; angle(vec.GetVnlVector(), -lastVec.GetVnlVector()) * 180 / vnl_math::pi &lt;&lt; "Â°";</span>

          // compute desired display position of text
<span style = "background-color:#fdd">          Vector2D vec2d = pt2d - lastPt2d; // first arm enclosing the angle
          vec2d.Normalize();
          Vector2D lastVec2d = lastPt2d - preLastPt2d; // second arm enclosing the angle
          lastVec2d.Normalize();
          vec2d = vec2d - lastVec2d; // vector connecting both arms
          vec2d.Normalize();</span>

          // middle between two vectors that enclose the angle
<span style = "background-color:#fdd">          Vector2D pos2d = lastPt2d.GetVectorFromOrigin() + vec2d * text2dDistance * text2dDistance;</span>

<span style = "background-color:#fdd">          ls-&gt;m_VtkTextActor = vtkSmartPointer&lt;vtkTextActor&gt;::New();</span>

<span style = "background-color:#fdd">          ls-&gt;m_VtkTextActor-&gt;SetDisplayPosition(pos2d[0], pos2d[1]);
          ls-&gt;m_VtkTextActor-&gt;SetInput(buffer.str().c_str());
          ls-&gt;m_VtkTextActor-&gt;GetTextProperty()-&gt;SetColor(0.0, 1.0, 0.0);</span>

<span style = "background-color:#fdd">          ls-&gt;m_VtkTextAngleActors.push_back(ls-&gt;m_VtkTextActor);
        }
      }</span>
    }

<span style = "background-color:#fdd">    if (pointDataIter != itkPointSet-&gt;GetPointData()-&gt;End())</span>
    {
<span style = "background-color:#fdd">      pointDataIter++;
      count++;</span>
    }
<span style = "background-color:#fdd">  }</span>

  // add each single text actor to the assembly
<span style = "background-color:#fdd">  for (i = 0; i &lt; ls-&gt;m_VtkTextLabelActors.size(); i++)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_PropAssembly-&gt;AddPart(ls-&gt;m_VtkTextLabelActors.at(i));
  }</span>

<span style = "background-color:#fdd">  for (i = 0; i &lt; ls-&gt;m_VtkTextDistanceActors.size(); i++)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_PropAssembly-&gt;AddPart(ls-&gt;m_VtkTextDistanceActors.at(i));
  }</span>

<span style = "background-color:#fdd">  for (i = 0; i &lt; ls-&gt;m_VtkTextAngleActors.size(); i++)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_PropAssembly-&gt;AddPart(ls-&gt;m_VtkTextAngleActors.at(i));
  }</span>

  //---- CONTOUR -----//

  // create lines between the points which intersect the plane
<span style = "background-color:#fdd">  if (m_ShowContour)</span>
  {
    // draw line between first and last point which is rendered
<span style = "background-color:#fdd">    if (m_CloseContour &amp;&amp; NumberContourPoints &gt; 1)</span>
    {
<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkLine&gt; closingLine = vtkSmartPointer&lt;vtkLine&gt;::New();
      closingLine-&gt;GetPointIds()-&gt;SetId(0, 0);                       // index of first point
      closingLine-&gt;GetPointIds()-&gt;SetId(1, NumberContourPoints - 1); // index of last point
      ls-&gt;m_ContourLines-&gt;InsertNextCell(closingLine);
    }</span>

<span style = "background-color:#fdd">    ls-&gt;m_VtkContourPolyData-&gt;SetPoints(ls-&gt;m_ContourPoints);
    ls-&gt;m_VtkContourPolyData-&gt;SetLines(ls-&gt;m_ContourLines);</span>

<span style = "background-color:#fdd">    ls-&gt;m_VtkContourPolyDataMapper-&gt;SetInputData(ls-&gt;m_VtkContourPolyData);
    ls-&gt;m_ContourActor-&gt;SetMapper(ls-&gt;m_VtkContourPolyDataMapper);
    ls-&gt;m_ContourActor-&gt;GetProperty()-&gt;SetLineWidth(m_LineWidth);</span>

<span style = "background-color:#fdd">    ls-&gt;m_PropAssembly-&gt;AddPart(ls-&gt;m_ContourActor);</span>
  }

  // the point set must be transformed in order to obtain the appropriate glyph orientation
  // according to the current view
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkTransform&gt; transform = vtkSmartPointer&lt;vtkTransform&gt;::New();
  vtkSmartPointer&lt;vtkMatrix4x4&gt; a, b = vtkSmartPointer&lt;vtkMatrix4x4&gt;::New();</span>

<span style = "background-color:#fdd">  a = geo2D-&gt;GetVtkTransform()-&gt;GetMatrix();
  b-&gt;DeepCopy(a);</span>

  // delete transformation from matrix, only take orientation
<span style = "background-color:#fdd">  b-&gt;SetElement(3, 3, 1);
  b-&gt;SetElement(2, 3, 0);
  b-&gt;SetElement(1, 3, 0);
  b-&gt;SetElement(0, 3, 0);
  b-&gt;SetElement(3, 2, 0);
  b-&gt;SetElement(3, 1, 0);
  b-&gt;SetElement(3, 0, 0);</span>

<span style = "background-color:#fdd">  Vector3D spacing = geo2D-&gt;GetSpacing();</span>

  // If you find a way to simplyfy the following, feel free to change!
<span style = "background-color:#fdd">  b-&gt;SetElement(0, 0, b-&gt;GetElement(0, 0) / spacing[0]);
  b-&gt;SetElement(1, 0, b-&gt;GetElement(1, 0) / spacing[0]);
  b-&gt;SetElement(2, 0, b-&gt;GetElement(2, 0) / spacing[0]);
  b-&gt;SetElement(1, 1, b-&gt;GetElement(1, 1) / spacing[1]);
  b-&gt;SetElement(2, 1, b-&gt;GetElement(2, 1) / spacing[1]);</span>

<span style = "background-color:#fdd">  b-&gt;SetElement(0, 2, b-&gt;GetElement(0, 2) / spacing[2]);
  b-&gt;SetElement(1, 2, b-&gt;GetElement(1, 2) / spacing[2]);
  b-&gt;SetElement(2, 2, b-&gt;GetElement(2, 2) / spacing[2]);</span>

<span style = "background-color:#fdd">  transform-&gt;SetMatrix(b);</span>

  //---- UNSELECTED POINTS  -----//

  // apply properties to glyph
<span style = "background-color:#fdd">  ls-&gt;m_UnselectedGlyphSource2D-&gt;SetGlyphType(m_IDShapeProperty);</span>

<span style = "background-color:#fdd">  if (m_FillShape)
    ls-&gt;m_UnselectedGlyphSource2D-&gt;FilledOn();</span>
  else
<span style = "background-color:#fdd">    ls-&gt;m_UnselectedGlyphSource2D-&gt;FilledOff();</span>

  // apply transform
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkTransformFilter&gt; transformFilterU = vtkSmartPointer&lt;vtkTransformFilter&gt;::New();
  transformFilterU-&gt;SetInputConnection(ls-&gt;m_UnselectedGlyphSource2D-&gt;GetOutputPort());
  transformFilterU-&gt;SetTransform(transform);</span>

<span style = "background-color:#fdd">  ls-&gt;m_VtkUnselectedPointListPolyData-&gt;SetPoints(ls-&gt;m_UnselectedPoints);
  ls-&gt;m_VtkUnselectedPointListPolyData-&gt;GetPointData()-&gt;SetVectors(ls-&gt;m_UnselectedScales);</span>

  // apply transform of current plane to glyphs
<span style = "background-color:#fdd">  ls-&gt;m_UnselectedGlyph3D-&gt;SetSourceConnection(transformFilterU-&gt;GetOutputPort());
  ls-&gt;m_UnselectedGlyph3D-&gt;SetInputData(ls-&gt;m_VtkUnselectedPointListPolyData);
  ls-&gt;m_UnselectedGlyph3D-&gt;SetScaleFactor(m_FixedSizeOnScreen ? resolution : 1.0);
  ls-&gt;m_UnselectedGlyph3D-&gt;SetScaleModeToScaleByVector();
  ls-&gt;m_UnselectedGlyph3D-&gt;SetVectorModeToUseVector();</span>

<span style = "background-color:#fdd">  ls-&gt;m_VtkUnselectedPolyDataMapper-&gt;SetInputConnection(ls-&gt;m_UnselectedGlyph3D-&gt;GetOutputPort());
  ls-&gt;m_UnselectedActor-&gt;SetMapper(ls-&gt;m_VtkUnselectedPolyDataMapper);
  ls-&gt;m_UnselectedActor-&gt;GetProperty()-&gt;SetLineWidth(m_PointLineWidth);</span>

<span style = "background-color:#fdd">  ls-&gt;m_PropAssembly-&gt;AddPart(ls-&gt;m_UnselectedActor);</span>

  //---- SELECTED POINTS  -----//

<span style = "background-color:#fdd">  ls-&gt;m_SelectedGlyphSource2D-&gt;SetGlyphTypeToDiamond();
  ls-&gt;m_SelectedGlyphSource2D-&gt;CrossOn();
  ls-&gt;m_SelectedGlyphSource2D-&gt;FilledOff();</span>

  // apply transform
<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkTransformFilter&gt; transformFilterS = vtkSmartPointer&lt;vtkTransformFilter&gt;::New();
  transformFilterS-&gt;SetInputConnection(ls-&gt;m_SelectedGlyphSource2D-&gt;GetOutputPort());
  transformFilterS-&gt;SetTransform(transform);</span>

<span style = "background-color:#fdd">  ls-&gt;m_VtkSelectedPointListPolyData-&gt;SetPoints(ls-&gt;m_SelectedPoints);
  ls-&gt;m_VtkSelectedPointListPolyData-&gt;GetPointData()-&gt;SetVectors(ls-&gt;m_SelectedScales);</span>

  // apply transform of current plane to glyphs
<span style = "background-color:#fdd">  ls-&gt;m_SelectedGlyph3D-&gt;SetSourceConnection(transformFilterS-&gt;GetOutputPort());
  ls-&gt;m_SelectedGlyph3D-&gt;SetInputData(ls-&gt;m_VtkSelectedPointListPolyData);
  ls-&gt;m_SelectedGlyph3D-&gt;SetScaleFactor(m_FixedSizeOnScreen ? resolution : 1.0);
  ls-&gt;m_SelectedGlyph3D-&gt;SetScaleModeToScaleByVector();
  ls-&gt;m_SelectedGlyph3D-&gt;SetVectorModeToUseVector();</span>

<span style = "background-color:#fdd">  ls-&gt;m_VtkSelectedPolyDataMapper-&gt;SetInputConnection(ls-&gt;m_SelectedGlyph3D-&gt;GetOutputPort());
  ls-&gt;m_SelectedActor-&gt;SetMapper(ls-&gt;m_VtkSelectedPolyDataMapper);
  ls-&gt;m_SelectedActor-&gt;GetProperty()-&gt;SetLineWidth(m_PointLineWidth);</span>

<span style = "background-color:#fdd">  ls-&gt;m_PropAssembly-&gt;AddPart(ls-&gt;m_SelectedActor);
}</span>

void mitk::PointSetVtkMapper2D::GenerateDataForRenderer(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  const mitk::DataNode *node = GetDataNode();
  if (node == nullptr)
    return;</span>

<span style = "background-color:#fdd">  LocalStorage *ls = m_LSH.GetLocalStorage(renderer);</span>

  // check whether the input data has been changed
<span style = "background-color:#fdd">  bool needGenerateData = ls-&gt;IsGenerateDataRequired(renderer, this, GetDataNode());</span>

  // toggle visibility
<span style = "background-color:#fdd">  bool visible = true;
  node-&gt;GetVisibility(visible, renderer, "visible");
  if (!visible)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;m_UnselectedActor-&gt;VisibilityOff();
    ls-&gt;m_SelectedActor-&gt;VisibilityOff();
    ls-&gt;m_ContourActor-&gt;VisibilityOff();
    ls-&gt;m_PropAssembly-&gt;VisibilityOff();
    return;
  }</span>
  else
  {
<span style = "background-color:#fdd">    ls-&gt;m_PropAssembly-&gt;VisibilityOn();</span>
  }

<span style = "background-color:#fdd">  node-&gt;GetBoolProperty("show contour", m_ShowContour, renderer);
  node-&gt;GetBoolProperty("close contour", m_CloseContour, renderer);
  node-&gt;GetBoolProperty("show points", m_ShowPoints, renderer);
  node-&gt;GetBoolProperty("show distances", m_ShowDistances, renderer);
  node-&gt;GetIntProperty("distance decimal digits", m_DistancesDecimalDigits, renderer);
  node-&gt;GetBoolProperty("show angles", m_ShowAngles, renderer);
  node-&gt;GetBoolProperty("show distant lines", m_ShowDistantLines, renderer);
  node-&gt;GetIntProperty("line width", m_LineWidth, renderer);
  node-&gt;GetIntProperty("point line width", m_PointLineWidth, renderer);
  if (!node-&gt;GetFloatProperty(</span>
        "point 2D size", m_Point2DSize, renderer)) // re-defined to float 2015-08-13, keep a fallback
  {
<span style = "background-color:#fdd">    int oldPointSize = m_Point2DSize;
    if (node-&gt;GetIntProperty("point 2D size", oldPointSize, renderer))</span>
    {
<span style = "background-color:#fdd">      m_Point2DSize = oldPointSize;</span>
    }
  }
<span style = "background-color:#fdd">  node-&gt;GetBoolProperty("Pointset.2D.fill shape", m_FillShape, renderer);
  node-&gt;GetFloatProperty("Pointset.2D.distance to plane", m_DistanceToPlane, renderer);
  node-&gt;GetBoolProperty("Pointset.2D.fixed size on screen", m_FixedSizeOnScreen, renderer);</span>

<span style = "background-color:#fdd">  mitk::PointSetShapeProperty::Pointer shape =</span>
    dynamic_cast&lt;mitk::PointSetShapeProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("Pointset.2D.shape", renderer));
<span style = "background-color:#fdd">  if (shape.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    m_IDShapeProperty = shape-&gt;GetPointSetShape();</span>
  }

  // check for color props and use it for rendering of selected/unselected points and contour
  // due to different params in VTK (double/float) we have to convert

<span style = "background-color:#fdd">  float opacity = 1.0;</span>

<span style = "background-color:#fdd">  GetDataNode()-&gt;GetOpacity(opacity, renderer);</span>

  // apply color and opacity
<span style = "background-color:#fdd">  if (m_ShowPoints)</span>
  {
    float unselectedColor[4];
<span style = "background-color:#fdd">    double selectedColor[4] = {1.0f, 0.0f, 0.0f, 1.0f}; // red</span>

<span style = "background-color:#fdd">    ls-&gt;m_UnselectedActor-&gt;VisibilityOn();
    ls-&gt;m_SelectedActor-&gt;VisibilityOn();</span>

    // check if there is a color property
<span style = "background-color:#fdd">    GetDataNode()-&gt;GetColor(unselectedColor);</span>

    // get selected color property
    if (dynamic_cast&lt;mitk::ColorProperty *&gt;(
<span style = "background-color:#fdd">          this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("selectedcolor")) != nullptr)</span>
    {
<span style = "background-color:#fdd">      mitk::Color tmpColor = dynamic_cast&lt;mitk::ColorProperty *&gt;(</span>
                               this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("selectedcolor"))
                               -&gt;GetValue();
<span style = "background-color:#fdd">      selectedColor[0] = tmpColor[0];
      selectedColor[1] = tmpColor[1];
      selectedColor[2] = tmpColor[2];
      selectedColor[3] = 1.0f; // alpha value
    }</span>
    else if (dynamic_cast&lt;mitk::ColorProperty *&gt;(
<span style = "background-color:#fdd">               this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("selectedcolor")) != nullptr)</span>
    {
<span style = "background-color:#fdd">      mitk::Color tmpColor =</span>
        dynamic_cast&lt;mitk::ColorProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("selectedcolor"))
          -&gt;GetValue();
<span style = "background-color:#fdd">      selectedColor[0] = tmpColor[0];
      selectedColor[1] = tmpColor[1];
      selectedColor[2] = tmpColor[2];
      selectedColor[3] = 1.0f; // alpha value</span>
    }

<span style = "background-color:#fdd">    ls-&gt;m_SelectedActor-&gt;GetProperty()-&gt;SetColor(selectedColor);
    ls-&gt;m_SelectedActor-&gt;GetProperty()-&gt;SetOpacity(opacity);</span>

<span style = "background-color:#fdd">    ls-&gt;m_UnselectedActor-&gt;GetProperty()-&gt;SetColor(unselectedColor[0], unselectedColor[1], unselectedColor[2]);
    ls-&gt;m_UnselectedActor-&gt;GetProperty()-&gt;SetOpacity(opacity);
  }</span>
  else
  {
<span style = "background-color:#fdd">    ls-&gt;m_UnselectedActor-&gt;VisibilityOff();
    ls-&gt;m_SelectedActor-&gt;VisibilityOff();</span>
  }

<span style = "background-color:#fdd">  if (m_ShowContour)</span>
  {
<span style = "background-color:#fdd">    double contourColor[4] = {1.0f, 0.0f, 0.0f, 1.0f}; // red
    ls-&gt;m_ContourActor-&gt;VisibilityOn();</span>

    // get contour color property
    if (dynamic_cast&lt;mitk::ColorProperty *&gt;(
<span style = "background-color:#fdd">          this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("contourcolor")) != nullptr)</span>
    {
<span style = "background-color:#fdd">      mitk::Color tmpColor =</span>
        dynamic_cast&lt;mitk::ColorProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(renderer)-&gt;GetProperty("contourcolor"))
          -&gt;GetValue();
<span style = "background-color:#fdd">      contourColor[0] = tmpColor[0];
      contourColor[1] = tmpColor[1];
      contourColor[2] = tmpColor[2];
      contourColor[3] = 1.0f;
    }</span>
    else if (dynamic_cast&lt;mitk::ColorProperty *&gt;(
<span style = "background-color:#fdd">               this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("contourcolor")) != nullptr)</span>
    {
<span style = "background-color:#fdd">      mitk::Color tmpColor =</span>
        dynamic_cast&lt;mitk::ColorProperty *&gt;(this-&gt;GetDataNode()-&gt;GetPropertyList(nullptr)-&gt;GetProperty("contourcolor"))
          -&gt;GetValue();
<span style = "background-color:#fdd">      contourColor[0] = tmpColor[0];
      contourColor[1] = tmpColor[1];
      contourColor[2] = tmpColor[2];
      contourColor[3] = 1.0f;</span>
    }

<span style = "background-color:#fdd">    ls-&gt;m_ContourActor-&gt;GetProperty()-&gt;SetColor(contourColor);
    ls-&gt;m_ContourActor-&gt;GetProperty()-&gt;SetOpacity(opacity);
  }</span>
  else
  {
<span style = "background-color:#fdd">    ls-&gt;m_ContourActor-&gt;VisibilityOff();</span>
  }

<span style = "background-color:#fdd">  if (needGenerateData)</span>
  {
    // create new vtk render objects (e.g. a circle for a point)
<span style = "background-color:#fdd">    this-&gt;CreateVTKRenderObjects(renderer);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::PointSetVtkMapper2D::SetDefaultProperties(mitk::DataNode *node, mitk::BaseRenderer *renderer, bool overwrite)
<span style = "background-color:#fdd">{
  node-&gt;AddProperty("line width", mitk::IntProperty::New(2), renderer, overwrite);
  node-&gt;AddProperty("point line width", mitk::IntProperty::New(1), renderer, overwrite);
  node-&gt;AddProperty("point 2D size", mitk::FloatProperty::New(6), renderer, overwrite);
  node-&gt;AddProperty("show contour", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("close contour", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("show points", mitk::BoolProperty::New(true), renderer, overwrite);
  node-&gt;AddProperty("show distances", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("distance decimal digits", mitk::IntProperty::New(2), renderer, overwrite);
  node-&gt;AddProperty("show angles", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("show distant lines", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("layer", mitk::IntProperty::New(1), renderer, overwrite);
  node-&gt;AddProperty("Pointset.2D.fill shape",</span>
                    mitk::BoolProperty::New(false),
                    renderer,
                    overwrite); // fill or do not fill the glyph shape
<span style = "background-color:#fdd">  mitk::PointSetShapeProperty::Pointer pointsetShapeProperty = mitk::PointSetShapeProperty::New();
  node-&gt;AddProperty("Pointset.2D.shape", pointsetShapeProperty, renderer, overwrite);
  node-&gt;AddProperty("Pointset.2D.distance to plane",</span>
                    mitk::FloatProperty::New(4.0f),
                    renderer,
                    overwrite); // show the point at a certain distance above/below the 2D imaging plane.
<span style = "background-color:#fdd">  node-&gt;AddProperty("Pointset.2D.fixed size on screen", mitk::BoolProperty::New(false), renderer, overwrite);</span>

<span style = "background-color:#fdd">  Superclass::SetDefaultProperties(node, renderer, overwrite);
}</span></pre>
	</body>
</html>