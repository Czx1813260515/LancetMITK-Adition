<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkExtractSliceFilter2.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;mitkExtractSliceFilter2.h&gt;
#include &lt;mitkExceptionMacro.h&gt;
#include &lt;mitkImageAccessByItk.h&gt;
#include &lt;mitkImageWriteAccessor.h&gt;

#include &lt;itkBSplineInterpolateImageFunction.h&gt;
#include &lt;itkLinearInterpolateImageFunction.h&gt;
#include &lt;itkNearestNeighborInterpolateImageFunction.h&gt;

#include &lt;limits&gt;

struct mitk::ExtractSliceFilter2::Impl
{
  Impl();
  ~Impl();

  PlaneGeometry::Pointer OutputGeometry;
  mitk::ExtractSliceFilter2::Interpolator Interpolator;
  itk::Object::Pointer InterpolateImageFunction;
};

mitk::ExtractSliceFilter2::Impl::Impl()
<span style = "background-color:#fdd">  : Interpolator(NearestNeighbor)
{
}</span>

mitk::ExtractSliceFilter2::Impl::~Impl()
<span style = "background-color:#fdd">{
}</span>

namespace
{
  template &lt;class TInputImage&gt;
  void CreateInterpolateImageFunction(const TInputImage* inputImage, mitk::ExtractSliceFilter2::Interpolator interpolator, itk::Object::Pointer&amp; result)
<span style = "background-color:#fdd">  {
    typename itk::InterpolateImageFunction&lt;TInputImage&gt;::Pointer interpolateImageFunction;</span>

<span style = "background-color:#fdd">    switch (interpolator)</span>
    {
      case mitk::ExtractSliceFilter2::NearestNeighbor:
<span style = "background-color:#fdd">        interpolateImageFunction = itk::NearestNeighborInterpolateImageFunction&lt;TInputImage&gt;::New().GetPointer();
        break;</span>

      case mitk::ExtractSliceFilter2::Linear:
<span style = "background-color:#fdd">        interpolateImageFunction = itk::LinearInterpolateImageFunction&lt;TInputImage&gt;::New().GetPointer();
        break;</span>

      case mitk::ExtractSliceFilter2::Cubic:
      {
<span style = "background-color:#fdd">        auto bSplineInterpolateImageFunction = itk::BSplineInterpolateImageFunction&lt;TInputImage&gt;::New();
        bSplineInterpolateImageFunction-&gt;SetSplineOrder(2);
        interpolateImageFunction = bSplineInterpolateImageFunction.GetPointer();
        break;
      }</span>

      default:
<span style = "background-color:#fdd">        mitkThrow() &lt;&lt; "Interplator is unknown.";</span>
    }

<span style = "background-color:#fdd">    interpolateImageFunction-&gt;SetInputImage(inputImage);</span>

<span style = "background-color:#fdd">    result = interpolateImageFunction.GetPointer();
  }</span>

  template &lt;typename TPixel, unsigned int VImageDimension&gt;
  void GenerateData(const itk::Image&lt;TPixel, VImageDimension&gt;* inputImage, mitk::Image* outputImage, const mitk::ExtractSliceFilter2::OutputImageRegionType&amp; outputRegion, itk::Object* interpolateImageFunction)
<span style = "background-color:#fdd">  {</span>
    typedef itk::Image&lt;TPixel, VImageDimension&gt; TInputImage;
    typedef itk::InterpolateImageFunction&lt;TInputImage&gt; TInterpolateImageFunction;

<span style = "background-color:#fdd">    auto outputGeometry = outputImage-&gt;GetSlicedGeometry()-&gt;GetPlaneGeometry(0);
    auto interpolator = static_cast&lt;TInterpolateImageFunction*&gt;(interpolateImageFunction);</span>

<span style = "background-color:#fdd">    auto origin = outputGeometry-&gt;GetOrigin();
    auto spacing = outputGeometry-&gt;GetSpacing();
    auto xDirection = outputGeometry-&gt;GetAxisVector(0);
    auto yDirection = outputGeometry-&gt;GetAxisVector(1);</span>

<span style = "background-color:#fdd">    xDirection.Normalize();
    yDirection.Normalize();</span>

<span style = "background-color:#fdd">    auto spacingAlongXDirection = xDirection * spacing[0];
    auto spacingAlongYDirection = yDirection * spacing[1];</span>

<span style = "background-color:#fdd">    const std::size_t pixelSize = outputImage-&gt;GetPixelType().GetSize();
    const std::size_t width = outputGeometry-&gt;GetExtent(0);
    const std::size_t xBegin = outputRegion.GetIndex(0);
    const std::size_t yBegin = outputRegion.GetIndex(1);
    const std::size_t xEnd = xBegin + outputRegion.GetSize(0);
    const std::size_t yEnd = yBegin + outputRegion.GetSize(1);</span>

<span style = "background-color:#fdd">    mitk::ImageWriteAccessor writeAccess(outputImage, nullptr, mitk::ImageAccessorBase::IgnoreLock);
    auto data = static_cast&lt;char*&gt;(writeAccess.GetData());</span>

<span style = "background-color:#fdd">    const TPixel backgroundPixel = std::numeric_limits&lt;TPixel&gt;::lowest();</span>
    TPixel pixel;

    itk::ContinuousIndex&lt;mitk::ScalarType, 3&gt; index;
<span style = "background-color:#fdd">    mitk::Point3D yPoint;
    mitk::Point3D point;</span>

<span style = "background-color:#fdd">    for (std::size_t y = yBegin; y &lt; yEnd; ++y)</span>
    {
<span style = "background-color:#fdd">      yPoint = origin + spacingAlongYDirection * y;</span>

<span style = "background-color:#fdd">      for (std::size_t x = xBegin; x &lt; xEnd; ++x)</span>
      {
<span style = "background-color:#fdd">        point = yPoint + spacingAlongXDirection * x;</span>

<span style = "background-color:#fdd">        if (inputImage-&gt;TransformPhysicalPointToContinuousIndex(point, index))</span>
        {
<span style = "background-color:#fdd">          pixel = interpolator-&gt;EvaluateAtContinuousIndex(index);
          memcpy(static_cast&lt;void*&gt;(data + pixelSize * (width * y + x)), static_cast&lt;const void*&gt;(&amp;pixel), pixelSize);
        }</span>
        else
        {
<span style = "background-color:#fdd">          memcpy(static_cast&lt;void*&gt;(data + pixelSize * (width * y + x)), static_cast&lt;const void*&gt;(&amp;backgroundPixel), pixelSize);</span>
        }
<span style = "background-color:#fdd">      }
    }
  }</span>

  void VerifyInputImage(const mitk::Image* inputImage)
<span style = "background-color:#fdd">  {
    auto dimension = inputImage-&gt;GetDimension();</span>

<span style = "background-color:#fdd">    if (3 != dimension)
      mitkThrow() &lt;&lt; "Input images with " &lt;&lt; dimension &lt;&lt; " dimensions are not supported.";</span>

<span style = "background-color:#fdd">    if (!inputImage-&gt;IsInitialized())
      mitkThrow() &lt;&lt; "Input image is not initialized.";</span>

<span style = "background-color:#fdd">    if (!inputImage-&gt;IsVolumeSet())
      mitkThrow() &lt;&lt; "Input image volume is not set.";</span>

<span style = "background-color:#fdd">    auto geometry = inputImage-&gt;GetGeometry();</span>

<span style = "background-color:#fdd">    if (nullptr == geometry || !geometry-&gt;IsValid())
      mitkThrow() &lt;&lt; "Input image has invalid geometry.";</span>

<span style = "background-color:#fdd">    if (!geometry-&gt;GetImageGeometry())
      mitkThrow() &lt;&lt; "Geometry of input image is not an image geometry.";
  }</span>

  void VerifyOutputGeometry(const mitk::PlaneGeometry* outputGeometry)
<span style = "background-color:#fdd">  {
    if (nullptr == outputGeometry)
      mitkThrow() &lt;&lt; "Output geometry is not set.";</span>

<span style = "background-color:#fdd">    if (!outputGeometry-&gt;GetImageGeometry())
      mitkThrow() &lt;&lt; "Output geometry is not an image geometry.";
  }</span>
}

mitk::ExtractSliceFilter2::ExtractSliceFilter2()
<span style = "background-color:#fdd">  : m_Impl(new Impl)
{
}</span>

mitk::ExtractSliceFilter2::~ExtractSliceFilter2()
<span style = "background-color:#fdd">{
  delete m_Impl;
}</span>

void mitk::ExtractSliceFilter2::AllocateOutputs()
<span style = "background-color:#fdd">{
  const auto* inputImage = this-&gt;GetInput();
  const auto* outputGeometry = this-&gt;GetOutputGeometry();
  auto outputImage = this-&gt;GetOutput();
  auto pixelType = inputImage-&gt;GetPixelType();</span>

<span style = "background-color:#fdd">  outputImage-&gt;Initialize(pixelType, 1, *outputGeometry);</span>

<span style = "background-color:#fdd">  auto data = new char[static_cast&lt;std::size_t&gt;(pixelType.GetSize() * outputGeometry-&gt;GetExtent(0) * outputGeometry-&gt;GetExtent(1))];</span>

  try
  {
<span style = "background-color:#fdd">    if (!outputImage-&gt;SetImportVolume(data, 0, 0, mitk::Image::ReferenceMemory))
      throw;</span>
  }
  catch (...)
<span style = "background-color:#fdd">  {
    delete[] data;
  }
}</span>

/*void mitk::ExtractSliceFilter2::BeforeThreadedGenerateData()
{
  if (nullptr != m_Impl-&gt;InterpolateImageFunction &amp;&amp; this-&gt;GetInput()-&gt;GetMTime() &lt; this-&gt;GetMTime())
    return;

  const auto* inputImage = this-&gt;GetInput();
  AccessFixedDimensionByItk_2(inputImage, CreateInterpolateImageFunction, 3, this-&gt;GetInterpolator(), m_Impl-&gt;InterpolateImageFunction);
}

void mitk::ExtractSliceFilter2::ThreadedGenerateData(const OutputImageRegionType&amp; outputRegionForThread, itk::ThreadIdType)
{
  const auto* inputImage = this-&gt;GetInput();
  AccessFixedDimensionByItk_3(inputImage, ::GenerateData, 3, this-&gt;GetOutput(), outputRegionForThread, m_Impl-&gt;InterpolateImageFunction);
}*/

void mitk::ExtractSliceFilter2::GenerateData()
<span style = "background-color:#fdd">{
  if (nullptr != m_Impl-&gt;InterpolateImageFunction &amp;&amp; this-&gt;GetInput()-&gt;GetMTime() &lt; this-&gt;GetMTime())
    return;</span>

<span style = "background-color:#fdd">  const auto* inputImage = this-&gt;GetInput();</span>

<span style = "background-color:#fdd">  AccessFixedDimensionByItk_2(inputImage, CreateInterpolateImageFunction, 3, this-&gt;GetInterpolator(), m_Impl-&gt;InterpolateImageFunction);</span>

<span style = "background-color:#fdd">  this-&gt;AllocateOutputs();
  auto outputRegion = this-&gt;GetOutput()-&gt;GetLargestPossibleRegion();</span>

<span style = "background-color:#fdd">  AccessFixedDimensionByItk_3(inputImage, ::GenerateData, 3, this-&gt;GetOutput(), outputRegion, m_Impl-&gt;InterpolateImageFunction);
}</span>

void mitk::ExtractSliceFilter2::SetInput(const InputImageType* image)
<span style = "background-color:#fdd">{
  if (this-&gt;GetInput() == image)
    return;</span>

<span style = "background-color:#fdd">  Superclass::SetInput(image);
  m_Impl-&gt;InterpolateImageFunction = nullptr;
}</span>

void mitk::ExtractSliceFilter2::SetInput(unsigned int index, const InputImageType* image)
<span style = "background-color:#fdd">{
  if (0 != index)
    mitkThrow() &lt;&lt; "Input index " &lt;&lt; index &lt;&lt; " is invalid.";</span>

<span style = "background-color:#fdd">  this-&gt;SetInput(image);
}</span>

const mitk::PlaneGeometry* mitk::ExtractSliceFilter2::GetOutputGeometry() const
<span style = "background-color:#fdd">{
  return m_Impl-&gt;OutputGeometry;
}</span>

void mitk::ExtractSliceFilter2::SetOutputGeometry(PlaneGeometry::Pointer outputGeometry)
<span style = "background-color:#fdd">{
  if (m_Impl-&gt;OutputGeometry != outputGeometry)</span>
  {
<span style = "background-color:#fdd">    m_Impl-&gt;OutputGeometry = outputGeometry;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::ExtractSliceFilter2::Interpolator mitk::ExtractSliceFilter2::GetInterpolator() const
<span style = "background-color:#fdd">{
  return m_Impl-&gt;Interpolator;
}</span>

void mitk::ExtractSliceFilter2::SetInterpolator(Interpolator interpolator)
<span style = "background-color:#fdd">{
  if (m_Impl-&gt;Interpolator != interpolator)</span>
  {
<span style = "background-color:#fdd">    m_Impl-&gt;Interpolator = interpolator;
    m_Impl-&gt;InterpolateImageFunction = nullptr;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::ExtractSliceFilter2::VerifyInputInformation() const
<span style = "background-color:#fdd">{
  Superclass::VerifyInputInformation();</span>

<span style = "background-color:#fdd">  VerifyInputImage(this-&gt;GetInput());
  VerifyOutputGeometry(this-&gt;GetOutputGeometry());
}</span></pre>
	</body>
</html>