<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkTemporalJoinImagesFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkTemporalJoinImagesFilter.h"

#include &lt;numeric&gt;

#include "mitkArbitraryTimeGeometry.h"
#include "mitkImageReadAccessor.h"
#include "mitkTemporoSpatialStringProperty.h"

void mitk::TemporalJoinImagesFilter::SetMaxTimeBounds(const TimeBoundsVectorType&amp; timeBounds)
<span style = "background-color:#fdd">{
  m_MaxTimeBounds = timeBounds;
  this-&gt;Modified();
}</span>

void mitk::TemporalJoinImagesFilter::GenerateInputRequestedRegion()
<span style = "background-color:#fdd">{
  Superclass::GenerateInputRequestedRegion();
  const auto nrOfInputs = this-&gt;GetNumberOfInputs();
  for (DataObjectPointerArraySizeType pos = 0; pos &lt; nrOfInputs; ++pos)</span>
  {
<span style = "background-color:#fdd">    this-&gt;GetInput(pos)-&gt;SetRequestedRegionToLargestPossibleRegion();
  }
}</span>

void mitk::TemporalJoinImagesFilter::GenerateOutputInformation()
<span style = "background-color:#fdd">{
  mitk::Image::ConstPointer input = this-&gt;GetInput();
  mitk::Image::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  const auto nrOfInputs = this-&gt;GetNumberOfInputs();
  auto timeBounds = m_MaxTimeBounds;</span>

<span style = "background-color:#fdd">  if (timeBounds.empty())</span>
  {
<span style = "background-color:#fdd">    timeBounds.resize(nrOfInputs);
    std::iota(timeBounds.begin(), timeBounds.end(), 1.0);
  }
  else if(timeBounds.size() != nrOfInputs)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "User defined max time bounds do not match the number if inputs (" &lt;&lt; nrOfInputs &lt;&lt; "). Size of max timebounds is " &lt;&lt; timeBounds.size() &lt;&lt; ", but it should be " &lt;&lt; nrOfInputs &lt;&lt; ".";</span>
  }

<span style = "background-color:#fdd">  timeBounds.insert(timeBounds.begin(), m_FirstMinTimeBound);</span>

<span style = "background-color:#fdd">  auto timeGeo = mitk::ArbitraryTimeGeometry::New();
  timeGeo-&gt;ReserveSpaceForGeometries(nrOfInputs);</span>

<span style = "background-color:#fdd">  for (DataObjectPointerArraySizeType pos = 0; pos &lt; nrOfInputs; ++pos)</span>
  {
<span style = "background-color:#fdd">    timeGeo-&gt;AppendNewTimeStepClone(this-&gt;GetInput(pos)-&gt;GetGeometry(), timeBounds[pos], timeBounds[pos + 1]);
  }
  output-&gt;Initialize(input-&gt;GetPixelType(), *timeGeo);</span>

<span style = "background-color:#fdd">  auto newPropList = input-&gt;GetPropertyList()-&gt;Clone();
  for (DataObjectPointerArraySizeType pos = 1; pos &lt; nrOfInputs; ++pos)</span>
  {
<span style = "background-color:#fdd">    const auto otherList = this-&gt;GetInput(pos)-&gt;GetPropertyList();
    for (const auto&amp; key : otherList-&gt;GetPropertyKeys())</span>
    {
<span style = "background-color:#fdd">      auto prop = newPropList-&gt;GetProperty(key);
      if (prop == nullptr)</span>
      {
<span style = "background-color:#fdd">        newPropList-&gt;SetProperty(key, otherList-&gt;GetProperty(key)-&gt;Clone());
      }</span>
      else
      {
<span style = "background-color:#fdd">        auto tempoSpatialProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty*&gt;(prop);
        auto oTempoSpatialProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty*&gt;(otherList-&gt;GetProperty(key));
        if (prop != nullptr &amp;&amp; oTempoSpatialProp != nullptr)</span>
        {
<span style = "background-color:#fdd">          auto availabelSlices = oTempoSpatialProp-&gt;GetAvailableSlices(0);</span>

<span style = "background-color:#fdd">          for (const auto&amp; sliceID : availabelSlices)</span>
          {
<span style = "background-color:#fdd">            tempoSpatialProp-&gt;SetValue(pos, sliceID, oTempoSpatialProp-&gt;GetValueBySlice(sliceID));
          }
        }</span>
        //other prop types can be ignored, we only use the values of the first frame.
<span style = "background-color:#fdd">      }
    }
  }</span>

<span style = "background-color:#fdd">  output-&gt;SetPropertyList(newPropList);
}</span>


void mitk::TemporalJoinImagesFilter::GenerateData()
<span style = "background-color:#fdd">{
  mitk::Image::Pointer output = this-&gt;GetOutput();
  mitk::Image::ConstPointer refInput = this-&gt;GetInput();
  const auto nrOfInputs = this-&gt;GetNumberOfInputs();</span>

<span style = "background-color:#fdd">  for (DataObjectPointerArraySizeType pos = 0; pos &lt; nrOfInputs; ++pos)</span>
  {
<span style = "background-color:#fdd">    if (!Equal(*(refInput-&gt;GetGeometry()), *(this-&gt;GetInput(pos)-&gt;GetGeometry()), mitk::eps, false))</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot fuse images. At least image #" &lt;&lt; pos &lt;&lt; " has another geometry than the first image.";</span>
    }
<span style = "background-color:#fdd">    if (refInput-&gt;GetPixelType() != this-&gt;GetInput(pos)-&gt;GetPixelType())</span>
    {
<span style = "background-color:#fdd">      mitkThrow() &lt;&lt; "Cannot fuse images. At least image #" &lt;&lt; pos &lt;&lt; " has another pixeltype than the first image.";</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  for (DataObjectPointerArraySizeType pos = 0; pos &lt; nrOfInputs; ++pos)</span>
  {
<span style = "background-color:#fdd">    mitk::ImageReadAccessor accessor(this-&gt;GetInput(pos));
    output-&gt;SetVolume(accessor.GetData(), pos);
  }
}</span></pre>
	</body>
</html>