<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkAbstractTransformGeometry.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkAbstractTransformGeometry.h"
#include &lt;vtkAbstractTransform.h&gt;

<span style = "background-color:#fdd">mitk::AbstractTransformGeometry::AbstractTransformGeometry() : Superclass(), m_Plane(nullptr), m_FrameGeometry(nullptr)
{
  Initialize();
  m_ItkVtkAbstractTransform = itk::VtkAbstractTransform&lt;ScalarType&gt;::New();
}</span>

mitk::AbstractTransformGeometry::AbstractTransformGeometry(const AbstractTransformGeometry &amp;other)
<span style = "background-color:#fdd">  : Superclass(other), m_ParametricBoundingBox(other.m_ParametricBoundingBox)
{
  if (other.m_ParametricBoundingBox.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    m_ParametricBoundingBox = other.m_ParametricBoundingBox-&gt;DeepCopy();
    this-&gt;SetParametricBounds(m_ParametricBoundingBox-&gt;GetBounds());</span>
  }

<span style = "background-color:#fdd">  this-&gt;SetPlane(other.m_Plane);</span>

<span style = "background-color:#fdd">  this-&gt;SetFrameGeometry(other.m_FrameGeometry);
  m_ItkVtkAbstractTransform = itk::VtkAbstractTransform&lt;ScalarType&gt;::New();
}</span>

mitk::AbstractTransformGeometry::~AbstractTransformGeometry()
<span style = "background-color:#fdd">{
}</span>

vtkAbstractTransform *mitk::AbstractTransformGeometry::GetVtkAbstractTransform() const
<span style = "background-color:#fdd">{
  return m_ItkVtkAbstractTransform-&gt;GetVtkAbstractTransform();
}</span>

mitk::ScalarType mitk::AbstractTransformGeometry::GetParametricExtentInMM(int direction) const
<span style = "background-color:#fdd">{
  if (m_Plane.IsNull())</span>
  {
<span style = "background-color:#fdd">    itkExceptionMacro(&lt;&lt; "m_Plane is nullptr.");</span>
  }
<span style = "background-color:#fdd">  return m_Plane-&gt;GetExtentInMM(direction);
}</span>

const itk::Transform&lt;mitk::ScalarType, 3, 3&gt; *mitk::AbstractTransformGeometry::GetParametricTransform() const
<span style = "background-color:#fdd">{
  return m_ItkVtkAbstractTransform;
}</span>

bool mitk::AbstractTransformGeometry::Project(const mitk::Point3D &amp;pt3d_mm, mitk::Point3D &amp;projectedPt3d_mm) const
<span style = "background-color:#fdd">{
  assert(this-&gt;IsBoundingBoxNull() == false);</span>

<span style = "background-color:#fdd">  mitk::Point2D pt2d_mm;</span>
  bool isInside;
<span style = "background-color:#fdd">  isInside = Map(pt3d_mm, pt2d_mm);
  Map(pt2d_mm, projectedPt3d_mm);
  return isInside;</span>
  // Point3D pt3d_units;
  // pt3d_units = m_ItkVtkAbstractTransform-&gt;BackTransform(pt3d_mm);
  // pt3d_units[2] = 0;
  // projectedPt3d_mm = m_ItkVtkAbstractTransform-&gt;TransformPoint(pt3d_units);
  // return const_cast&lt;BoundingBox*&gt;(m_BoundingBox.GetPointer())-&gt;IsInside(pt3d_units);
<span style = "background-color:#fdd">}</span>

bool mitk::AbstractTransformGeometry::Map(const mitk::Point3D &amp;pt3d_mm, mitk::Point2D &amp;pt2d_mm) const
<span style = "background-color:#fdd">{
  assert((m_ItkVtkAbstractTransform.IsNotNull()) &amp;&amp; (m_Plane.IsNotNull()));</span>

<span style = "background-color:#fdd">  Point3D pt3d_units;
  pt3d_units = m_ItkVtkAbstractTransform-&gt;BackTransform(pt3d_mm);</span>

<span style = "background-color:#fdd">  return m_Plane-&gt;Map(pt3d_units, pt2d_mm);
}</span>

void mitk::AbstractTransformGeometry::Map(const mitk::Point2D &amp;pt2d_mm, mitk::Point3D &amp;pt3d_mm) const
<span style = "background-color:#fdd">{
  assert((m_ItkVtkAbstractTransform.IsNotNull()) &amp;&amp; (m_Plane.IsNotNull()));</span>

<span style = "background-color:#fdd">  m_Plane-&gt;Map(pt2d_mm, pt3d_mm);
  pt3d_mm = m_ItkVtkAbstractTransform-&gt;TransformPoint(pt3d_mm);
}</span>

bool mitk::AbstractTransformGeometry::Project(const mitk::Point3D &amp;atPt3d_mm,
                                              const mitk::Vector3D &amp;vec3d_mm,
                                              mitk::Vector3D &amp;projectedVec3d_mm) const
<span style = "background-color:#fdd">{
  itkExceptionMacro("not implemented yet - replace GetIndexToWorldTransform by "</span>
                    "m_ItkVtkAbstractTransform-&gt;GetInverseVtkAbstractTransform()");
<span style = "background-color:#fdd">  assert(this-&gt;IsBoundingBoxNull() == false);</span>

<span style = "background-color:#fdd">  auto inverse = mitk::AffineTransform3D::New();
  GetIndexToWorldTransform()-&gt;GetInverse(inverse);</span>

<span style = "background-color:#fdd">  Vector3D vec3d_units = inverse-&gt;GetMatrix() * vec3d_mm;
  vec3d_units[2] = 0;
  projectedVec3d_mm = GetIndexToWorldTransform()-&gt;TransformVector(vec3d_units);</span>

<span style = "background-color:#fdd">  Point3D pt3d_units;</span>
  mitk::ScalarType temp[3];
  unsigned int i, j;

<span style = "background-color:#fdd">  for (j = 0; j &lt; 3; ++j)
    temp[j] = atPt3d_mm[j] - GetIndexToWorldTransform()-&gt;GetOffset()[j];</span>

<span style = "background-color:#fdd">  for (i = 0; i &lt; 3; ++i)</span>
  {
<span style = "background-color:#fdd">    pt3d_units[i] = 0.0;</span>

<span style = "background-color:#fdd">    for (j = 0; j &lt; 3; ++j)
      pt3d_units[i] += inverse-&gt;GetMatrix()[i][j] * temp[j];
  }</span>

<span style = "background-color:#fdd">  return this-&gt;GetBoundingBox()-&gt;IsInside(pt3d_units);
}</span>

bool mitk::AbstractTransformGeometry::Project(const mitk::Vector3D &amp; /*vec3d_mm*/,
                                              mitk::Vector3D &amp; /*projectedVec3d_mm*/) const
<span style = "background-color:#fdd">{
  MITK_WARN &lt;&lt; "Need additional point! No standard value defined. Please use Project(const mitk::Point3D &amp; atPt3d_mm, "</span>
               "const mitk::Vector3D &amp;vec3d_mm, mitk::Vector3D &amp;projectedVec3d_mm). Unfortunatley this one is not "
               "implemented at the moment. Sorry :(";
<span style = "background-color:#fdd">  itkExceptionMacro("not implemented yet - replace GetIndexToWorldTransform by "</span>
                    "m_ItkVtkAbstractTransform-&gt;GetInverseVtkAbstractTransform()");
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::AbstractTransformGeometry::Map(const mitk::Point3D &amp;atPt3d_mm,
                                          const mitk::Vector3D &amp;vec3d_mm,
                                          mitk::Vector2D &amp;vec2d_mm) const
<span style = "background-color:#fdd">{
  assert((m_ItkVtkAbstractTransform.IsNotNull()) &amp;&amp; (m_Plane.IsNotNull()));</span>

  ScalarType vtkpt[3], vtkvec[3];
<span style = "background-color:#fdd">  itk2vtk(atPt3d_mm, vtkpt);
  itk2vtk(vec3d_mm, vtkvec);
  m_ItkVtkAbstractTransform-&gt;GetInverseVtkAbstractTransform()-&gt;TransformVectorAtPoint(vtkpt, vtkvec, vtkvec);
  mitk::Vector3D vec3d_units;
  vtk2itk(vtkvec, vec3d_units);
  return m_Plane-&gt;Map(atPt3d_mm, vec3d_units, vec2d_mm);
}</span>

void mitk::AbstractTransformGeometry::Map(const mitk::Point2D &amp;atPt2d_mm,
                                          const mitk::Vector2D &amp;vec2d_mm,
                                          mitk::Vector3D &amp;vec3d_mm) const
<span style = "background-color:#fdd">{
  m_Plane-&gt;Map(atPt2d_mm, vec2d_mm, vec3d_mm);
  Point3D atPt3d_mm;
  Map(atPt2d_mm, atPt3d_mm);</span>
  float vtkpt[3], vtkvec[3];
<span style = "background-color:#fdd">  itk2vtk(atPt3d_mm, vtkpt);
  itk2vtk(vec3d_mm, vtkvec);
  m_ItkVtkAbstractTransform-&gt;GetVtkAbstractTransform()-&gt;TransformVectorAtPoint(vtkpt, vtkvec, vtkvec);
  vtk2itk(vtkvec, vec3d_mm);
}</span>

void mitk::AbstractTransformGeometry::IndexToWorld(const mitk::Point2D &amp;pt_units, mitk::Point2D &amp;pt_mm) const
<span style = "background-color:#fdd">{
  m_Plane-&gt;IndexToWorld(pt_units, pt_mm);
}</span>

void mitk::AbstractTransformGeometry::WorldToIndex(const mitk::Point2D &amp;pt_mm, mitk::Point2D &amp;pt_units) const
<span style = "background-color:#fdd">{
  m_Plane-&gt;WorldToIndex(pt_mm, pt_units);
}</span>

void mitk::AbstractTransformGeometry::IndexToWorld(const mitk::Point2D &amp; /*atPt2d_units*/,
                                                   const mitk::Vector2D &amp;vec_units,
                                                   mitk::Vector2D &amp;vec_mm) const
<span style = "background-color:#fdd">{
  MITK_WARN &lt;&lt; "Warning! Call of the deprecated function AbstractTransformGeometry::IndexToWorld(point, vec, vec). Use "</span>
               "AbstractTransformGeometry::IndexToWorld(vec, vec) instead!";
<span style = "background-color:#fdd">  this-&gt;IndexToWorld(vec_units, vec_mm);
}</span>

void mitk::AbstractTransformGeometry::IndexToWorld(const mitk::Vector2D &amp;vec_units, mitk::Vector2D &amp;vec_mm) const
<span style = "background-color:#fdd">{
  m_Plane-&gt;IndexToWorld(vec_units, vec_mm);
}</span>

void mitk::AbstractTransformGeometry::WorldToIndex(const mitk::Point2D &amp; /*atPt2d_mm*/,
                                                   const mitk::Vector2D &amp;vec_mm,
                                                   mitk::Vector2D &amp;vec_units) const
<span style = "background-color:#fdd">{
  MITK_WARN &lt;&lt; "Warning! Call of the deprecated function AbstractTransformGeometry::WorldToIndex(point, vec, vec). Use "</span>
               "AbstractTransformGeometry::WorldToIndex(vec, vec) instead!";
<span style = "background-color:#fdd">  this-&gt;WorldToIndex(vec_mm, vec_units);
}</span>

void mitk::AbstractTransformGeometry::WorldToIndex(const mitk::Vector2D &amp;vec_mm, mitk::Vector2D &amp;vec_units) const
<span style = "background-color:#fdd">{
  m_Plane-&gt;WorldToIndex(vec_mm, vec_units);
}</span>

bool mitk::AbstractTransformGeometry::IsAbove(const mitk::Point3D &amp;pt3d_mm, bool /*considerBoundingBox*/) const
<span style = "background-color:#fdd">{
  assert((m_ItkVtkAbstractTransform.IsNotNull()) &amp;&amp; (m_Plane.IsNotNull()));</span>

<span style = "background-color:#fdd">  Point3D pt3d_ParametricWorld;
  pt3d_ParametricWorld = m_ItkVtkAbstractTransform-&gt;BackTransform(pt3d_mm);</span>

<span style = "background-color:#fdd">  Point3D pt3d_ParametricUnits;
  ((BaseGeometry *)m_Plane)-&gt;WorldToIndex(pt3d_ParametricWorld, pt3d_ParametricUnits);</span>

<span style = "background-color:#fdd">  return (pt3d_ParametricUnits[2] &gt; m_ParametricBoundingBox-&gt;GetBounds()[4]);
}</span>

void mitk::AbstractTransformGeometry::SetVtkAbstractTransform(vtkAbstractTransform *aVtkAbstractTransform)
<span style = "background-color:#fdd">{
  m_ItkVtkAbstractTransform-&gt;SetVtkAbstractTransform(aVtkAbstractTransform);
}</span>

void mitk::AbstractTransformGeometry::SetPlane(const mitk::PlaneGeometry *aPlane)
<span style = "background-color:#fdd">{
  if (aPlane != nullptr)</span>
  {
<span style = "background-color:#fdd">    m_Plane = static_cast&lt;mitk::PlaneGeometry *&gt;(aPlane-&gt;Clone().GetPointer());</span>

<span style = "background-color:#fdd">    BoundingBox::BoundsArrayType b = m_Plane-&gt;GetBoundingBox()-&gt;GetBounds();</span>

<span style = "background-color:#fdd">    SetParametricBounds(b);</span>

<span style = "background-color:#fdd">    CalculateFrameGeometry();
  }</span>
  else
  {
<span style = "background-color:#fdd">    if (m_Plane.IsNull())
      return;
    m_Plane = nullptr;</span>
  }
<span style = "background-color:#fdd">  Modified();
}</span>

void mitk::AbstractTransformGeometry::CalculateFrameGeometry()
<span style = "background-color:#fdd">{
  if ((m_Plane.IsNull()) || (m_FrameGeometry.IsNotNull()))
    return;</span>
  //@warning affine-transforms and bounding-box should be set by specific sub-classes!
<span style = "background-color:#fdd">  SetBounds(m_Plane-&gt;GetBoundingBox()-&gt;GetBounds());
}</span>

void mitk::AbstractTransformGeometry::SetFrameGeometry(const mitk::BaseGeometry *frameGeometry)
<span style = "background-color:#fdd">{
  if ((frameGeometry != nullptr) &amp;&amp; (frameGeometry-&gt;IsValid()))</span>
  {
<span style = "background-color:#fdd">    m_FrameGeometry = static_cast&lt;mitk::BaseGeometry *&gt;(frameGeometry-&gt;Clone().GetPointer());
    SetIndexToWorldTransform(m_FrameGeometry-&gt;GetIndexToWorldTransform());
    SetBounds(m_FrameGeometry-&gt;GetBounds());
  }</span>
  else
  {
<span style = "background-color:#fdd">    m_FrameGeometry = nullptr;</span>
  }
<span style = "background-color:#fdd">}</span>

itk::ModifiedTimeType mitk::AbstractTransformGeometry::GetMTime() const
<span style = "background-color:#fdd">{
  if (Superclass::GetMTime() &lt; m_ItkVtkAbstractTransform-&gt;GetMTime())
    return m_ItkVtkAbstractTransform-&gt;GetMTime();</span>

<span style = "background-color:#fdd">  return Superclass::GetMTime();
}</span>

void mitk::AbstractTransformGeometry::SetOversampling(mitk::ScalarType oversampling)
<span style = "background-color:#fdd">{
  if (m_Plane.IsNull())</span>
  {
<span style = "background-color:#fdd">    itkExceptionMacro(&lt;&lt; "m_Plane is not set.");</span>
  }

<span style = "background-color:#fdd">  mitk::BoundingBox::BoundsArrayType bounds = m_Plane-&gt;GetBounds();
  bounds[1] *= oversampling;
  bounds[3] *= oversampling;
  bounds[5] *= oversampling;
  SetParametricBounds(bounds);
}</span>

itk::LightObject::Pointer mitk::AbstractTransformGeometry::InternalClone() const
<span style = "background-color:#fdd">{
  Self::Pointer newGeometry = new AbstractTransformGeometry(*this);
  newGeometry-&gt;UnRegister();
  return newGeometry.GetPointer();
}</span>

void mitk::AbstractTransformGeometry::SetParametricBounds(const BoundingBox::BoundsArrayType &amp;bounds)
<span style = "background-color:#fdd">{
  m_ParametricBoundingBox = BoundingBoxType::New();</span>

<span style = "background-color:#fdd">  BoundingBoxType::PointsContainer::Pointer pointscontainer = BoundingBoxType::PointsContainer::New();</span>
  BoundingBoxType::PointType p;
  BoundingBoxType::PointIdentifier pointid;

<span style = "background-color:#fdd">  for (pointid = 0; pointid &lt; 2; ++pointid)</span>
  {
    unsigned int i;
<span style = "background-color:#fdd">    for (i = 0; i &lt; GetNDimensions(); ++i)</span>
    {
<span style = "background-color:#fdd">      p[i] = bounds[2 * i + pointid];
    }
    pointscontainer-&gt;InsertElement(pointid, p);
  }</span>

<span style = "background-color:#fdd">  m_ParametricBoundingBox-&gt;SetPoints(pointscontainer);
  m_ParametricBoundingBox-&gt;ComputeBoundingBox();
  this-&gt;Modified();
}</span>

const mitk::BoundingBox::BoundsArrayType &amp;mitk::AbstractTransformGeometry::GetParametricBounds() const
<span style = "background-color:#fdd">{
  assert(m_ParametricBoundingBox.IsNotNull());
  return m_ParametricBoundingBox-&gt;GetBounds();
}</span>

mitk::ScalarType mitk::AbstractTransformGeometry::GetParametricExtent(int direction) const
<span style = "background-color:#fdd">{
  if (direction &lt; 0 || direction &gt;= 3)
    mitkThrow() &lt;&lt; "Invalid direction. Must be between either 0, 1 or 2. ";
  assert(m_ParametricBoundingBox.IsNotNull());</span>

<span style = "background-color:#fdd">  BoundingBoxType::BoundsArrayType bounds = m_ParametricBoundingBox-&gt;GetBounds();
  return bounds[direction * 2 + 1] - bounds[direction * 2];
}</span></pre>
	</body>
</html>