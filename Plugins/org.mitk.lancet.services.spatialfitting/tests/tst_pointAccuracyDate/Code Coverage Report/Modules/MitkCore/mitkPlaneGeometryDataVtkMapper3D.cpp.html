<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlaneGeometryDataVtkMapper3D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlaneGeometryDataVtkMapper3D.h"

#include "mitkImageVtkMapper2D.h"
#include "mitkNodePredicateDataType.h"
#include "mitkNodePredicateOr.h"
#include "mitkPointSetVtkMapper3D.h"
#include "mitkSmartPointerProperty.h"
#include "mitkSurface.h"
#include "mitkVtkRepresentationProperty.h"
#include "mitkWeakPointerProperty.h"
#include "vtkMitkLevelWindowFilter.h"
#include "vtkNeverTranslucentTexture.h"

#include &lt;vtkAssembly.h&gt;
#include &lt;vtkDataSetMapper.h&gt;
#include &lt;vtkFeatureEdges.h&gt;
#include &lt;vtkHedgeHog.h&gt;
#include &lt;vtkImageData.h&gt;
#include &lt;vtkLinearTransform.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkProp3DCollection.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;
#include &lt;vtkTubeFilter.h&gt;

namespace mitk
{
  mitk::PlaneGeometryDataVtkMapper3D::LocalStorage::LocalStorage()
<span style = "background-color:#fdd">    : m_NormalsActorAdded(false)     
  {
    m_EdgeTuber = vtkTubeFilter::New();
    m_EdgeMapper = vtkPolyDataMapper::New();</span>

<span style = "background-color:#fdd">    m_SurfaceCreator = PlaneGeometryDataToSurfaceFilter::New();
    m_SurfaceCreatorBoundingBox = BoundingBox::New();
    m_SurfaceCreatorPointsContainer = BoundingBox::PointsContainer::New();
    m_Edges = vtkFeatureEdges::New();</span>

<span style = "background-color:#fdd">    m_Edges-&gt;BoundaryEdgesOn();
    m_Edges-&gt;FeatureEdgesOff();
    m_Edges-&gt;NonManifoldEdgesOff();
    m_Edges-&gt;ManifoldEdgesOff();</span>

<span style = "background-color:#fdd">    m_EdgeTransformer = vtkTransformPolyDataFilter::New();
    m_NormalsTransformer = vtkTransformPolyDataFilter::New();
    m_EdgeActor = vtkActor::New();
    m_BackgroundMapper = vtkPolyDataMapper::New();
    m_BackgroundActor = vtkActor::New();
    m_Prop3DAssembly = vtkAssembly::New();
    m_ImageAssembly = vtkAssembly::New();</span>

<span style = "background-color:#fdd">    m_SurfaceCreatorBoundingBox-&gt;SetPoints(m_SurfaceCreatorPointsContainer);</span>

<span style = "background-color:#fdd">    m_Cleaner = vtkCleanPolyData::New();</span>

<span style = "background-color:#fdd">    m_Cleaner-&gt;PieceInvariantOn();
    m_Cleaner-&gt;ConvertLinesToPointsOn();
    m_Cleaner-&gt;ConvertPolysToLinesOn();
    m_Cleaner-&gt;ConvertStripsToPolysOn();
    m_Cleaner-&gt;PointMergingOn();</span>

    // Make sure that the FeatureEdge algorithm is initialized with a "valid"
    // (though empty) input
<span style = "background-color:#fdd">    vtkPolyData *emptyPolyData = vtkPolyData::New();
    m_Cleaner-&gt;SetInputData(emptyPolyData);
    emptyPolyData-&gt;Delete();</span>

<span style = "background-color:#fdd">    m_Edges-&gt;SetInputConnection(m_Cleaner-&gt;GetOutputPort());
    m_EdgeTransformer-&gt;SetInputConnection(m_Edges-&gt;GetOutputPort());</span>

<span style = "background-color:#fdd">    m_EdgeTuber-&gt;SetInputConnection(m_EdgeTransformer-&gt;GetOutputPort());
    m_EdgeTuber-&gt;SetVaryRadiusToVaryRadiusOff();
    m_EdgeTuber-&gt;SetNumberOfSides(12);
    m_EdgeTuber-&gt;CappingOn();</span>

<span style = "background-color:#fdd">    m_EdgeMapper-&gt;SetInputConnection(m_EdgeTuber-&gt;GetOutputPort());
    m_EdgeMapper-&gt;ScalarVisibilityOff();</span>

<span style = "background-color:#fdd">    m_BackgroundMapper-&gt;SetInputData(emptyPolyData);
    m_BackgroundMapper-&gt;Update();</span>

<span style = "background-color:#fdd">    m_EdgeActor-&gt;SetMapper(m_EdgeMapper);</span>

<span style = "background-color:#fdd">    m_BackgroundActor-&gt;GetProperty()-&gt;SetAmbient(0.5);
    m_BackgroundActor-&gt;GetProperty()-&gt;SetColor(0.0, 0.0, 0.0);
    m_BackgroundActor-&gt;GetProperty()-&gt;SetOpacity(0.0);
    m_BackgroundActor-&gt;SetMapper(m_BackgroundMapper);</span>

<span style = "background-color:#fdd">    vtkProperty *backfaceProperty = m_BackgroundActor-&gt;MakeProperty();
    backfaceProperty-&gt;SetColor(0.0, 0.0, 0.0);
    m_BackgroundActor-&gt;SetBackfaceProperty(backfaceProperty);
    backfaceProperty-&gt;Delete();</span>

<span style = "background-color:#fdd">    m_FrontHedgeHog = vtkHedgeHog::New();
    m_BackHedgeHog = vtkHedgeHog::New();</span>

<span style = "background-color:#fdd">    m_FrontNormalsMapper = vtkPolyDataMapper::New();
    m_FrontNormalsMapper-&gt;SetInputConnection(m_FrontHedgeHog-&gt;GetOutputPort());
    m_BackNormalsMapper = vtkPolyDataMapper::New();</span>

<span style = "background-color:#fdd">    m_Prop3DAssembly-&gt;AddPart(m_EdgeActor);
    m_Prop3DAssembly-&gt;AddPart(m_ImageAssembly);
    m_FrontNormalsActor = vtkActor::New();
    m_FrontNormalsActor-&gt;SetMapper(m_FrontNormalsMapper);
    m_BackNormalsActor = vtkActor::New();
    m_BackNormalsActor-&gt;SetMapper(m_BackNormalsMapper);</span>

<span style = "background-color:#fdd">    m_ImageMapperDeletedCommand = MemberCommandType::New();
    m_ImageMapperDeletedCommand-&gt;SetCallbackFunction(this, &amp;LocalStorage::ImageMapperDeletedCallback);
  }</span>

  void mitk::PlaneGeometryDataVtkMapper3D::LocalStorage::ImageMapperDeletedCallback(
    itk::Object *caller,
    const itk::EventObject &amp; /*event*/)
<span style = "background-color:#fdd">  {
    auto *imageMapper = dynamic_cast&lt;ImageVtkMapper2D *&gt;(caller);
    if ((imageMapper != nullptr))</span>
    {
<span style = "background-color:#fdd">      if (m_ImageActors.count(imageMapper) &gt; 0)</span>
      {
<span style = "background-color:#fdd">        m_ImageActors[imageMapper].m_Sender = nullptr; // sender is already destroying itself
        m_ImageActors.erase(imageMapper);</span>
      }
    }
<span style = "background-color:#fdd">  }</span>

  // destructor LocalStorage
  mitk::PlaneGeometryDataVtkMapper3D::LocalStorage::~LocalStorage()
<span style = "background-color:#fdd">  {
    m_ImageAssembly-&gt;Delete();
    m_Prop3DAssembly-&gt;Delete();
    m_EdgeTuber-&gt;Delete();
    m_EdgeMapper-&gt;Delete();
    m_EdgeTransformer-&gt;Delete();
    m_Cleaner-&gt;Delete();
    m_Edges-&gt;Delete();
    m_NormalsTransformer-&gt;Delete();
    m_EdgeActor-&gt;Delete();
    m_BackgroundMapper-&gt;Delete();
    m_BackgroundActor-&gt;Delete();
    m_FrontNormalsMapper-&gt;Delete();
    m_FrontNormalsActor-&gt;Delete();
    m_FrontHedgeHog-&gt;Delete();
    m_BackNormalsMapper-&gt;Delete();
    m_BackNormalsActor-&gt;Delete();
    m_BackHedgeHog-&gt;Delete();</span>

<span style = "background-color:#fdd">    for (auto it = m_ImageActors.begin(); it != m_ImageActors.end(); ++it)
      it-&gt;second.m_Actor-&gt;ReleaseGraphicsResources(nullptr);</span>

    // Delete entries in m_ImageActors list one by one
<span style = "background-color:#fdd">    m_ImageActors.clear();</span>


<span style = "background-color:#fdd">  }</span>

  PlaneGeometryDataVtkMapper3D::PlaneGeometryDataVtkMapper3D()
<span style = "background-color:#fdd">    :m_DataStorage(nullptr)
  {
  }</span>

  PlaneGeometryDataVtkMapper3D::~PlaneGeometryDataVtkMapper3D()
<span style = "background-color:#fdd">  {
      m_DataStorage = nullptr;
  }</span>

  vtkProp *PlaneGeometryDataVtkMapper3D::GetVtkProp(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">  {
    LocalStorage *ls = m_LSH.GetLocalStorage(renderer);
    if ((this-&gt;GetDataNode() != nullptr) &amp;&amp; (ls-&gt;m_ImageAssembly != nullptr))</span>
    {
      // Do not transform the entire Prop3D assembly, but only the image part
      // here. The colored frame is transformed elsewhere (via m_EdgeTransformer),
      // since only vertices should be transformed there, not the poly data
      // itself, to avoid distortion for anisotropic datasets.
<span style = "background-color:#fdd">      ls-&gt;m_ImageAssembly-&gt;SetUserTransform(this-&gt;GetDataNode()-&gt;GetVtkTransform());</span>
    }
<span style = "background-color:#fdd">    return ls-&gt;m_Prop3DAssembly;
  }</span>

  void PlaneGeometryDataVtkMapper3D::UpdateVtkTransform(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">  {
    LocalStorage *ls = m_LSH.GetLocalStorage(renderer);
    ls-&gt;m_ImageAssembly-&gt;SetUserTransform(this-&gt;GetDataNode()-&gt;GetVtkTransform(this-&gt;GetTimestep()));
  }</span>

  const PlaneGeometryData *PlaneGeometryDataVtkMapper3D::GetInput()
<span style = "background-color:#fdd">  {
    return static_cast&lt;const PlaneGeometryData *&gt;(GetDataNode()-&gt;GetData());
  }</span>

  void PlaneGeometryDataVtkMapper3D::SetDataStorageForTexture(mitk::DataStorage *storage)
<span style = "background-color:#fdd">  {
    if (storage != nullptr &amp;&amp; m_DataStorage != storage)</span>
    {
<span style = "background-color:#fdd">      m_DataStorage = storage;
      this-&gt;Modified();</span>
    }
<span style = "background-color:#fdd">  }</span>


  void PlaneGeometryDataVtkMapper3D::GenerateDataForRenderer(BaseRenderer *renderer)
<span style = "background-color:#fdd">  {
    LocalStorage* ls = m_LSH.GetLocalStorage(renderer);</span>
    // Remove all actors from the assembly, and re-initialize it with the
    // edge actor
<span style = "background-color:#fdd">    ls-&gt;m_ImageAssembly-&gt;GetParts()-&gt;RemoveAllItems();</span>

<span style = "background-color:#fdd">    bool visible = true;
    GetDataNode()-&gt;GetVisibility(visible, renderer, "visible");</span>

<span style = "background-color:#fdd">    if (!visible)</span>
    {
      // visibility has explicitly to be set in the single actors
      // due to problems when using cell picking:
      // even if the assembly is invisible, the renderer contains
      // references to the assemblies parts. During picking the
      // visibility of each part is checked, and not only for the
      // whole assembly.
<span style = "background-color:#fdd">      ls-&gt;m_ImageAssembly-&gt;VisibilityOff();
      ls-&gt;m_EdgeActor-&gt;VisibilityOff();
      return;</span>
    }

    // visibility has explicitly to be set in the single actors
    // due to problems when using cell picking:
    // even if the assembly is invisible, the renderer contains
    // references to the assemblies parts. During picking the
    // visibility of each part is checked, and not only for the
    // whole assembly.
<span style = "background-color:#fdd">    ls-&gt;m_ImageAssembly-&gt;VisibilityOn();
    bool drawEdges = true;
    this-&gt;GetDataNode()-&gt;GetBoolProperty("draw edges", drawEdges, renderer);
    ls-&gt;m_EdgeActor-&gt;SetVisibility(drawEdges);</span>

<span style = "background-color:#fdd">    PlaneGeometryData::ConstPointer input = this-&gt;GetInput();</span>

<span style = "background-color:#fdd">    if (input.IsNotNull() &amp;&amp; (input-&gt;GetPlaneGeometry() != nullptr))</span>
    {
<span style = "background-color:#fdd">      SmartPointerProperty::Pointer surfacecreatorprop;
      surfacecreatorprop =</span>
        dynamic_cast&lt;SmartPointerProperty *&gt;(GetDataNode()-&gt;GetProperty("surfacegeometry", renderer));

<span style = "background-color:#fdd">      if ((surfacecreatorprop.IsNull()) || (surfacecreatorprop-&gt;GetSmartPointer().IsNull()) ||</span>
          ((ls-&gt;m_SurfaceCreator =
            dynamic_cast&lt;PlaneGeometryDataToSurfaceFilter *&gt;(surfacecreatorprop-&gt;GetSmartPointer().GetPointer()))
            .IsNull()))
      {
<span style = "background-color:#fdd">        ls-&gt;m_SurfaceCreator-&gt;PlaceByGeometryOn();
        surfacecreatorprop = SmartPointerProperty::New(ls-&gt;m_SurfaceCreator);
        GetDataNode()-&gt;SetProperty("surfacegeometry", surfacecreatorprop);</span>
      }

<span style = "background-color:#fdd">      ls-&gt;m_SurfaceCreator-&gt;SetInput(input);</span>

      int res;
<span style = "background-color:#fdd">      if (GetDataNode()-&gt;GetIntProperty("xresolution", res, renderer))</span>
      {
<span style = "background-color:#fdd">        ls-&gt;m_SurfaceCreator-&gt;SetXResolution(res);</span>
      }
<span style = "background-color:#fdd">      if (GetDataNode()-&gt;GetIntProperty("yresolution", res, renderer))</span>
      {
<span style = "background-color:#fdd">        ls-&gt;m_SurfaceCreator-&gt;SetYResolution(res);</span>
      }

<span style = "background-color:#fdd">      double tubeRadius = 1.0; // Radius of tubular edge surrounding plane</span>

      // Clip the PlaneGeometry with the reference geometry bounds (if available)
<span style = "background-color:#fdd">      if (input-&gt;GetPlaneGeometry()-&gt;HasReferenceGeometry())</span>
      {
<span style = "background-color:#fdd">        const BaseGeometry *referenceGeometry = input-&gt;GetPlaneGeometry()-&gt;GetReferenceGeometry();</span>

        BoundingBox::PointType boundingBoxMin, boundingBoxMax;
<span style = "background-color:#fdd">        boundingBoxMin = referenceGeometry-&gt;GetBoundingBox()-&gt;GetMinimum();
        boundingBoxMax = referenceGeometry-&gt;GetBoundingBox()-&gt;GetMaximum();</span>

<span style = "background-color:#fdd">        if (referenceGeometry-&gt;GetImageGeometry())</span>
        {
<span style = "background-color:#fdd">          for (unsigned int i = 0; i &lt; 3; ++i)</span>
          {
<span style = "background-color:#fdd">            boundingBoxMin[i] -= 0.5;
            boundingBoxMax[i] -= 0.5;
          }</span>
        }

<span style = "background-color:#fdd">        ls-&gt;m_SurfaceCreatorPointsContainer-&gt;CreateElementAt(0) = boundingBoxMin;
        ls-&gt;m_SurfaceCreatorPointsContainer-&gt;CreateElementAt(1) = boundingBoxMax;</span>

<span style = "background-color:#fdd">        ls-&gt;m_SurfaceCreatorBoundingBox-&gt;ComputeBoundingBox();</span>

<span style = "background-color:#fdd">        ls-&gt;m_SurfaceCreator-&gt;SetBoundingBox(ls-&gt;m_SurfaceCreatorBoundingBox);</span>

<span style = "background-color:#fdd">        tubeRadius = referenceGeometry-&gt;GetDiagonalLength() / 450.0;
      }</span>

        // If no reference geometry is available, clip with the current global
        // bounds
<span style = "background-color:#fdd">      else if (!m_DataStorage.IsExpired())</span>
      {
<span style = "background-color:#fdd">        ls-&gt;m_SurfaceCreator-&gt;SetBoundingBox(</span>
          m_DataStorage.Lock()-&gt;ComputeVisibleBoundingBox(nullptr, "includeInBoundingBox"));
<span style = "background-color:#fdd">        tubeRadius = sqrt(ls-&gt;m_SurfaceCreator-&gt;GetBoundingBox()-&gt;GetDiagonalLength2()) / 450.0;</span>
      }

      // Calculate the surface of the PlaneGeometry
<span style = "background-color:#fdd">      ls-&gt;m_SurfaceCreator-&gt;Update();
      Surface *surface = ls-&gt;m_SurfaceCreator-&gt;GetOutput();</span>

      // Check if there's something to display, otherwise return
<span style = "background-color:#fdd">      if ((surface-&gt;GetVtkPolyData() == nullptr) || (surface-&gt;GetVtkPolyData()-&gt;GetNumberOfCells() == 0))</span>
      {
<span style = "background-color:#fdd">        ls-&gt;m_ImageAssembly-&gt;VisibilityOff();
        return;</span>
      }

      // add a graphical representation of the surface normals if requested
<span style = "background-color:#fdd">      DataNode *node = this-&gt;GetDataNode();
      bool displayNormals = false;
      bool colorTwoSides = false;
      bool invertNormals = false;
      node-&gt;GetBoolProperty("draw normals 3D", displayNormals, renderer);
      node-&gt;GetBoolProperty("color two sides", colorTwoSides, renderer);
      node-&gt;GetBoolProperty("invert normals", invertNormals, renderer);</span>

      // if we want to draw the display normals or render two sides we have to get the colors
<span style = "background-color:#fdd">      if (displayNormals || colorTwoSides)</span>
      {
        // get colors
<span style = "background-color:#fdd">        float frontColor[3] = {0.0, 0.0, 1.0};
        node-&gt;GetColor(frontColor, renderer, "front color");
        float backColor[3] = {1.0, 0.0, 0.0};
        node-&gt;GetColor(backColor, renderer, "back color");</span>

<span style = "background-color:#fdd">        if (displayNormals)</span>
        {
<span style = "background-color:#fdd">          ls-&gt;m_NormalsTransformer-&gt;SetInputData(surface-&gt;GetVtkPolyData());
          ls-&gt;m_NormalsTransformer-&gt;SetTransform(node-&gt;GetVtkTransform(this-&gt;GetTimestep()));</span>

<span style = "background-color:#fdd">          ls-&gt;m_FrontHedgeHog-&gt;SetInputConnection(ls-&gt;m_NormalsTransformer-&gt;GetOutputPort());
          ls-&gt;m_FrontHedgeHog-&gt;SetVectorModeToUseNormal();
          ls-&gt;m_FrontHedgeHog-&gt;SetScaleFactor(invertNormals ? 1.0 : -1.0);
          ls-&gt;m_FrontHedgeHog-&gt;Update();</span>

<span style = "background-color:#fdd">          ls-&gt;m_FrontNormalsActor-&gt;GetProperty()-&gt;SetColor(frontColor[0], frontColor[1], frontColor[2]);</span>

<span style = "background-color:#fdd">          ls-&gt;m_BackHedgeHog-&gt;SetInputConnection(ls-&gt;m_NormalsTransformer-&gt;GetOutputPort());
          ls-&gt;m_BackHedgeHog-&gt;SetVectorModeToUseNormal();
          ls-&gt;m_BackHedgeHog-&gt;SetScaleFactor(invertNormals ? -1.0 : 1.0);
          ls-&gt;m_BackHedgeHog-&gt;Update();</span>

<span style = "background-color:#fdd">          ls-&gt;m_BackNormalsActor-&gt;GetProperty()-&gt;SetColor(backColor[0], backColor[1], backColor[2]);</span>

          // if there is no actor added yet, add one
<span style = "background-color:#fdd">          if (!ls-&gt;m_NormalsActorAdded)</span>
          {
<span style = "background-color:#fdd">            ls-&gt;m_Prop3DAssembly-&gt;AddPart(ls-&gt;m_FrontNormalsActor);
            ls-&gt;m_Prop3DAssembly-&gt;AddPart(ls-&gt;m_BackNormalsActor);
            ls-&gt;m_NormalsActorAdded = true;</span>
          }
<span style = "background-color:#fdd">        }</span>
          // if we don't want to display normals AND there is an actor added remove the actor
<span style = "background-color:#fdd">        else if (ls-&gt;m_NormalsActorAdded)</span>
        {
<span style = "background-color:#fdd">          ls-&gt;m_Prop3DAssembly-&gt;RemovePart(ls-&gt;m_FrontNormalsActor);
          ls-&gt;m_Prop3DAssembly-&gt;RemovePart(ls-&gt;m_BackNormalsActor);
          ls-&gt;m_NormalsActorAdded = false;</span>
        }

<span style = "background-color:#fdd">        if (colorTwoSides)</span>
        {
<span style = "background-color:#fdd">          if (!invertNormals)</span>
          {
<span style = "background-color:#fdd">            ls-&gt;m_BackgroundActor-&gt;GetProperty()-&gt;SetColor(backColor[0], backColor[1], backColor[2]);
            ls-&gt;m_BackgroundActor-&gt;GetBackfaceProperty()-&gt;SetColor(frontColor[0], frontColor[1], frontColor[2]);
          }</span>
          else
          {
<span style = "background-color:#fdd">            ls-&gt;m_BackgroundActor-&gt;GetProperty()-&gt;SetColor(frontColor[0], frontColor[1], frontColor[2]);
            ls-&gt;m_BackgroundActor-&gt;GetBackfaceProperty()-&gt;SetColor(backColor[0], backColor[1], backColor[2]);</span>
          }
        }
      }

      // Add black background for all images (which may be transparent)
<span style = "background-color:#fdd">      ls-&gt;m_BackgroundMapper-&gt;SetInputData(surface-&gt;GetVtkPolyData());</span>
      //      ls-&gt;m_ImageAssembly-&gt;AddPart(ls-&gt;m_BackgroundActor);

<span style = "background-color:#fdd">      LayerSortedActorList layerSortedActors;</span>

      // Traverse the data tree to find nodes resliced by ImageMapperGL2D
      // use a predicate to get all data nodes which are "images" or inherit from mitk::Image
<span style = "background-color:#fdd">      mitk::TNodePredicateDataType&lt;mitk::Image&gt;::Pointer predicateAllImages =</span>
        mitk::TNodePredicateDataType&lt;mitk::Image&gt;::New();
<span style = "background-color:#fdd">      if(m_DataStorage.Lock() == nullptr)</span>
      {
<span style = "background-color:#fdd">          MITK_ERROR &lt;&lt; "m_DataStorage null";
          return;</span>
      }
<span style = "background-color:#fdd">      mitk::DataStorage::SetOfObjects::ConstPointer all = m_DataStorage.Lock()-&gt;GetSubset(predicateAllImages);</span>
      // process all found images
<span style = "background-color:#fdd">      for (mitk::DataStorage::SetOfObjects::ConstIterator it = all-&gt;Begin(); it != all-&gt;End(); ++it)</span>
      {
<span style = "background-color:#fdd">        DataNode *node = it-&gt;Value();
        if (node != nullptr)
          this-&gt;ProcessNode(node, renderer, surface, layerSortedActors);
      }</span>

      // Add all image actors to the assembly, sorted according to
      // layer property
<span style = "background-color:#fdd">      LayerSortedActorList::iterator actorIt;
      for (actorIt = layerSortedActors.begin(); actorIt != layerSortedActors.end(); ++actorIt)</span>
      {
<span style = "background-color:#fdd">        ls-&gt;m_ImageAssembly-&gt;AddPart(actorIt-&gt;second);
      }</span>

      // Configurate the tube-shaped frame: size according to the surface
      // bounds, color as specified in the plane's properties
<span style = "background-color:#fdd">      vtkPolyData *surfacePolyData = surface-&gt;GetVtkPolyData();
      ls-&gt;m_Cleaner-&gt;SetInputData(surfacePolyData);
      ls-&gt;m_EdgeTransformer-&gt;SetTransform(this-&gt;GetDataNode()-&gt;GetVtkTransform(this-&gt;GetTimestep()));</span>

      // Adjust the radius according to extent
<span style = "background-color:#fdd">      ls-&gt;m_EdgeTuber-&gt;SetRadius(tubeRadius);</span>

      // Get the plane's color and set the tube properties accordingly
<span style = "background-color:#fdd">      ColorProperty::Pointer colorProperty;
      colorProperty = dynamic_cast&lt;ColorProperty *&gt;(this-&gt;GetDataNode()-&gt;GetProperty("color"));
      if (colorProperty.IsNotNull())</span>
      {
<span style = "background-color:#fdd">        const Color &amp;color = colorProperty-&gt;GetColor();
        ls-&gt;m_EdgeActor-&gt;GetProperty()-&gt;SetColor(color.GetRed(), color.GetGreen(), color.GetBlue());
      }</span>
      else
      {
<span style = "background-color:#fdd">        ls-&gt;m_EdgeActor-&gt;GetProperty()-&gt;SetColor(1.0, 1.0, 1.0);</span>
      }

<span style = "background-color:#fdd">      ls-&gt;m_ImageAssembly-&gt;SetUserTransform(this-&gt;GetDataNode()-&gt;GetVtkTransform(this-&gt;GetTimestep()));
    }</span>

    VtkRepresentationProperty *representationProperty;
<span style = "background-color:#fdd">    this-&gt;GetDataNode()-&gt;GetProperty(representationProperty, "material.representation", renderer);
    if (representationProperty != nullptr)
      ls-&gt;m_BackgroundActor-&gt;GetProperty()-&gt;SetRepresentation(representationProperty-&gt;GetVtkRepresentation());
  }</span>

  void PlaneGeometryDataVtkMapper3D::ProcessNode(DataNode *node,
                                                 BaseRenderer *renderer,
                                                 Surface *surface,
                                                 LayerSortedActorList &amp;layerSortedActors)
<span style = "background-color:#fdd">  {
      LocalStorage* ls = m_LSH.GetLocalStorage(renderer);
    if (node != nullptr)</span>
    {
      // we need to get the information from the 2D mapper to render the texture on the 3D plane
<span style = "background-color:#fdd">      auto *imageMapper =</span>
        dynamic_cast&lt;ImageVtkMapper2D *&gt;(node-&gt;GetMapper(1)); // GetMapper(1) provides the 2D mapper for the data node

      // if there is a 2D mapper, which is not the standard image mapper...
<span style = "background-color:#fdd">      if (!imageMapper &amp;&amp; node-&gt;GetMapper(1))</span>
      {
        //... check if it is the composite mapper
<span style = "background-color:#fdd">        std::string cname(node-&gt;GetMapper(1)-&gt;GetNameOfClass());
        if (!cname.compare("CompositeMapper")) // string.compare returns 0 if the two strings are equal.</span>
        {
          // get the standard image mapper.
          // This is a special case in MITK and does only work for the CompositeMapper.
<span style = "background-color:#fdd">          imageMapper = dynamic_cast&lt;ImageVtkMapper2D *&gt;(node-&gt;GetMapper(3));</span>
        }
<span style = "background-color:#fdd">      }</span>

<span style = "background-color:#fdd">      if ((node-&gt;IsVisible(renderer)) &amp;&amp; imageMapper)</span>
      {
<span style = "background-color:#fdd">        WeakPointerProperty::Pointer rendererProp =</span>
          dynamic_cast&lt;WeakPointerProperty *&gt;(GetDataNode()-&gt;GetPropertyList()-&gt;GetProperty("renderer"));

<span style = "background-color:#fdd">        if (rendererProp.IsNotNull())</span>
        {
<span style = "background-color:#fdd">          BaseRenderer::Pointer planeRenderer =</span>
            dynamic_cast&lt;BaseRenderer *&gt;(rendererProp-&gt;GetWeakPointer().GetPointer());
          // Retrieve and update image to be mapped
<span style = "background-color:#fdd">          const ImageVtkMapper2D::LocalStorage *localStorage = imageMapper-&gt;GetConstLocalStorage(planeRenderer);</span>

<span style = "background-color:#fdd">          if (planeRenderer.IsNotNull())</span>
          {
            // perform update of imagemapper if needed (maybe the respective 2D renderwindow is not rendered/update
            // before)
<span style = "background-color:#fdd">            imageMapper-&gt;Update(planeRenderer);</span>

            // If it has not been initialized already in a previous pass,
            // generate an actor and a texture object to
            // render the image associated with the ImageVtkMapper2D.
            vtkActor *imageActor;
<span style = "background-color:#fdd">            vtkDataSetMapper *dataSetMapper = nullptr;</span>
            vtkTexture *texture;
<span style = "background-color:#fdd">            if (ls-&gt;m_ImageActors.count(imageMapper) == 0)</span>
            {
<span style = "background-color:#fdd">              dataSetMapper = vtkDataSetMapper::New();</span>

<span style = "background-color:#fdd">              texture = vtkNeverTranslucentTexture::New();
              texture-&gt;RepeatOff();</span>

<span style = "background-color:#fdd">              imageActor = vtkActor::New();
              imageActor-&gt;SetMapper(dataSetMapper);
              imageActor-&gt;SetTexture(texture);
              imageActor-&gt;GetProperty()-&gt;SetOpacity(</span>
                0.999); // HACK! otherwise VTK wouldn't recognize this as translucent
              // surface (if LUT values map to alpha &lt; 255
              // improvement: apply "opacity" property onle HERE and also in 2D image mapper. DO NOT change LUT to
              // achieve
              // translucent images (see method ChangeOpacity in image mapper 2D)

              // Make imageActor the sole owner of the mapper and texture
              // objects
<span style = "background-color:#fdd">              dataSetMapper-&gt;UnRegister(nullptr);
              texture-&gt;UnRegister(nullptr);</span>

              // Store the actor so that it may be accessed in following
              // passes.
<span style = "background-color:#fdd">              ls-&gt;m_ImageActors[imageMapper].Initialize(imageActor, imageMapper, ls-&gt;m_ImageMapperDeletedCommand);
            }</span>
            else
            {
              // Else, retrieve the actor and associated objects from the
              // previous pass.
<span style = "background-color:#fdd">              imageActor = ls-&gt;m_ImageActors[imageMapper].m_Actor;
              dataSetMapper = (vtkDataSetMapper *)imageActor-&gt;GetMapper();
              texture = imageActor-&gt;GetTexture();</span>
            }

            // Set poly data new each time its object changes (e.g. when
            // switching between planar and curved geometries)
<span style = "background-color:#fdd">            if ((dataSetMapper != nullptr) &amp;&amp; (dataSetMapper-&gt;GetInput() != surface-&gt;GetVtkPolyData()))</span>
            {
<span style = "background-color:#fdd">              dataSetMapper-&gt;SetInputData(surface-&gt;GetVtkPolyData());</span>
            }

<span style = "background-color:#fdd">            dataSetMapper-&gt;Update();</span>

            // Check if the m_ReslicedImage is nullptr.
            // This is the case when no image geometry is met by
            // the reslicer. In that case, the texture has to be
            // empty (black) and we don't have to do anything.
            // See fixed bug #13275
<span style = "background-color:#fdd">            if (localStorage-&gt;m_ReslicedImage != nullptr)</span>
            {
<span style = "background-color:#fdd">              texture-&gt;SetInputConnection(localStorage-&gt;m_LevelWindowFilter-&gt;GetOutputPort());</span>

              // do not use a VTK lookup table (we do that ourselves in m_LevelWindowFilter)
<span style = "background-color:#fdd">              texture-&gt;SetColorModeToDirectScalars();</span>

<span style = "background-color:#fdd">              auto *property3d = imageActor-&gt;GetProperty();
              property3d-&gt;LightingOff();</span>

              // re-use properties from the 2D image mapper
<span style = "background-color:#fdd">              auto *property2d = localStorage-&gt;m_ImageActor-&gt;GetProperty();
              property3d-&gt;SetColor(property2d-&gt;GetColor());
              property3d-&gt;SetOpacity(property2d-&gt;GetOpacity());</span>

              // Set texture interpolation on/off
<span style = "background-color:#fdd">              bool textureInterpolation = node-&gt;IsOn("texture interpolation", renderer);
              texture-&gt;SetInterpolate(textureInterpolation);</span>

              // Store this actor to be added to the actor assembly, sort
              // by layer
<span style = "background-color:#fdd">              int layer = 1;
              node-&gt;GetIntProperty("layer", layer);
              layerSortedActors.insert(std::pair&lt;int, vtkActor *&gt;(layer, imageActor));</span>
            }
          }
<span style = "background-color:#fdd">        }
      }</span>
    }
<span style = "background-color:#fdd">  }</span>

  void PlaneGeometryDataVtkMapper3D::ActorInfo::Initialize(vtkActor *actor, itk::Object *sender, itk::Command *command)
<span style = "background-color:#fdd">  {
    m_Actor = actor;
    m_Sender = sender;</span>
    // Get informed when ImageMapper object is deleted, so that
    // the data structures built here can be deleted as well
<span style = "background-color:#fdd">    m_ObserverID = sender-&gt;AddObserver(itk::DeleteEvent(), command);
  }</span>

  PlaneGeometryDataVtkMapper3D::ActorInfo::ActorInfo()
<span style = "background-color:#fdd">    : m_Actor(nullptr),
      m_Sender(nullptr),
      m_ObserverID(0)
  {
  }</span>

  PlaneGeometryDataVtkMapper3D::ActorInfo::~ActorInfo()
<span style = "background-color:#fdd">  {
    if (m_Sender != nullptr)</span>
    {
<span style = "background-color:#fdd">      m_Sender-&gt;RemoveObserver(m_ObserverID);</span>
    }
<span style = "background-color:#fdd">    if (m_Actor != nullptr)</span>
    {
<span style = "background-color:#fdd">      m_Actor-&gt;ReleaseGraphicsResources(nullptr);
      m_Actor-&gt;Delete();</span>
    }
<span style = "background-color:#fdd">  }</span>
} // namespace mitk</pre>
	</body>
</html>