<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPropertyPersistence.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;algorithm&gt;
#include &lt;regex&gt;
#include &lt;utility&gt;

#include &lt;mitkPropertyPersistence.h&gt;

mitk::PropertyPersistence::PropertyPersistence()
<span style = "background-color:#dfd">{
}</span>

mitk::PropertyPersistence::~PropertyPersistence()
<span style = "background-color:#dfd">{
}</span>

bool mitk::PropertyPersistence::AddInfo(const PropertyPersistenceInfo *info, bool overwrite)
<span style = "background-color:#dfd">{
  if (!info)</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#dfd">  if (info-&gt;GetName().empty())</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#dfd">  mitk::PropertyPersistenceInfo::MimeTypeNameType mime = info-&gt;GetMimeTypeName();</span>

<span style = "background-color:#dfd">  auto infoRange = m_InfoMap.equal_range(info-&gt;GetName());</span>

<span style = "background-color:#dfd">  auto predicate = [mime](const std::pair&lt;const std::string, mitk::PropertyPersistenceInfo::ConstPointer&gt; &amp;x) {</span>
<span style = "background-color:#fdd">    return x.second.IsNotNull() &amp;&amp; x.second-&gt;GetMimeTypeName() == mime;</span>
<span style = "background-color:#dfd">  };</span>

<span style = "background-color:#dfd">  auto finding = std::find_if(infoRange.first, infoRange.second, predicate);</span>

<span style = "background-color:#dfd">  bool exists = finding != infoRange.second;
  bool result = false;</span>

<span style = "background-color:#dfd">  if (!exists || overwrite)</span>
  {
<span style = "background-color:#dfd">    if (exists &amp;&amp; overwrite)</span>
    {
<span style = "background-color:#fdd">      m_InfoMap.erase(finding);</span>
    }
<span style = "background-color:#dfd">    result = true;
    m_InfoMap.insert(std::make_pair(info-&gt;GetName(), info));</span>
  }

<span style = "background-color:#dfd">  return result;
}</span>

mitk::PropertyPersistence::InfoMap mitk::PropertyPersistence::SelectInfo(const InfoMap &amp;infoMap,
                                                                         const SelectFunctionType &amp;selectFunction)
<span style = "background-color:#fdd">{
  InfoMap result;</span>

<span style = "background-color:#fdd">  for (auto pos : infoMap)</span>
  {
<span style = "background-color:#fdd">    if (selectFunction(pos))</span>
    {
<span style = "background-color:#fdd">      result.insert(pos);</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return result;
};</span>

mitk::PropertyPersistence::InfoResultType mitk::PropertyPersistence::GetInfo(const std::string &amp;propertyName,
                                                                             bool allowNameRegEx) const
<span style = "background-color:#fdd">{
  SelectFunctionType select = [propertyName](const InfoMap::value_type &amp;x) {
    return x.second.IsNotNull() &amp;&amp; !x.second-&gt;IsRegEx() &amp;&amp; x.second-&gt;GetName() == propertyName;
  };</span>

<span style = "background-color:#fdd">  InfoMap selection = SelectInfo(m_InfoMap, select);</span>

<span style = "background-color:#fdd">  InfoResultType result;
  for (const auto &amp;pos : selection)</span>
  {
<span style = "background-color:#fdd">    result.push_back(pos.second-&gt;UnRegExByName(propertyName).GetPointer());
  }</span>

<span style = "background-color:#fdd">  if (allowNameRegEx)</span>
  {
<span style = "background-color:#fdd">    select = [propertyName](const InfoMap::value_type &amp;x) {
      if (x.second.IsNotNull() &amp;&amp; x.second-&gt;IsRegEx())</span>
      {
<span style = "background-color:#fdd">        std::regex ex(x.second-&gt;GetName());
        return std::regex_match(propertyName, ex);</span>
      }
<span style = "background-color:#fdd">      return false;
    };</span>

<span style = "background-color:#fdd">    selection = SelectInfo(m_InfoMap, select);</span>

<span style = "background-color:#fdd">    for (const auto &amp;pos : selection)</span>
    {
<span style = "background-color:#fdd">      result.push_back(pos.second-&gt;UnRegExByName(propertyName).GetPointer());
    }</span>
  }

<span style = "background-color:#fdd">  return result;
}</span>

bool infoPredicate(const std::multimap&lt;const std::string, mitk::PropertyPersistenceInfo::ConstPointer&gt;::value_type &amp;x,
                   const std::string &amp;propertyName,
                   const std::string &amp;mime)
<span style = "background-color:#fdd">{
  return x.second.IsNotNull() &amp;&amp; !x.second-&gt;IsRegEx() &amp;&amp; x.second-&gt;GetName() == propertyName &amp;&amp;</span>
         x.second-&gt;GetMimeTypeName() == mime;
<span style = "background-color:#fdd">}</span>

bool infoPredicateRegEx(
  const std::multimap&lt;const std::string, mitk::PropertyPersistenceInfo::ConstPointer&gt;::value_type &amp;x,
  const std::string &amp;propertyName,
  const std::string &amp;mime)
<span style = "background-color:#fdd">{
  if (x.second.IsNotNull() &amp;&amp; x.second-&gt;IsRegEx())</span>
  {
<span style = "background-color:#fdd">    std::regex ex(x.second-&gt;GetName());
    return std::regex_match(propertyName, ex) &amp;&amp; x.second-&gt;GetMimeTypeName() == mime;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

mitk::PropertyPersistence::InfoResultType mitk::PropertyPersistence::GetInfo(const std::string &amp;propertyName,
                                                                             const MimeTypeNameType &amp;mime,
                                                                             bool allowMimeWildCard,
                                                                             bool allowNameRegEx) const
<span style = "background-color:#fdd">{
  SelectFunctionType select = [propertyName, mime](const InfoMap::value_type &amp;x) {
    return infoPredicate(x, propertyName, mime);
  };</span>

<span style = "background-color:#fdd">  InfoMap selection = SelectInfo(m_InfoMap, select);</span>

<span style = "background-color:#fdd">  if (allowNameRegEx)</span>
  {
<span style = "background-color:#fdd">    select = [propertyName, mime](const InfoMap::value_type &amp;x) { return infoPredicateRegEx(x, propertyName, mime); };</span>

<span style = "background-color:#fdd">    InfoMap regExSelection = SelectInfo(m_InfoMap, select);</span>

<span style = "background-color:#fdd">    selection.insert(regExSelection.begin(), regExSelection.end());
  }</span>

<span style = "background-color:#fdd">  if (selection.empty() &amp;&amp; allowMimeWildCard)</span>
  { // no perfect match =&gt; second run through with "any mime type"
<span style = "background-color:#fdd">    select = [propertyName](const InfoMap::value_type &amp;x) {
      return infoPredicate(x, propertyName, PropertyPersistenceInfo::ANY_MIMETYPE_NAME());
    };</span>

<span style = "background-color:#fdd">    selection = SelectInfo(m_InfoMap, select);</span>

<span style = "background-color:#fdd">    if (allowNameRegEx)</span>
    {
<span style = "background-color:#fdd">      select = [propertyName](const InfoMap::value_type &amp;x) {
        return infoPredicateRegEx(x, propertyName, PropertyPersistenceInfo::ANY_MIMETYPE_NAME());
      };</span>

<span style = "background-color:#fdd">      InfoMap regExSelection = SelectInfo(m_InfoMap, select);</span>

<span style = "background-color:#fdd">      selection.insert(regExSelection.begin(), regExSelection.end());
    }</span>
  }

<span style = "background-color:#fdd">  InfoResultType result;
  for (const auto &amp;pos : selection)</span>
  {
<span style = "background-color:#fdd">    result.push_back(pos.second-&gt;UnRegExByName(propertyName).GetPointer());
  }</span>

<span style = "background-color:#fdd">  return result;
}</span>

mitk::PropertyPersistence::InfoResultType mitk::PropertyPersistence::GetInfoByKey(const std::string &amp;persistenceKey,
                                                                                  bool allowKeyRegEx) const
<span style = "background-color:#fdd">{
  InfoResultType result;</span>

<span style = "background-color:#fdd">  for (const auto &amp;pos : m_InfoMap)</span>
  {
<span style = "background-color:#fdd">    if (pos.second.IsNotNull())</span>
    {
<span style = "background-color:#fdd">      bool valid = pos.second-&gt;GetKey() == persistenceKey;
      if (!valid &amp;&amp; pos.second-&gt;IsRegEx() &amp;&amp; allowKeyRegEx)</span>
      {
<span style = "background-color:#fdd">        std::regex ex(pos.second-&gt;GetKey());
        valid = std::regex_match(persistenceKey, ex);
      }</span>

<span style = "background-color:#fdd">      if (valid)</span>
      {
<span style = "background-color:#fdd">        result.push_back(pos.second-&gt;UnRegExByKey(persistenceKey).GetPointer());</span>
      }
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return result;
}</span>

bool mitk::PropertyPersistence::HasInfo(const std::string &amp;propertyName, bool allowNameRegEx) const
<span style = "background-color:#fdd">{
  return !this-&gt;GetInfo(propertyName, allowNameRegEx).empty();
}</span>

void mitk::PropertyPersistence::RemoveAllInfo()
<span style = "background-color:#fdd">{
  m_InfoMap.clear();
}</span>

void mitk::PropertyPersistence::RemoveInfo(const std::string &amp;propertyName)
<span style = "background-color:#fdd">{
  if (!propertyName.empty())</span>
  {
<span style = "background-color:#fdd">    m_InfoMap.erase(propertyName);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::PropertyPersistence::RemoveInfo(const std::string &amp;propertyName, const MimeTypeNameType &amp;mime)
<span style = "background-color:#fdd">{
  auto itr = m_InfoMap.begin();
  while (itr != m_InfoMap.end())</span>
  {
<span style = "background-color:#fdd">    if (itr-&gt;first == propertyName &amp;&amp; itr-&gt;second.IsNotNull() &amp;&amp; itr-&gt;second-&gt;GetMimeTypeName() == mime)</span>
    {
<span style = "background-color:#fdd">      itr = m_InfoMap.erase(itr);
    }</span>
    else
    {
<span style = "background-color:#fdd">      ++itr;</span>
    }
<span style = "background-color:#fdd">  }
}</span>

mitk::IPropertyPersistence *mitk::CreateTestInstancePropertyPersistence()
<span style = "background-color:#fdd">{
  return new PropertyPersistence();
};</span></pre>
	</body>
</html>