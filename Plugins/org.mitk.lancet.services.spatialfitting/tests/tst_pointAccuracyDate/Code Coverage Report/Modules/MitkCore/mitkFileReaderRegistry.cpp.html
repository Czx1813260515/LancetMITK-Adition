<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkFileReaderRegistry.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkFileReaderRegistry.h"

#include "mitkCoreServices.h"
#include "mitkIMimeTypeProvider.h"

// Microservices
#include &lt;usGetModuleContext.h&gt;
#include &lt;usLDAPProp.h&gt;
#include &lt;usModuleContext.h&gt;
#include &lt;usServiceProperties.h&gt;

#include "itksys/SystemTools.hxx"

mitk::FileReaderRegistry::FileReaderRegistry()
<span style = "background-color:#fdd">{
}</span>

mitk::FileReaderRegistry::~FileReaderRegistry()
<span style = "background-color:#fdd">{
  for (auto &amp;elem : m_ServiceObjects)</span>
  {
<span style = "background-color:#fdd">    elem.second.UngetService(elem.first);
  }
}</span>

mitk::MimeType mitk::FileReaderRegistry::GetMimeTypeForFile(const std::string &amp;path, us::ModuleContext *context)
<span style = "background-color:#fdd">{
  if (path.empty())</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "FileReaderRegistry::GetMimeTypeForFile was called with empty path. Returning empty MimeType, "</span>
                   "please report this error to the developers.";
  }

<span style = "background-color:#fdd">  mitk::CoreServicePointer&lt;mitk::IMimeTypeProvider&gt; mimeTypeProvider(mitk::CoreServices::GetMimeTypeProvider(context));
  std::vector&lt;MimeType&gt; mimeTypes = mimeTypeProvider-&gt;GetMimeTypesForFile(path);
  if (mimeTypes.empty())</span>
  {
<span style = "background-color:#fdd">    return MimeType();
  }</span>
  else
  {
<span style = "background-color:#fdd">    return mimeTypes.front();</span>
  }
<span style = "background-color:#fdd">}</span>

std::vector&lt;mitk::FileReaderRegistry::ReaderReference&gt; mitk::FileReaderRegistry::GetReferences(
  const MimeType &amp;mimeType, us::ModuleContext *context)
<span style = "background-color:#fdd">{
  if (context == nullptr)
    context = us::GetModuleContext();</span>

<span style = "background-color:#fdd">  std::string filter = us::LDAPProp(us::ServiceConstants::OBJECTCLASS()) == us_service_interface_iid&lt;IFileReader&gt;() &amp;&amp;</span>
                       us::LDAPProp(IFileReader::PROP_MIMETYPE()) == mimeType.GetName();
<span style = "background-color:#fdd">  return context-&gt;GetServiceReferences&lt;IFileReader&gt;(filter);
}</span>

mitk::IFileReader *mitk::FileReaderRegistry::GetReader(const mitk::FileReaderRegistry::ReaderReference &amp;ref,
                                                       us::ModuleContext *context)
<span style = "background-color:#fdd">{
  if (context == nullptr)
    context = us::GetModuleContext();</span>

<span style = "background-color:#fdd">  us::ServiceObjects&lt;mitk::IFileReader&gt; serviceObjects = context-&gt;GetServiceObjects(ref);
  mitk::IFileReader *reader = serviceObjects.GetService();
  m_ServiceObjects.insert(std::make_pair(reader, serviceObjects));
  return reader;
}</span>

std::vector&lt;mitk::IFileReader *&gt; mitk::FileReaderRegistry::GetReaders(const MimeType &amp;mimeType,
                                                                      us::ModuleContext *context)
<span style = "background-color:#fdd">{
  if (context == nullptr)
    context = us::GetModuleContext();</span>

<span style = "background-color:#fdd">  std::vector&lt;mitk::IFileReader *&gt; result;</span>

<span style = "background-color:#fdd">  if (!mimeType.IsValid())
    return result;</span>

<span style = "background-color:#fdd">  std::vector&lt;us::ServiceReference&lt;IFileReader&gt;&gt; refs = GetReferences(mimeType, context);
  std::sort(refs.begin(), refs.end());</span>

<span style = "background-color:#fdd">  result.reserve(refs.size());</span>

  // Translate List of ServiceRefs to List of Pointers
<span style = "background-color:#fdd">  for (std::vector&lt;us::ServiceReference&lt;IFileReader&gt;&gt;::const_reverse_iterator iter = refs.rbegin(), end = refs.rend();
       iter != end;
       ++iter)</span>
  {
<span style = "background-color:#fdd">    us::ServiceObjects&lt;mitk::IFileReader&gt; serviceObjects = context-&gt;GetServiceObjects(*iter);
    mitk::IFileReader *reader = serviceObjects.GetService();
    m_ServiceObjects.insert(std::make_pair(reader, serviceObjects));
    result.push_back(reader);
  }</span>

<span style = "background-color:#fdd">  return result;
}</span>

void mitk::FileReaderRegistry::UngetReader(mitk::IFileReader *reader)
<span style = "background-color:#fdd">{
  auto readerIter =</span>
    m_ServiceObjects.find(reader);
<span style = "background-color:#fdd">  if (readerIter != m_ServiceObjects.end())</span>
  {
<span style = "background-color:#fdd">    readerIter-&gt;second.UngetService(reader);
    m_ServiceObjects.erase(readerIter);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::FileReaderRegistry::UngetReaders(const std::vector&lt;mitk::IFileReader *&gt; &amp;readers)
<span style = "background-color:#fdd">{
  for (const auto &amp;reader : readers)</span>
  {
<span style = "background-color:#fdd">    this-&gt;UngetReader(reader);
  }
}</span></pre>
	</body>
</html>