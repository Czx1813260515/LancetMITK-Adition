<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>robotRegistration.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
#include "robotRegistration.h"
#include &lt;vtkMatrix4x4.h&gt;
#include &lt;vtkNew.h&gt;
#include &lt;mitkLog.h&gt;

#ifndef M_PI
#define M_PI (3.14159265358979323846)
#endif

using namespace Eigen;
void RobotRegistration::AddPose(mitk::NavigationData::Pointer nd_robot2flange, mitk::NavigationData::Pointer nd_Ndi2RegistFrame, bool translationOnly)
<span style = "background-color:#fdd">{
  mitk::Matrix3D Rrobot2flange = nd_robot2flange-&gt;GetRotationMatrix();
  mitk::Point3D Vrobot2flange = nd_robot2flange-&gt;GetPosition();
  mitk::Matrix3D Rndi2RegistFrame = nd_Ndi2RegistFrame-&gt;GetRotationMatrix();
  mitk::Point3D Vndi2RegistFrame = nd_Ndi2RegistFrame-&gt;GetPosition();</span>

<span style = "background-color:#fdd">	Matrix3d r;
	r &lt;&lt; Rrobot2flange(0, 0), Rrobot2flange(0, 1), Rrobot2flange(0, 2), Rrobot2flange(1, 0),</span>
		Rrobot2flange(1, 1), Rrobot2flange(1, 2), Rrobot2flange(2, 0), Rrobot2flange(2, 1),
		Rrobot2flange(2, 2);

<span style = "background-color:#fdd">	Vector3d v;
	v &lt;&lt; Vrobot2flange[0], Vrobot2flange[1], Vrobot2flange[2];</span>

<span style = "background-color:#fdd">	Matrix3d rn;
	rn &lt;&lt; Rndi2RegistFrame(0, 0), Rndi2RegistFrame(0, 1), Rndi2RegistFrame(0, 2), Rndi2RegistFrame(1, 0),</span>
		Rndi2RegistFrame(1, 1), Rndi2RegistFrame(1, 2), Rndi2RegistFrame(2, 0), Rndi2RegistFrame(2, 1),
		Rndi2RegistFrame(2, 2);

<span style = "background-color:#fdd">	Vector3d vn;
    vn &lt;&lt; Vndi2RegistFrame[0], Vndi2RegistFrame[1], Vndi2RegistFrame[2];</span>

<span style = "background-color:#fdd">	this-&gt;m_translationOnly = translationOnly;
	if (translationOnly)</span>
	{
<span style = "background-color:#fdd">		R.emplace(R.begin(), r);
		V.emplace(V.begin(), v);
		Rn.emplace(Rn.begin(), rn);
		Vn.emplace(Vn.begin(), vn);
		m_numberOfFixR++;
	}</span>
	else
	{
<span style = "background-color:#fdd">		R.push_back(r);
		V.push_back(v);
		Rn.push_back(rn);
		Vn.push_back(vn);</span>
	}
<span style = "background-color:#fdd">	m_numberOfPose++;
}</span>

bool RobotRegistration::PopLastPose()
<span style = "background-color:#fdd">{
	return this-&gt;PopLastPose(this-&gt;m_translationOnly);
}</span>

bool RobotRegistration::PopLastPose(bool translationOnly)
<span style = "background-color:#fdd">{
	if (R.size() != V.size() || V.size() != Rn.size() || Rn.size() != Vn.size())</span>
	{
<span style = "background-color:#fdd">		MITK_WARN &lt;&lt; "Unknown error, the number of internal containers does not correspond.";
		return false;</span>
	}

<span style = "background-color:#fdd">	if (R.size() == 0)</span>
	{
<span style = "background-color:#fdd">		MITK_WARN &lt;&lt; "Internal container quantity is empty.";
		return false;</span>
	}

<span style = "background-color:#fdd">	if (true == translationOnly)</span>
	{
<span style = "background-color:#fdd">		R.erase(R.begin());
		V.erase(V.begin());
		Rn.erase(Rn.begin());
		Vn.erase(Vn.begin());
		--m_numberOfFixR;
	}</span>
	else
	{
<span style = "background-color:#fdd">		R.pop_back();
		V.pop_back();
		Rn.pop_back();
		Vn.pop_back();</span>
	}
<span style = "background-color:#fdd">	--m_numberOfPose;
	return true;
}</span>

void RobotRegistration::RemoveAllPose()
<span style = "background-color:#fdd">{
	Rn.clear();
	Vn.clear();</span>

<span style = "background-color:#fdd">	R0 = Matrix3d();
	V0 = Vector3d();</span>

<span style = "background-color:#fdd">	R.clear();
	V.clear();</span>

<span style = "background-color:#fdd">	Re = Matrix3d();
	Ve = Vector3d();</span>

<span style = "background-color:#fdd">	m_numberOfFixR = 0;
	m_numberOfPose = 0;</span>

<span style = "background-color:#fdd">	m_translationOnly = true;
	m_calculateEndToolAttitude = false;
}</span>

int RobotRegistration::PoseCount() const
<span style = "background-color:#fdd">{
	return m_numberOfPose;
}</span>

bool RobotRegistration::GetRegistraionMatrix(vtkMatrix4x4* output)
<span style = "background-color:#fdd">{
	if (Regist() == false)</span>
	{
<span style = "background-color:#fdd">		return false;</span>
	}

<span style = "background-color:#fdd">	Matrix4d matrix;
	matrix.setIdentity();
	matrix.block(0, 0, 3, 3) = R0;
	matrix.block(0, 3, 3, 1) = V0;</span>

<span style = "background-color:#fdd">	vtkNew&lt;vtkMatrix4x4&gt; res;
	res-&gt;DeepCopy(matrix.data());
	res-&gt;Transpose();</span>

<span style = "background-color:#fdd">	output-&gt;DeepCopy(res);
	return true;
}</span>

void RobotRegistration::GetTCP(std::array&lt;double, 6&gt;&amp; output)
<span style = "background-color:#fdd">{</span>
	//In case anyone forgets to do calculation
<span style = "background-color:#fdd">	Regist();</span>

<span style = "background-color:#fdd">	output[0] = Ve(0);
	output[1] = Ve(1);
	output[2] = Ve(2);</span>

<span style = "background-color:#fdd">	Eigen::Vector3d eulerAngle = Re.eulerAngles(2, 1, 0);
	output[3] = eulerAngle(0);
	output[4] = eulerAngle(1);
	output[5] = eulerAngle(2);
}</span>


bool RobotRegistration::Regist()
<span style = "background-color:#fdd">{</span>
	//check calculation pre requirements
<span style = "background-color:#fdd">	if (m_numberOfFixR &lt; 4)</span>
	{
<span style = "background-color:#fdd">		MITK_ERROR &lt;&lt; "At least four translation only pose needed to regist";
		return false;</span>
	}
	// check if truly translate only
<span style = "background-color:#fdd">	for (int i = 0; i &lt; m_numberOfFixR; i++)</span>
	{
<span style = "background-color:#fdd">		if (!R[i].isApprox(R[0], 0.001))</span>
		{
<span style = "background-color:#fdd">			MITK_WARN &lt;&lt; "There is rotation in Only translation pose, Registration Is not accurate. ";
			MITK_WARN &lt;&lt; R[0];
			MITK_WARN &lt;&lt; R[i];</span>
		}
<span style = "background-color:#fdd">	}</span>
	//print r v
<span style = "background-color:#fdd">	MITK_INFO &lt;&lt; "RV robot ";
	for each (auto r in R)</span>
	{
<span style = "background-color:#fdd">		MITK_INFO &lt;&lt; r;
	}
	for each (auto v in V)</span>
	{
<span style = "background-color:#fdd">		MITK_INFO &lt;&lt; v;
	}
	MITK_INFO &lt;&lt; "RV ndi base";
	for each (auto rn in Rn)</span>
	{
<span style = "background-color:#fdd">		MITK_INFO &lt;&lt; rn;
	}
	for each (auto vn in Vn)</span>
	{
<span style = "background-color:#fdd">		MITK_INFO &lt;&lt; vn;
	}
	calculateR0();
	calculateVe();
	calculateV0();
	calculateRe();
	return true;
}</span>

double RobotRegistration::RMS()
<span style = "background-color:#fdd">{
	double res = 0;
	for (int i = 0; i &lt; m_numberOfPose; i++)</span>
	{
<span style = "background-color:#fdd">		Vector3d err = Vn[i] - R0 * R[i] * Ve - R0 * V[i] - V0;
		res += err.cwiseProduct(err).sum();
	}
	return sqrt(res / m_numberOfPose);
}</span>

void RobotRegistration::Print()
<span style = "background-color:#fdd">{
	for (int i = 0; i &lt; Rn.size(); i++)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "Robot Matrix in algo" &lt;&lt; std::endl;
		std::cout &lt;&lt; R[i] &lt;&lt; std::endl;
		std::cout &lt;&lt; V[i] &lt;&lt; std::endl;
		std::cout &lt;&lt; "tool Matrix in algo" &lt;&lt; std::endl;
		std::cout &lt;&lt; Rn[i] &lt;&lt; std::endl;
		std::cout &lt;&lt; Vn[i] &lt;&lt; std::endl;
	}
}</span>

void RobotRegistration::calculateR0()
<span style = "background-color:#fdd">{
	MatrixXd A;
	A.resize(3, m_numberOfFixR - 1);
	int col_index = 0;
	for (int i = 1; i &lt; m_numberOfFixR; i++)</span>
	{
<span style = "background-color:#fdd">		Vector3d dV = V[i] - V[i - 1];
		A.col(col_index) = dV;
		col_index++;
	}</span>
	//std::cout &lt;&lt; "A:\n" &lt;&lt; A &lt;&lt; std::endl;

<span style = "background-color:#fdd">	Matrix3Xd B;
	B.resize(3, m_numberOfFixR - 1);
	col_index = 0;
	for (int i = 1; i &lt; m_numberOfFixR; i++)</span>
	{
<span style = "background-color:#fdd">		Vector3d dV = Vn[i] - Vn[i - 1];
		B.col(col_index) = dV;
		col_index++;
	}</span>
	//std::cout &lt;&lt; "B:\n" &lt;&lt; B &lt;&lt; std::endl;

<span style = "background-color:#fdd">	MatrixXd ABt = A * B.transpose();</span>
	//std::cout &lt;&lt; "ABt:\n" &lt;&lt; ABt &lt;&lt; std::endl;

<span style = "background-color:#fdd">	JacobiSVD&lt;MatrixXd&gt; svd(ABt, ComputeThinU | ComputeThinV);
	auto v = svd.matrixV();
	auto u = svd.matrixU();</span>
	//std::cout &lt;&lt; "V:\n" &lt;&lt; v &lt;&lt; std::endl;
	//std::cout &lt;&lt; "U:\n" &lt;&lt; u &lt;&lt; std::endl;
<span style = "background-color:#fdd">	R0 = v * u.transpose();</span>

	//std::cout &lt;&lt; "R0:\n" &lt;&lt; R0 &lt;&lt; std::endl;
<span style = "background-color:#fdd">}</span>

void RobotRegistration::calculateRe()
<span style = "background-color:#fdd">{
	MatrixXd A;
	const int n = m_numberOfPose - m_numberOfFixR;
	A.resize(3 * n, 3);
	for (int i = 0; i &lt; n; i++)</span>
	{
<span style = "background-color:#fdd">		A.block(3 * i, 0, 3, 3) = R[i + m_numberOfFixR];
	}</span>
	//std::cout &lt;&lt; "A:\n" &lt;&lt; A &lt;&lt; std::endl;

<span style = "background-color:#fdd">	MatrixXd B;
	B.resize(3 * n, 3);
	for (int i = 0; i &lt; n; i++)</span>
	{
<span style = "background-color:#fdd">		B.block(3 * i, 0, 3, 3) = R0.transpose() * Rn[i + m_numberOfFixR];
	}</span>
	//std::cout &lt;&lt; "B:\n" &lt;&lt; B &lt;&lt; std::endl;
<span style = "background-color:#fdd">	Re = (A.transpose() * A).inverse() * A.transpose() * B;</span>
	//std::cout &lt;&lt; "Re:\n" &lt;&lt; Re &lt;&lt; std::endl;
<span style = "background-color:#fdd">}</span>

void RobotRegistration::calculateVe()
<span style = "background-color:#fdd">{
	MatrixXd A;
	const int n = m_numberOfPose - m_numberOfFixR - 1;
	A.resize(3 * n, 3);
	for (int i = 0; i &lt; n; i++)</span>
	{
<span style = "background-color:#fdd">		Matrix3d a = R0 * (R[i + m_numberOfFixR + 1] - R[i + m_numberOfFixR]);
		A.block(3 * i, 0, 3, 3) = a;
	}</span>
	//std::cout &lt;&lt; "A:\n" &lt;&lt; A &lt;&lt; std::endl;

<span style = "background-color:#fdd">	MatrixXd B;
	B.resize(3 * n, 1);
	for (int i = 0; i &lt; n; i++)</span>
	{
<span style = "background-color:#fdd">		B.block(3 * i, 0, 3, 1) =</span>
			Vn[i + m_numberOfFixR + 1] - Vn[i + m_numberOfFixR] - R0 * (V[i + m_numberOfFixR + 1] - V[i + m_numberOfFixR]);
<span style = "background-color:#fdd">	}</span>
	//std::cout &lt;&lt; "B:\n" &lt;&lt; B &lt;&lt; std::endl;
<span style = "background-color:#fdd">	Ve = (A.transpose() * A).inverse() * A.transpose() * B;</span>
	//std::cout &lt;&lt; "Ve:\n" &lt;&lt; Ve &lt;&lt; std::endl;
<span style = "background-color:#fdd">}</span>

void RobotRegistration::calculateV0()
<span style = "background-color:#fdd">{
	V0.setZero();
	for (int i = 0; i &lt; m_numberOfPose; i++)</span>
	{
<span style = "background-color:#fdd">		V0 = V0 + (Vn[i] - R0 * R[i] * Ve - R0 * V[i]);
	}
	V0 = V0 / R.size();</span>
	//std::cout &lt;&lt; "V0:\n" &lt;&lt; V0 &lt;&lt; std::endl;
<span style = "background-color:#fdd">}</span>

void RobotRegistration::genTestData()
<span style = "background-color:#fdd">{</span>
	//Tm2b
<span style = "background-color:#fdd">	Transform&lt;double, 3, Affine&gt; transform = Translation3d(10, 10, 10) * AngleAxis&lt;double&gt;(M_PI / 6, Vector3d(0, 0, 1));
	Matrix4d Tm2b = transform.matrix();
	std::cout &lt;&lt; "Tm2b:\n" &lt;&lt; Tm2b &lt;&lt; std::endl;</span>
	//Tf2e TCP
<span style = "background-color:#fdd">	transform = Translation3d(5, 5, 5) * AngleAxis&lt;double&gt;(M_PI / 2, Vector3d(0, 1, 0));
	Matrix4d Tf2e = transform.matrix();
	std::cout &lt;&lt; "Tf2e:\n" &lt;&lt; Tf2e &lt;&lt; std::endl;</span>

	//10 pose of robot arm,first 5 fixR;
<span style = "background-color:#fdd">	std::vector&lt;Matrix4d&gt; Tb2f;</span>
	//
<span style = "background-color:#fdd">	transform = Translation3d(5, 5, 5) * AngleAxis&lt;double&gt;(M_PI / 2, Vector3d(1, 2, 3).normalized());
	Tb2f.push_back(transform.matrix());
	transform = Translation3d(5, 3, 10) * AngleAxis&lt;double&gt;(M_PI / 2, Vector3d(1, 2, 3).normalized());
	Tb2f.push_back(transform.matrix());
	transform = Translation3d(5, 5, 4) * AngleAxis&lt;double&gt;(M_PI / 2, Vector3d(1, 2, 3).normalized());
	Tb2f.push_back(transform.matrix());
	transform = Translation3d(1, 5, 5) * AngleAxis&lt;double&gt;(M_PI / 2, Vector3d(1, 2, 3).normalized());
	Tb2f.push_back(transform.matrix());
	transform = Translation3d(5, 2, 6) * AngleAxis&lt;double&gt;(M_PI / 2, Vector3d(1, 2, 3).normalized());
	Tb2f.push_back(transform.matrix());</span>
	//
<span style = "background-color:#fdd">	transform = Translation3d(1, 5, 7) * AngleAxis&lt;double&gt;(M_PI / 6, Vector3d(1, 2, 3).normalized());
	Tb2f.push_back(transform.matrix());
	transform = Translation3d(5, 3, 10) * AngleAxis&lt;double&gt;(M_PI / 2, Vector3d(2, 1, 3).normalized());
	Tb2f.push_back(transform.matrix());
	transform = Translation3d(2, 5, 4) * AngleAxis&lt;double&gt;(M_PI / 5, Vector3d(1, 2, 3).normalized());
	Tb2f.push_back(transform.matrix());
	transform = Translation3d(1, 8, 3) * AngleAxis&lt;double&gt;(M_PI / 9, Vector3d(1, 0, 0).normalized());
	Tb2f.push_back(transform.matrix());
	transform = Translation3d(5, 2, 6) * AngleAxis&lt;double&gt;(M_PI / 2, Vector3d(1, 2, 0).normalized());
	Tb2f.push_back(transform.matrix());</span>

<span style = "background-color:#fdd">	std::vector&lt;Matrix4d&gt; Tm2e;
	for (auto t : Tb2f)</span>
	{
<span style = "background-color:#fdd">		Tm2e.push_back(Tm2b * t * Tf2e);
	}</span>

<span style = "background-color:#fdd">	for (int i = 0; i &lt; 10; i++)</span>
	{
<span style = "background-color:#fdd">		Matrix3d r = Tb2f[i].block(0, 0, 3, 3);
		Vector3d v = Tb2f[i].block(0, 3, 3, 1);</span>

<span style = "background-color:#fdd">		Matrix3d rn = Tm2e[i].block(0, 0, 3, 3);
		Vector3d vn = Tm2e[i].block(0, 3, 3, 1);</span>

<span style = "background-color:#fdd">		R.push_back(r);
		V.push_back(v);</span>

<span style = "background-color:#fdd">		Rn.push_back(rn);
		Vn.push_back(vn);
	}</span>

<span style = "background-color:#fdd">	m_numberOfFixR = 5;
}</span></pre>
	</body>
</html>