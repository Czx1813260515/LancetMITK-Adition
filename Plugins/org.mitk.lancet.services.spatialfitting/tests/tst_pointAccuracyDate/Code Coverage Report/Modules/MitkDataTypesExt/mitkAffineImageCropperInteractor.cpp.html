<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkAffineImageCropperInteractor.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkAffineImageCropperInteractor.h"

#include "mitkInteractionConst.h"
#include "mitkInteractionPositionEvent.h"
#include "mitkRotationOperation.h"
#include "mitkSurface.h"
#include "mitkVtkMapper.h"

#include &lt;mitkBoundingObject.h&gt;
#include &lt;mitkMouseWheelEvent.h&gt;
#include &lt;vtkCamera.h&gt;
#include &lt;vtkInteractorStyle.h&gt;
#include &lt;vtkMatrix4x4.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkRenderWindowInteractor.h&gt;

#include &lt;mitkRotationOperation.h&gt;
#include &lt;mitkScaleOperation.h&gt;

mitk::AffineImageCropperInteractor::AffineImageCropperInteractor()
<span style = "background-color:#fdd">{
  m_OriginalGeometry = Geometry3D::New();
}</span>

mitk::AffineImageCropperInteractor::~AffineImageCropperInteractor()
<span style = "background-color:#fdd">{
}</span>

void mitk::AffineImageCropperInteractor::ConnectActionsAndFunctions()
<span style = "background-color:#fdd">{</span>
  // **Conditions** that can be used in the state machine, to ensure that certain conditions are met, before actually
  // executing an action
<span style = "background-color:#fdd">  CONNECT_CONDITION("isOverObject", CheckOverObject);</span>

  // **Function** in the statmachine patterns also referred to as **Actions**
<span style = "background-color:#fdd">  CONNECT_FUNCTION("selectObject", SelectObject);
  CONNECT_FUNCTION("deselectObject", DeselectObject);
  CONNECT_FUNCTION("initTranslate", InitTranslate);
  CONNECT_FUNCTION("initRotate", InitRotate);
  CONNECT_FUNCTION("initDeformation", InitDeformation);
  CONNECT_FUNCTION("translateObject", TranslateObject);
  CONNECT_FUNCTION("rotateObject", RotateObject);
  CONNECT_FUNCTION("deformObject", DeformObject);
  CONNECT_FUNCTION("scaleRadius", ScaleRadius);
}</span>

void mitk::AffineImageCropperInteractor::DataNodeChanged()
<span style = "background-color:#fdd">{
}</span>

bool mitk::AffineImageCropperInteractor::CheckOverObject(const InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  mitk::DataNode::Pointer dn = this-&gt;GetDataNode();
  if (dn.IsNull())
    return false;
  const auto *positionEvent = dynamic_cast&lt;const InteractionPositionEvent *&gt;(interactionEvent);
  Point3D currentPickedPoint = positionEvent-&gt;GetPositionInWorld();
  auto *object = dynamic_cast&lt;mitk::BoundingObject *&gt;(dn-&gt;GetData());
  object-&gt;GetGeometry()-&gt;WorldToIndex(currentPickedPoint, currentPickedPoint);
  return object &amp;&amp; object-&gt;GetGeometry()-&gt;GetBoundingBox()-&gt;IsInside(currentPickedPoint);
}</span>

void mitk::AffineImageCropperInteractor::SelectObject(StateMachineAction *, InteractionEvent *)
<span style = "background-color:#fdd">{
  mitk::DataNode::Pointer dn = this-&gt;GetDataNode();</span>

<span style = "background-color:#fdd">  if (dn.IsNull())
    return;</span>

<span style = "background-color:#fdd">  m_SelectedNode = dn;</span>

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::AffineImageCropperInteractor::Deselect()
<span style = "background-color:#fdd">{
  mitk::DataNode::Pointer dn = this-&gt;GetDataNode();</span>

<span style = "background-color:#fdd">  if (dn.IsNull())
    return;</span>

<span style = "background-color:#fdd">  m_SelectedNode = dn;
}</span>

void mitk::AffineImageCropperInteractor::DeselectObject(StateMachineAction *, InteractionEvent *)
<span style = "background-color:#fdd">{
  Deselect();
  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::AffineImageCropperInteractor::ScaleRadius(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  const auto *wheelEvent = dynamic_cast&lt;const MouseWheelEvent *&gt;(interactionEvent);
  if (wheelEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  if (m_SelectedNode.IsNull())
    return;</span>

<span style = "background-color:#fdd">  double scale = (double)(wheelEvent-&gt;GetWheelDelta()) / 64.0;
  mitk::Point3D newScale;
  newScale[0] = newScale[1] = newScale[2] = scale;</span>

<span style = "background-color:#fdd">  mitk::Point3D anchorPoint = wheelEvent-&gt;GetPositionInWorld();
  auto *doOp = new mitk::ScaleOperation(OpSCALE, newScale, anchorPoint);
  m_SelectedNode-&gt;GetData()-&gt;GetGeometry()-&gt;ExecuteOperation(doOp);</span>

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::AffineImageCropperInteractor::InitTranslate(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  if (m_SelectedNode.IsNull())
    return;
  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  m_InitialPickedPoint = positionEvent-&gt;GetPositionInWorld();
  m_InitialPickedDisplayPoint = positionEvent-&gt;GetPointerPositionOnScreen();</span>

<span style = "background-color:#fdd">  mitk::Surface::Pointer surface = dynamic_cast&lt;mitk::Surface *&gt;(m_SelectedNode-&gt;GetData());
  mitk::BaseGeometry::Pointer surGeo = surface-&gt;GetGeometry();
  m_InitialOrigin = surGeo-&gt;GetOrigin();
}</span>

void mitk::AffineImageCropperInteractor::InitRotate(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  m_InitialPickedPoint = positionEvent-&gt;GetPositionInWorld();
  m_InitialPickedDisplayPoint = positionEvent-&gt;GetPointerPositionOnScreen();</span>

<span style = "background-color:#fdd">  mitk::Surface::Pointer surface = dynamic_cast&lt;mitk::Surface *&gt;(m_SelectedNode-&gt;GetData());
  mitk::BaseGeometry::Pointer surGeo = surface-&gt;GetGeometry();
  m_OriginalGeometry = dynamic_cast&lt;mitk::Geometry3D *&gt;(surGeo.GetPointer());
}</span>

void mitk::AffineImageCropperInteractor::InitDeformation(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  m_InitialPickedPoint = positionEvent-&gt;GetPositionInWorld();
  m_InitialPickedDisplayPoint = positionEvent-&gt;GetPointerPositionOnScreen();</span>

<span style = "background-color:#fdd">  mitk::Surface::Pointer surface = dynamic_cast&lt;mitk::Surface *&gt;(m_SelectedNode-&gt;GetData());
  mitk::BaseGeometry::Pointer surGeo = surface-&gt;GetGeometry();
  m_OriginalGeometry = dynamic_cast&lt;mitk::Geometry3D *&gt;(surGeo.GetPointer());
}</span>

void mitk::AffineImageCropperInteractor::TranslateObject(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  Point3D currentPickedPoint = positionEvent-&gt;GetPositionInWorld();</span>

<span style = "background-color:#fdd">  Vector3D interactionMove;
  interactionMove[0] = currentPickedPoint[0] - m_InitialPickedPoint[0];
  interactionMove[1] = currentPickedPoint[1] - m_InitialPickedPoint[1];
  interactionMove[2] = currentPickedPoint[2] - m_InitialPickedPoint[2];</span>

<span style = "background-color:#fdd">  mitk::Surface::Pointer surface = dynamic_cast&lt;mitk::Surface *&gt;(m_SelectedNode-&gt;GetData());
  mitk::BaseGeometry::Pointer surGeo = surface-&gt;GetGeometry();
  surGeo-&gt;SetOrigin(m_InitialOrigin);
  surGeo-&gt;Translate(interactionMove);</span>

<span style = "background-color:#fdd">  RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::AffineImageCropperInteractor::DeformObject(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  Point3D currentPickedPoint = positionEvent-&gt;GetPositionInWorld();
  Vector3D interactionMove = currentPickedPoint - m_InitialPickedPoint;</span>

<span style = "background-color:#fdd">  mitk::Surface::Pointer surface = dynamic_cast&lt;mitk::Surface *&gt;(m_SelectedNode-&gt;GetData());
  surface-&gt;SetGeometry(m_OriginalGeometry);
  mitk::BaseGeometry::Pointer surGeo = surface-&gt;GetGeometry();</span>

<span style = "background-color:#fdd">  surGeo-&gt;WorldToIndex(interactionMove, interactionMove);
  Point3D scale;
  for (int i = 0; i &lt; 3; ++i)</span>
  {
<span style = "background-color:#fdd">    scale[i] = (interactionMove[i] * surGeo-&gt;GetMatrixColumn(i).magnitude()) - 1;
  }</span>

<span style = "background-color:#fdd">  mitk::Point3D anchorPoint = surGeo-&gt;GetCenter();</span>

<span style = "background-color:#fdd">  auto *doOp = new mitk::ScaleOperation(OpSCALE, scale, anchorPoint);
  surGeo-&gt;ExecuteOperation(doOp);</span>

<span style = "background-color:#fdd">  mitk::RenderingManager::GetInstance()-&gt;RequestUpdateAll();
}</span>

void mitk::AffineImageCropperInteractor::RotateObject(StateMachineAction *, InteractionEvent *interactionEvent)
<span style = "background-color:#fdd">{
  auto *positionEvent = dynamic_cast&lt;InteractionPositionEvent *&gt;(interactionEvent);
  if (positionEvent == nullptr)
    return;</span>

<span style = "background-color:#fdd">  Point2D currentPickedDisplayPoint = positionEvent-&gt;GetPointerPositionOnScreen();
  if (currentPickedDisplayPoint.EuclideanDistanceTo(m_InitialPickedDisplayPoint) &lt; 1)
    return;</span>

<span style = "background-color:#fdd">  vtkRenderer *currentVtkRenderer = interactionEvent-&gt;GetSender()-&gt;GetVtkRenderer();</span>

<span style = "background-color:#fdd">  if (currentVtkRenderer &amp;&amp; currentVtkRenderer-&gt;GetActiveCamera())</span>
  {
    double vpn[3];
<span style = "background-color:#fdd">    currentVtkRenderer-&gt;GetActiveCamera()-&gt;GetViewPlaneNormal(vpn);</span>

<span style = "background-color:#fdd">    Vector3D rotationAxis;
    rotationAxis[0] = vpn[0];
    rotationAxis[1] = vpn[1];
    rotationAxis[2] = vpn[2];
    rotationAxis.Normalize();</span>

<span style = "background-color:#fdd">    Vector2D move = currentPickedDisplayPoint - m_InitialPickedDisplayPoint;</span>

<span style = "background-color:#fdd">    double rotationAngle = -57.3 * atan(move[0] / move[1]);
    if (move[1] &lt; 0)
      rotationAngle += 180;</span>

    // Use center of data bounding box as center of rotation
<span style = "background-color:#fdd">    Point3D rotationCenter = m_OriginalGeometry-&gt;GetCenter();
    if (positionEvent-&gt;GetSender()-&gt;GetMapperID() == BaseRenderer::Standard2D)
      rotationCenter = m_InitialPickedPoint;</span>

    // Reset current Geometry3D to original state (pre-interaction) and
    // apply rotation
<span style = "background-color:#fdd">    RotationOperation op(OpROTATE, rotationCenter, rotationAxis, rotationAngle);
    Geometry3D::Pointer newGeometry = static_cast&lt;Geometry3D *&gt;(m_OriginalGeometry-&gt;Clone().GetPointer());
    newGeometry-&gt;ExecuteOperation(&amp;op);
    m_SelectedNode-&gt;GetData()-&gt;SetGeometry(newGeometry);</span>

<span style = "background-color:#fdd">    RenderingManager::GetInstance()-&gt;RequestUpdateAll();
  }
}</span></pre>
	</body>
</html>