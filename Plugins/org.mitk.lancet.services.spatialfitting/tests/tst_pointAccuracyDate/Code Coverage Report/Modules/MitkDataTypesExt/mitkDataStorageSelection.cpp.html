<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDataStorageSelection.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkDataStorageSelection.h"
#include &lt;itkCommand.h&gt;
#include &lt;mitkBaseProperty.h&gt;
#include &lt;mitkPropertyList.h&gt;

namespace mitk
{
  DataStorageSelection::DataStorageSelection(mitk::DataStorage *_DataStorage, bool _AutoAddNodes)
<span style = "background-color:#fdd">    : m_DataStorage(nullptr), m_Predicate(nullptr), m_SelfCall(false), m_AutoAddNodes(_AutoAddNodes)
  {
    this-&gt;SetDataStorage(_DataStorage);
  }</span>

  DataStorageSelection::DataStorageSelection(mitk::DataStorage *_DataStorage,
                                             mitk::NodePredicateBase *_Predicate,
                                             bool _AutoAddNodes)
<span style = "background-color:#fdd">    : m_DataStorage(nullptr), m_Predicate(_Predicate), m_SelfCall(false), m_AutoAddNodes(_AutoAddNodes)
  {
    this-&gt;SetDataStorage(_DataStorage);
  }</span>

  DataStorageSelection::~DataStorageSelection()
<span style = "background-color:#fdd">  {</span>
    // kick datastorage and all nodes and all listeners
<span style = "background-color:#fdd">    this-&gt;SetDataStorage(nullptr);
  }</span>

<span style = "background-color:#fdd">  mitk::DataStorage::Pointer DataStorageSelection::GetDataStorage() const { return m_DataStorage; }
  mitk::NodePredicateBase::Pointer DataStorageSelection::GetPredicate() const { return m_Predicate; }
  unsigned int DataStorageSelection::GetSize() const { return m_Nodes.size(); }
  mitk::DataNode::Pointer DataStorageSelection::GetNode() const { return this-&gt;GetNode(0); }</span>
  mitk::DataNode::Pointer DataStorageSelection::GetNode(unsigned int index) const
<span style = "background-color:#fdd">  {
    return (index &lt; m_Nodes.size()) ? m_Nodes.at(index) : nullptr;
  }</span>

<span style = "background-color:#fdd">  std::vector&lt;mitk::DataNode *&gt; DataStorageSelection::GetNodes() const { return m_Nodes; }
  bool DataStorageSelection::DoesAutoAddNodes() const { return m_AutoAddNodes; }</span>
  DataStorageSelection &amp;DataStorageSelection::operator=(mitk::DataNode *node)
<span style = "background-color:#fdd">  {
    this-&gt;RemoveAllNodes();
    this-&gt;AddNode(node);
    return *this;
  }</span>

  DataStorageSelection &amp;DataStorageSelection::operator=(mitk::DataNode::Pointer node)
<span style = "background-color:#fdd">  {
    *this = node.GetPointer();
    return *this;
  }</span>

  void DataStorageSelection::SetDataStorage(mitk::DataStorage *_DataStorage)
<span style = "background-color:#fdd">  {</span>
    // only proceed if we have a new datastorage
<span style = "background-color:#fdd">    if (m_DataStorage != _DataStorage)</span>
    {
      // if a data storage was set before remove old event listeners
<span style = "background-color:#fdd">      if (m_DataStorage != nullptr)</span>
      {
<span style = "background-color:#fdd">        if (m_AutoAddNodes)
          this-&gt;m_DataStorage-&gt;AddNodeEvent.RemoveListener(</span>
            mitk::MessageDelegate1&lt;DataStorageSelection, const mitk::DataNode *&gt;(this, &amp;DataStorageSelection::AddNode));

<span style = "background-color:#fdd">        this-&gt;m_DataStorage-&gt;RemoveNodeEvent.RemoveListener(</span>
          mitk::MessageDelegate1&lt;DataStorageSelection, const mitk::DataNode *&gt;(this,
                                                                               &amp;DataStorageSelection::RemoveNode));

<span style = "background-color:#fdd">        m_DataStorage-&gt;RemoveObserver(m_DataStorageDeletedTag);
        m_DataStorageDeletedTag = 0;</span>
      }

      // set new data storage
<span style = "background-color:#fdd">      m_DataStorage = _DataStorage;</span>

      // if new storage is not 0 subscribe for events
<span style = "background-color:#fdd">      if (m_DataStorage != nullptr)</span>
      {
        // subscribe for node added/removed events
<span style = "background-color:#fdd">        if (m_AutoAddNodes)
          this-&gt;m_DataStorage-&gt;AddNodeEvent.AddListener(</span>
            mitk::MessageDelegate1&lt;DataStorageSelection, const mitk::DataNode *&gt;(this, &amp;DataStorageSelection::AddNode));

<span style = "background-color:#fdd">        this-&gt;m_DataStorage-&gt;RemoveNodeEvent.AddListener(</span>
          mitk::MessageDelegate1&lt;DataStorageSelection, const mitk::DataNode *&gt;(this,
                                                                               &amp;DataStorageSelection::RemoveNode));

<span style = "background-color:#fdd">        itk::MemberCommand&lt;DataStorageSelection&gt;::Pointer ObjectChangedCommand =</span>
          itk::MemberCommand&lt;DataStorageSelection&gt;::New();
<span style = "background-color:#fdd">        ObjectChangedCommand-&gt;SetCallbackFunction(this, &amp;DataStorageSelection::ObjectChanged);</span>

<span style = "background-color:#fdd">        m_DataStorageDeletedTag = m_DataStorage-&gt;AddObserver(itk::DeleteEvent(), ObjectChangedCommand);
      }</span>
      // Reset model (even if datastorage is 0-&gt;will be checked in Reset())
<span style = "background-color:#fdd">      this-&gt;Reset();</span>
    }
<span style = "background-color:#fdd">  }</span>

  void DataStorageSelection::SetPredicate(mitk::NodePredicateBase *_Predicate)
<span style = "background-color:#fdd">  {</span>
    // ensure that a new predicate is set in order to avoid unnecessary changed events
<span style = "background-color:#fdd">    if (m_Predicate != _Predicate)</span>
    {
<span style = "background-color:#fdd">      m_Predicate = _Predicate;
      this-&gt;Reset();</span>
    }
<span style = "background-color:#fdd">  }</span>

  void DataStorageSelection::AddNode(const mitk::DataNode *node)
<span style = "background-color:#fdd">  {</span>
    // garantuee no recursions when a new node event is thrown
<span style = "background-color:#fdd">    if (m_SelfCall)
      return;</span>

    // if we have a predicate, check node against predicate first
<span style = "background-color:#fdd">    if (m_Predicate.IsNotNull() &amp;&amp; !m_Predicate-&gt;CheckNode(node))
      return;</span>

    // no duplicates
<span style = "background-color:#fdd">    if (std::find(m_Nodes.begin(), m_Nodes.end(), node) != m_Nodes.end())
      return;</span>

<span style = "background-color:#fdd">    auto *nonConstNode = const_cast&lt;mitk::DataNode *&gt;(node);</span>
    // add listener
<span style = "background-color:#fdd">    this-&gt;AddListener(nonConstNode);</span>

    // add node
<span style = "background-color:#fdd">    m_Nodes.push_back(nonConstNode);</span>

<span style = "background-color:#fdd">    NodeAdded.Send(node);
  }</span>

  void DataStorageSelection::RemoveNode(const mitk::DataNode *node)
<span style = "background-color:#fdd">  {
    if (m_SelfCall)
      return;</span>

    // find corresponding node
<span style = "background-color:#fdd">    auto nodeIt = std::find(m_Nodes.begin(), m_Nodes.end(), node);</span>

<span style = "background-color:#fdd">    if (nodeIt == m_Nodes.end())
      return;</span>

<span style = "background-color:#fdd">    auto *nonConstNode = const_cast&lt;mitk::DataNode *&gt;(node);</span>
    // add listener
<span style = "background-color:#fdd">    this-&gt;RemoveListener(nonConstNode);</span>

    // remove node
<span style = "background-color:#fdd">    m_Nodes.erase(nodeIt);</span>

<span style = "background-color:#fdd">    NodeRemoved.Send(node);
  }</span>

  void DataStorageSelection::RemoveAllNodes()
<span style = "background-color:#fdd">  {</span>
    // remove all nodes now (dont use iterators because removing elements
    // would invalidate the iterator)
    // start at the last element: first in, last out
<span style = "background-color:#fdd">    unsigned int i = m_Nodes.size();
    while (!m_Nodes.empty())</span>
    {
<span style = "background-color:#fdd">      --i;
      this-&gt;RemoveNode(m_Nodes.at(i));
    }
  }</span>

  void DataStorageSelection::ObjectChanged(const itk::Object *caller, const itk::EventObject &amp; /*event*/)
<span style = "background-color:#fdd">  {
    if (m_SelfCall)
      return;</span>

    /*
    const itk::DeleteEvent* delEvent = 0;
    const itk::ModifiedEvent* modifiedEvent = dynamic_cast&lt;const itk::ModifiedEvent*&gt;(&amp;event);
    if(!modifiedEvent)
      delEvent = dynamic_cast&lt;const itk::DeleteEvent*&gt;(&amp;event);
    */
<span style = "background-color:#fdd">    const mitk::BaseProperty *prop = nullptr;
    const mitk::PropertyList *propList = nullptr;
    const auto *node = dynamic_cast&lt;const mitk::DataNode *&gt;(caller);
    if (!node)</span>
    {
<span style = "background-color:#fdd">      if ((prop = dynamic_cast&lt;const mitk::BaseProperty *&gt;(caller)))</span>
      {
<span style = "background-color:#fdd">        node = this-&gt;FindNode(prop);
      }
      else if ((propList = dynamic_cast&lt;const mitk::PropertyList *&gt;(caller)))</span>
      {
<span style = "background-color:#fdd">        node = this-&gt;FindNode(propList);
      }
      else if (dynamic_cast&lt;const mitk::DataStorage *&gt;(caller))</span>
      {
<span style = "background-color:#fdd">        this-&gt;SetDataStorage(nullptr);</span>
      }
    }

<span style = "background-color:#fdd">    if (prop &amp;&amp; node)</span>
    {
<span style = "background-color:#fdd">      PropertyChanged.Send(node, prop);
    }
    else if (node)</span>
    {
<span style = "background-color:#fdd">      NodeChanged.Send(node);</span>
    }
<span style = "background-color:#fdd">  }</span>

  //# protected
  mitk::DataNode::Pointer DataStorageSelection::FindNode(const mitk::BaseProperty *prop) const
<span style = "background-color:#fdd">  {
    mitk::DataNode *node = nullptr;
    for (auto it = m_Nodes.begin(); it != m_Nodes.end(); ++it)</span>
    {
<span style = "background-color:#fdd">      for (auto it2 = (*it)-&gt;GetPropertyList()-&gt;GetMap()-&gt;begin(); it2 != (*it)-&gt;GetPropertyList()-&gt;GetMap()-&gt;end();
           ++it2)</span>
      {
<span style = "background-color:#fdd">        if (it2-&gt;second == prop)</span>
        {
<span style = "background-color:#fdd">          node = *it;
          break;
        }
      }
    }
    return node;
  }</span>

  mitk::DataNode::Pointer DataStorageSelection::FindNode(const mitk::PropertyList *propList) const
<span style = "background-color:#fdd">  {
    mitk::DataNode *node = nullptr;
    for (auto it = m_Nodes.begin(); it != m_Nodes.end(); ++it)</span>
    {
<span style = "background-color:#fdd">      if ((*it)-&gt;GetPropertyList() == propList)</span>
      {
<span style = "background-color:#fdd">        node = *it;
        break;
      }
    }
    return node;
  }</span>

  void DataStorageSelection::Reset()
<span style = "background-color:#fdd">  {
    this-&gt;RemoveAllNodes();</span>
    // the whole reset depends on the fact if a data storage is set or not
<span style = "background-color:#fdd">    if (m_DataStorage)</span>
    {
<span style = "background-color:#fdd">      mitk::DataStorage::SetOfObjects::ConstPointer _NodeSet = nullptr;
      if (m_AutoAddNodes &amp;&amp; m_Predicate.IsNotNull())</span>
        // get subset
<span style = "background-color:#fdd">        _NodeSet = m_DataStorage-&gt;GetSubset(m_Predicate);</span>
      // if predicate is nullptr, select all nodes
<span style = "background-color:#fdd">      else if (m_AutoAddNodes)</span>
      {
<span style = "background-color:#fdd">        _NodeSet = m_DataStorage-&gt;GetAll();
      }</span>
      else
<span style = "background-color:#fdd">        return;</span>
      // finally add all nodes to the model
<span style = "background-color:#fdd">      for (auto it = _NodeSet-&gt;begin(); it != _NodeSet-&gt;end(); it++)</span>
      {
        // save node
<span style = "background-color:#fdd">        this-&gt;AddNode(*it);
      }
    }
  }</span>

  void DataStorageSelection::RemoveListener(mitk::DataNode *node)
<span style = "background-color:#fdd">  {</span>
    // remove node listener
<span style = "background-color:#fdd">    node-&gt;RemoveObserver(m_NodeModifiedObserverTags[node]);
    m_NodeModifiedObserverTags.erase(node);</span>

    // remove propertylist listener
<span style = "background-color:#fdd">    mitk::PropertyList *propList = node-&gt;GetPropertyList();
    propList-&gt;RemoveObserver(m_PropertyListModifiedObserverTags[propList]);
    m_PropertyListModifiedObserverTags.erase(propList);
    propList-&gt;RemoveObserver(m_PropertyListDeletedObserverTags[propList]);
    m_PropertyListDeletedObserverTags.erase(propList);</span>

<span style = "background-color:#fdd">    mitk::BaseProperty *prop = nullptr;</span>
    // do the same for each property
<span style = "background-color:#fdd">    for (auto it = propList-&gt;GetMap()-&gt;begin(); it != propList-&gt;GetMap()-&gt;end(); ++it)</span>
    {
<span style = "background-color:#fdd">      prop = it-&gt;second;
      prop-&gt;RemoveObserver(m_PropertyModifiedObserverTags[prop]);
      m_PropertyModifiedObserverTags.erase(prop);
      prop-&gt;RemoveObserver(m_PropertyDeletedObserverTags[prop]);
      m_PropertyDeletedObserverTags.erase(prop);
    }
  }</span>

  void DataStorageSelection::AddListener(mitk::DataNode *node)
<span style = "background-color:#fdd">  {</span>
    // node listener
<span style = "background-color:#fdd">    itk::MemberCommand&lt;DataStorageSelection&gt;::Pointer ObjectChangedCommand =</span>
      itk::MemberCommand&lt;DataStorageSelection&gt;::New();
<span style = "background-color:#fdd">    ObjectChangedCommand-&gt;SetCallbackFunction(this, &amp;DataStorageSelection::ObjectChanged);</span>

<span style = "background-color:#fdd">    m_NodeModifiedObserverTags[node] = node-&gt;AddObserver(itk::ModifiedEvent(), ObjectChangedCommand);</span>

    // create propertylist listener
<span style = "background-color:#fdd">    mitk::PropertyList *propList = node-&gt;GetPropertyList();
    m_PropertyListModifiedObserverTags[propList] = propList-&gt;AddObserver(itk::ModifiedEvent(), ObjectChangedCommand);
    m_PropertyListDeletedObserverTags[propList] = propList-&gt;AddObserver(itk::DeleteEvent(), ObjectChangedCommand);</span>

<span style = "background-color:#fdd">    mitk::BaseProperty *prop = nullptr;</span>
    // do the same for each property
<span style = "background-color:#fdd">    for (auto it = propList-&gt;GetMap()-&gt;begin(); it != propList-&gt;GetMap()-&gt;end(); ++it)</span>
    {
<span style = "background-color:#fdd">      prop = it-&gt;second;
      m_PropertyModifiedObserverTags[prop] = prop-&gt;AddObserver(itk::ModifiedEvent(), ObjectChangedCommand);
      m_PropertyDeletedObserverTags[prop] = prop-&gt;AddObserver(itk::ModifiedEvent(), ObjectChangedCommand);
    }
  }</span>
}</pre>
	</body>
</html>