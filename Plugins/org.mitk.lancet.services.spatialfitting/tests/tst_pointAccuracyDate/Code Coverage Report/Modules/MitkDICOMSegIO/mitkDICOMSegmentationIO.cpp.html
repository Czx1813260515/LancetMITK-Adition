<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkDICOMSegmentationIO.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef __mitkDICOMSegmentationIO__cpp
#define __mitkDICOMSegmentationIO__cpp

#include "mitkDICOMSegmentationIO.h"

#include "mitkDICOMSegIOMimeTypes.h"
#include "mitkDICOMSegmentationConstants.h"
#include &lt;mitkDICOMDCMTKTagScanner.h&gt;
#include &lt;mitkDICOMIOHelper.h&gt;
#include &lt;mitkDICOMProperty.h&gt;
#include &lt;mitkIDICOMTagsOfInterest.h&gt;
#include &lt;mitkImageAccessByItk.h&gt;
#include &lt;mitkImageCast.h&gt;
#include &lt;mitkLocaleSwitch.h&gt;
#include &lt;mitkPropertyNameHelper.h&gt;


// itk
#include &lt;itkThresholdImageFilter.h&gt;

// dcmqi
#include &lt;dcmqi/ImageSEGConverter.h&gt;

// us
#include &lt;usGetModuleContext.h&gt;
#include &lt;usModuleContext.h&gt;

namespace mitk
{
  DICOMSegmentationIO::DICOMSegmentationIO()
<span style = "background-color:#dfd">    : AbstractFileIO(LabelSetImage::GetStaticNameOfClass(),</span>
      mitk::MitkDICOMSEGIOMimeTypes::DICOMSEG_MIMETYPE_NAME(),
      "DICOM Segmentation")
<span style = "background-color:#dfd">  {
    AbstractFileWriter::SetRanking(10);
    AbstractFileReader::SetRanking(10);
    this-&gt;RegisterService();
  }</span>

  std::vector&lt;mitk::DICOMTagPath&gt; DICOMSegmentationIO::GetDICOMTagsOfInterest()
<span style = "background-color:#dfd">  {
    std::vector&lt;mitk::DICOMTagPath&gt; result;
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_SEQUENCE_PATH());</span>

<span style = "background-color:#dfd">    result.emplace_back(DICOMSegmentationConstants::SEGMENT_NUMBER_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_LABEL_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_ALGORITHM_TYPE_PATH());</span>

<span style = "background-color:#dfd">    result.emplace_back(DICOMSegmentationConstants::ANATOMIC_REGION_SEQUENCE_PATH());
    result.emplace_back(DICOMSegmentationConstants::ANATOMIC_REGION_CODE_VALUE_PATH());
    result.emplace_back(DICOMSegmentationConstants::ANATOMIC_REGION_CODE_SCHEME_PATH());
    result.emplace_back(DICOMSegmentationConstants::ANATOMIC_REGION_CODE_MEANING_PATH());</span>

<span style = "background-color:#dfd">    result.emplace_back(DICOMSegmentationConstants::SEGMENTED_PROPERTY_CATEGORY_SEQUENCE_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_CATEGORY_CODE_VALUE_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_CATEGORY_CODE_SCHEME_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_CATEGORY_CODE_MEANING_PATH());</span>

<span style = "background-color:#dfd">    result.emplace_back(DICOMSegmentationConstants::SEGMENTED_PROPERTY_TYPE_SEQUENCE_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_TYPE_CODE_VALUE_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_TYPE_CODE_SCHEME_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_TYPE_CODE_MEANING_PATH());</span>

<span style = "background-color:#dfd">    result.emplace_back(DICOMSegmentationConstants::SEGMENTED_PROPERTY_MODIFIER_SEQUENCE_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_MODIFIER_CODE_VALUE_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_MODIFIER_CODE_SCHEME_PATH());
    result.emplace_back(DICOMSegmentationConstants::SEGMENT_MODIFIER_CODE_MEANING_PATH());</span>

<span style = "background-color:#dfd">    return result;
  }</span>

  IFileIO::ConfidenceLevel DICOMSegmentationIO::GetWriterConfidenceLevel() const
<span style = "background-color:#fdd">  {
    if (AbstractFileIO::GetWriterConfidenceLevel() == Unsupported)
      return Unsupported;</span>

    // Check if the input file is a segmentation
<span style = "background-color:#fdd">    const LabelSetImage *input = static_cast&lt;const LabelSetImage *&gt;(this-&gt;GetInput());</span>

<span style = "background-color:#fdd">    if (input)</span>
    {
<span style = "background-color:#fdd">      if ((input-&gt;GetDimension() != 3))</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "DICOM segmentation writer is tested only with 3D images, sorry.";
        return Unsupported;</span>
      }

      // Check if input file has dicom information for the referenced image (original DICOM image, e.g. CT) Still necessary, see write()
<span style = "background-color:#fdd">      mitk::StringLookupTableProperty::Pointer dicomFilesProp =</span>
      dynamic_cast&lt;mitk::StringLookupTableProperty *&gt;(input-&gt;GetProperty("referenceFiles").GetPointer());

<span style = "background-color:#fdd">      if (dicomFilesProp.IsNotNull())
        return Supported;
    }</span>

<span style = "background-color:#fdd">    return Unsupported;
  }</span>

  void DICOMSegmentationIO::Write()
<span style = "background-color:#fdd">  {
    ValidateOutputLocation();</span>

<span style = "background-color:#fdd">    mitk::LocaleSwitch localeSwitch("C");
    LocalFile localFile(this);
    const std::string path = localFile.GetFileName();</span>

<span style = "background-color:#fdd">    auto input = dynamic_cast&lt;const LabelSetImage *&gt;(this-&gt;GetInput());
    if (input == nullptr)
      mitkThrow() &lt;&lt; "Cannot write non-image data";</span>

    // Get DICOM information from referenced image
<span style = "background-color:#fdd">    vector&lt;std::unique_ptr&lt;DcmDataset&gt;&gt; dcmDatasetsSourceImage;
    std::unique_ptr&lt;DcmFileFormat&gt; readFileFormat(new DcmFileFormat());</span>
    try
    {
      // TODO: Generate dcmdataset witk DICOM tags from property list; ATM the source are the filepaths from the
      // property list
<span style = "background-color:#fdd">      mitk::StringLookupTableProperty::Pointer filesProp =</span>
        dynamic_cast&lt;mitk::StringLookupTableProperty *&gt;(input-&gt;GetProperty("referenceFiles").GetPointer());

<span style = "background-color:#fdd">      if (filesProp.IsNull())</span>
      {
<span style = "background-color:#fdd">        mitkThrow() &lt;&lt; "No property with dicom file path.";
        return;</span>
      }

<span style = "background-color:#fdd">      StringLookupTable filesLut = filesProp-&gt;GetValue();
      const StringLookupTable::LookupTableType &amp;lookUpTableMap = filesLut.GetLookupTable();</span>

<span style = "background-color:#fdd">      for (const auto &amp;it : lookUpTableMap)</span>
      {
<span style = "background-color:#fdd">        const char *fileName = (it.second).c_str();
        if (readFileFormat-&gt;loadFile(fileName, EXS_Unknown).good())</span>
        {
<span style = "background-color:#fdd">          std::unique_ptr&lt;DcmDataset&gt; readDCMDataset(readFileFormat-&gt;getAndRemoveDataset());
          dcmDatasetsSourceImage.push_back(std::move(readDCMDataset));
        }
      }
    }</span>
    catch (const std::exception &amp;e)
<span style = "background-color:#fdd">    {
      MITK_ERROR &lt;&lt; "An error occurred while getting the dicom informations: " &lt;&lt; e.what() &lt;&lt; endl;
      return;
    }</span>

    // Iterate over all layers. For each a dcm file will be generated
<span style = "background-color:#fdd">    for (unsigned int layer = 0; layer &lt; input-&gt;GetNumberOfLayers(); ++layer)</span>
    {
<span style = "background-color:#fdd">      vector&lt;itkInternalImageType::Pointer&gt; segmentations;</span>

      try
      {
        // Hack: Remove the const attribute to switch between the layer images. Normally you could get the different
        // layer images by input-&gt;GetLayerImage(layer)
<span style = "background-color:#fdd">        mitk::LabelSetImage *mitkLayerImage = const_cast&lt;mitk::LabelSetImage *&gt;(input);
        mitkLayerImage-&gt;SetActiveLayer(layer);</span>

        // Cast mitk layer image to itk
<span style = "background-color:#fdd">        ImageToItk&lt;itkInputImageType&gt;::Pointer imageToItkFilter = ImageToItk&lt;itkInputImageType&gt;::New();
        imageToItkFilter-&gt;SetInput(mitkLayerImage);</span>
        // Cast from original itk type to dcmqi input itk image type
        typedef itk::CastImageFilter&lt;itkInputImageType, itkInternalImageType&gt; castItkImageFilterType;
<span style = "background-color:#fdd">        castItkImageFilterType::Pointer castFilter = castItkImageFilterType::New();
        castFilter-&gt;SetInput(imageToItkFilter-&gt;GetOutput());
        castFilter-&gt;Update();</span>

<span style = "background-color:#fdd">        itkInternalImageType::Pointer itkLabelImage = castFilter-&gt;GetOutput();
        itkLabelImage-&gt;DisconnectPipeline();</span>

        // Iterate over all labels. For each label a segmentation image will be created
<span style = "background-color:#fdd">        const LabelSet *labelSet = input-&gt;GetLabelSet(layer);
        auto labelIter = labelSet-&gt;IteratorConstBegin();</span>
        // Ignore background label
<span style = "background-color:#fdd">        ++labelIter;</span>

<span style = "background-color:#fdd">        for (; labelIter != labelSet-&gt;IteratorConstEnd(); ++labelIter)</span>
        {
          // Thresold over the image with the given label value
<span style = "background-color:#fdd">          itk::ThresholdImageFilter&lt;itkInternalImageType&gt;::Pointer thresholdFilter =</span>
            itk::ThresholdImageFilter&lt;itkInternalImageType&gt;::New();
<span style = "background-color:#fdd">          thresholdFilter-&gt;SetInput(itkLabelImage);
          thresholdFilter-&gt;ThresholdOutside(labelIter-&gt;first, labelIter-&gt;first);
          thresholdFilter-&gt;SetOutsideValue(0);
          thresholdFilter-&gt;Update();
          itkInternalImageType::Pointer segmentImage = thresholdFilter-&gt;GetOutput();
          segmentImage-&gt;DisconnectPipeline();</span>

<span style = "background-color:#fdd">          segmentations.push_back(segmentImage);
        }
      }</span>
      catch (const itk::ExceptionObject &amp;e)
<span style = "background-color:#fdd">      {
        MITK_ERROR &lt;&lt; e.GetDescription() &lt;&lt; endl;
        return;
      }</span>

      // Create segmentation meta information
<span style = "background-color:#fdd">      const std::string tmpMetaInfoFile = this-&gt;CreateMetaDataJsonFile(layer);</span>

<span style = "background-color:#fdd">      MITK_INFO &lt;&lt; "Writing image: " &lt;&lt; path &lt;&lt; std::endl;</span>
      try
      {
        //TODO is there a better way? Interface expects a vector of raw pointer.
<span style = "background-color:#fdd">        vector&lt;DcmDataset*&gt; rawVecDataset;
        for (const auto&amp; dcmDataSet : dcmDatasetsSourceImage)
          rawVecDataset.push_back(dcmDataSet.get());</span>

        // Convert itk segmentation images to dicom image
<span style = "background-color:#fdd">        std::unique_ptr&lt;dcmqi::ImageSEGConverter&gt; converter = std::make_unique&lt;dcmqi::ImageSEGConverter&gt;();
        std::unique_ptr&lt;DcmDataset&gt; result(converter-&gt;itkimage2dcmSegmentation(rawVecDataset, segmentations, tmpMetaInfoFile, false));</span>

        // Write dicom file
<span style = "background-color:#fdd">        DcmFileFormat dcmFileFormat(result.get());</span>

<span style = "background-color:#fdd">        std::string filePath = path.substr(0, path.find_last_of("."));</span>
        // If there is more than one layer, we have to write more than 1 dicom file
<span style = "background-color:#fdd">        if (input-&gt;GetNumberOfLayers() != 1)
          filePath = filePath + std::to_string(layer) + ".dcm";</span>
        else
<span style = "background-color:#fdd">          filePath = filePath + ".dcm";</span>

<span style = "background-color:#fdd">        dcmFileFormat.saveFile(filePath.c_str(), EXS_LittleEndianExplicit);
      }</span>
      catch (const std::exception &amp;e)
<span style = "background-color:#fdd">      {
        MITK_ERROR &lt;&lt; "An error occurred during writing the DICOM Seg: " &lt;&lt; e.what() &lt;&lt; endl;
        return;
      }
    } // Write a dcm file for the next layer
  }</span>

  IFileIO::ConfidenceLevel DICOMSegmentationIO::GetReaderConfidenceLevel() const
<span style = "background-color:#fdd">  {
    if (AbstractFileIO::GetReaderConfidenceLevel() == Unsupported)
      return Unsupported;</span>

<span style = "background-color:#fdd">    const std::string fileName = this-&gt;GetLocalFileName();</span>

<span style = "background-color:#fdd">    DcmFileFormat dcmFileFormat;
    OFCondition status = dcmFileFormat.loadFile(fileName.c_str());</span>

<span style = "background-color:#fdd">    if (status.bad())
      return Unsupported;</span>

<span style = "background-color:#fdd">    OFString modality;
    if (dcmFileFormat.getDataset()-&gt;findAndGetOFString(DCM_Modality, modality).good())</span>
    {
<span style = "background-color:#fdd">      if (modality.compare("SEG") == 0)
        return Supported;</span>
      else
<span style = "background-color:#fdd">        return Unsupported;</span>
    }
<span style = "background-color:#fdd">    return Unsupported;
  }</span>

  std::vector&lt;BaseData::Pointer&gt; DICOMSegmentationIO::DoRead()
<span style = "background-color:#fdd">  {
    mitk::LocaleSwitch localeSwitch("C");</span>

<span style = "background-color:#fdd">    LabelSetImage::Pointer labelSetImage;
    std::vector&lt;BaseData::Pointer&gt; result;</span>

<span style = "background-color:#fdd">    const std::string path = this-&gt;GetLocalFileName();</span>

<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "loading " &lt;&lt; path &lt;&lt; std::endl;</span>

<span style = "background-color:#fdd">    if (path.empty())
      mitkThrow() &lt;&lt; "Empty filename in mitk::ItkImageIO ";</span>

    try
    {
      // Get the dcm data set from file path
<span style = "background-color:#fdd">      DcmFileFormat dcmFileFormat;
      OFCondition status = dcmFileFormat.loadFile(path.c_str());
      if (status.bad())
        mitkThrow() &lt;&lt; "Can't read the input file!";</span>

<span style = "background-color:#fdd">      DcmDataset *dataSet = dcmFileFormat.getDataset();
      if (dataSet == nullptr)
        mitkThrow() &lt;&lt; "Can't read data from input file!";</span>

      //=============================== dcmqi part ====================================
      // Read the DICOM SEG images (segItkImages) and DICOM tags (metaInfo)
<span style = "background-color:#fdd">      std::unique_ptr&lt;dcmqi::ImageSEGConverter&gt; converter = std::make_unique&lt;dcmqi::ImageSEGConverter&gt;();
      pair&lt;map&lt;unsigned, itkInternalImageType::Pointer&gt;, string&gt; dcmqiOutput =</span>
        converter-&gt;dcmSegmentation2itkimage(dataSet);

<span style = "background-color:#fdd">      map&lt;unsigned, itkInternalImageType::Pointer&gt; segItkImages = dcmqiOutput.first;</span>

<span style = "background-color:#fdd">      dcmqi::JSONSegmentationMetaInformationHandler metaInfo(dcmqiOutput.second.c_str());
      metaInfo.read();</span>

<span style = "background-color:#fdd">      MITK_INFO &lt;&lt; "Input " &lt;&lt; metaInfo.getJSONOutputAsString();</span>
      //===============================================================================

      // Get the label information from segment attributes for each itk image
<span style = "background-color:#fdd">      vector&lt;map&lt;unsigned, dcmqi::SegmentAttributes *&gt;&gt;::const_iterator segmentIter =</span>
        metaInfo.segmentsAttributesMappingList.begin();

      // For each itk image add a layer to the LabelSetImage output
<span style = "background-color:#fdd">      for (auto &amp;element : segItkImages)</span>
      {
        // Get the labeled image and cast it to mitkImage
        typedef itk::CastImageFilter&lt;itkInternalImageType, itkInputImageType&gt; castItkImageFilterType;
<span style = "background-color:#fdd">        castItkImageFilterType::Pointer castFilter = castItkImageFilterType::New();
        castFilter-&gt;SetInput(element.second);
        castFilter-&gt;Update();</span>

<span style = "background-color:#fdd">        Image::Pointer layerImage;
        CastToMitkImage(castFilter-&gt;GetOutput(), layerImage);</span>

        // Get pixel value of the label
<span style = "background-color:#fdd">        itkInternalImageType::ValueType segValue = 1;</span>
        typedef itk::ImageRegionIterator&lt;const itkInternalImageType&gt; IteratorType;
        // Iterate over the image to find the pixel value of the label
<span style = "background-color:#fdd">        IteratorType iter(element.second, element.second-&gt;GetLargestPossibleRegion());
        iter.GoToBegin();
        while (!iter.IsAtEnd())</span>
        {
<span style = "background-color:#fdd">          itkInputImageType::PixelType value = iter.Get();
          if (value != 0)</span>
          {
<span style = "background-color:#fdd">            segValue = value;
            break;</span>
          }
<span style = "background-color:#fdd">          ++iter;
        }</span>
        // Get Segment information map
<span style = "background-color:#fdd">        map&lt;unsigned, dcmqi::SegmentAttributes *&gt; segmentMap = (*segmentIter);
        map&lt;unsigned, dcmqi::SegmentAttributes *&gt;::const_iterator segmentMapIter = (*segmentIter).begin();
        dcmqi::SegmentAttributes *segmentAttribute = (*segmentMapIter).second;</span>

<span style = "background-color:#fdd">        OFString labelName;</span>

<span style = "background-color:#fdd">        if (segmentAttribute-&gt;getSegmentedPropertyTypeCodeSequence() != nullptr)</span>
        {
<span style = "background-color:#fdd">          segmentAttribute-&gt;getSegmentedPropertyTypeCodeSequence()-&gt;getCodeMeaning(labelName);
          if (segmentAttribute-&gt;getSegmentedPropertyTypeModifierCodeSequence() != nullptr)</span>
          {
<span style = "background-color:#fdd">            OFString modifier;
            segmentAttribute-&gt;getSegmentedPropertyTypeModifierCodeSequence()-&gt;getCodeMeaning(modifier);
            labelName.append(" (").append(modifier).append(")");
          }
        }</span>
        else
        {
<span style = "background-color:#fdd">          labelName = std::to_string(segmentAttribute-&gt;getLabelID()).c_str();
          if (labelName.empty())
            labelName = "Unnamed";</span>
        }

<span style = "background-color:#fdd">        float tmp[3] = { 0.0, 0.0, 0.0 };
        if (segmentAttribute-&gt;getRecommendedDisplayRGBValue() != nullptr)</span>
        {
<span style = "background-color:#fdd">          tmp[0] = segmentAttribute-&gt;getRecommendedDisplayRGBValue()[0] / 255.0;
          tmp[1] = segmentAttribute-&gt;getRecommendedDisplayRGBValue()[1] / 255.0;
          tmp[2] = segmentAttribute-&gt;getRecommendedDisplayRGBValue()[2] / 255.0;</span>
        }

<span style = "background-color:#fdd">        Label *newLabel = nullptr;</span>
        // If labelSetImage do not exists (first image)
<span style = "background-color:#fdd">        if (labelSetImage.IsNull())</span>
        {
          // Initialize the labelSetImage with the read image
<span style = "background-color:#fdd">          labelSetImage = LabelSetImage::New();
          labelSetImage-&gt;InitializeByLabeledImage(layerImage);</span>
          // Already a label was generated, so set the information to this
<span style = "background-color:#fdd">          newLabel = labelSetImage-&gt;GetActiveLabel(labelSetImage-&gt;GetActiveLayer());
          newLabel-&gt;SetName(labelName.c_str());
          newLabel-&gt;SetColor(Color(tmp));
          newLabel-&gt;SetValue(segValue);
        }</span>
        else
        {
          // Add a new layer to the labelSetImage. Background label is set automatically
<span style = "background-color:#fdd">          labelSetImage-&gt;AddLayer(layerImage);</span>

          // Add new label
<span style = "background-color:#fdd">          newLabel = new Label;
          newLabel-&gt;SetName(labelName.c_str());
          newLabel-&gt;SetColor(Color(tmp));
          newLabel-&gt;SetValue(segValue);
          labelSetImage-&gt;GetLabelSet(labelSetImage-&gt;GetActiveLayer())-&gt;AddLabel(newLabel);</span>
        }

        // Add some more label properties
<span style = "background-color:#fdd">        this-&gt;SetLabelProperties(newLabel, segmentAttribute);
        ++segmentIter;
      }</span>

<span style = "background-color:#fdd">      labelSetImage-&gt;GetLabelSet()-&gt;SetAllLabelsVisible(true);</span>

      // Add some general DICOM Segmentation properties
<span style = "background-color:#fdd">      mitk::IDICOMTagsOfInterest *toiSrv = GetDicomTagsOfInterestService();
      auto tagsOfInterest = toiSrv-&gt;GetTagsOfInterest();
      DICOMTagPathList tagsOfInterestList;
      for (const auto &amp;tag : tagsOfInterest)</span>
      {
<span style = "background-color:#fdd">        tagsOfInterestList.push_back(tag.first);
      }</span>

<span style = "background-color:#fdd">      mitk::DICOMDCMTKTagScanner::Pointer scanner = mitk::DICOMDCMTKTagScanner::New();
      scanner-&gt;SetInputFiles({ GetInputLocation() });
      scanner-&gt;AddTagPaths(tagsOfInterestList);
      scanner-&gt;Scan();</span>

<span style = "background-color:#fdd">      mitk::DICOMDatasetAccessingImageFrameList frames = scanner-&gt;GetFrameInfoList();
      if (frames.empty())</span>
      {
<span style = "background-color:#fdd">        MITK_ERROR &lt;&lt; "Error reading the DICOM Seg file" &lt;&lt; std::endl;
        return result;</span>
      }

<span style = "background-color:#fdd">      auto findings = ExtractPathsOfInterest(tagsOfInterestList, frames);
      SetProperties(labelSetImage, findings);</span>

      // Set active layer to the first layer of the labelset image
<span style = "background-color:#fdd">      if (labelSetImage-&gt;GetNumberOfLayers() &gt; 1 &amp;&amp; labelSetImage-&gt;GetActiveLayer() != 0)
        labelSetImage-&gt;SetActiveLayer(0);
    }</span>
    catch (const std::exception &amp;e)
<span style = "background-color:#fdd">    {
      MITK_ERROR &lt;&lt; "An error occurred while reading the DICOM Seg file: " &lt;&lt; e.what();
      return result;
    }</span>
    catch (...)
<span style = "background-color:#fdd">    {
      MITK_ERROR &lt;&lt; "An error occurred in dcmqi while reading the DICOM Seg file";
      return result;
    }</span>

<span style = "background-color:#fdd">    result.push_back(labelSetImage.GetPointer());
    return result;
  }</span>

  const std::string mitk::DICOMSegmentationIO::CreateMetaDataJsonFile(int layer)
<span style = "background-color:#fdd">  {
    const mitk::LabelSetImage *image = dynamic_cast&lt;const mitk::LabelSetImage *&gt;(this-&gt;GetInput());</span>

<span style = "background-color:#fdd">    const std::string output;
    dcmqi::JSONSegmentationMetaInformationHandler handler;</span>


    // 1. Metadata attributes that will be listed in the resulting DICOM SEG object
<span style = "background-color:#fdd">    std::string contentCreatorName;
    if (!image-&gt;GetPropertyList()-&gt;GetStringProperty(GeneratePropertyNameForDICOMTag(0x0070, 0x0084).c_str(),</span>
      contentCreatorName))
<span style = "background-color:#fdd">      contentCreatorName = "MITK";
    handler.setContentCreatorName(contentCreatorName);</span>

<span style = "background-color:#fdd">    std::string clinicalTrailSeriesId;
    if (!image-&gt;GetPropertyList()-&gt;GetStringProperty(GeneratePropertyNameForDICOMTag(0x0012, 0x0071).c_str(),</span>
      clinicalTrailSeriesId))
<span style = "background-color:#fdd">      clinicalTrailSeriesId = "Session 1";
    handler.setClinicalTrialSeriesID(clinicalTrailSeriesId);</span>

<span style = "background-color:#fdd">    std::string clinicalTrialTimePointID;
    if (!image-&gt;GetPropertyList()-&gt;GetStringProperty(GeneratePropertyNameForDICOMTag(0x0012, 0x0050).c_str(),</span>
      clinicalTrialTimePointID))
<span style = "background-color:#fdd">      clinicalTrialTimePointID = "0";
    handler.setClinicalTrialTimePointID(clinicalTrialTimePointID);</span>

<span style = "background-color:#fdd">    std::string clinicalTrialCoordinatingCenterName = "";
    if (!image-&gt;GetPropertyList()-&gt;GetStringProperty(GeneratePropertyNameForDICOMTag(0x0012, 0x0060).c_str(),</span>
      clinicalTrialCoordinatingCenterName))
<span style = "background-color:#fdd">      clinicalTrialCoordinatingCenterName = "Unknown";
    handler.setClinicalTrialCoordinatingCenterName(clinicalTrialCoordinatingCenterName);</span>

<span style = "background-color:#fdd">    std::string seriesDescription;
    if (!image-&gt;GetPropertyList()-&gt;GetStringProperty("name", seriesDescription))
      seriesDescription = "MITK Segmentation";
    handler.setSeriesDescription(seriesDescription);</span>

<span style = "background-color:#fdd">    handler.setSeriesNumber("0" + std::to_string(layer));
    handler.setInstanceNumber("1");
    handler.setBodyPartExamined("");</span>

<span style = "background-color:#fdd">    const LabelSet *labelSet = image-&gt;GetLabelSet(layer);
    auto labelIter = labelSet-&gt;IteratorConstBegin();</span>
    // Ignore background label
<span style = "background-color:#fdd">    ++labelIter;</span>

<span style = "background-color:#fdd">    for (; labelIter != labelSet-&gt;IteratorConstEnd(); ++labelIter)</span>
    {
<span style = "background-color:#fdd">      const Label *label = labelIter-&gt;second;</span>

<span style = "background-color:#fdd">      if (label != nullptr)</span>
      {
<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentNumberProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_NUMBER_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentLabelProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_LABEL_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *algorithmTypeProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_ALGORITHM_TYPE_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentCategoryCodeValueProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_CATEGORY_CODE_VALUE_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentCategoryCodeSchemeProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_CATEGORY_CODE_SCHEME_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentCategoryCodeMeaningProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_CATEGORY_CODE_MEANING_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentTypeCodeValueProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_TYPE_CODE_VALUE_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentTypeCodeSchemeProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_TYPE_CODE_SCHEME_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentTypeCodeMeaningProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_TYPE_CODE_MEANING_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentModifierCodeValueProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_MODIFIER_CODE_VALUE_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentModifierCodeSchemeProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_MODIFIER_CODE_SCHEME_PATH()).c_str()));

<span style = "background-color:#fdd">        TemporoSpatialStringProperty *segmentModifierCodeMeaningProp = dynamic_cast&lt;mitk::TemporoSpatialStringProperty *&gt;(label-&gt;GetProperty(</span>
          mitk::DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_MODIFIER_CODE_MEANING_PATH()).c_str()));

<span style = "background-color:#fdd">        dcmqi::SegmentAttributes *segmentAttribute = nullptr;</span>

<span style = "background-color:#fdd">        if (segmentNumberProp-&gt;GetValue() == "")</span>
        {
<span style = "background-color:#fdd">          MITK_ERROR &lt;&lt; "Something went wrong with the label ID.";
        }</span>
        else
        {
<span style = "background-color:#fdd">          int labelId = std::stoi(segmentNumberProp-&gt;GetValue());
          segmentAttribute = handler.createAndGetNewSegment(labelId);</span>
        }
<span style = "background-color:#fdd">        if (segmentAttribute != nullptr)</span>
        {
<span style = "background-color:#fdd">          segmentAttribute-&gt;setSegmentDescription(segmentLabelProp-&gt;GetValueAsString());
          segmentAttribute-&gt;setSegmentAlgorithmType(algorithmTypeProp-&gt;GetValueAsString());
          segmentAttribute-&gt;setSegmentAlgorithmName("MITK Segmentation");
          if (segmentCategoryCodeValueProp != nullptr &amp;&amp; segmentCategoryCodeSchemeProp != nullptr &amp;&amp;</span>
            segmentCategoryCodeMeaningProp != nullptr)
<span style = "background-color:#fdd">            segmentAttribute-&gt;setSegmentedPropertyCategoryCodeSequence(</span>
              segmentCategoryCodeValueProp-&gt;GetValueAsString(),
              segmentCategoryCodeSchemeProp-&gt;GetValueAsString(),
              segmentCategoryCodeMeaningProp-&gt;GetValueAsString());
          else
            // some default values
<span style = "background-color:#fdd">            segmentAttribute-&gt;setSegmentedPropertyCategoryCodeSequence(</span>
              "M-01000", "SRT", "Morphologically Altered Structure");

<span style = "background-color:#fdd">          if (segmentTypeCodeValueProp != nullptr &amp;&amp; segmentTypeCodeSchemeProp != nullptr &amp;&amp;</span>
            segmentTypeCodeMeaningProp != nullptr)
          {
<span style = "background-color:#fdd">            segmentAttribute-&gt;setSegmentedPropertyTypeCodeSequence(segmentTypeCodeValueProp-&gt;GetValueAsString(),</span>
              segmentTypeCodeSchemeProp-&gt;GetValueAsString(),
              segmentTypeCodeMeaningProp-&gt;GetValueAsString());
<span style = "background-color:#fdd">            handler.setBodyPartExamined(segmentTypeCodeMeaningProp-&gt;GetValueAsString());
          }</span>
          else
          {
            // some default values
<span style = "background-color:#fdd">            segmentAttribute-&gt;setSegmentedPropertyTypeCodeSequence("M-03000", "SRT", "Mass");
            handler.setBodyPartExamined("Mass");</span>
          }
<span style = "background-color:#fdd">          if (segmentModifierCodeValueProp != nullptr &amp;&amp; segmentModifierCodeSchemeProp != nullptr &amp;&amp;</span>
            segmentModifierCodeMeaningProp != nullptr)
<span style = "background-color:#fdd">            segmentAttribute-&gt;setSegmentedPropertyTypeModifierCodeSequence(</span>
              segmentModifierCodeValueProp-&gt;GetValueAsString(),
              segmentModifierCodeSchemeProp-&gt;GetValueAsString(),
              segmentModifierCodeMeaningProp-&gt;GetValueAsString());

<span style = "background-color:#fdd">          Color color = label-&gt;GetColor();
          segmentAttribute-&gt;setRecommendedDisplayRGBValue(color[0] * 255, color[1] * 255, color[2] * 255);</span>
        }
      }
<span style = "background-color:#fdd">    }
    return handler.getJSONOutputAsString();
  }</span>

  void mitk::DICOMSegmentationIO::SetLabelProperties(mitk::Label *label, dcmqi::SegmentAttributes *segmentAttribute)
<span style = "background-color:#fdd">  {</span>
    // Segment Number:Identification number of the segment.The value of Segment Number(0062, 0004) shall be unique
    // within the Segmentation instance in which it is created
<span style = "background-color:#fdd">    label-&gt;SetProperty(DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_NUMBER_PATH()).c_str(),</span>
      TemporoSpatialStringProperty::New(std::to_string(label-&gt;GetValue())));

    // Segment Label: User-defined label identifying this segment.
<span style = "background-color:#fdd">    label-&gt;SetProperty(DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_LABEL_PATH()).c_str(),</span>
      TemporoSpatialStringProperty::New(label-&gt;GetName()));

    // Segment Algorithm Type: Type of algorithm used to generate the segment.
<span style = "background-color:#fdd">    if (!segmentAttribute-&gt;getSegmentAlgorithmType().empty())
      label-&gt;SetProperty(DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_ALGORITHM_TYPE_PATH()).c_str(),</span>
        TemporoSpatialStringProperty::New(segmentAttribute-&gt;getSegmentAlgorithmType()));

    // Add Segmented Property Category Code Sequence tags
<span style = "background-color:#fdd">    auto categoryCodeSequence = segmentAttribute-&gt;getSegmentedPropertyCategoryCodeSequence();
    if (categoryCodeSequence != nullptr)</span>
    {
<span style = "background-color:#fdd">      OFString codeValue; // (0008,0100) Code Value
      categoryCodeSequence-&gt;getCodeValue(codeValue);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_CATEGORY_CODE_VALUE_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeValue.c_str()));

<span style = "background-color:#fdd">      OFString codeScheme; // (0008,0102) Coding Scheme Designator
      categoryCodeSequence-&gt;getCodingSchemeDesignator(codeScheme);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_CATEGORY_CODE_SCHEME_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeScheme.c_str()));

<span style = "background-color:#fdd">      OFString codeMeaning; // (0008,0104) Code Meaning
      categoryCodeSequence-&gt;getCodeMeaning(codeMeaning);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_CATEGORY_CODE_MEANING_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeMeaning.c_str()));
<span style = "background-color:#fdd">    }</span>

    // Add Segmented Property Type Code Sequence tags
<span style = "background-color:#fdd">    auto typeCodeSequence = segmentAttribute-&gt;getSegmentedPropertyTypeCodeSequence();
    if (typeCodeSequence != nullptr)</span>
    {
<span style = "background-color:#fdd">      OFString codeValue; // (0008,0100) Code Value
      typeCodeSequence-&gt;getCodeValue(codeValue);
      label-&gt;SetProperty(DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_TYPE_CODE_VALUE_PATH()).c_str(),</span>
        TemporoSpatialStringProperty::New(codeValue.c_str()));

<span style = "background-color:#fdd">      OFString codeScheme; // (0008,0102) Coding Scheme Designator
      typeCodeSequence-&gt;getCodingSchemeDesignator(codeScheme);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_TYPE_CODE_SCHEME_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeScheme.c_str()));

<span style = "background-color:#fdd">      OFString codeMeaning; // (0008,0104) Code Meaning
      typeCodeSequence-&gt;getCodeMeaning(codeMeaning);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_TYPE_CODE_MEANING_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeMeaning.c_str()));
<span style = "background-color:#fdd">    }</span>

    // Add Segmented Property Type Modifier Code Sequence tags
<span style = "background-color:#fdd">    auto modifierCodeSequence = segmentAttribute-&gt;getSegmentedPropertyTypeModifierCodeSequence();
    if (modifierCodeSequence != nullptr)</span>
    {
<span style = "background-color:#fdd">      OFString codeValue; // (0008,0100) Code Value
      modifierCodeSequence-&gt;getCodeValue(codeValue);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_MODIFIER_CODE_VALUE_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeValue.c_str()));

<span style = "background-color:#fdd">      OFString codeScheme; // (0008,0102) Coding Scheme Designator
      modifierCodeSequence-&gt;getCodingSchemeDesignator(codeScheme);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_MODIFIER_CODE_SCHEME_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeScheme.c_str()));

<span style = "background-color:#fdd">      OFString codeMeaning; // (0008,0104) Code Meaning
      modifierCodeSequence-&gt;getCodeMeaning(codeMeaning);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::SEGMENT_MODIFIER_CODE_MEANING_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeMeaning.c_str()));
<span style = "background-color:#fdd">    }</span>

    // Add Atomic RegionSequence tags
<span style = "background-color:#fdd">    auto atomicRegionSequence = segmentAttribute-&gt;getAnatomicRegionSequence();
    if (atomicRegionSequence != nullptr)</span>
    {
<span style = "background-color:#fdd">      OFString codeValue; // (0008,0100) Code Value
      atomicRegionSequence-&gt;getCodeValue(codeValue);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::ANATOMIC_REGION_CODE_VALUE_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeValue.c_str()));

<span style = "background-color:#fdd">      OFString codeScheme; // (0008,0102) Coding Scheme Designator
      atomicRegionSequence-&gt;getCodingSchemeDesignator(codeScheme);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::ANATOMIC_REGION_CODE_SCHEME_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeScheme.c_str()));

<span style = "background-color:#fdd">      OFString codeMeaning; // (0008,0104) Code Meaning
      atomicRegionSequence-&gt;getCodeMeaning(codeMeaning);
      label-&gt;SetProperty(</span>
        DICOMTagPathToPropertyName(DICOMSegmentationConstants::ANATOMIC_REGION_CODE_MEANING_PATH()).c_str(),
        TemporoSpatialStringProperty::New(codeMeaning.c_str()));
<span style = "background-color:#fdd">    }
  }</span>

<span style = "background-color:#fdd">  DICOMSegmentationIO *DICOMSegmentationIO::IOClone() const { return new DICOMSegmentationIO(*this); }</span>
} // namespace

#endif //__mitkDICOMSegmentationIO__cpp</pre>
	</body>
</html>