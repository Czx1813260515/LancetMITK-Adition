<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlanarDoubleEllipse.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlanarDoubleEllipse.h"
#include &lt;mitkProperties.h&gt;

#include &lt;algorithm&gt;

mitk::PlanarDoubleEllipse::PlanarDoubleEllipse()
<span style = "background-color:#fdd">  : FEATURE_ID_MAJOR_AXIS(Superclass::AddFeature("Major Axis", "mm")),
    FEATURE_ID_MINOR_AXIS(Superclass::AddFeature("Minor Axis", "mm")),
    FEATURE_ID_THICKNESS(Superclass::AddFeature("Thickness", "mm")),
    m_NumberOfSegments(64),
    m_ConstrainCircle(true),
    m_ConstrainThickness(true)
{
  this-&gt;ResetNumberOfControlPoints(4);
  this-&gt;SetNumberOfPolyLines(2);
  this-&gt;SetProperty("closed", mitk::BoolProperty::New(true));
}</span>

mitk::PlanarDoubleEllipse::PlanarDoubleEllipse(double fixedRadius, double fixedThickness)
<span style = "background-color:#fdd">  : FEATURE_ID_MAJOR_AXIS(Superclass::AddFeature("Major Axis", "mm")),
  FEATURE_ID_MINOR_AXIS(Superclass::AddFeature("Minor Axis", "mm")),
  FEATURE_ID_THICKNESS(Superclass::AddFeature("Thickness", "mm")),
  m_NumberOfSegments(64),
  m_ConstrainCircle(true),
  m_ConstrainThickness(true),
  m_FixedRadius(fixedRadius),
  m_FixedThickness(fixedThickness),
  m_SizeIsFixed(true)
{
  this-&gt;ResetNumberOfControlPoints(1);
  this-&gt;SetNumberOfPolyLines(2);
  this-&gt;SetProperty("closed", mitk::BoolProperty::New(true));</span>

<span style = "background-color:#fdd">  if (fixedThickness&gt;fixedRadius)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Invalid constructor of fixed sized double ellipses. Thickness (" &lt;&lt; fixedThickness &lt;&lt; ") is greater than the radius (" &lt;&lt; fixedRadius &lt;&lt; ")";</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::Point2D mitk::PlanarDoubleEllipse::ApplyControlPointConstraints(unsigned int index, const Point2D &amp;point)
<span style = "background-color:#fdd">{
  if (index == 2 &amp;&amp; !m_ConstrainCircle)</span>
  {
<span style = "background-color:#fdd">    const Point2D centerPoint = this-&gt;GetControlPoint(CP_CENTER);
    const Vector2D outerMajorVector = this-&gt;GetControlPoint(CP_OUTER_MAJOR_AXIS) - centerPoint;</span>

<span style = "background-color:#fdd">    Vector2D minorDirection;
    minorDirection[0] = outerMajorVector[1];
    minorDirection[1] = -outerMajorVector[0];
    minorDirection.Normalize();</span>

<span style = "background-color:#fdd">    const double outerMajorRadius = outerMajorVector.GetNorm();
    const double innerMajorRadius = (this-&gt;GetControlPoint(CP_INNER_MAJOR_AXIS) - centerPoint).GetNorm();
    const ScalarType radius =</span>
      std::max(outerMajorRadius - innerMajorRadius, std::min(centerPoint.EuclideanDistanceTo(point), outerMajorRadius));

<span style = "background-color:#fdd">    return centerPoint + minorDirection * radius;
  }
  else if (index == 3 &amp;&amp; !m_ConstrainThickness)</span>
  {
<span style = "background-color:#fdd">    const Point2D centerPoint = this-&gt;GetControlPoint(CP_CENTER);
    Vector2D outerMajorVector = this-&gt;GetControlPoint(CP_OUTER_MAJOR_AXIS) - centerPoint;</span>

<span style = "background-color:#fdd">    const double outerMajorRadius = outerMajorVector.GetNorm();
    const double outerMinorRadius = (this-&gt;GetControlPoint(CP_OUTER_MINOR_AXIS) - centerPoint).GetNorm();
    const ScalarType radius =</span>
      std::max(outerMajorRadius - outerMinorRadius, std::min(centerPoint.EuclideanDistanceTo(point), outerMajorRadius));

<span style = "background-color:#fdd">    outerMajorVector.Normalize();</span>

<span style = "background-color:#fdd">    return centerPoint - outerMajorVector * radius;</span>
  }

<span style = "background-color:#fdd">  return point;
}</span>

void mitk::PlanarDoubleEllipse::EvaluateFeaturesInternal()
<span style = "background-color:#fdd">{
  const Point2D centerPoint = this-&gt;GetControlPoint(CP_CENTER);
  const ScalarType outerMajorRadius = (m_SizeIsFixed)? m_FixedRadius : centerPoint.EuclideanDistanceTo(this-&gt;GetControlPoint(CP_OUTER_MAJOR_AXIS));
  const ScalarType outerMinorRadius = (m_SizeIsFixed)? m_FixedRadius : centerPoint.EuclideanDistanceTo(this-&gt;GetControlPoint(CP_OUTER_MINOR_AXIS));
  const ScalarType thickness = (m_SizeIsFixed)? m_FixedThickness : outerMajorRadius - centerPoint.EuclideanDistanceTo(this-&gt;GetControlPoint(CP_INNER_MAJOR_AXIS));</span>

<span style = "background-color:#fdd">  this-&gt;SetQuantity(FEATURE_ID_MAJOR_AXIS, 2 * outerMajorRadius);
  this-&gt;SetQuantity(FEATURE_ID_MINOR_AXIS, 2 * outerMinorRadius);
  this-&gt;SetQuantity(FEATURE_ID_THICKNESS, thickness);
}</span>

void mitk::PlanarDoubleEllipse::GenerateHelperPolyLine(double, unsigned int)
<span style = "background-color:#fdd">{
}</span>

void mitk::PlanarDoubleEllipse::GeneratePolyLine()
<span style = "background-color:#fdd">{
  this-&gt;ClearPolyLines();</span>

<span style = "background-color:#fdd">  const Point2D centerPoint = this-&gt;GetControlPoint(CP_CENTER);</span>

<span style = "background-color:#fdd">  Vector2D direction(0.);
  direction[0] = 1.;
  if (!m_SizeIsFixed)</span>
  {
<span style = "background-color:#fdd">    direction = this-&gt;GetControlPoint(CP_OUTER_MAJOR_AXIS) - centerPoint;
    direction.Normalize();</span>
  }

<span style = "background-color:#fdd">  const ScalarType deltaAngle = vnl_math::pi / (m_NumberOfSegments / 2);</span>

<span style = "background-color:#fdd">  int start = 0;
  int end = m_NumberOfSegments;</span>

<span style = "background-color:#fdd">  if (direction[1] &lt; 0.0)</span>
  {
<span style = "background-color:#fdd">    direction[0] = -direction[0];
    end = m_NumberOfSegments / 2;
    start = -end;</span>
  }

  vnl_matrix_fixed&lt;mitk::ScalarType, 2, 2&gt; rotation;
<span style = "background-color:#fdd">  rotation[1][0] = std::sin(std::acos(direction[0]));
  rotation[0][0] = direction[0];
  rotation[1][1] = direction[0];
  rotation[0][1] = -rotation[1][0];</span>

<span style = "background-color:#fdd">  const ScalarType outerMajorRadius = (m_SizeIsFixed) ? m_FixedRadius : centerPoint.EuclideanDistanceTo(this-&gt;GetControlPoint(CP_OUTER_MAJOR_AXIS));
  const ScalarType outerMinorRadius = (m_SizeIsFixed) ? m_FixedRadius : centerPoint.EuclideanDistanceTo(this-&gt;GetControlPoint(CP_OUTER_MINOR_AXIS));
  const ScalarType innerMajorRadius = (m_SizeIsFixed) ? (m_FixedRadius-m_FixedThickness) : centerPoint.EuclideanDistanceTo(this-&gt;GetControlPoint(CP_INNER_MAJOR_AXIS));
  const ScalarType innerMinorRadius = (m_SizeIsFixed) ? (m_FixedRadius-m_FixedThickness) : innerMajorRadius - (outerMajorRadius - outerMinorRadius);</span>

<span style = "background-color:#fdd">  ScalarType angle = 0;
  ScalarType cosAngle = 0;
  ScalarType sinAngle = 0;</span>
  vnl_vector_fixed&lt;mitk::ScalarType, 2&gt; vector;
<span style = "background-color:#fdd">  Point2D point;</span>

<span style = "background-color:#fdd">  for (int i = start; i &lt; end; ++i)</span>
  {
<span style = "background-color:#fdd">    angle = i * deltaAngle;
    cosAngle = std::cos(angle);
    sinAngle = std::sin(angle);</span>

<span style = "background-color:#fdd">    vector[0] = outerMajorRadius * cosAngle;
    vector[1] = outerMinorRadius * sinAngle;
    vector = rotation * vector;</span>

<span style = "background-color:#fdd">    point[0] = centerPoint[0] + vector[0];
    point[1] = centerPoint[1] + vector[1];</span>

<span style = "background-color:#fdd">    this-&gt;AppendPointToPolyLine(0, point);</span>

<span style = "background-color:#fdd">    vector[0] = innerMajorRadius * cosAngle;
    vector[1] = innerMinorRadius * sinAngle;
    vector = rotation * vector;</span>

<span style = "background-color:#fdd">    point[0] = centerPoint[0] + vector[0];
    point[1] = centerPoint[1] + vector[1];</span>

<span style = "background-color:#fdd">    this-&gt;AppendPointToPolyLine(1, point);
  }
}</span>

unsigned int mitk::PlanarDoubleEllipse::GetNumberOfSegments() const
<span style = "background-color:#fdd">{
  return m_NumberOfSegments;
}</span>

void mitk::PlanarDoubleEllipse::SetNumberOfSegments(unsigned int numSegments)
<span style = "background-color:#fdd">{
  m_NumberOfSegments = std::max(4U, numSegments);</span>

<span style = "background-color:#fdd">  if (this-&gt;IsPlaced())</span>
  {
<span style = "background-color:#fdd">    this-&gt;GeneratePolyLine();
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

unsigned int mitk::PlanarDoubleEllipse::GetMaximumNumberOfControlPoints() const
<span style = "background-color:#fdd">{
  return (m_SizeIsFixed)? 1 : 4;
}</span>

unsigned int mitk::PlanarDoubleEllipse::GetMinimumNumberOfControlPoints() const
<span style = "background-color:#fdd">{
  return (m_SizeIsFixed)? 1 : 4;
}</span>

bool mitk::PlanarDoubleEllipse::SetControlPoint(unsigned int index, const Point2D &amp;point, bool createIfDoesNotExist)
<span style = "background-color:#fdd">{
  switch (index)</span>
  {
    case 0:
    {
<span style = "background-color:#fdd">      const Point2D centerPoint = this-&gt;GetControlPoint(CP_CENTER);
      const Vector2D vector = point - centerPoint;</span>

<span style = "background-color:#fdd">      Superclass::SetControlPoint(0, point, createIfDoesNotExist);
      if (!m_SizeIsFixed)</span>
      {
<span style = "background-color:#fdd">        Superclass::SetControlPoint(1, this-&gt;GetControlPoint(CP_OUTER_MAJOR_AXIS) + vector, createIfDoesNotExist);
        Superclass::SetControlPoint(2, this-&gt;GetControlPoint(CP_OUTER_MINOR_AXIS) + vector, createIfDoesNotExist);
        Superclass::SetControlPoint(3, this-&gt;GetControlPoint(CP_INNER_MAJOR_AXIS) + vector, createIfDoesNotExist);</span>
      }

<span style = "background-color:#fdd">      break;</span>
    }

    case 1:
    {
<span style = "background-color:#fdd">      const Vector2D vector = point - this-&gt;GetControlPoint(CP_OUTER_MAJOR_AXIS);</span>

<span style = "background-color:#fdd">      Superclass::SetControlPoint(1, point, createIfDoesNotExist);</span>

<span style = "background-color:#fdd">      const Point2D centerPoint = this-&gt;GetControlPoint(CP_CENTER);
      const Vector2D outerMajorVector = point - centerPoint;</span>

<span style = "background-color:#fdd">      Vector2D outerMinorVector;
      outerMinorVector[0] = outerMajorVector[1];
      outerMinorVector[1] = -outerMajorVector[0];</span>

<span style = "background-color:#fdd">      if (!m_ConstrainCircle)</span>
      {
<span style = "background-color:#fdd">        outerMinorVector.Normalize();
        outerMinorVector *= centerPoint.EuclideanDistanceTo(this-&gt;GetControlPoint(CP_OUTER_MINOR_AXIS));</span>
      }

<span style = "background-color:#fdd">      Superclass::SetControlPoint(2, centerPoint + outerMinorVector, createIfDoesNotExist);</span>

<span style = "background-color:#fdd">      Vector2D innerMajorVector = outerMajorVector;</span>

<span style = "background-color:#fdd">      if (!m_ConstrainThickness)</span>
      {
<span style = "background-color:#fdd">        innerMajorVector.Normalize();
        innerMajorVector *= centerPoint.EuclideanDistanceTo(this-&gt;GetControlPoint(CP_INNER_MAJOR_AXIS) - vector);</span>
      }

<span style = "background-color:#fdd">      Superclass::SetControlPoint(3, centerPoint - innerMajorVector, createIfDoesNotExist);</span>

<span style = "background-color:#fdd">      break;</span>
    }

    case 2:
    {
<span style = "background-color:#fdd">      m_ConstrainCircle = false;
      Superclass::SetControlPoint(2, point, createIfDoesNotExist);</span>

<span style = "background-color:#fdd">      break;</span>
    }

    case 3:
    {
<span style = "background-color:#fdd">      m_ConstrainThickness = false;
      Superclass::SetControlPoint(3, point, createIfDoesNotExist);</span>

<span style = "background-color:#fdd">      break;</span>
    }

    default:
<span style = "background-color:#fdd">      return false;</span>
  }

<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::PlanarDoubleEllipse::Equals(const mitk::PlanarFigure &amp;other) const
<span style = "background-color:#fdd">{
  const auto *otherDoubleEllipse = dynamic_cast&lt;const mitk::PlanarDoubleEllipse *&gt;(&amp;other);
  if (otherDoubleEllipse)</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;m_ConstrainCircle != otherDoubleEllipse-&gt;m_ConstrainCircle)
      return false;
    if (this-&gt;m_ConstrainThickness != otherDoubleEllipse-&gt;m_ConstrainThickness)
      return false;
    if (this-&gt;m_NumberOfSegments != otherDoubleEllipse-&gt;m_NumberOfSegments)
      return false;
    return Superclass::Equals(other);
  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>