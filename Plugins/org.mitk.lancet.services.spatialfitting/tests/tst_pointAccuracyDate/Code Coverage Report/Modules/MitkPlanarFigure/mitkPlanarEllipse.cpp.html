<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlanarEllipse.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlanarEllipse.h"
#include "mitkPlaneGeometry.h"
#include "mitkProperties.h"

#include &lt;algorithm&gt;

mitk::PlanarEllipse::PlanarEllipse()
<span style = "background-color:#fdd">  : FEATURE_ID_MAJOR_AXIS(Superclass::AddFeature("Major Axis", "mm")),
    FEATURE_ID_MINOR_AXIS(Superclass::AddFeature("Minor Axis", "mm")),
    FEATURE_ID_AREA(Superclass::AddFeature("Area", "mm2")),
    m_MinRadius(0),
    m_MaxRadius(100),
    m_MinMaxRadiusContraintsActive(false),
    m_TreatAsCircle(true)
{</span>
  // Ellipse has three control points
<span style = "background-color:#fdd">  this-&gt;ResetNumberOfControlPoints(4);
  this-&gt;SetNumberOfPolyLines(2);
  this-&gt;SetProperty("closed", mitk::BoolProperty::New(true));
}</span>

bool mitk::PlanarEllipse::SetControlPoint(unsigned int index, const Point2D &amp;point, bool createIfDoesNotExist)
<span style = "background-color:#fdd">{
  if (index == 0) // moving center point and control points accordingly</span>
  {
<span style = "background-color:#fdd">    const Point2D &amp;centerPoint = GetControlPoint(0);
    Point2D boundaryPoint1 = GetControlPoint(1);
    Point2D boundaryPoint2 = GetControlPoint(2);
    Point2D boundaryPoint3 = GetControlPoint(3);
    const vnl_vector&lt;ScalarType&gt; vec = (point.GetVnlVector() - centerPoint.GetVnlVector());</span>

<span style = "background-color:#fdd">    boundaryPoint1[0] += vec[0];
    boundaryPoint1[1] += vec[1];
    boundaryPoint2[0] += vec[0];
    boundaryPoint2[1] += vec[1];
    boundaryPoint3[0] += vec[0];
    boundaryPoint3[1] += vec[1];
    PlanarFigure::SetControlPoint(0, point, createIfDoesNotExist);
    PlanarFigure::SetControlPoint(1, boundaryPoint1, createIfDoesNotExist);
    PlanarFigure::SetControlPoint(2, boundaryPoint2, createIfDoesNotExist);
    PlanarFigure::SetControlPoint(3, boundaryPoint3, createIfDoesNotExist);
    return true;
  }
  else if (index &lt; 3)</span>
  {
<span style = "background-color:#fdd">    PlanarFigure::SetControlPoint(index, point, createIfDoesNotExist);
    int otherIndex = index + 1;
    if (otherIndex &gt; 2)
      otherIndex = 1;</span>

<span style = "background-color:#fdd">    const Point2D centerPoint = GetControlPoint(0);
    Point2D otherPoint = GetControlPoint(otherIndex);
    Point2D point3 = GetControlPoint(3);</span>

<span style = "background-color:#fdd">    const Vector2D vec1 = point - centerPoint;
    Vector2D vec2;</span>

<span style = "background-color:#fdd">    if (index == 1 &amp;&amp; m_TreatAsCircle)</span>
    {
<span style = "background-color:#fdd">      const float x = vec1[0];
      vec2[0] = vec1[1];
      vec2[1] = x;</span>

<span style = "background-color:#fdd">      if (index == 1)
        vec2[0] *= -1;</span>
      else
<span style = "background-color:#fdd">        vec2[1] *= -1;</span>

<span style = "background-color:#fdd">      otherPoint = centerPoint + vec2;
      PlanarFigure::SetControlPoint(otherIndex, otherPoint, createIfDoesNotExist);
      const float r = centerPoint.EuclideanDistanceTo(otherPoint);</span>

      // adjust additional third control point
<span style = "background-color:#fdd">      const Point2D p3 = this-&gt;GetControlPoint(3);
      Vector2D vec3;
      vec3[0] = p3[0] - centerPoint[0];
      vec3[1] = p3[1] - centerPoint[1];
      if (vec3[0] != 0 || vec3[1] != 0)</span>
      {
<span style = "background-color:#fdd">        vec3.Normalize();
        vec3 *= r;
      }</span>
      else
      {
<span style = "background-color:#fdd">        vec3[0] = r;
        vec3[1] = 0;</span>
      }
<span style = "background-color:#fdd">      point3 = centerPoint + vec3;
      PlanarFigure::SetControlPoint(3, point3, createIfDoesNotExist);
    }
    else if (vec1.GetNorm() &gt; 0)</span>
    {
<span style = "background-color:#fdd">      const float r = centerPoint.EuclideanDistanceTo(otherPoint);
      const float x = vec1[0];
      vec2[0] = vec1[1];
      vec2[1] = x;</span>

<span style = "background-color:#fdd">      if (index == 1)
        vec2[0] *= -1;</span>
      else
<span style = "background-color:#fdd">        vec2[1] *= -1;</span>

<span style = "background-color:#fdd">      vec2.Normalize();
      vec2 *= r;</span>

<span style = "background-color:#fdd">      if (vec2.GetNorm() &gt; 0)</span>
      {
<span style = "background-color:#fdd">        otherPoint = centerPoint + vec2;
        PlanarFigure::SetControlPoint(otherIndex, otherPoint, createIfDoesNotExist);</span>
      }

      // adjust third control point
<span style = "background-color:#fdd">      Vector2D vec3 = point3 - centerPoint;
      vec3.Normalize();
      const double r1 = centerPoint.EuclideanDistanceTo(GetControlPoint(1));
      const double r2 = centerPoint.EuclideanDistanceTo(GetControlPoint(2));
      const Point2D newPoint = centerPoint + vec3 * std::max(r1, r2);
      PlanarFigure::SetControlPoint(3, newPoint, createIfDoesNotExist);</span>

<span style = "background-color:#fdd">      m_TreatAsCircle = false;</span>
    }
<span style = "background-color:#fdd">    return true;
  }
  else if (index == 3)</span>
  {
<span style = "background-color:#fdd">    const Point2D centerPoint = GetControlPoint(0);
    Vector2D vec3 = point - centerPoint;
    vec3.Normalize();
    const double r1 = centerPoint.EuclideanDistanceTo(GetControlPoint(1));
    const double r2 = centerPoint.EuclideanDistanceTo(GetControlPoint(2));
    const Point2D newPoint = centerPoint + vec3 * std::max(r1, r2);
    PlanarFigure::SetControlPoint(index, newPoint, createIfDoesNotExist);
    m_TreatAsCircle = false;
    return true;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

void mitk::PlanarEllipse::PlaceFigure(const mitk::Point2D &amp;point)
<span style = "background-color:#fdd">{
  PlanarFigure::PlaceFigure(point);
  m_SelectedControlPoint = 1;
}</span>

mitk::Point2D mitk::PlanarEllipse::ApplyControlPointConstraints(unsigned int index, const Point2D &amp;point)
<span style = "background-color:#fdd">{
  return point;</span>

<span style = "background-color:#fdd">  Point2D indexPoint;
  this-&gt;GetPlaneGeometry()-&gt;WorldToIndex(point, indexPoint);</span>

<span style = "background-color:#fdd">  BoundingBox::BoundsArrayType bounds = this-&gt;GetPlaneGeometry()-&gt;GetBounds();
  if (indexPoint[0] &lt; bounds[0])</span>
  {
<span style = "background-color:#fdd">    indexPoint[0] = bounds[0];</span>
  }
<span style = "background-color:#fdd">  if (indexPoint[0] &gt; bounds[1])</span>
  {
<span style = "background-color:#fdd">    indexPoint[0] = bounds[1];</span>
  }
<span style = "background-color:#fdd">  if (indexPoint[1] &lt; bounds[2])</span>
  {
<span style = "background-color:#fdd">    indexPoint[1] = bounds[2];</span>
  }
<span style = "background-color:#fdd">  if (indexPoint[1] &gt; bounds[3])</span>
  {
<span style = "background-color:#fdd">    indexPoint[1] = bounds[3];</span>
  }

<span style = "background-color:#fdd">  Point2D constrainedPoint;
  this-&gt;GetPlaneGeometry()-&gt;IndexToWorld(indexPoint, constrainedPoint);</span>

<span style = "background-color:#fdd">  if (m_MinMaxRadiusContraintsActive)</span>
  {
<span style = "background-color:#fdd">    if (index != 0)</span>
    {
<span style = "background-color:#fdd">      const Point2D &amp;centerPoint = this-&gt;GetControlPoint(0);
      const double euclideanDinstanceFromCenterToPoint1 = centerPoint.EuclideanDistanceTo(point);</span>

<span style = "background-color:#fdd">      Vector2D vectorProjectedPoint = point - centerPoint;
      vectorProjectedPoint.Normalize();</span>

<span style = "background-color:#fdd">      if (euclideanDinstanceFromCenterToPoint1 &gt; m_MaxRadius)</span>
      {
<span style = "background-color:#fdd">        vectorProjectedPoint *= m_MaxRadius;
        constrainedPoint = centerPoint;
        constrainedPoint += vectorProjectedPoint;
      }
      else if (euclideanDinstanceFromCenterToPoint1 &lt; m_MinRadius)</span>
      {
<span style = "background-color:#fdd">        vectorProjectedPoint *= m_MinRadius;
        constrainedPoint = centerPoint;
        constrainedPoint += vectorProjectedPoint;</span>
      }
    }
  }

<span style = "background-color:#fdd">  return constrainedPoint;
}</span>

void mitk::PlanarEllipse::GeneratePolyLine()
<span style = "background-color:#fdd">{</span>
  // clear the PolyLine-Contrainer, it will be reconstructed soon enough...
<span style = "background-color:#fdd">  this-&gt;ClearPolyLines();</span>

<span style = "background-color:#fdd">  const Point2D &amp;centerPoint = GetControlPoint(0);
  const Point2D &amp;boundaryPoint1 = GetControlPoint(1);
  const Point2D &amp;boundaryPoint2 = GetControlPoint(2);</span>

<span style = "background-color:#fdd">  Vector2D dir = boundaryPoint1 - centerPoint;
  dir.Normalize();</span>
  vnl_matrix_fixed&lt;float, 2, 2&gt; rot;

  // differentiate between clockwise and counterclockwise rotation
<span style = "background-color:#fdd">  int start = 0;
  int end = 64;
  if (dir[1] &lt; 0)</span>
  {
<span style = "background-color:#fdd">    dir[0] = -dir[0];
    start = -32;
    end = 32;</span>
  }
  // construct rotation matrix to align ellipse with control point vector
<span style = "background-color:#fdd">  rot[0][0] = dir[0];
  rot[1][1] = rot[0][0];
  rot[1][0] = sin(acos(rot[0][0]));
  rot[0][1] = -rot[1][0];</span>

<span style = "background-color:#fdd">  const double radius1 = centerPoint.EuclideanDistanceTo(boundaryPoint1);
  const double radius2 = centerPoint.EuclideanDistanceTo(boundaryPoint2);</span>

  // Generate poly-line with 64 segments
<span style = "background-color:#fdd">  for (int t = start; t &lt; end; ++t)</span>
  {
<span style = "background-color:#fdd">    const double alpha = (double)t * vnl_math::pi / 32.0;</span>

    // construct the new polyline point ...
    vnl_vector_fixed&lt;float, 2&gt; vec;
<span style = "background-color:#fdd">    vec[0] = radius1 * cos(alpha);
    vec[1] = radius2 * sin(alpha);
    vec = rot * vec;</span>

<span style = "background-color:#fdd">    Point2D polyLinePoint;
    polyLinePoint[0] = centerPoint[0] + vec[0];
    polyLinePoint[1] = centerPoint[1] + vec[1];</span>

    // ... and append it to the PolyLine.
    // No extending supported here, so we can set the index of the PolyLineElement to '0'
<span style = "background-color:#fdd">    this-&gt;AppendPointToPolyLine(0, polyLinePoint);
  }</span>

<span style = "background-color:#fdd">  this-&gt;AppendPointToPolyLine(1, centerPoint);
  this-&gt;AppendPointToPolyLine(1, this-&gt;GetControlPoint(3));
}</span>

void mitk::PlanarEllipse::GenerateHelperPolyLine(double /*mmPerDisplayUnit*/, unsigned int /*displayHeight*/)
<span style = "background-color:#fdd">{</span>
  // A circle does not require a helper object
<span style = "background-color:#fdd">}</span>

void mitk::PlanarEllipse::EvaluateFeaturesInternal()
<span style = "background-color:#fdd">{
  const Point2D centerPoint = this-&gt;GetControlPoint(0);</span>

<span style = "background-color:#fdd">  const auto longAxisLength = centerPoint.EuclideanDistanceTo(this-&gt;GetControlPoint(1));
  const auto shortAxisLength = centerPoint.EuclideanDistanceTo(this-&gt;GetControlPoint(2));</span>

<span style = "background-color:#fdd">  this-&gt;SetQuantity(FEATURE_ID_MAJOR_AXIS, 2 * longAxisLength);
  this-&gt;SetQuantity(FEATURE_ID_MINOR_AXIS, 2 * shortAxisLength);
  this-&gt;SetQuantity(FEATURE_ID_AREA, longAxisLength * shortAxisLength * itk::Math::pi);
}</span>

void mitk::PlanarEllipse::PrintSelf(std::ostream &amp;os, itk::Indent indent) const
<span style = "background-color:#fdd">{
  Superclass::PrintSelf(os, indent);
}</span>

bool mitk::PlanarEllipse::Equals(const mitk::PlanarFigure &amp;other) const
<span style = "background-color:#fdd">{
  const auto *otherEllipse = dynamic_cast&lt;const mitk::PlanarEllipse *&gt;(&amp;other);
  if (otherEllipse)</span>
  {
<span style = "background-color:#fdd">    if (this-&gt;m_TreatAsCircle != otherEllipse-&gt;m_TreatAsCircle)
      return false;</span>

<span style = "background-color:#fdd">    return Superclass::Equals(other);
  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>