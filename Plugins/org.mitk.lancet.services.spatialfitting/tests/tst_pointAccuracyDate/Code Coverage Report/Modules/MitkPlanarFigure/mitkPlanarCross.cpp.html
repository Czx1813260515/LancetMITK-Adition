<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkPlanarCross.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkPlanarCross.h"
#include "mitkPlaneGeometry.h"
#include "mitkProperties.h"

mitk::PlanarCross::PlanarCross()
<span style = "background-color:#fdd">  : FEATURE_ID_LONGESTDIAMETER(this-&gt;AddFeature("Longest Axis", "mm")),
    FEATURE_ID_SHORTAXISDIAMETER(this-&gt;AddFeature("Short Axis", "mm"))
{</span>
  // Cross has two control points at the beginning
<span style = "background-color:#fdd">  this-&gt;ResetNumberOfControlPoints(2);</span>

  // Create property for SingleLineMode (default: false)
<span style = "background-color:#fdd">  this-&gt;SetProperty("SingleLineMode", mitk::BoolProperty::New(false));</span>

  // Create helper polyline object (for drawing the orthogonal orientation line)
<span style = "background-color:#fdd">  this-&gt;SetNumberOfHelperPolyLines(1);
  m_HelperPolyLinesToBePainted-&gt;InsertElement(0, false);
}</span>

void mitk::PlanarCross::SetSingleLineMode(bool singleLineMode)
<span style = "background-color:#fdd">{
  this-&gt;SetProperty("SingleLineMode", mitk::BoolProperty::New(singleLineMode));
  this-&gt;Modified();
}</span>

bool mitk::PlanarCross::GetSingleLineMode() const
<span style = "background-color:#fdd">{
  const mitk::BoolProperty *singleLineMode =</span>
    dynamic_cast&lt;mitk::BoolProperty *&gt;(this-&gt;GetProperty("SingleLineMode").GetPointer());

<span style = "background-color:#fdd">  if (singleLineMode != nullptr)</span>
  {
<span style = "background-color:#fdd">    return singleLineMode-&gt;GetValue();</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

bool mitk::PlanarCross::ResetOnPointSelectNeeded() const
<span style = "background-color:#fdd">{
  return this-&gt;GetSingleLineMode() == false || (m_SelectedControlPoint &gt;= 0 &amp;&amp; m_SelectedControlPoint &lt;= 3);
}</span>

bool mitk::PlanarCross::ResetOnPointSelect()
<span style = "background-color:#fdd">{
  if (this-&gt;GetSingleLineMode())</span>
  {
    // In single line mode --&gt; nothing to reset
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  switch (m_SelectedControlPoint)</span>
  {
    default:
      // Nothing selected --&gt; nothing to reset
<span style = "background-color:#fdd">      return false;</span>
    case 0:
      // Control point 0 selected: exchange points 0 and 1
      {
<span style = "background-color:#fdd">        const Point2D tmpPoint = this-&gt;GetControlPoint(0);
        this-&gt;SetControlPoint(0, this-&gt;GetControlPoint(1));
        this-&gt;SetControlPoint(1, tmpPoint);</span>
      }
      // FALLTHRU!
    case 1:
      // Control point 0 or 1 selected: reset number of control points to two
<span style = "background-color:#fdd">      this-&gt;ResetNumberOfControlPoints(2);
      this-&gt;SelectControlPoint(1);
      return true;</span>
    case 2:
      // Control point 2 selected: replace point 0 with point 3 and point 1 with point 2
<span style = "background-color:#fdd">      this-&gt;SetControlPoint(0, this-&gt;GetControlPoint(3));
      this-&gt;SetControlPoint(1, this-&gt;GetControlPoint(2));</span>

      // Adjust selected control point, reset number of control points to two
<span style = "background-color:#fdd">      this-&gt;ResetNumberOfControlPoints(2);
      this-&gt;SelectControlPoint(1);
      return true;</span>
    case 3:
      // Control point 3 selected: replace point 0 with point 2 and point 1 with point 3

<span style = "background-color:#fdd">      this-&gt;SetControlPoint(0, this-&gt;GetControlPoint(2));
      this-&gt;SetControlPoint(1, this-&gt;GetControlPoint(3));</span>

      // Adjust selected control point, reset number of control points to two
<span style = "background-color:#fdd">      this-&gt;ResetNumberOfControlPoints(2);
      this-&gt;SelectControlPoint(1);
      return true;</span>
  }
<span style = "background-color:#fdd">}</span>

unsigned int mitk::PlanarCross::GetNumberOfFeatures() const
<span style = "background-color:#fdd">{
  if (this-&gt;GetSingleLineMode() || (this-&gt;GetNumberOfControlPoints() &lt; 4))</span>
  {
<span style = "background-color:#fdd">    return 1;
  }</span>
  else
  {
<span style = "background-color:#fdd">    return 2;</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::Point2D mitk::PlanarCross::ApplyControlPointConstraints(unsigned int index, const Point2D &amp;point)
<span style = "background-color:#fdd">{</span>
  // Apply spatial constraints from superclass and from this class until the resulting constrained
  // point converges. Although not an optimal implementation, this iterative approach
  // helps to respect both constraints from the superclass and from this class. Without this,
  // situations may occur where control points are constrained by the superclass, but again
  // moved out of the superclass bounds by the subclass, or vice versa.

<span style = "background-color:#fdd">  unsigned int count = 0; // ensures stop of approach if point does not converge in reasonable time
  Point2D confinedPoint = point;
  Point2D superclassConfinedPoint;</span>
  do
  {
<span style = "background-color:#fdd">    superclassConfinedPoint = Superclass::ApplyControlPointConstraints(index, confinedPoint);
    confinedPoint = this-&gt;InternalApplyControlPointConstraints(index, superclassConfinedPoint);
    ++count;
  } while ((confinedPoint.EuclideanDistanceTo(superclassConfinedPoint) &gt; mitk::eps) &amp;&amp; (count &lt; 32));</span>

<span style = "background-color:#fdd">  return confinedPoint;
}</span>

mitk::Point2D mitk::PlanarCross::InternalApplyControlPointConstraints(unsigned int index, const Point2D &amp;point)
<span style = "background-color:#fdd">{</span>
  // Apply constraints depending on current interaction state
<span style = "background-color:#fdd">  switch (index)</span>
  {
    case 2:
    {
      // Check if 3rd control point is outside of the range (2D area) defined by the first
      // line (via the first two control points); if it is outside, clip it to the bounds
<span style = "background-color:#fdd">      const Point2D p1 = this-&gt;GetControlPoint(0);
      const Point2D p2 = this-&gt;GetControlPoint(1);</span>

<span style = "background-color:#fdd">      Vector2D n1 = p2 - p1;
      n1.Normalize();</span>

<span style = "background-color:#fdd">      const Vector2D v1 = point - p1;
      const double dotProduct = n1 * v1;
      const Point2D crossPoint = p1 + n1 * dotProduct;</span>
      ;
<span style = "background-color:#fdd">      const Vector2D crossVector = point - crossPoint;</span>

<span style = "background-color:#fdd">      if (dotProduct &lt; 0.0)</span>
      {
        // Out-of-bounds on the left: clip point to left boundary
<span style = "background-color:#fdd">        return (p1 + crossVector);
      }
      else if (dotProduct &gt; p2.EuclideanDistanceTo(p1))</span>
      {
        // Out-of-bounds on the right: clip point to right boundary
<span style = "background-color:#fdd">        return (p2 + crossVector);
      }</span>
      else
      {
        // Pass back original point
<span style = "background-color:#fdd">        return point;</span>
      }
    }

    case 3:
    {
      // Constrain 4th control point so that with the 3rd control point it forms
      // a line orthogonal to the first line (constraint 1); the 4th control point
      // must lie on the opposite side of the line defined by the first two control
      // points than the 3rd control point (constraint 2)
<span style = "background-color:#fdd">      const Point2D p1 = this-&gt;GetControlPoint(0);
      const Point2D p2 = this-&gt;GetControlPoint(1);
      const Point2D p3 = this-&gt;GetControlPoint(2);</span>

      // Calculate distance of original point from orthogonal line the corrected
      // point should lie on to project the point onto this line
<span style = "background-color:#fdd">      Vector2D n1 = p2 - p1;
      n1.Normalize();</span>

<span style = "background-color:#fdd">      const Vector2D v1 = point - p3;
      const double dotProduct1 = n1 * v1;</span>

<span style = "background-color:#fdd">      const Point2D pointOnLine = point - n1 * dotProduct1;</span>

      // Project new point onto line [p1, p2]
<span style = "background-color:#fdd">      const Vector2D v2 = pointOnLine - p1;
      double dotProduct2 = n1 * v2;</span>

<span style = "background-color:#fdd">      const Point2D crossingPoint = p1 + n1 * dotProduct2;</span>

      // Determine whether the projected point on the line, or the crossing point should be
      // used (according to the second constraint in the comment above)
<span style = "background-color:#fdd">      if ((pointOnLine.SquaredEuclideanDistanceTo(p3) &gt; crossingPoint.SquaredEuclideanDistanceTo(p3)) &amp;&amp;</span>
          (pointOnLine.SquaredEuclideanDistanceTo(p3) &gt; pointOnLine.SquaredEuclideanDistanceTo(crossingPoint)))
      {
<span style = "background-color:#fdd">        return pointOnLine;
      }</span>
      else
      {
<span style = "background-color:#fdd">        return crossingPoint;</span>
      }
    }

    default:
<span style = "background-color:#fdd">      return point;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::PlanarCross::GeneratePolyLine()
<span style = "background-color:#fdd">{
  this-&gt;SetNumberOfPolyLines(1);
  this-&gt;ClearPolyLines();</span>

<span style = "background-color:#fdd">  if (this-&gt;GetNumberOfControlPoints() &gt; 2)
    this-&gt;SetNumberOfPolyLines(2);</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; this-&gt;GetNumberOfControlPoints(); ++i)</span>
  {
<span style = "background-color:#fdd">    if (i &lt; 2)
      this-&gt;AppendPointToPolyLine(0, this-&gt;GetControlPoint(i));</span>

<span style = "background-color:#fdd">    if (i &gt; 1)
      this-&gt;AppendPointToPolyLine(1, this-&gt;GetControlPoint(i));
  }
}</span>

void mitk::PlanarCross::GenerateHelperPolyLine(double /*mmPerDisplayUnit*/, unsigned int /*displayHeight*/)
<span style = "background-color:#fdd">{</span>
  // Generate helper polyline (orientation line orthogonal to first line)
  // if the third control point is currently being set
<span style = "background-color:#fdd">  if (this-&gt;GetNumberOfControlPoints() != 3)</span>
  {
<span style = "background-color:#fdd">    m_HelperPolyLinesToBePainted-&gt;SetElement(0, false);
    return;</span>
  }

<span style = "background-color:#fdd">  m_HelperPolyLinesToBePainted-&gt;SetElement(0, true);</span>

<span style = "background-color:#fdd">  this-&gt;ClearHelperPolyLines();</span>

  // Calculate cross point of first line (p1 to p2) and orthogonal line through
  // the third control point (p3)
<span style = "background-color:#fdd">  const Point2D p1 = this-&gt;GetControlPoint(0);
  const Point2D p2 = this-&gt;GetControlPoint(1);
  const Point2D p3 = this-&gt;GetControlPoint(2);</span>

<span style = "background-color:#fdd">  Vector2D n1 = p2 - p1;
  n1.Normalize();</span>

<span style = "background-color:#fdd">  const Vector2D v1 = p3 - p1;
  const Point2D crossPoint = p1 + n1 * (n1 * v1);</span>

<span style = "background-color:#fdd">  const Vector2D v2 = crossPoint - p3;
  if (v2.GetNorm() &lt; 1.0)</span>
  {
    // If third point is on the first line, draw orthogonal "infinite" line
    // through cross point on line
<span style = "background-color:#fdd">    Vector2D v0;
    v0[0] = n1[1];
    v0[1] = -n1[0];
    this-&gt;AppendPointToHelperPolyLine(0, Point2D(p3 - v0 * 10000.0));
    this-&gt;AppendPointToHelperPolyLine(0, Point2D(p3 + v0 * 10000.0));
  }</span>
  else
  {
    // Else, draw orthogonal line starting from third point and crossing the
    // first line, open-ended only on the other side
<span style = "background-color:#fdd">    this-&gt;AppendPointToHelperPolyLine(0, p3);
    this-&gt;AppendPointToHelperPolyLine(0, Point2D(p3 + v2 * 10000.0));</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::PlanarCross::EvaluateFeaturesInternal()
<span style = "background-color:#fdd">{</span>
  // Calculate length of first line
<span style = "background-color:#fdd">  const Point3D &amp;p0 = this-&gt;GetWorldControlPoint(0);
  const Point3D &amp;p1 = this-&gt;GetWorldControlPoint(1);
  double l1 = p0.EuclideanDistanceTo(p1);</span>

  // Calculate length of second line
<span style = "background-color:#fdd">  double l2 = 0.0;
  if (!this-&gt;GetSingleLineMode() &amp;&amp; (this-&gt;GetNumberOfControlPoints() &gt; 3))</span>
  {
<span style = "background-color:#fdd">    const Point3D &amp;p2 = this-&gt;GetWorldControlPoint(2);
    const Point3D &amp;p3 = this-&gt;GetWorldControlPoint(3);
    l2 = p2.EuclideanDistanceTo(p3);</span>
  }

  double longestDiameter;
  double shortAxisDiameter;
<span style = "background-color:#fdd">  if (l1 &gt; l2)</span>
  {
<span style = "background-color:#fdd">    longestDiameter = l1;
    shortAxisDiameter = l2;
  }</span>
  else
  {
<span style = "background-color:#fdd">    longestDiameter = l2;
    shortAxisDiameter = l1;</span>
  }

<span style = "background-color:#fdd">  this-&gt;SetQuantity(FEATURE_ID_LONGESTDIAMETER, longestDiameter);
  this-&gt;SetQuantity(FEATURE_ID_SHORTAXISDIAMETER, shortAxisDiameter);
}</span>

void mitk::PlanarCross::PrintSelf(std::ostream &amp;os, itk::Indent indent) const
<span style = "background-color:#fdd">{
  Superclass::PrintSelf(os, indent);
}</span>

bool mitk::PlanarCross::Equals(const mitk::PlanarFigure &amp;other) const
<span style = "background-color:#fdd">{
  const auto *otherCross = dynamic_cast&lt;const mitk::PlanarCross *&gt;(&amp;other);
  if (otherCross)</span>
  {
<span style = "background-color:#fdd">    return Superclass::Equals(other);
  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>