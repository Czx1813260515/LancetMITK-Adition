<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkIGTLDevice.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkIGTLDevice.h"
//#include "mitkIGTException.h"
//#include "mitkIGTTimeStamp.h"
#include &lt;itkMultiThreaderBase.h&gt;
#include &lt;itksys/SystemTools.hxx&gt;
#include &lt;cstring&gt;
#include &lt;thread&gt;

#include &lt;igtlTransformMessage.h&gt;
#include &lt;mitkIGTLMessageCommon.h&gt;

#include &lt;igtl_status.h&gt;

//remove later
#include &lt;igtlTrackingDataMessage.h&gt;

namespace mitk
{
<span style = "background-color:#fdd">  itkEventMacroDefinition(MessageSentEvent, itk::AnyEvent);
  itkEventMacroDefinition(MessageReceivedEvent, itk::AnyEvent);
  itkEventMacroDefinition(CommandReceivedEvent, itk::AnyEvent);
  itkEventMacroDefinition(NewClientConnectionEvent, itk::AnyEvent);
  itkEventMacroDefinition(LostConnectionEvent, itk::AnyEvent);</span>
}

//TODO: Which timeout is acceptable and also needed to transmit image data? Is there a maximum data limit?
static const int SOCKET_SEND_RECEIVE_TIMEOUT_MSEC = 100;

mitk::IGTLDevice::IGTLDevice(bool ReadFully) :
//  m_Data(mitk::DeviceDataUnspecified),
<span style = "background-color:#fdd">m_State(mitk::IGTLDevice::Setup),
m_Name("Unspecified Device"),
m_StopCommunication(false),
m_Hostname("127.0.0.1"),
m_PortNumber(-1),
m_LogMessages(false)
{
  m_ReadFully = ReadFully;</span>
  // execution rights are owned by the application thread at the beginning
<span style = "background-color:#fdd">  m_SendingFinishedMutex.lock();
  m_ReceivingFinishedMutex.lock();
  m_ConnectingFinishedMutex.lock();</span>
  //  m_Data = mitk::DeviceDataUnspecified;
  //  m_LatestMessage = igtl::MessageBase::New();

<span style = "background-color:#fdd">  m_MessageFactory = mitk::IGTLMessageFactory::New();
  m_MessageQueue = mitk::IGTLMessageQueue::New();
}</span>

mitk::IGTLDevice::~IGTLDevice()
<span style = "background-color:#fdd">{</span>
  /* stop communication and disconnect from igtl device */
<span style = "background-color:#fdd">  if (GetState() == Running)</span>
  {
<span style = "background-color:#fdd">    this-&gt;StopCommunication();
    this-&gt;CloseConnection();
  }
  else if (GetState() == Ready)</span>
  {
<span style = "background-color:#fdd">    this-&gt;CloseConnection();</span>
  }
  /* cleanup tracking thread */
<span style = "background-color:#fdd">  if (m_SendThread.joinable())
    m_SendThread.detach();</span>

<span style = "background-color:#fdd">  if (m_ReceiveThread.joinable())
    m_ReceiveThread.detach();</span>

<span style = "background-color:#fdd">  if (m_ConnectThread.joinable())
    m_ConnectThread.detach();
}</span>

mitk::IGTLDevice::IGTLDeviceState mitk::IGTLDevice::GetState() const
<span style = "background-color:#fdd">{
  std::lock_guard&lt;std::mutex&gt; lock(m_StateMutex);
  return m_State;
}</span>

void mitk::IGTLDevice::SetState(IGTLDeviceState state)
<span style = "background-color:#fdd">{
  itkDebugMacro("setting  m_State to " &lt;&lt; state);</span>

<span style = "background-color:#fdd">  m_StateMutex.lock();</span>
  //  MutexLockHolder lock(*m_StateMutex); // lock and unlock the mutex

<span style = "background-color:#fdd">  if (m_State == state)</span>
  {
<span style = "background-color:#fdd">    m_StateMutex.unlock();
    return;</span>
  }
<span style = "background-color:#fdd">  m_State = state;
  m_StateMutex.unlock();
  this-&gt;Modified();
}</span>

bool mitk::IGTLDevice::TestConnection()
<span style = "background-color:#fdd">{
  return true;
}</span>

unsigned int mitk::IGTLDevice::ReceivePrivate(igtl::Socket* socket)
<span style = "background-color:#fdd">{</span>
  // Create a message buffer to receive header
<span style = "background-color:#fdd">  igtl::MessageHeader::Pointer headerMsg;
  headerMsg = igtl::MessageHeader::New();</span>

  // Initialize receive buffer
<span style = "background-color:#fdd">  headerMsg-&gt;InitPack();</span>

  // Receive generic header from the socket
<span style = "background-color:#fdd">  int r =</span>
    socket-&gt;Receive(headerMsg-&gt;GetPackPointer(), headerMsg-&gt;GetPackSize(), 0);

  //MITK_INFO &lt;&lt; "Server received r = " &lt;&lt; r;

  //MITK_INFO &lt;&lt; "Received r = " &lt;&lt; r;

<span style = "background-color:#fdd">  if (r == 0) //connection error</span>
  {
    // an error was received, therefore the communication with this socket
    // must be stoppedy
<span style = "background-color:#fdd">    return IGTL_STATUS_NOT_PRESENT;
  }
  else if (r == -1) //timeout</span>
  {
    // a timeout was received, this is no error state, thus, do nothing
<span style = "background-color:#fdd">    return IGTL_STATUS_TIME_OUT;
  }
  else if (r == headerMsg-&gt;GetPackSize())</span>
  {
    // Deserialize the header and check the CRC
    // ERROR HERE: This probably means the header data is corrupted...
<span style = "background-color:#fdd">    int crcCheck = headerMsg-&gt;Unpack(1);</span>

<span style = "background-color:#fdd">    if (crcCheck &amp; igtl::MessageHeader::UNPACK_HEADER)</span>
    {
      // Allocate a time stamp
<span style = "background-color:#fdd">      igtl::TimeStamp::Pointer ts;
      ts = igtl::TimeStamp::New();</span>

      // Get time stamp
      igtlUint32 sec;
      igtlUint32 nanosec;

<span style = "background-color:#fdd">      headerMsg-&gt;GetTimeStamp(ts);
      ts-&gt;GetTimeStamp(&amp;sec, &amp;nanosec);</span>

      //      std::cerr &lt;&lt; "Time stamp: "
      //                &lt;&lt; sec &lt;&lt; "."
      //                &lt;&lt; nanosec &lt;&lt; std::endl;

      //      std::cerr &lt;&lt; "Dev type and name: " &lt;&lt; headerMsg-&gt;GetDeviceType() &lt;&lt; " "
      //                &lt;&lt; headerMsg-&gt;GetDeviceName() &lt;&lt; std::endl;

      // headerMsg-&gt;Print(std::cout);

      //check the type of the received message
      //if it is a GET_, STP_ or RTS_ command push it into the command queue
      //otherwise continue reading the whole message from the socket
<span style = "background-color:#fdd">      const char* curDevType = headerMsg-&gt;GetDeviceType();</span>
      if (std::strstr(curDevType, "GET_") != nullptr ||
<span style = "background-color:#fdd">        std::strstr(curDevType, "STP_") != nullptr ||</span>
        std::strstr(curDevType, "RTS_") != nullptr)
      {
<span style = "background-color:#fdd">        this-&gt;m_MessageQueue-&gt;PushCommandMessage(headerMsg);
        this-&gt;InvokeEvent(CommandReceivedEvent());
        return IGTL_STATUS_OK;</span>
      }

      //Create a message according to the header message
<span style = "background-color:#fdd">      igtl::MessageBase::Pointer curMessage;
      curMessage = m_MessageFactory-&gt;CreateInstance(headerMsg);</span>

      //check if the curMessage is created properly, if not the message type is
      //not supported and the message has to be skipped
<span style = "background-color:#fdd">      if (curMessage.IsNull())</span>
      {
<span style = "background-color:#fdd">        socket-&gt;Skip(headerMsg-&gt;GetBodySizeToRead(), 0);</span>
        //  MITK_ERROR("IGTLDevice") &lt;&lt; "The received type is not supported. Please "
        //                              "add it to the message factory.";
<span style = "background-color:#fdd">        return IGTL_STATUS_NOT_FOUND;</span>
      }

      //insert the header to the message and allocate the pack
<span style = "background-color:#fdd">      curMessage-&gt;SetMessageHeader(headerMsg);
      curMessage-&gt;AllocatePack();</span>

      // Receive transform data from the socket
<span style = "background-color:#fdd">      int receiveCheck = 0;
      receiveCheck = socket-&gt;Receive(curMessage-&gt;GetPackBodyPointer(),</span>
        curMessage-&gt;GetPackBodySize(), m_ReadFully);

<span style = "background-color:#fdd">      if (receiveCheck &gt; 0)</span>
      {
<span style = "background-color:#fdd">        int c = curMessage-&gt;Unpack(1);
        if (!(c &amp; igtl::MessageHeader::UNPACK_BODY))</span>
        {
<span style = "background-color:#fdd">          return IGTL_STATUS_CHECKSUM_ERROR;</span>
        }

        //check the type of the received message
        //if it is a command push it into the command queue
        //otherwise into the normal receive queue
        //STP_ commands are handled here because they implemented additional
        //member variables that are not stored in the header message
<span style = "background-color:#fdd">        if (std::strstr(curDevType, "STT_") != nullptr)</span>
        {
<span style = "background-color:#fdd">          this-&gt;m_MessageQueue-&gt;PushCommandMessage(curMessage);
          this-&gt;InvokeEvent(CommandReceivedEvent());
        }</span>
        else
        {
<span style = "background-color:#fdd">          if(m_LogMessages)
            MITK_INFO &lt;&lt; "Received Message: " &lt;&lt; mitk::IGTLMessage::New(curMessage)-&gt;ToString();
          this-&gt;m_MessageQueue-&gt;PushMessage(curMessage);
          this-&gt;InvokeEvent(MessageReceivedEvent());</span>
        }
<span style = "background-color:#fdd">        return IGTL_STATUS_OK;
      }</span>
      else
      {
<span style = "background-color:#fdd">        MITK_WARN("IGTLDevice") &lt;&lt; "Received a valid header but could not "</span>
          &lt;&lt; "read the whole message.";
<span style = "background-color:#fdd">        return IGTL_STATUS_UNKNOWN_ERROR;</span>
      }
<span style = "background-color:#fdd">    }</span>
    else
    {
      //CRC check failed
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "CRC Check failed";
      return IGTL_STATUS_CHECKSUM_ERROR;</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
    //Message size information and actual data size don't match.
    //this state is not suppossed to be reached, return unknown error
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "IGTL status unknown";
    return IGTL_STATUS_UNKNOWN_ERROR;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::IGTLDevice::SendMessage(mitk::IGTLMessage::Pointer msg)
<span style = "background-color:#fdd">{
  m_MessageQueue-&gt;PushSendMessage(msg);
}</span>

unsigned int mitk::IGTLDevice::SendMessagePrivate(mitk::IGTLMessage::Pointer msg,
  igtl::Socket::Pointer socket)
<span style = "background-color:#fdd">{</span>
  //check the input message
<span style = "background-color:#fdd">  if (msg.IsNull())</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR("IGTLDevice") &lt;&lt; "Could not send message because message is not "</span>
      "valid. Please check.";
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  igtl::MessageBase* sendMessage = msg-&gt;GetMessage();</span>

  // Pack (serialize) and send
<span style = "background-color:#fdd">  sendMessage-&gt;Pack();</span>

<span style = "background-color:#fdd">  int sendSuccess = socket-&gt;Send(sendMessage-&gt;GetPackPointer(), sendMessage-&gt;GetPackSize());</span>

<span style = "background-color:#fdd">  if (sendSuccess)</span>
  {
<span style = "background-color:#fdd">    if (m_LogMessages) { MITK_INFO &lt;&lt; "Send IGTL message: " &lt;&lt; msg-&gt;ToString(); }
    this-&gt;InvokeEvent(MessageSentEvent());
    return IGTL_STATUS_OK;
  }</span>
  else
  {
<span style = "background-color:#fdd">    return IGTL_STATUS_UNKNOWN_ERROR;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::IGTLDevice::RunCommunication(void (IGTLDevice::*ComFunction)(void), std::mutex&amp; mutex)
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Running)
    return;</span>

  try
  {
    // keep lock until end of scope
<span style = "background-color:#fdd">    std::lock_guard&lt;std::mutex&gt; communicationFinishedLockHolder(mutex);</span>

    // Because m_StopCommunication is used by two threads, access has to be guarded
    // by a mutex. To minimize thread locking, a local copy is used here
    bool localStopCommunication;

    // update the local copy of m_StopCommunication
<span style = "background-color:#fdd">    this-&gt;m_StopCommunicationMutex.lock();
    localStopCommunication = this-&gt;m_StopCommunication;
    this-&gt;m_StopCommunicationMutex.unlock();
    while ((this-&gt;GetState() == Running) &amp;&amp; (localStopCommunication == false))</span>
    {
<span style = "background-color:#fdd">      (this-&gt;*ComFunction)();</span>

      /* Update the local copy of m_StopCommunication */
<span style = "background-color:#fdd">      this-&gt;m_StopCommunicationMutex.lock();
      localStopCommunication = m_StopCommunication;
      this-&gt;m_StopCommunicationMutex.unlock();</span>

      // time to relax, this sets the maximum ever possible framerate to 1000 Hz
<span style = "background-color:#fdd">      itksys::SystemTools::Delay(1);
    }
  }</span>
  catch (...)
<span style = "background-color:#fdd">  {
    mutex.unlock();
    this-&gt;StopCommunication();
    MITK_ERROR("IGTLDevice::RunCommunication") &lt;&lt; "Error while communicating. Thread stopped.";</span>
    //mitkThrowException(mitk::IGTException) &lt;&lt; "Error while communicating. Thread stopped.";
<span style = "background-color:#fdd">  }</span>
  // StopCommunication was called, thus the mode should be changed back to Ready now
  // that the tracking loop has ended.
  //this-&gt;SetState(Ready); //this is done elsewhere
<span style = "background-color:#fdd">  MITK_DEBUG("IGTLDevice::RunCommunication") &lt;&lt; "Reached end of communication.";</span>
  // returning from this function (and ThreadStartCommunication())
  // this will end the thread
  return;
<span style = "background-color:#fdd">}</span>

bool mitk::IGTLDevice::StartCommunication()
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() != Ready)
    return false;</span>

  // go to mode Running
<span style = "background-color:#fdd">  this-&gt;SetState(Running);</span>

  // set a timeout for the sending and receiving
<span style = "background-color:#fdd">  this-&gt;m_Socket-&gt;SetTimeout(SOCKET_SEND_RECEIVE_TIMEOUT_MSEC);</span>

  // update the local copy of m_StopCommunication
<span style = "background-color:#fdd">  this-&gt;m_StopCommunicationMutex.lock();
  this-&gt;m_StopCommunication = false;
  this-&gt;m_StopCommunicationMutex.unlock();</span>

  // transfer the execution rights to tracking thread
<span style = "background-color:#fdd">  m_SendingFinishedMutex.unlock();
  m_ReceivingFinishedMutex.unlock();
  m_ConnectingFinishedMutex.unlock();</span>

  // start new threads that execute the communication
<span style = "background-color:#fdd">  m_SendThread = std::thread(&amp;IGTLDevice::ThreadStartSending, this);
  m_ReceiveThread = std::thread(&amp;IGTLDevice::ThreadStartReceiving, this);
  m_ConnectThread = std::thread(&amp;IGTLDevice::ThreadStartConnecting, this);</span>
  //  mitk::IGTTimeStamp::GetInstance()-&gt;Start(this);
<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::IGTLDevice::StopCommunication()
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() == Running) // Only if the object is in the correct state</span>
  {
    // m_StopCommunication is used by two threads, so we have to ensure correct
    // thread handling
<span style = "background-color:#fdd">    m_StopCommunicationMutex.lock();
    m_StopCommunication = true;
    m_StopCommunicationMutex.unlock();</span>
    // we have to wait here that the other thread recognizes the STOP-command
    // and executes it
<span style = "background-color:#fdd">    m_SendingFinishedMutex.lock();
    m_ReceivingFinishedMutex.lock();
    m_ConnectingFinishedMutex.lock();</span>
    //    mitk::IGTTimeStamp::GetInstance()-&gt;Stop(this); // notify realtime clock
    // StopCommunication was called, thus the mode should be changed back
    // to Ready now that the tracking loop has ended.
<span style = "background-color:#fdd">    this-&gt;SetState(Ready);</span>
  }
<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::IGTLDevice::CloseConnection()
<span style = "background-color:#fdd">{
  if (this-&gt;GetState() == Setup)</span>
  {
<span style = "background-color:#fdd">    return true;
  }
  else if (this-&gt;GetState() == Running)</span>
  {
<span style = "background-color:#fdd">    this-&gt;StopCommunication();</span>
  }

<span style = "background-color:#fdd">  m_Socket-&gt;CloseSocket();</span>

  /* return to setup mode */
<span style = "background-color:#fdd">  this-&gt;SetState(Setup);</span>

  //  this-&gt;InvokeEvent(mitk::LostConnectionEvent());

<span style = "background-color:#fdd">  return true;
}</span>

bool mitk::IGTLDevice::SendRTSMessage(const char* type)
<span style = "background-color:#fdd">{</span>
  //construct the device type for the return message, it starts with RTS_ and
  //continues with the requested type
<span style = "background-color:#fdd">  std::string returnType("RTS_");
  returnType.append(type);</span>
  //create a return message
<span style = "background-color:#fdd">  igtl::MessageBase::Pointer rtsMsg =</span>
    this-&gt;m_MessageFactory-&gt;CreateInstance(returnType);
  //if retMsg is nullptr there is no return message defined and thus it is not
  //necessary to send one back
<span style = "background-color:#fdd">  if (rtsMsg.IsNotNull())</span>
  {
<span style = "background-color:#fdd">    this-&gt;SendMessage(mitk::IGTLMessage::New(rtsMsg));
    return true;
  }</span>
  else
  {
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::IGTLDevice::Connect()
<span style = "background-color:#fdd">{
  MITK_DEBUG &lt;&lt; "mitk::IGTLDevice::Connect();";
}</span>

igtl::ImageMessage::Pointer mitk::IGTLDevice::GetNextImage2dMessage()
<span style = "background-color:#fdd">{
  return this-&gt;m_MessageQueue-&gt;PullImage2dMessage();
}</span>

igtl::ImageMessage::Pointer mitk::IGTLDevice::GetNextImage3dMessage()
<span style = "background-color:#fdd">{
  return this-&gt;m_MessageQueue-&gt;PullImage3dMessage();
}</span>

igtl::TransformMessage::Pointer mitk::IGTLDevice::GetNextTransformMessage()
<span style = "background-color:#fdd">{
  return this-&gt;m_MessageQueue-&gt;PullTransformMessage();
}</span>

igtl::TrackingDataMessage::Pointer mitk::IGTLDevice::GetNextTrackingDataMessage()
<span style = "background-color:#fdd">{
  igtl::TrackingDataMessage::Pointer msg = this-&gt;m_MessageQueue-&gt;PullTrackingMessage();
  return msg;
}</span>

igtl::StringMessage::Pointer mitk::IGTLDevice::GetNextStringMessage()
<span style = "background-color:#fdd">{
  return this-&gt;m_MessageQueue-&gt;PullStringMessage();
}</span>

igtl::MessageBase::Pointer mitk::IGTLDevice::GetNextMiscMessage()
<span style = "background-color:#fdd">{
  return this-&gt;m_MessageQueue-&gt;PullMiscMessage();
}</span>

igtl::MessageBase::Pointer mitk::IGTLDevice::GetNextCommand()
<span style = "background-color:#fdd">{
  return m_MessageQueue-&gt;PullCommandMessage();
}</span>
void mitk::IGTLDevice::EnableNoBufferingMode(bool enable)
<span style = "background-color:#fdd">{
  m_MessageQueue-&gt;EnableNoBufferingMode(enable);
}</span>

void mitk::IGTLDevice::EnableNoBufferingMode(
  mitk::IGTLMessageQueue::Pointer queue,
  bool enable)
<span style = "background-color:#fdd">{
  queue-&gt;EnableNoBufferingMode(enable);
}</span>

void mitk::IGTLDevice::ThreadStartSending()
<span style = "background-color:#fdd">{
  this-&gt;RunCommunication(&amp;IGTLDevice::Send, m_SendingFinishedMutex);
}</span>

void mitk::IGTLDevice::ThreadStartReceiving()
<span style = "background-color:#fdd">{
   this-&gt;RunCommunication(&amp;IGTLDevice::Receive, m_ReceivingFinishedMutex);
}</span>

void mitk::IGTLDevice::ThreadStartConnecting()
<span style = "background-color:#fdd">{
  this-&gt;RunCommunication(&amp;IGTLDevice::Connect, m_ConnectingFinishedMutex);
}</span></pre>
	</body>
</html>