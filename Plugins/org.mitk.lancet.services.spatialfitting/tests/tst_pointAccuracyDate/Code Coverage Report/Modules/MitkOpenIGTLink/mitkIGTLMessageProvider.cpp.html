<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkIGTLMessageProvider.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkIGTLMessageProvider.h"

#include "mitkIGTLDevice.h"
#include "mitkIGTLMessage.h"
#include "mitkIGTLMessageFactory.h"

#include "mitkCallbackFromGUIThread.h"

//Microservices
#include "usServiceReference.h"
#include "usModuleContext.h"
#include "usServiceEvent.h"
#include "mitkServiceInterface.h"
#include "usGetModuleContext.h"

//igt (remove this later)
#include "igtlBindMessage.h"
#include "igtlQuaternionTrackingDataMessage.h"
#include "igtlTrackingDataMessage.h"

#ifndef WIN32
#include &lt;unistd.h&gt;
#endif

namespace mitk
{
<span style = "background-color:#fdd">  itkEventMacroDefinition(StreamingStartRequiredEvent, itk::AnyEvent);
  itkEventMacroDefinition(StreamingStopRequiredEvent, itk::AnyEvent);</span>
}

mitk::IGTLMessageProvider::IGTLMessageProvider()
<span style = "background-color:#fdd">  : mitk::IGTLDeviceSource()
{
  this-&gt;SetName("IGTLMessageProvider");
  m_IsStreaming = false;</span>

  // Create a command object. The function will be called later from the main thread
<span style = "background-color:#fdd">  this-&gt;m_StopStreamingCommand = ProviderCommand::New();
  m_StopStreamingCommand-&gt;SetCallbackFunction(this,</span>
    &amp;mitk::IGTLMessageProvider::InvokeStopStreamingEvent);

<span style = "background-color:#fdd">  this-&gt;m_StreamingCommand = ProviderCommand::New();
  m_StreamingCommand-&gt;SetCallbackFunction(this,</span>
    &amp;mitk::IGTLMessageProvider::InvokeStartStreamingEvent);
<span style = "background-color:#fdd">}</span>

mitk::IGTLMessageProvider::~IGTLMessageProvider()
<span style = "background-color:#fdd">{
  this-&gt;InvokeEvent(StreamingStartRequiredEvent());
}</span>

void mitk::IGTLMessageProvider::Update()
<span style = "background-color:#fdd">{</span>

<span style = "background-color:#fdd">  Superclass::Update();</span>

<span style = "background-color:#fdd">  if (this-&gt;GetInput() != nullptr)</span>
  {
<span style = "background-color:#fdd">    igtl::MessageBase::Pointer curMessage = this-&gt;GetInput()-&gt;GetMessage();
    if (dynamic_cast&lt;igtl::TrackingDataMessage*&gt;(curMessage.GetPointer()) != nullptr)</span>
    {
<span style = "background-color:#fdd">      igtl::TrackingDataMessage* tdMsg =</span>
        (igtl::TrackingDataMessage*)(curMessage.GetPointer());
<span style = "background-color:#fdd">      igtl::TrackingDataElement::Pointer trackingData = igtl::TrackingDataElement::New();
      tdMsg-&gt;GetTrackingDataElement(0, trackingData);</span>
      float x_pos, y_pos, z_pos;
<span style = "background-color:#fdd">      trackingData-&gt;GetPosition(&amp;x_pos, &amp;y_pos, &amp;z_pos);
    }
  }
}</span>

void mitk::IGTLMessageProvider::GenerateData()
<span style = "background-color:#fdd">{
  if (this-&gt;m_IGTLDevice.IsNull())
    return;</span>

<span style = "background-color:#fdd">  for (unsigned int index = 0; index &lt; this-&gt;GetNumberOfIndexedInputs(); index++)</span>
  {
<span style = "background-color:#fdd">    mitk::IGTLMessage::Pointer msg = const_cast&lt;mitk::IGTLMessage*&gt;(this-&gt;GetInput(index));
    if (msg == nullptr)</span>
    {
<span style = "background-color:#fdd">       continue;</span>
    }

<span style = "background-color:#fdd">    if ( !msg-&gt;IsDataValid() )</span>
    {
<span style = "background-color:#fdd">      continue;</span>
    }

<span style = "background-color:#fdd">    this-&gt;m_IGTLDevice-&gt;SendMessage(msg);
  }
}</span>

void mitk::IGTLMessageProvider::CreateOutputs()
<span style = "background-color:#fdd">{</span>
  //if outputs are set then delete them
<span style = "background-color:#fdd">  if (this-&gt;GetNumberOfOutputs() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    for (int numOP = this-&gt;GetNumberOfOutputs() - 1; numOP &gt;= 0; numOP--)
      this-&gt;RemoveOutput(numOP);
    this-&gt;Modified();</span>
  }

  //fill the outputs if a valid OpenIGTLink device is set
<span style = "background-color:#fdd">  if (m_IGTLDevice.IsNull())
    return;</span>

<span style = "background-color:#fdd">  this-&gt;SetNumberOfIndexedOutputs(1);
  if (this-&gt;GetOutput(0) == nullptr)</span>
  {
<span style = "background-color:#fdd">    DataObjectPointer newOutput = this-&gt;MakeOutput(0);
    this-&gt;SetNthOutput(0, newOutput);
    this-&gt;Modified();
  }
}</span>

//void mitk::IGTLMessageProvider::UpdateOutputInformation()
//{
//  this-&gt;Modified();  // make sure that we need to be updated
//  Superclass::UpdateOutputInformation();
//}


void mitk::IGTLMessageProvider::OnIncomingMessage()
<span style = "background-color:#fdd">{</span>

<span style = "background-color:#fdd">}</span>

void mitk::IGTLMessageProvider::OnLostConnection()
<span style = "background-color:#fdd">{</span>
  //in case the provider is streaming at the moment we have to stop it
<span style = "background-color:#fdd">  if (m_IsStreaming)</span>
  {
<span style = "background-color:#fdd">    MITK_DEBUG("IGTLMessageProvider") &lt;&lt; "lost connection, stop streaming";
    this-&gt;StopStreamingOfAllSources();</span>
  }
<span style = "background-color:#fdd">}</span>

std::string RemoveRequestPrefixes(std::string requestType)
<span style = "background-color:#fdd">{
  return requestType.substr(4);
}</span>

void mitk::IGTLMessageProvider::OnIncomingCommand()
<span style = "background-color:#fdd">{</span>
  //get the next command
<span style = "background-color:#fdd">  igtl::MessageBase::Pointer curCommand = this-&gt;m_IGTLDevice-&gt;GetNextCommand();</span>
  //extract the type
<span style = "background-color:#fdd">  const char * requestType = curCommand-&gt;GetDeviceType();</span>
  //check the type
<span style = "background-color:#fdd">  std::string reqType(requestType);
  bool isGetMsg = !reqType.find("GET_");
  bool isSTTMsg = !reqType.find("STT_");
  bool isSTPMsg = !reqType.find("STP_");</span>

  //get the type from the request type (remove STT_, STP_, GET_, RTS_)
<span style = "background-color:#fdd">  std::string type = RemoveRequestPrefixes(requestType);</span>
  //check all microservices if there is a fitting source for the requested type
<span style = "background-color:#fdd">  mitk::IGTLMessageSource::Pointer source = this-&gt;GetFittingSource(type.c_str());</span>
  //if there is no fitting source return a RTS message, if there is a RTS
  //type defined in the message factory send it
<span style = "background-color:#fdd">  if ( source.IsNull() )</span>
  {
<span style = "background-color:#fdd">    if ( !this-&gt;GetIGTLDevice()-&gt;SendRTSMessage(type.c_str()) )</span>
    {
      //sending RTS message failed, probably because the type is not in the
      //message factory
<span style = "background-color:#fdd">      MITK_WARN("IGTLMessageProvider") &lt;&lt; "Tried to send a RTS message but did "</span>
                                          "not succeed. Check if this type ( "
                                       &lt;&lt; type &lt;&lt; " ) was added to the message "
                                          "factory. ";
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    if ( isGetMsg ) //if it is a single value push it into sending queue</span>
    {
      //first it is necessary to update the source. This needs additional time
      //but is necessary. But are we really allowed to call this here? In which
      //thread are we? Is the source thread safe?
<span style = "background-color:#fdd">      source-&gt;Update();
      mitk::IGTLMessage::Pointer sourceOutput = source-&gt;GetOutput();
      if (sourceOutput.IsNotNull() &amp;&amp; sourceOutput-&gt;IsDataValid())</span>
      {
<span style = "background-color:#fdd">        if ( source.IsNotNull() )</span>
        {
<span style = "background-color:#fdd">          this-&gt;GetIGTLDevice()-&gt;SendMessage(sourceOutput);</span>
        }
      }
<span style = "background-color:#fdd">    }
    else if ( isSTTMsg )</span>
    {
      //read the requested frames per second
<span style = "background-color:#fdd">      int fps = 10;</span>

      //read the fps from the command
<span style = "background-color:#fdd">      igtl::MessageBase* curCommandPt = curCommand.GetPointer();
      if ( std::strcmp( curCommand-&gt;GetDeviceType(), "STT_BIND" ) == 0 )</span>
      {
<span style = "background-color:#fdd">        fps = ((igtl::StartBindMessage*)curCommandPt)-&gt;GetResolution();
      }
      else if ( std::strcmp( curCommand-&gt;GetDeviceType(), "STT_QTDATA" ) == 0 )</span>
      {
<span style = "background-color:#fdd">        fps = ((igtl::StartQuaternionTrackingDataMessage*)curCommandPt)-&gt;GetResolution();
      }
      else if ( std::strcmp( curCommand-&gt;GetDeviceType(), "STT_TDATA" ) == 0 )</span>
      {
<span style = "background-color:#fdd">        fps = ((igtl::StartTrackingDataMessage*)curCommandPt)-&gt;GetResolution();</span>
      }

<span style = "background-color:#fdd">      this-&gt;StartStreamingOfSource(source, fps);
    }
    else if ( isSTPMsg )</span>
    {
<span style = "background-color:#fdd">      this-&gt;StopStreamingOfSource(source);</span>
    }
    else
    {
      //do nothing
    }
  }
<span style = "background-color:#fdd">}</span>

bool mitk::IGTLMessageProvider::IsStreaming()
<span style = "background-color:#fdd">{
  return m_IsStreaming;
}</span>

void mitk::IGTLMessageProvider::StartStreamingOfSource(IGTLMessageSource* src,
                                                       unsigned int fps)
<span style = "background-color:#fdd">{
  if ( src == nullptr )
    return;</span>

  //so far the provider allows the streaming of a single source only
  //if the streaming thread is already running return a RTS message
<span style = "background-color:#fdd">  if ( !m_IsStreaming )</span>
  {
    //if it is a stream establish a connection between the provider and the
    //source
<span style = "background-color:#fdd">    this-&gt;ConnectTo(src);</span>

    // calculate the streaming time
<span style = "background-color:#fdd">    this-&gt;m_StreamingTimeMutex.lock();
    this-&gt;m_StreamingTime = 1.0 / (double) fps * 1000.0;
    this-&gt;m_StreamingTimeMutex.unlock();</span>

    //// For streaming we need a continues time signal, since there is no timer
    //// available we start a thread that generates a timing signal
    //// This signal is invoked from the other thread the update of the pipeline
    //// has to be executed from the main thread. Thus, we use the
    //// callbackfromGUIThread class to pass the execution to the main thread
    //this-&gt;m_ThreadId = m_MultiThreader-&gt;SpawnThread(this-&gt;TimerThread, this);

<span style = "background-color:#fdd">    mitk::CallbackFromGUIThread::GetInstance()-&gt;CallThisFromGUIThread(</span>
          this-&gt;m_StreamingCommand);

<span style = "background-color:#fdd">    this-&gt;m_IsStreaming = true;
  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_WARN("IGTLMessageProvider") &lt;&lt; "This provider just supports the "</span>
                                        "streaming of one source.";
  }
<span style = "background-color:#fdd">}</span>

void mitk::IGTLMessageProvider::InvokeStartStreamingEvent()
<span style = "background-color:#fdd">{
  this-&gt;InvokeEvent(StreamingStartRequiredEvent());
}</span>

void mitk::IGTLMessageProvider::InvokeStopStreamingEvent()
<span style = "background-color:#fdd">{
  this-&gt;InvokeEvent(StreamingStopRequiredEvent());
}</span>

void mitk::IGTLMessageProvider::StopStreamingOfSource(IGTLMessageSource* src)
<span style = "background-color:#fdd">{</span>
  //this is something bad!!! The streaming thread has to be stopped before the
  //source is disconnected otherwise it can cause a crash. This has to be added!!
<span style = "background-color:#fdd">  this-&gt;DisconnectFrom(src);</span>

<span style = "background-color:#fdd">  mitk::CallbackFromGUIThread::GetInstance()-&gt;CallThisFromGUIThread(</span>
    this-&gt;m_StopStreamingCommand);

  //does this flag needs a mutex???
<span style = "background-color:#fdd">  this-&gt;m_IsStreaming = false;
}</span>

void mitk::IGTLMessageProvider::StopStreamingOfAllSources()
<span style = "background-color:#fdd">{</span>
  // \todo remove all inputs

<span style = "background-color:#fdd">  mitk::CallbackFromGUIThread::GetInstance()-&gt;CallThisFromGUIThread(</span>
    this-&gt;m_StopStreamingCommand);

  //does this flag needs a mutex???
<span style = "background-color:#fdd">  this-&gt;m_IsStreaming = false;
}</span>

mitk::IGTLMessageSource::Pointer mitk::IGTLMessageProvider::GetFittingSource(const char* requestedType)
<span style = "background-color:#fdd">{</span>
  //get the context
<span style = "background-color:#fdd">  us::ModuleContext* context = us::GetModuleContext();</span>
  //define the interface name
<span style = "background-color:#fdd">  std::string interface = mitk::IGTLMessageSource::US_INTERFACE_NAME;</span>
  //specify a filter that defines the requested type
<span style = "background-color:#fdd">  std::string filter = "(" + mitk::IGTLMessageSource::US_PROPKEY_DEVICETYPE +</span>
      "=" + requestedType + ")";
  //find the fitting service
<span style = "background-color:#fdd">  std::vector&lt;us::ServiceReferenceU&gt; serviceReferences =</span>
      context-&gt;GetServiceReferences(interface, filter);

  //check if a service reference was found. It is also possible that several
  //services were found. This is not checked here, just the first one is taken.
<span style = "background-color:#fdd">  if ( serviceReferences.size() )</span>
  {
<span style = "background-color:#fdd">    mitk::IGTLMessageSource::Pointer curSource =</span>
        context-&gt;GetService&lt;mitk::IGTLMessageSource&gt;(serviceReferences.front());

<span style = "background-color:#fdd">    if ( curSource.IsNotNull() )
      return curSource;
  }</span>
  //no service reference was found or found service reference has no valid source
<span style = "background-color:#fdd">  return nullptr;
}</span>

void mitk::IGTLMessageProvider::Send(mitk::IGTLMessage::Pointer msg)
<span style = "background-color:#fdd">{
  if (msg != nullptr)</span>
  {
<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "Sending OpenIGTLink Message: " &lt;&lt; msg-&gt;ToString();
    this-&gt;m_IGTLDevice-&gt;SendMessage(msg);</span>
  }
<span style = "background-color:#fdd">}</span>

void
mitk::IGTLMessageProvider::ConnectTo( mitk::IGTLMessageSource* UpstreamFilter )
<span style = "background-color:#fdd">{
  for (DataObjectPointerArraySizeType i = 0;
       i &lt; UpstreamFilter-&gt;GetNumberOfOutputs(); i++)</span>
  {
<span style = "background-color:#fdd">    this-&gt;SetInput(i, UpstreamFilter-&gt;GetOutput(i));
  }
}</span>

void
mitk::IGTLMessageProvider::DisconnectFrom( mitk::IGTLMessageSource* UpstreamFilter )
<span style = "background-color:#fdd">{
  if (UpstreamFilter == nullptr)
    return;</span>

<span style = "background-color:#fdd">  for (DataObjectPointerArraySizeType i = 0; i &lt; UpstreamFilter-&gt;GetNumberOfOutputs(); ++i)</span>
  {
<span style = "background-color:#fdd">    auto input = UpstreamFilter-&gt;GetOutput(i);</span>

<span style = "background-color:#fdd">    if (input == nullptr)
      continue;</span>

<span style = "background-color:#fdd">    auto nb = this-&gt;GetNumberOfIndexedInputs();</span>

<span style = "background-color:#fdd">    for (DataObjectPointerArraySizeType i = 0; i &lt; nb; ++i)</span>
    {
<span style = "background-color:#fdd">      if (this-&gt;GetInput(i) == input)</span>
      {
<span style = "background-color:#fdd">        this-&gt;RemoveInput(i);
        break;</span>
      }
<span style = "background-color:#fdd">    }
  }
}</span></pre>
	</body>
</html>