<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>itkStitchImageFilter.tpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef itkStitchImageFilter_hxx
#define itkStitchImageFilter_hxx

#include "itkStitchImageFilter.h"
#include "itkObjectFactory.h"
#include "itkIdentityTransform.h"
#include "itkProgressReporter.h"
#include "itkImageRegionIteratorWithIndex.h"
#include "itkImageScanlineIterator.h"
#include "itkSpecialCoordinatesImage.h"
#include "itkDefaultConvertPixelTraits.h"
#include "itkSimpleDataObjectDecorator.h"

#include &lt;numeric&gt;

namespace itk
{

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::StitchImageFilter() :
<span style = "background-color:#fdd">  m_OutputSpacing( 1.0 ),
  m_OutputOrigin( 0.0 ),
  m_UseReferenceImage( false ),
  m_StitchStrategy(StitchStrategy::Mean)
{
  this-&gt;DynamicMultiThreadingOff();</span>

<span style = "background-color:#fdd">  m_Size.Fill( 0 );
  m_OutputStartIndex.Fill( 0 );</span>

<span style = "background-color:#fdd">  m_OutputDirection.SetIdentity();</span>

  // Pipeline input configuration

  // implicit input index set:
  // #1 "ReferenceImage" optional
<span style = "background-color:#fdd">  Self::AddOptionalInputName("ReferenceImage");</span>

<span style = "background-color:#fdd">  m_DefaultPixelValue</span>
    = NumericTraits&lt;PixelType&gt;::ZeroValue( m_DefaultPixelValue );
<span style = "background-color:#fdd">}</span>

template&lt; typename TInputImage,
  typename TOutputImage,
  typename TInterpolatorPrecisionType,
  typename TTransformPrecisionType &gt;
  void
  StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
  ::SetInput(const InputImageType* image)
<span style = "background-color:#fdd">{
  this-&gt;SetInput(0, image, itk::IdentityTransform&lt; TTransformPrecisionType, ImageDimension&gt;::New().GetPointer(), LinearInterpolatorType::New().GetPointer());
}</span>

template&lt; typename TInputImage,
  typename TOutputImage,
  typename TInterpolatorPrecisionType,
  typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::SetInput(unsigned int index, const InputImageType* image)
<span style = "background-color:#fdd">{
  this-&gt;SetInput(index, image, itk::IdentityTransform&lt; TTransformPrecisionType, ImageDimension&gt;::New().GetPointer(), LinearInterpolatorType::New().GetPointer());
}</span>

template&lt; typename TInputImage,
  typename TOutputImage,
  typename TInterpolatorPrecisionType,
  typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::SetInput(unsigned int index, const InputImageType* image, const TransformType* transform)
<span style = "background-color:#fdd">{
  this-&gt;SetInput(index, image, transform, LinearInterpolatorType::New().GetPointer());
}</span>

template&lt; typename TInputImage,
  typename TOutputImage,
  typename TInterpolatorPrecisionType,
  typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::SetInput(unsigned int index, const InputImageType* image, const TransformType* transform, InterpolatorType* interpolator)
<span style = "background-color:#fdd">{
  Superclass::SetInput(index, image);
  m_Interpolators[image] = interpolator;</span>

<span style = "background-color:#fdd">  this-&gt;SetTransform(index, transform);
}</span>

template&lt; typename TInputImage,
  typename TOutputImage,
  typename TInterpolatorPrecisionType,
  typename TTransformPrecisionType &gt;
  void
  StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
  ::SetTransform(unsigned int index, const TransformType* transform)
<span style = "background-color:#fdd">{
  const auto transformName = this-&gt;GetTransformInputName(index);</span>
  typedef SimpleDataObjectDecorator&lt; TransformPointerType &gt; DecoratorType;
<span style = "background-color:#fdd">  const DecoratorType* oldInput = itkDynamicCastInDebugMode&lt; const DecoratorType* &gt;(this-&gt;ProcessObject::GetInput(transformName));
  if (!oldInput || oldInput-&gt;Get() != transform)</span>
  {
<span style = "background-color:#fdd">    typename DecoratorType::Pointer newInput = DecoratorType::New();</span>
    // Process object is not const-correct so the const_cast is required here
<span style = "background-color:#fdd">    newInput-&gt;Set(const_cast&lt;TransformType*&gt;(transform));
    this-&gt;ProcessObject::SetInput(transformName, newInput);
  }
}</span>

template&lt; typename TInputImage,
  typename TOutputImage,
  typename TInterpolatorPrecisionType,
  typename TTransformPrecisionType &gt;
  const typename StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;::TransformType*
  StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
  ::GetTransform(unsigned int index) const
<span style = "background-color:#fdd">{</span>
  typedef SimpleDataObjectDecorator&lt; TransformPointerType &gt; DecoratorType;
<span style = "background-color:#fdd">  const DecoratorType* input = itkDynamicCastInDebugMode&lt; const DecoratorType* &gt;(this-&gt;ProcessObject::GetInput(this-&gt;GetTransformInputName(index)));</span>

<span style = "background-color:#fdd">  if (nullptr != input)</span>
  {
<span style = "background-color:#fdd">    return input-&gt;Get();</span>
  }

<span style = "background-color:#fdd">  return nullptr;
}</span>

template&lt; typename TInputImage,
  typename TOutputImage,
  typename TInterpolatorPrecisionType,
  typename TTransformPrecisionType &gt;
  const typename StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;::InterpolatorType*
  StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
  ::GetInterpolator(unsigned int index) const
{
  auto input = this-&gt;GetInput(index);
  if (m_Interpolators.find(input) != std::end(m_Interpolators))
  {
    return m_Interpolators[input];
  }

  return nullptr;
}

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::SetOutputSpacing(const double *spacing)
<span style = "background-color:#fdd">{</span>
  SpacingType s;
<span style = "background-color:#fdd">  for(unsigned int i = 0; i &lt; TOutputImage::ImageDimension; ++i)</span>
    {
<span style = "background-color:#fdd">    s[i] = static_cast&lt; typename SpacingType::ValueType &gt;(spacing[i]);
    }
  this-&gt;SetOutputSpacing(s);
}</span>

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::SetOutputOrigin(const double *origin)
<span style = "background-color:#fdd">{
  OriginPointType p(origin);</span>

<span style = "background-color:#fdd">  this-&gt;SetOutputOrigin(p);
}</span>

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::SetOutputParametersFromImage(const ImageBaseType *image)
{
  this-&gt;SetOutputOrigin ( image-&gt;GetOrigin() );
  this-&gt;SetOutputSpacing ( image-&gt;GetSpacing() );
  this-&gt;SetOutputDirection ( image-&gt;GetDirection() );
  this-&gt;SetOutputStartIndex ( image-&gt;GetLargestPossibleRegion().GetIndex() );
  this-&gt;SetSize ( image-&gt;GetLargestPossibleRegion().GetSize() );
}

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::BeforeThreadedGenerateData()
<span style = "background-color:#fdd">{
  this-&gt;EnsureInterpolators();
  this-&gt;EnsureTransforms();</span>

<span style = "background-color:#fdd">  for (const auto&amp; interpolator : m_Interpolators)</span>
  {
<span style = "background-color:#fdd">    interpolator.second-&gt;SetInputImage(interpolator.first);
  }</span>

  unsigned int nComponents
<span style = "background-color:#fdd">    = DefaultConvertPixelTraits&lt;PixelType&gt;::GetNumberOfComponents(</span>
        m_DefaultPixelValue );

<span style = "background-color:#fdd">  if (nComponents == 0)</span>
    {
    PixelComponentType zeroComponent
<span style = "background-color:#fdd">      = NumericTraits&lt;PixelComponentType&gt;::ZeroValue();
    nComponents = this-&gt;GetInput()-&gt;GetNumberOfComponentsPerPixel();
    NumericTraits&lt;PixelType&gt;::SetLength(m_DefaultPixelValue, nComponents );
    for (unsigned int n=0; n&lt;nComponents; n++)</span>
      {
<span style = "background-color:#fdd">      PixelConvertType::SetNthComponent( n, m_DefaultPixelValue,</span>
                                         zeroComponent );
<span style = "background-color:#fdd">      }</span>
    }
<span style = "background-color:#fdd">}</span>

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::AfterThreadedGenerateData()
<span style = "background-color:#fdd">{</span>
  // Disconnect input image from the interpolator
<span style = "background-color:#fdd">  for (auto&amp; interpolator : m_Interpolators)</span>
  {
<span style = "background-color:#fdd">    interpolator.second-&gt;SetInputImage(ITK_NULLPTR);
  }
}</span>

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::ThreadedGenerateData(const OutputImageRegionType &amp; outputRegionForThread,
                       ThreadIdType threadId)
<span style = "background-color:#fdd">{</span>

<span style = "background-color:#fdd">  if( outputRegionForThread.GetNumberOfPixels() == 0 )</span>
    {
<span style = "background-color:#fdd">    return;</span>
    }

  // Get the output pointers
<span style = "background-color:#fdd">  OutputImageType* outputPtr = this-&gt;GetOutput();</span>
  // Get this input pointers
<span style = "background-color:#fdd">  InputImageVectorType inputs = this-&gt;GetInputs();
  TransformMapType transforms = this-&gt;GetTransforms();</span>

<span style = "background-color:#fdd">  std::map&lt;const InputImageType*, typename InputImageType::IndexType&gt; lowerIndices;
  std::map&lt;const InputImageType*, typename InputImageType::IndexType&gt; upperIndices;
  for (const auto&amp; input : inputs)</span>
  {
<span style = "background-color:#fdd">    const auto largestRegion = input-&gt;GetLargestPossibleRegion();
    lowerIndices[input] = largestRegion.GetIndex();
    upperIndices[input] = largestRegion.GetUpperIndex();
  }</span>

  // Create an iterator that will walk the output region for this thread.
  typedef ImageRegionIteratorWithIndex&lt; OutputImageType &gt; OutputIterator;
<span style = "background-color:#fdd">  OutputIterator outIt(outputPtr, outputRegionForThread);</span>

  // Define a few indices that will be used to translate from an input pixel
  // to an output pixel
  PointType outputPoint;         // Coordinates of current output pixel
  PointType inputPoint;          // Coordinates of current input pixel

  ContinuousInputIndexType inputIndex;

  // Support for progress methods/callbacks
<span style = "background-color:#fdd">  ProgressReporter progress(this,</span>
    threadId,
    outputRegionForThread.GetNumberOfPixels());

  // Min/max values of the output pixel type AND these values
  // represented as the output type of the interpolator
<span style = "background-color:#fdd">  const PixelComponentType minValue = NumericTraits&lt; PixelComponentType &gt;::NonpositiveMin();
  const PixelComponentType maxValue = NumericTraits&lt; PixelComponentType &gt;::max();</span>

  typedef typename InterpolatorType::OutputType OutputType;
<span style = "background-color:#fdd">  const ComponentType minOutputValue = static_cast&lt;ComponentType&gt;(minValue);
  const ComponentType maxOutputValue = static_cast&lt;ComponentType&gt;(maxValue);</span>

  // Walk the output region
<span style = "background-color:#fdd">  outIt.GoToBegin();</span>

<span style = "background-color:#fdd">  while (!outIt.IsAtEnd())</span>
  {
    // Determine the index of the current output pixel
<span style = "background-color:#fdd">    outputPtr-&gt;TransformIndexToPhysicalPoint(outIt.GetIndex(), outputPoint);</span>

<span style = "background-color:#fdd">    std::vector&lt;PixelType&gt; pixvals;
    std::vector&lt;double&gt; pixDistance;</span>

<span style = "background-color:#fdd">    for (const auto&amp; input : inputs)</span>
    {
      // Compute corresponding input pixel position
<span style = "background-color:#fdd">      inputPoint = transforms[input]-&gt;TransformPoint(outputPoint);
      const bool isInsideInput = input-&gt;TransformPhysicalPointToContinuousIndex(inputPoint, inputIndex);</span>

      // Evaluate input at right position and copy to the output
<span style = "background-color:#fdd">      if (m_Interpolators[input]-&gt;IsInsideBuffer(inputIndex) &amp;&amp; isInsideInput)</span>
      {
<span style = "background-color:#fdd">        OutputType value = m_Interpolators[input]-&gt;EvaluateAtContinuousIndex(inputIndex);
        pixvals.emplace_back(this-&gt;CastPixelWithBoundsChecking(value, minOutputValue, maxOutputValue));</span>

<span style = "background-color:#fdd">        const auto spacing = input-&gt;GetSpacing();</span>

<span style = "background-color:#fdd">        double minBorderDistance = std::numeric_limits&lt;double&gt;::max();
        for (unsigned int i = 0; i &lt; ImageDimension; ++i)</span>
        {
<span style = "background-color:#fdd">          minBorderDistance = std::min(minBorderDistance, std::min(std::abs(lowerIndices[input][i] - inputIndex[i]) * spacing[i], std::abs(upperIndices[input][i] - inputIndex[i]) * spacing[i]));
        }
        pixDistance.emplace_back(minBorderDistance);</span>
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    if (!pixvals.empty())</span>
    { //at least one input provided a value
<span style = "background-color:#fdd">      if (StitchStrategy::Mean == m_StitchStrategy)</span>
      {
<span style = "background-color:#fdd">        double sum = std::accumulate(pixvals.begin(), pixvals.end(), 0.0);
        outIt.Set(sum / pixvals.size());
      }</span>
      else
      {
<span style = "background-color:#fdd">        auto finding = std::max_element(pixDistance.begin(), pixDistance.end());
        outIt.Set(pixvals[std::distance(pixDistance.begin(), finding)]);
      }
    }</span>
    else
    {
<span style = "background-color:#fdd">      outIt.Set(m_DefaultPixelValue); // default background value</span>
    }

<span style = "background-color:#fdd">    progress.CompletedPixel();
    ++outIt;
  }
}</span>

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
typename StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::PixelType
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::CastPixelWithBoundsChecking(const InterpolatorOutputType value,
                              const ComponentType minComponent,
                              const ComponentType maxComponent ) const
<span style = "background-color:#fdd">{
  const unsigned int nComponents = InterpolatorConvertType::GetNumberOfComponents(value);</span>
  PixelType          outputValue;

<span style = "background-color:#fdd">  NumericTraits&lt;PixelType&gt;::SetLength( outputValue, nComponents );</span>

<span style = "background-color:#fdd">  for (unsigned int n = 0; n &lt; nComponents; n++)</span>
    {
<span style = "background-color:#fdd">    ComponentType component = InterpolatorConvertType::GetNthComponent( n, value );</span>

<span style = "background-color:#fdd">    if ( component &lt; minComponent )</span>
      {
<span style = "background-color:#fdd">      PixelConvertType::SetNthComponent( n, outputValue, static_cast&lt;PixelComponentType&gt;( minComponent ) );
      }
    else if ( component &gt; maxComponent )</span>
      {
<span style = "background-color:#fdd">      PixelConvertType::SetNthComponent( n, outputValue, static_cast&lt;PixelComponentType&gt;( maxComponent ) );
      }</span>
    else
      {
<span style = "background-color:#fdd">      PixelConvertType::SetNthComponent(n, outputValue,</span>
                                        static_cast&lt;PixelComponentType&gt;( component ) );
      }
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">  return outputValue;
}</span>

template&lt;typename TInputImage, typename TOutputImage, typename TInterpolatorPrecisionType, typename TTransformPrecisionType&gt;
typename StitchImageFilter&lt;TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType&gt;::InputImageVectorType
StitchImageFilter&lt;TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType&gt;
::GetInputs()
<span style = "background-color:#fdd">{
  InputImageVectorType inputs;
  for (unsigned int i = 0; i &lt; this-&gt;GetNumberOfIndexedInputs(); ++i)</span>
  {
<span style = "background-color:#fdd">    auto input = this-&gt;GetInput(i);
    if (nullptr != input)</span>
    {
<span style = "background-color:#fdd">      inputs.push_back(input);</span>
    }
<span style = "background-color:#fdd">  }
  return inputs;
}</span>

template&lt;typename TInputImage, typename TOutputImage, typename TInterpolatorPrecisionType, typename TTransformPrecisionType&gt;
typename StitchImageFilter&lt;TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType&gt;::TransformMapType
StitchImageFilter&lt;TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType&gt;
::GetTransforms()
<span style = "background-color:#fdd">{
  TransformMapType transforms;
  for (unsigned int i = 0; i &lt; this-&gt;GetNumberOfIndexedInputs(); ++i)</span>
  {
<span style = "background-color:#fdd">    auto input = this-&gt;GetInput(i);
    auto transform = this-&gt;GetTransform(i);
    transforms[input] = transform;
  }
  return transforms;
}</span>

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::GenerateInputRequestedRegion()
<span style = "background-color:#fdd">{</span>
  // Call the superclass' implementation of this method
<span style = "background-color:#fdd">  Superclass::GenerateInputRequestedRegion();</span>

<span style = "background-color:#fdd">  if ( !this-&gt;GetInput() )</span>
    {
<span style = "background-color:#fdd">    return;</span>
    }

  // Get pointers to the input
<span style = "background-color:#fdd">  auto inputs = this-&gt;GetInputs();</span>

<span style = "background-color:#fdd">  for (auto&amp; input : inputs)</span>
  {
<span style = "background-color:#fdd">    InputImagePointer inputPtr =</span>
      const_cast&lt;TInputImage*&gt;(input);
    // Determining the actual input region is non-trivial, especially
    // when we cannot assume anything about the transform being used.
    // So we do the easy thing and request the entire input image.
    //
<span style = "background-color:#fdd">    inputPtr-&gt;SetRequestedRegionToLargestPossibleRegion();
  }
}</span>

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::GenerateOutputInformation()
<span style = "background-color:#fdd">{</span>
  // Call the superclass' implementation of this method
<span style = "background-color:#fdd">  Superclass::GenerateOutputInformation();</span>

  // Get pointers to the input and output
<span style = "background-color:#fdd">  OutputImageType *outputPtr = this-&gt;GetOutput();
  if ( !outputPtr )</span>
    {
<span style = "background-color:#fdd">    return;</span>
    }

<span style = "background-color:#fdd">  const ReferenceImageBaseType *referenceImage = this-&gt;GetReferenceImage();</span>

  // Set the size of the output region
<span style = "background-color:#fdd">  if ( m_UseReferenceImage &amp;&amp; referenceImage )</span>
    {
<span style = "background-color:#fdd">    outputPtr-&gt;SetLargestPossibleRegion(</span>
      referenceImage-&gt;GetLargestPossibleRegion() );
<span style = "background-color:#fdd">    }</span>
  else
    {
<span style = "background-color:#fdd">    typename TOutputImage::RegionType outputLargestPossibleRegion;
    outputLargestPossibleRegion.SetSize(m_Size);
    outputLargestPossibleRegion.SetIndex(m_OutputStartIndex);
    outputPtr-&gt;SetLargestPossibleRegion(outputLargestPossibleRegion);
    }</span>

  // Set spacing and origin
<span style = "background-color:#fdd">  if ( m_UseReferenceImage &amp;&amp; referenceImage )</span>
    {
<span style = "background-color:#fdd">    outputPtr-&gt;SetSpacing( referenceImage-&gt;GetSpacing() );
    outputPtr-&gt;SetOrigin( referenceImage-&gt;GetOrigin() );
    outputPtr-&gt;SetDirection( referenceImage-&gt;GetDirection() );
    }</span>
  else
    {
<span style = "background-color:#fdd">    outputPtr-&gt;SetSpacing(m_OutputSpacing);
    outputPtr-&gt;SetOrigin(m_OutputOrigin);
    outputPtr-&gt;SetDirection(m_OutputDirection);</span>
    }
<span style = "background-color:#fdd">}</span>

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
ModifiedTimeType
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::GetMTime(void) const
<span style = "background-color:#fdd">{
  ModifiedTimeType latestTime = Object::GetMTime();</span>

<span style = "background-color:#fdd">  for (const auto&amp; interpolator : m_Interpolators)</span>
  {
<span style = "background-color:#fdd">    if (interpolator.second.GetPointer())</span>
    {
<span style = "background-color:#fdd">      if (latestTime &lt; interpolator.second-&gt;GetMTime())</span>
      {
<span style = "background-color:#fdd">        latestTime = interpolator.second-&gt;GetMTime();</span>
      }
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return latestTime;
}</span>

template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType,
          typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::PrintSelf(std::ostream &amp; os, Indent indent) const
<span style = "background-color:#fdd">{
  Superclass::PrintSelf(os, indent);</span>

<span style = "background-color:#fdd">  os &lt;&lt; indent &lt;&lt; "DefaultPixelValue: "</span>
     &lt;&lt; static_cast&lt; typename NumericTraits&lt; PixelType &gt;::PrintType &gt;
  ( m_DefaultPixelValue )
     &lt;&lt; std::endl;
<span style = "background-color:#fdd">  os &lt;&lt; indent &lt;&lt; "Size: " &lt;&lt; m_Size &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; "OutputStartIndex: " &lt;&lt; m_OutputStartIndex &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; "OutputSpacing: " &lt;&lt; m_OutputSpacing &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; "OutputOrigin: " &lt;&lt; m_OutputOrigin &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; "OutputDirection: " &lt;&lt; m_OutputDirection &lt;&lt; std::endl;
  for (const auto&amp; interpolator : m_Interpolators)</span>
  {
<span style = "background-color:#fdd">    os &lt;&lt; indent &lt;&lt; "Interpolator: " &lt;&lt; interpolator.second.GetPointer() &lt;&lt; std::endl;
  }
  os &lt;&lt; indent &lt;&lt; "UseReferenceImage: " &lt;&lt; ( m_UseReferenceImage ? "On" : "Off" )</span>
     &lt;&lt; std::endl;
<span style = "background-color:#fdd">}</span>

template&lt; typename TInputImage,
  typename TOutputImage,
  typename TInterpolatorPrecisionType,
  typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::EnsureTransforms()
<span style = "background-color:#fdd">{
  const auto inputCount = this-&gt;GetNumberOfIndexedInputs();
  for (unsigned int i = 0; i &lt; inputCount; ++i)</span>
  {
<span style = "background-color:#fdd">    auto input = this-&gt;GetInput(i);</span>

<span style = "background-color:#fdd">    if (nullptr == input)</span>
    {
<span style = "background-color:#fdd">      itkExceptionMacro(&lt;&lt; "Nth input image is not set (n: " &lt;&lt; i &lt;&lt; ").");</span>
    }

<span style = "background-color:#fdd">    auto transform = this-&gt;GetTransform(i);
    if (nullptr == transform)</span>
    {
<span style = "background-color:#fdd">      this-&gt;SetTransform(i, itk::IdentityTransform&lt; TTransformPrecisionType, ImageDimension&gt;::New().GetPointer());</span>
    }
<span style = "background-color:#fdd">  }
}</span>

template&lt; typename TInputImage,
  typename TOutputImage,
  typename TInterpolatorPrecisionType,
  typename TTransformPrecisionType &gt;
void
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::EnsureInterpolators()
<span style = "background-color:#fdd">{
  const auto inputCount = this-&gt;GetNumberOfIndexedInputs();
  InterpolatorMapType newInterpolatorMap;</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; inputCount; ++i)</span>
  {
<span style = "background-color:#fdd">    auto input = this-&gt;GetInput(i);</span>

<span style = "background-color:#fdd">    if (nullptr == input)</span>
    {
<span style = "background-color:#fdd">      itkExceptionMacro(&lt;&lt; "Nth input image is not set (n: " &lt;&lt; i &lt;&lt; ").");</span>
    }

<span style = "background-color:#fdd">    if (m_Interpolators[input].IsNull())</span>
    {
<span style = "background-color:#fdd">      newInterpolatorMap[input] = LinearInterpolatorType::New().GetPointer();
    }</span>
    else
    {
<span style = "background-color:#fdd">      newInterpolatorMap[input] = m_Interpolators[input];</span>
    }
<span style = "background-color:#fdd">  }
  m_Interpolators = newInterpolatorMap;
}</span>

template&lt; typename TInputImage,
  typename TOutputImage,
  typename TInterpolatorPrecisionType,
  typename TTransformPrecisionType &gt;
std::string
StitchImageFilter&lt; TInputImage, TOutputImage, TInterpolatorPrecisionType, TTransformPrecisionType &gt;
::GetTransformInputName(unsigned int index)
<span style = "background-color:#fdd">{
  return "transform_" + std::to_string(index);
}</span>

} // end namespace itk

#endif</pre>
	</body>
</html>