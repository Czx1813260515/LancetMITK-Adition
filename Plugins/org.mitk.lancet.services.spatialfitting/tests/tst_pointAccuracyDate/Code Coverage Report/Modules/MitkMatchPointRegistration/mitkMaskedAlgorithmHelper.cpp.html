<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkMaskedAlgorithmHelper.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkMaskedAlgorithmHelper.h"

#include &lt;itkImageMaskSpatialObject.h&gt;

// Mitk
#include &lt;mitkImageAccessByItk.h&gt;

// MatchPoint
#include "mapMaskedRegistrationAlgorithmInterface.h"
#include &lt;mapRegistrationAlgorithmInterface.h&gt;

namespace mitk
{

<span style = "background-color:#fdd">  MaskedAlgorithmHelper::MaskedAlgorithmHelper(map::algorithm::RegistrationAlgorithmBase* algorithm) : m_AlgorithmBase(algorithm)
  {
  }</span>

  bool MaskedAlgorithmHelper::HasMaskedRegistrationAlgorithmInterface(const map::algorithm::RegistrationAlgorithmBase* algorithm)
<span style = "background-color:#fdd">  {</span>
    using MaskedInterface2D = const ::map::algorithm::facet::MaskedRegistrationAlgorithmInterface&lt;2, 2&gt;;
    using MaskedInterface3D = const ::map::algorithm::facet::MaskedRegistrationAlgorithmInterface&lt;3, 3&gt;;

<span style = "background-color:#fdd">    return dynamic_cast&lt;MaskedInterface2D*&gt;(algorithm) != nullptr &amp;&amp; dynamic_cast&lt;MaskedInterface3D*&gt;(algorithm) != nullptr;
  };</span>

  bool
    MaskedAlgorithmHelper::
    CheckSupport(const mitk::Image* movingMask, const mitk::Image* targetMask) const
<span style = "background-color:#fdd">  {
    if (! m_AlgorithmBase) mapDefaultExceptionStaticMacro(&lt;&lt; "Error, cannot check data. Helper has no algorithm defined.");</span>

<span style = "background-color:#fdd">    unsigned int movingDim = m_AlgorithmBase-&gt;getMovingDimensions();
    unsigned int targetDim = m_AlgorithmBase-&gt;getTargetDimensions();</span>

<span style = "background-color:#fdd">    bool result = movingDim == targetDim;</span>

<span style = "background-color:#fdd">    if ( movingMask)</span>
    {
<span style = "background-color:#fdd">      result = result &amp;&amp; (movingMask-&gt;GetDimension() == movingDim);</span>
    }

<span style = "background-color:#fdd">    if ( targetMask)</span>
    {
<span style = "background-color:#fdd">      result = result &amp;&amp; (targetMask-&gt;GetDimension() == targetDim);</span>
    }

<span style = "background-color:#fdd">    if (movingDim == 2)</span>
    {
      typedef ::map::algorithm::facet::MaskedRegistrationAlgorithmInterface&lt;2, 2&gt; MaskedInterface;
<span style = "background-color:#fdd">      const MaskedInterface* pMaskedReg = dynamic_cast&lt;const MaskedInterface*&gt;(m_AlgorithmBase.GetPointer());</span>

<span style = "background-color:#fdd">      result = result &amp;&amp; pMaskedReg;
    }
    else if (movingDim == 3)</span>
    {
      typedef ::map::algorithm::facet::MaskedRegistrationAlgorithmInterface&lt;3, 3&gt; MaskedInterface;
<span style = "background-color:#fdd">      const MaskedInterface* pMaskedReg = dynamic_cast&lt;const MaskedInterface*&gt;(m_AlgorithmBase.GetPointer());</span>

<span style = "background-color:#fdd">      result = result &amp;&amp; pMaskedReg;
    }</span>
    else
    {
<span style = "background-color:#fdd">      result = false;</span>
    }

<span style = "background-color:#fdd">    return result;
  };</span>

  bool MaskedAlgorithmHelper::SetMasks(const mitk::Image* movingMask, const mitk::Image* targetMask)
<span style = "background-color:#fdd">  {
    if (! m_AlgorithmBase) mapDefaultExceptionStaticMacro(&lt;&lt; "Error, cannot set data. Helper has no algorithm defined.");</span>

<span style = "background-color:#fdd">    if (! CheckSupport(movingMask, targetMask)) return false;</span>

<span style = "background-color:#fdd">    unsigned int movingDim = m_AlgorithmBase-&gt;getMovingDimensions();
    unsigned int targetDim = m_AlgorithmBase-&gt;getTargetDimensions();</span>

<span style = "background-color:#fdd">    if (movingDim!=targetDim) return false;</span>

<span style = "background-color:#fdd">    if (movingDim == 2)</span>
    {
<span style = "background-color:#fdd">      return DoSetMasks&lt;2,2&gt;(movingMask, targetMask);
    }
    else if (movingDim == 3)</span>
    {
<span style = "background-color:#fdd">      return DoSetMasks&lt;3,3&gt;(movingMask, targetMask);</span>
    }
<span style = "background-color:#fdd">    return false;
  };</span>

  template&lt;unsigned int VMovingDimension, unsigned int VTargetDimension&gt;
  bool MaskedAlgorithmHelper::DoSetMasks(const mitk::Image* movingMask, const mitk::Image* targetMask)
<span style = "background-color:#fdd">  {</span>
    typedef itk::SpatialObject&lt;VMovingDimension&gt; MovingSpatialType;
    typedef itk::SpatialObject&lt;VTargetDimension&gt; TargetSpatialType;

    typedef ::map::algorithm::facet::MaskedRegistrationAlgorithmInterface&lt;VMovingDimension, VTargetDimension&gt; MaskedRegInterface;
<span style = "background-color:#fdd">    MaskedRegInterface* pAlg = dynamic_cast&lt;MaskedRegInterface*&gt;(m_AlgorithmBase.GetPointer());</span>

<span style = "background-color:#fdd">    if (!pAlg) return false;</span>

<span style = "background-color:#fdd">    if (movingMask)</span>
    {
<span style = "background-color:#fdd">      AccessFixedDimensionByItk(movingMask, DoConvertMask, VMovingDimension);
      typename MovingSpatialType::Pointer movingSpatial = dynamic_cast&lt;MovingSpatialType*&gt;(m_convertResult.GetPointer());
      if (!movingSpatial) mapDefaultExceptionStaticMacro(&lt;&lt; "Error, cannot convert moving mask.");
      pAlg-&gt;setMovingMask(movingSpatial);
    }</span>
    else
    {
<span style = "background-color:#fdd">      pAlg-&gt;setMovingMask(nullptr);</span>
    }

<span style = "background-color:#fdd">    if (targetMask)</span>
    {
<span style = "background-color:#fdd">      AccessFixedDimensionByItk(targetMask, DoConvertMask, VTargetDimension);
      typename TargetSpatialType::Pointer targetSpatial = dynamic_cast&lt;TargetSpatialType*&gt;(m_convertResult.GetPointer());
      if (! targetSpatial) mapDefaultExceptionStaticMacro(&lt;&lt; "Error, cannot convert moving mask.");
      pAlg-&gt;setTargetMask(targetSpatial);
    }</span>
    else
    {
<span style = "background-color:#fdd">      pAlg-&gt;setTargetMask(nullptr);</span>
    }

<span style = "background-color:#fdd">    return true;
  }</span>

  template&lt;unsigned int VImageDimension&gt;
  typename itk::SpatialObject&lt;VImageDimension&gt;::Pointer
    MaskedAlgorithmHelper::ConvertMaskSO(const itk::Image&lt;MaskPixelType, VImageDimension&gt;* mask) const
<span style = "background-color:#fdd">  {</span>
    typedef itk::ImageMaskSpatialObject&lt;VImageDimension&gt; SpatialType;

<span style = "background-color:#fdd">    typename SpatialType::Pointer spatial = SpatialType::New();
    spatial-&gt;SetImage(mask);</span>

<span style = "background-color:#fdd">    return spatial.GetPointer();
  }</span>

  template&lt;typename TPixelType, unsigned int VImageDimension&gt;
  void MaskedAlgorithmHelper::DoConvertMask(const itk::Image&lt;TPixelType,VImageDimension&gt;* mask)
<span style = "background-color:#fdd">  {</span>
    using InImageType = itk::Image&lt;TPixelType, VImageDimension&gt;;
    using MaskImageType = itk::Image&lt;MaskPixelType, VImageDimension&gt;;

    typedef itk::CastImageFilter&lt; InImageType, MaskImageType &gt; CastFilterType;
<span style = "background-color:#fdd">    typename CastFilterType::Pointer  imageCaster = CastFilterType::New();</span>

<span style = "background-color:#fdd">    imageCaster-&gt;SetInput(mask);</span>

<span style = "background-color:#fdd">    auto castedMask = imageCaster-&gt;GetOutput();
    imageCaster-&gt;Update();
    m_convertResult = ConvertMaskSO&lt;VImageDimension&gt;(castedMask);
  }</span>

  template&lt;unsigned int VImageDimension&gt;
  void MaskedAlgorithmHelper::DoConvertMask(const itk::Image&lt;MaskPixelType, VImageDimension&gt;* mask)
<span style = "background-color:#fdd">  {
    m_convertResult = ConvertMaskSO&lt;VImageDimension&gt;(mask);
  }</span>
}</pre>
	</body>
</html>