<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>itkStitchImageFilter.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef itkStitchImageFilter_h
#define itkStitchImageFilter_h

#include "itkFixedArray.h"
#include "itkTransform.h"
#include "itkImageRegionIterator.h"
#include "itkImageToImageFilter.h"
#include "itkLinearInterpolateImageFunction.h"
#include "itkSize.h"
#include "itkDefaultConvertPixelTraits.h"
#include "itkDataObjectDecorator.h"


namespace itk
{
  enum class StitchStrategy
  {
    Mean = 0, //use the mean value of all inputs that can provide a pixel vaule
    BorderDistance = 1 //use the value that is largest minimal distance to its image borders (use e.g. if vaules tend to be not reliable at borders)
  };

  std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, const itk::StitchStrategy&amp; strategy)
<span style = "background-color:#fdd">  {
    if (itk::StitchStrategy::Mean == strategy)
      os &lt;&lt; "Mean";
    else if (itk::StitchStrategy::BorderDistance == strategy)
      os &lt;&lt; "BorderDistance";</span>
    else
<span style = "background-color:#fdd">      os &lt;&lt; "unkown";</span>

<span style = "background-color:#fdd">    return os;
  };</span>

  /** \class StitchImageFilter
 * \brief ITK filter that resamples/stitches multiple images into a given reference geometry.
 *
 * StitchImageFilter is similar to itk's ResampleImageFilter, but in difference to the last
 * mentioned StitchImageFilter is able to resample multiple input images at once (with a transform
 * for each input image). If multiple input images cover the output region the behavior depends on
 * the StitchStragy:
 * - Mean: a weighted sum of all voxels mapped input pixel values will be calculated.
 * - BorderDistance: the voxels will be choosen that have the largest minimal distance to its own image borders.
 *
 * All other behaviors are similar to itk::ResampleImageFilter. See the filter's description for
 * more details.
 */
template&lt; typename TInputImage,
          typename TOutputImage,
          typename TInterpolatorPrecisionType = double,
          typename TTransformPrecisionType = TInterpolatorPrecisionType&gt;
class StitchImageFilter :
  public ImageToImageFilter&lt; TInputImage, TOutputImage &gt;
{
public:
  /** Standard class typedefs. */
  typedef StitchImageFilter                             Self;
  typedef ImageToImageFilter&lt; TInputImage, TOutputImage &gt; Superclass;
  typedef SmartPointer&lt; Self &gt;                            Pointer;
  typedef SmartPointer&lt; const Self &gt;                      ConstPointer;

  typedef TInputImage                           InputImageType;
  typedef TOutputImage                          OutputImageType;
  typedef typename InputImageType::Pointer      InputImagePointer;
  typedef typename InputImageType::ConstPointer InputImageConstPointer;
  typedef typename OutputImageType::Pointer     OutputImagePointer;
  typedef typename InputImageType::RegionType   InputImageRegionType;

  /** Method for creation through the object factory. */
<span style = "background-color:#fdd">  itkNewMacro(Self);</span>

  /** Run-time type information (and related methods). */
<span style = "background-color:#fdd">  itkTypeMacro(StitchImageFilter, ImageToImageFilter);</span>

  /** Number of dimensions. */
  itkStaticConstMacro(ImageDimension, unsigned int,
                      TOutputImage::ImageDimension);
  itkStaticConstMacro(InputImageDimension, unsigned int,
                      TInputImage::ImageDimension);

  /** base type for images of the current ImageDimension */
  typedef ImageBase&lt; itkGetStaticConstMacro(ImageDimension) &gt; ImageBaseType;

  /**
   *  Transform typedef.
   */
  typedef Transform&lt; TTransformPrecisionType,
                     itkGetStaticConstMacro(ImageDimension),
                     itkGetStaticConstMacro(ImageDimension) &gt;   TransformType;
  typedef typename TransformType::ConstPointer                  TransformPointerType;
  typedef DataObjectDecorator&lt;TransformType&gt;                    DecoratedTransformType;
  typedef typename DecoratedTransformType::Pointer              DecoratedTransformPointer;


  /** Interpolator typedef. */
  typedef InterpolateImageFunction&lt; InputImageType,
                                    TInterpolatorPrecisionType &gt;     InterpolatorType;
  typedef typename InterpolatorType::Pointer InterpolatorPointerType;

  typedef typename InterpolatorType::OutputType InterpolatorOutputType;

  typedef DefaultConvertPixelTraits&lt; InterpolatorOutputType &gt; InterpolatorConvertType;

  typedef typename InterpolatorConvertType::ComponentType ComponentType;

  typedef LinearInterpolateImageFunction&lt; InputImageType,
                                          TInterpolatorPrecisionType &gt;   LinearInterpolatorType;
  typedef typename LinearInterpolatorType::Pointer
  LinearInterpolatorPointerType;

  /** Image size typedef. */
  typedef Size&lt; itkGetStaticConstMacro(ImageDimension) &gt; SizeType;

  /** Image index typedef. */
  typedef typename TOutputImage::IndexType IndexType;

  /** Image point typedef. */
  typedef typename InterpolatorType::PointType PointType;
  //typedef typename TOutputImage::PointType            PointType;

  /** Image pixel value typedef. */
  typedef typename TOutputImage::PixelType PixelType;
  typedef typename TInputImage::PixelType  InputPixelType;

  typedef DefaultConvertPixelTraits&lt;PixelType&gt; PixelConvertType;

  typedef typename PixelConvertType::ComponentType PixelComponentType;

  /** Input pixel continuous index typdef */
  typedef ContinuousIndex&lt; TTransformPrecisionType, ImageDimension &gt;
  ContinuousInputIndexType;

  /** Typedef to describe the output image region type. */
  typedef typename TOutputImage::RegionType OutputImageRegionType;

  /** Image spacing,origin and direction typedef */
  typedef typename TOutputImage::SpacingType   SpacingType;
  typedef typename TOutputImage::PointType     OriginPointType;
  typedef typename TOutputImage::DirectionType DirectionType;

  using Superclass::GetInput;

  /** Typedef the reference image type to be the ImageBase of the OutputImageType */
  typedef ImageBase&lt;ImageDimension&gt; ReferenceImageBaseType;

  using Superclass::SetInput;
  void SetInput(const InputImageType* image) override;
  void SetInput(unsigned int index, const InputImageType* image) override;
  /** Convinience methods that allows setting of input image and its transform in
   one call.*/
  virtual void SetInput(unsigned int index, const InputImageType* image, const TransformType* transform);
  virtual void SetInput(unsigned int index, const InputImageType* image, const TransformType* transform, InterpolatorType* interpolator);

  const TransformType* GetTransform(unsigned int index) const;

  const InterpolatorType* GetInterpolator(unsigned int index) const;

  /** Get/Set the size of the output image. */
<span style = "background-color:#fdd">  itkSetMacro(Size, SizeType);
  itkGetConstReferenceMacro(Size, SizeType);</span>

  /** Get/Set the pixel value when a transformed pixel is outside of the
   * image.  The default default pixel value is 0. */
<span style = "background-color:#fdd">  itkSetMacro(DefaultPixelValue, PixelType);
  itkGetConstReferenceMacro(DefaultPixelValue, PixelType);</span>

  /** Set the output image spacing. */
<span style = "background-color:#fdd">  itkSetMacro(OutputSpacing, SpacingType);</span>
  virtual void SetOutputSpacing(const double *values);

  /** Get the output image spacing. */
<span style = "background-color:#fdd">  itkGetConstReferenceMacro(OutputSpacing, SpacingType);</span>

  /** Set the output image origin. */
<span style = "background-color:#fdd">  itkSetMacro(OutputOrigin, OriginPointType);</span>
  virtual void SetOutputOrigin(const double *values);

  /** Get the output image origin. */
<span style = "background-color:#fdd">  itkGetConstReferenceMacro(OutputOrigin, OriginPointType);</span>

  /** Set the output direciton cosine matrix. */
<span style = "background-color:#fdd">  itkSetMacro(OutputDirection, DirectionType);
  itkGetConstReferenceMacro(OutputDirection, DirectionType);</span>

  /** Helper method to set the output parameters based on this image. */
  void SetOutputParametersFromImage(const ImageBaseType *image);

  /** Set the start index of the output largest possible region.
   * The default is an index of all zeros. */
<span style = "background-color:#fdd">  itkSetMacro(OutputStartIndex, IndexType);</span>

  /** Get the start index of the output largest possible region. */
<span style = "background-color:#fdd">  itkGetConstReferenceMacro(OutputStartIndex, IndexType);</span>

   /** Set a reference image to use to define the output information.
    *  By default, output information is specificed through the
    *  SetOutputSpacing, Origin, and Direction methods.  Alternatively,
    *  this method can be used to specify an image from which to
    *  copy the information. UseReferenceImageOn must be set to utilize the
    *  reference image. */
<span style = "background-color:#fdd">  itkSetInputMacro(ReferenceImage, ReferenceImageBaseType);</span>

  /** Get the reference image that is defining the output information. */
<span style = "background-color:#fdd">  itkGetInputMacro(ReferenceImage, ReferenceImageBaseType);</span>

  /** Turn on/off whether a specified reference image should be used to define
   *  the output information. */
<span style = "background-color:#fdd">  itkSetMacro(UseReferenceImage, bool);
  itkBooleanMacro(UseReferenceImage);
  itkGetConstMacro(UseReferenceImage, bool);</span>

<span style = "background-color:#fdd">  itkSetMacro(StitchStrategy, StitchStrategy);
  itkGetConstMacro(StitchStrategy, StitchStrategy);</span>

  /** StitchImageFilter produces an image which is a different size
   * than its input.  As such, it needs to provide an implementation
   * for GenerateOutputInformation() in order to inform the pipeline
   * execution model.  The original documentation of this method is
   * below. \sa ProcessObject::GenerateOutputInformaton() */
  virtual void GenerateOutputInformation() ITK_OVERRIDE;

  /** StitchImageFilter needs a different input requested region than
   * the output requested region.  As such, StitchImageFilter needs
   * to provide an implementation for GenerateInputRequestedRegion()
   * in order to inform the pipeline execution model.
   * \sa ProcessObject::GenerateInputRequestedRegion() */
  virtual void GenerateInputRequestedRegion() ITK_OVERRIDE;

  /** Set up state of filter before multi-threading.
   * InterpolatorType::SetInputImage is not thread-safe and hence
   * has to be set up before ThreadedGenerateData */
  virtual void BeforeThreadedGenerateData() ITK_OVERRIDE;

  /** Set the state of the filter after multi-threading. */
  virtual void AfterThreadedGenerateData() ITK_OVERRIDE;

  /** Compute the Modified Time based on the changed components. */
  ModifiedTimeType GetMTime(void) const ITK_OVERRIDE;

#ifdef ITK_USE_CONCEPT_CHECKING
  // Begin concept checking
  itkConceptMacro( OutputHasNumericTraitsCheck,
                   ( Concept::HasNumericTraits&lt; PixelComponentType &gt; ) );
  // End concept checking
#endif

protected:
  StitchImageFilter();
<span style = "background-color:#fdd">  ~StitchImageFilter() ITK_OVERRIDE {}</span>
  void PrintSelf(std::ostream &amp; os, Indent indent) const ITK_OVERRIDE;

  /** Override VeriyInputInformation() since this filter's inputs do
   * not need to occoupy the same physical space.
   *
   * \sa ProcessObject::VerifyInputInformation
   */
<span style = "background-color:#fdd">  virtual void VerifyInputInformation() const ITK_OVERRIDE { }</span>

  /** StitchImageFilter can be implemented as a multithreaded filter.
   * Therefore, this implementation provides a ThreadedGenerateData()
   * routine which is called for each processing thread. The output
   * image data is allocated automatically by the superclass prior
   * to calling ThreadedGenerateData().
   * ThreadedGenerateData can only write to the portion of the output image
   * specified by the parameter "outputRegionForThread"
   * \sa ImageToImageFilter::ThreadedGenerateData(),
   *     ImageToImageFilter::GenerateData() */
  virtual void ThreadedGenerateData(const OutputImageRegionType &amp; outputRegionForThread,
                                    ThreadIdType threadId) ITK_OVERRIDE;

  /** Cast pixel from interpolator output to PixelType. */
  virtual PixelType CastPixelWithBoundsChecking( const InterpolatorOutputType value,
                                                 const ComponentType minComponent,
                                                 const ComponentType maxComponent) const;

  void SetTransform(unsigned int index, const TransformType* transform);

  /** Helper that ensures that a transform is specified for every input image.
   If a input image has no specified transforms, an identity transform will
   be created and set as default.*/
  void EnsureTransforms();

  /** Helper that ensures that an interpolator is specified for every input image.
   If a input image has no specified interpolator, a linear interpolator will
   be created and set as default.*/
  void EnsureInterpolators();

  static std::string GetTransformInputName(unsigned int index);

private:
  ITK_DISALLOW_COPY_AND_ASSIGN(StitchImageFilter);

  typedef std::vector&lt;const InputImageType*&gt; InputImageVectorType;
  typedef std::map&lt;const InputImageType*, typename TransformType::ConstPointer&gt; TransformMapType;
  typedef std::map&lt;const InputImageType*, InterpolatorPointerType&gt; InterpolatorMapType;

  InputImageVectorType GetInputs();
  TransformMapType GetTransforms();

  InterpolatorMapType m_Interpolators;   // Image function for
                                          // interpolation
  PixelType m_DefaultPixelValue;          // default pixel value
                                          // if the point is
                                          // outside the image
  SizeType        m_Size;                 // Size of the output image
  SpacingType     m_OutputSpacing;        // output image spacing
  OriginPointType m_OutputOrigin;         // output image origin
  DirectionType   m_OutputDirection;      // output image direction cosines
  IndexType       m_OutputStartIndex;     // output image start index
  bool            m_UseReferenceImage;
  StitchStrategy  m_StitchStrategy;
};
} // end namespace itk

#ifndef ITK_MANUAL_INSTANTIATION
#include "itkStitchImageFilter.tpp"
#endif

#endif</pre>
	</body>
</html>