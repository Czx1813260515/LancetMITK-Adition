<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkMAPAlgorithmHelper.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkMAPAlgorithmHelper.h"

//itk
#include &lt;itkImageDuplicator.h&gt;

// Mitk
#include &lt;mitkImageAccessByItk.h&gt;
#include &lt;mitkPointSetMappingHelper.h&gt;

// MatchPoint
#include &lt;mapImageRegistrationAlgorithmInterface.h&gt;
#include &lt;mapRegistrationAlgorithmInterface.h&gt;
#include &lt;mapPointSetRegistrationAlgorithmInterface.h&gt;
#include &lt;mapDummyImageRegistrationAlgorithm.h&gt;
#include &lt;mapAlgorithmIdentificationInterface.h&gt;

namespace mitk
{

  MAPAlgorithmHelper::MAPAlgorithmHelper(map::algorithm::RegistrationAlgorithmBase *algorithm)
<span style = "background-color:#fdd">    : m_AlgorithmBase(algorithm), m_Error(CheckError::none)
  {
    m_AllowImageCasting = true;
  }</span>

  bool MAPAlgorithmHelper::HasImageAlgorithmInterface(const map::algorithm::RegistrationAlgorithmBase* algorithm)
<span style = "background-color:#fdd">  {</span>
    using InternalDefault2DImageType = itk::Image&lt;map::core::discrete::InternalPixelType, 2&gt;;
    using InternalDefault3DImageType = itk::Image&lt;map::core::discrete::InternalPixelType, 3&gt;;

    using Alg2DType = const ::map::algorithm::facet::ImageRegistrationAlgorithmInterface&lt;InternalDefault2DImageType, InternalDefault2DImageType&gt;;
<span style = "background-color:#fdd">    if (dynamic_cast&lt;Alg2DType*&gt;(algorithm) != nullptr) return true;</span>
    using Alg3DType = const ::map::algorithm::facet::ImageRegistrationAlgorithmInterface&lt;InternalDefault3DImageType, InternalDefault3DImageType&gt;;
<span style = "background-color:#fdd">    if (dynamic_cast&lt;Alg3DType*&gt;(algorithm) != nullptr) return true;</span>
    using Alg2D3DType = const ::map::algorithm::facet::ImageRegistrationAlgorithmInterface&lt;InternalDefault2DImageType, InternalDefault3DImageType&gt;;
<span style = "background-color:#fdd">    if (dynamic_cast&lt;Alg2D3DType*&gt;(algorithm) != nullptr) return true;</span>
    using Alg3D2DType = const ::map::algorithm::facet::ImageRegistrationAlgorithmInterface&lt;InternalDefault3DImageType, InternalDefault2DImageType&gt;;
<span style = "background-color:#fdd">    if (dynamic_cast&lt;Alg3D2DType*&gt;(algorithm) != nullptr) return true;</span>

<span style = "background-color:#fdd">    return false;
  }</span>

  bool MAPAlgorithmHelper::HasPointSetAlgorithmInterface(const map::algorithm::RegistrationAlgorithmBase* algorithm)
<span style = "background-color:#fdd">  {</span>
    typedef ::map::core::continuous::Elements&lt;3&gt;::InternalPointSetType InternalDefaultPointSetType;
    typedef const ::map::algorithm::facet::PointSetRegistrationAlgorithmInterface&lt;InternalDefaultPointSetType, InternalDefaultPointSetType&gt;
      PointSetRegInterface;

<span style = "background-color:#fdd">    return dynamic_cast&lt;PointSetRegInterface*&gt;(algorithm) != nullptr;
  }</span>

  map::core::RegistrationBase::Pointer
  MAPAlgorithmHelper::
  GetRegistration() const
<span style = "background-color:#fdd">  {
    map::core::RegistrationBase::Pointer spResult;</span>

<span style = "background-color:#fdd">    unsigned int movingDim = m_AlgorithmBase-&gt;getMovingDimensions();
    unsigned int targetDim = m_AlgorithmBase-&gt;getTargetDimensions();</span>

<span style = "background-color:#fdd">    if (movingDim != targetDim)</span>
    {
<span style = "background-color:#fdd">      mapDefaultExceptionStaticMacro( &lt;&lt;</span>
                                      "Error, algorithm instance has unequal dimensionality and is therefore not supported in the current version of MAPAlgorithmHelper.");
    }

<span style = "background-color:#fdd">    if (movingDim &gt; 3)</span>
    {
<span style = "background-color:#fdd">      mapDefaultExceptionStaticMacro( &lt;&lt;</span>
                                      "Error, algorithm instance has a dimensionality larger than 3 and is therefore not supported in the current version of MAPAlgorithmHelper.");
    }

    typedef ::map::algorithm::facet::RegistrationAlgorithmInterface&lt;2, 2&gt; RegistrationAlg2D2DInterface;
    typedef ::map::algorithm::facet::RegistrationAlgorithmInterface&lt;3, 3&gt; RegistrationAlg3D3DInterface;

<span style = "background-color:#fdd">    RegistrationAlg2D2DInterface* pRegAlgorithm2D2D = dynamic_cast&lt;RegistrationAlg2D2DInterface*&gt;</span>
        (m_AlgorithmBase.GetPointer());
<span style = "background-color:#fdd">    RegistrationAlg3D3DInterface* pRegAlgorithm3D3D = dynamic_cast&lt;RegistrationAlg3D3DInterface*&gt;</span>
        (m_AlgorithmBase.GetPointer());

<span style = "background-color:#fdd">    if (pRegAlgorithm2D2D)</span>
    {
<span style = "background-color:#fdd">      spResult = pRegAlgorithm2D2D-&gt;getRegistration();</span>
    }

<span style = "background-color:#fdd">    if (pRegAlgorithm3D3D)</span>
    {
<span style = "background-color:#fdd">      spResult = pRegAlgorithm3D3D-&gt;getRegistration();</span>
    }

<span style = "background-color:#fdd">    return spResult;
  }</span>

  mitk::MAPRegistrationWrapper::Pointer
  MAPAlgorithmHelper::
  GetMITKRegistrationWrapper() const
<span style = "background-color:#fdd">  {
    map::core::RegistrationBase::Pointer spInternalResult = GetRegistration();
    mitk::MAPRegistrationWrapper::Pointer spResult = mitk::MAPRegistrationWrapper::New(spInternalResult);
    return spResult;
  }</span>


  static const mitk::Image* GetDataAsImage(const mitk::BaseData* data)
<span style = "background-color:#fdd">  {
    return dynamic_cast&lt;const mitk::Image*&gt;(data);
  }</span>

  static const mitk::PointSet* GetDataAsPointSet(const mitk::BaseData* data)
<span style = "background-color:#fdd">  {
    return dynamic_cast&lt;const mitk::PointSet*&gt;(data);
  }</span>

  bool
  MAPAlgorithmHelper::
  CheckData(const mitk::BaseData* moving, const mitk::BaseData* target, CheckError::Type&amp; error) const
<span style = "background-color:#fdd">  {
    if (! m_AlgorithmBase)</span>
    {
<span style = "background-color:#fdd">      mapDefaultExceptionStaticMacro( &lt;&lt; "Error, cannot check data. Helper has no algorithm defined.");</span>
    }

<span style = "background-color:#fdd">    if (! moving)</span>
    {
<span style = "background-color:#fdd">      mapDefaultExceptionStaticMacro( &lt;&lt; "Error, cannot check data. Moving data pointer is nullptr.");</span>
    }

<span style = "background-color:#fdd">    if (! target)</span>
    {
<span style = "background-color:#fdd">      mapDefaultExceptionStaticMacro( &lt;&lt; "Error, cannot check data. Target data pointer is nullptr.");</span>
    }

<span style = "background-color:#fdd">    bool result = false;
    m_Error = CheckError::unsupportedDataType;</span>

<span style = "background-color:#fdd">    unsigned int movingDim = m_AlgorithmBase-&gt;getMovingDimensions();
    unsigned int targetDim = m_AlgorithmBase-&gt;getTargetDimensions();</span>

<span style = "background-color:#fdd">    if (movingDim != targetDim)</span>
    {
<span style = "background-color:#fdd">      m_Error = CheckError::wrongDimension;
    }</span>
    else
    {
      //First check if data are point sets or images
<span style = "background-color:#fdd">      if (GetDataAsPointSet(target) &amp;&amp; GetDataAsPointSet(moving))</span>
      {
        typedef ::map::core::continuous::Elements&lt;3&gt;::InternalPointSetType InternalDefaultPointSetType;
        typedef ::map::algorithm::facet::PointSetRegistrationAlgorithmInterface&lt;InternalDefaultPointSetType, InternalDefaultPointSetType&gt;
        PointSetRegInterface;

<span style = "background-color:#fdd">        PointSetRegInterface* pPointSetInterface = dynamic_cast&lt;PointSetRegInterface*&gt;</span>
            (m_AlgorithmBase.GetPointer());

<span style = "background-color:#fdd">        if (!pPointSetInterface)</span>
        {
<span style = "background-color:#fdd">          result = false;
          m_Error = CheckError::unsupportedDataType;</span>
        }
<span style = "background-color:#fdd">      }
      else if (GetDataAsImage(moving) &amp;&amp; GetDataAsImage(target))</span>
      {
<span style = "background-color:#fdd">        if (movingDim == 2)</span>
        {
<span style = "background-color:#fdd">          AccessTwoImagesFixedDimensionByItk(GetDataAsImage(moving), GetDataAsImage(target), DoCheckImages,</span>
                                             2);
<span style = "background-color:#fdd">        }
        else if (movingDim == 3)</span>
        {
<span style = "background-color:#fdd">          AccessTwoImagesFixedDimensionByItk(GetDataAsImage(moving), GetDataAsImage(target), DoCheckImages,</span>
                                             3);
<span style = "background-color:#fdd">        }</span>
        else
        {
<span style = "background-color:#fdd">          m_Error = CheckError::wrongDimension;</span>
        }

<span style = "background-color:#fdd">        if (m_Error == CheckError::none || (m_AllowImageCasting &amp;&amp; m_Error == CheckError::onlyByCasting))</span>
        {
<span style = "background-color:#fdd">          result = true;</span>
        }
      }

    }

<span style = "background-color:#fdd">    error = m_Error;
    return result;
  }</span>

  void MAPAlgorithmHelper::SetAllowImageCasting(bool allowCasting)
<span style = "background-color:#fdd">  {
    this-&gt;m_AllowImageCasting = allowCasting;
  }</span>

  bool MAPAlgorithmHelper::GetAllowImageCasting() const
<span style = "background-color:#fdd">  {
    return this-&gt;m_AllowImageCasting;
  }</span>

  void MAPAlgorithmHelper::SetData(const mitk::BaseData* moving, const mitk::BaseData* target)
<span style = "background-color:#fdd">  {
    if (! m_AlgorithmBase)</span>
    {
<span style = "background-color:#fdd">      mapDefaultExceptionStaticMacro( &lt;&lt; "Error, cannot check data. Helper has no algorithm defined.");</span>
    }

<span style = "background-color:#fdd">    if (! moving)</span>
    {
<span style = "background-color:#fdd">      mapDefaultExceptionStaticMacro( &lt;&lt; "Error, cannot check data. Moving data pointer is nullptr.");</span>
    }

<span style = "background-color:#fdd">    if (! target)</span>
    {
<span style = "background-color:#fdd">      mapDefaultExceptionStaticMacro( &lt;&lt; "Error, cannot check data. Target data pointer is nullptr.");</span>
    }

<span style = "background-color:#fdd">    unsigned int movingDim = m_AlgorithmBase-&gt;getMovingDimensions();
    unsigned int targetDim = m_AlgorithmBase-&gt;getTargetDimensions();</span>

<span style = "background-color:#fdd">    if (movingDim != targetDim)</span>
    {
<span style = "background-color:#fdd">      mapDefaultExceptionStaticMacro( &lt;&lt;</span>
                                      "Error, cannot set data. Current version of MAPAlgorithmHelper only supports images/point sets with same dimensionality.");
    }

<span style = "background-color:#fdd">    if (GetDataAsPointSet(target) &amp;&amp; GetDataAsPointSet(moving))</span>
    {
      typedef ::map::core::continuous::Elements&lt;3&gt;::InternalPointSetType InternalDefaultPointSetType;
      typedef ::map::algorithm::facet::PointSetRegistrationAlgorithmInterface&lt;InternalDefaultPointSetType, InternalDefaultPointSetType&gt;
      PointSetRegInterface;

<span style = "background-color:#fdd">      PointSetRegInterface* pPointSetInterface = dynamic_cast&lt;PointSetRegInterface*&gt;</span>
          (m_AlgorithmBase.GetPointer());

<span style = "background-color:#fdd">      pPointSetInterface-&gt;setMovingPointSet(mitk::PointSetMappingHelper::ConvertPointSetMITKtoMAP(</span>
                                              GetDataAsPointSet(moving)-&gt;GetPointSet()));
<span style = "background-color:#fdd">      pPointSetInterface-&gt;setTargetPointSet(mitk::PointSetMappingHelper::ConvertPointSetMITKtoMAP(</span>
                                              GetDataAsPointSet(target)-&gt;GetPointSet()));
<span style = "background-color:#fdd">    }
    else if (GetDataAsImage(moving) &amp;&amp; GetDataAsImage(target))</span>
    {
<span style = "background-color:#fdd">      if (movingDim == 2)</span>
      {
<span style = "background-color:#fdd">        AccessTwoImagesFixedDimensionByItk(GetDataAsImage(moving), GetDataAsImage(target), DoSetImages, 2);
      }
      else if (movingDim == 3)</span>
      {
<span style = "background-color:#fdd">        AccessTwoImagesFixedDimensionByItk(GetDataAsImage(moving), GetDataAsImage(target), DoSetImages, 3);</span>
      }
    }
<span style = "background-color:#fdd">  }</span>

  template&lt;typename TInImageType, typename TOutImageType&gt;
  typename TOutImageType::Pointer MAPAlgorithmHelper::CastImage(const TInImageType* input) const
<span style = "background-color:#fdd">  {</span>
    typedef itk::CastImageFilter&lt; TInImageType, TOutImageType &gt; CastFilterType;
<span style = "background-color:#fdd">    typename CastFilterType::Pointer  spImageCaster =  CastFilterType::New();</span>

<span style = "background-color:#fdd">    spImageCaster-&gt;SetInput(input);</span>

<span style = "background-color:#fdd">    typename TOutImageType::Pointer spImage = spImageCaster-&gt;GetOutput();
    spImageCaster-&gt;Update();</span>

<span style = "background-color:#fdd">    return spImage;
  }</span>

  template&lt;typename TPixelType1, unsigned int VImageDimension1,
           typename TPixelType2, unsigned int VImageDimension2&gt;
  void MAPAlgorithmHelper::DoSetImages(const itk::Image&lt;TPixelType1, VImageDimension1&gt;* moving,
                                        const itk::Image&lt;TPixelType2, VImageDimension2&gt;* target)
<span style = "background-color:#fdd">  {</span>
    typedef itk::Image&lt;TPixelType1, VImageDimension1&gt; MovingImageType;
    typedef itk::Image&lt;TPixelType2, VImageDimension2&gt; TargetImageType;
    typedef itk::Image&lt;map::core::discrete::InternalPixelType, VImageDimension1&gt;
    InternalDefaultMovingImageType;
    typedef itk::Image&lt;map::core::discrete::InternalPixelType, VImageDimension2&gt;
    InternalDefaultTargetImageType;

    typedef ::map::algorithm::facet::ImageRegistrationAlgorithmInterface&lt;MovingImageType, TargetImageType&gt;
    ImageRegInterface;
    typedef ::map::algorithm::facet::ImageRegistrationAlgorithmInterface&lt;InternalDefaultMovingImageType, InternalDefaultTargetImageType&gt;
    DefaultImageRegInterface;


<span style = "background-color:#fdd">    ImageRegInterface* pImageInterface = dynamic_cast&lt;ImageRegInterface*&gt;(m_AlgorithmBase.GetPointer());
    DefaultImageRegInterface* pDefaultImageInterface = dynamic_cast&lt;DefaultImageRegInterface*&gt;</span>
        (m_AlgorithmBase.GetPointer());

<span style = "background-color:#fdd">    if (pImageInterface)</span>
    {
      //just set directly and you are done

      /**@todo the duplication work arround is needed due to a insufficuence
       in the AccessTwoImagesFixedDimensionByItk macro. The macro always cast
       the passed image into non const (even if tha image was passed as const).
       This behavior enforces the unnecessary use of an writeaccessor, which as a consequence
       will lead to redundant access exceptions as long as the algorithm exists;
       e.g. in the typical scenario with the MatchPoint Plugins*/
      typedef itk::ImageDuplicator&lt; MovingImageType &gt; MovingDuplicatorType;
      typedef itk::ImageDuplicator&lt; TargetImageType &gt; TargetDuplicatorType;
<span style = "background-color:#fdd">      typename MovingDuplicatorType::Pointer mDuplicator = MovingDuplicatorType::New();
      mDuplicator-&gt;SetInputImage(moving);
      mDuplicator-&gt;Update();</span>

<span style = "background-color:#fdd">      typename TargetDuplicatorType::Pointer tDuplicator = TargetDuplicatorType::New();
      tDuplicator-&gt;SetInputImage(target);
      tDuplicator-&gt;Update();</span>

<span style = "background-color:#fdd">      typename MovingImageType::Pointer clonedMoving = mDuplicator-&gt;GetOutput();
      typename TargetImageType::Pointer clonedTarget = tDuplicator-&gt;GetOutput();</span>

<span style = "background-color:#fdd">      pImageInterface-&gt;setTargetImage(clonedTarget);
      pImageInterface-&gt;setMovingImage(clonedMoving);
    }
    else if (pDefaultImageInterface)</span>
    {
      //you may convert it to the default image type and use it then
<span style = "background-color:#fdd">      if (! m_AllowImageCasting)</span>
      {
<span style = "background-color:#fdd">        mapDefaultExceptionStaticMacro( &lt;&lt;</span>
                                        "Error, cannot set images. MAPAlgorithmHelper has to convert them into MatchPoint default images, but is not allowed. Please reconfigure helper.");
      }

<span style = "background-color:#fdd">      typename InternalDefaultTargetImageType::Pointer spCastedTarget =</span>
        CastImage&lt;TargetImageType, InternalDefaultTargetImageType&gt;(target);
<span style = "background-color:#fdd">      typename InternalDefaultMovingImageType::Pointer spCastedMoving =</span>
        CastImage&lt;MovingImageType, InternalDefaultMovingImageType&gt;(moving);
<span style = "background-color:#fdd">      pDefaultImageInterface-&gt;setTargetImage(spCastedTarget);
      pDefaultImageInterface-&gt;setMovingImage(spCastedMoving);
    }</span>
    else
    {
<span style = "background-color:#fdd">      mapDefaultExceptionStaticMacro( &lt;&lt; "Error, algorithm is not able to use the based images.");</span>
    }
<span style = "background-color:#fdd">  }</span>

  template&lt;typename TPixelType1, unsigned int VImageDimension1,
           typename TPixelType2, unsigned int VImageDimension2&gt;
  void MAPAlgorithmHelper::DoCheckImages(const itk::Image&lt;TPixelType1, VImageDimension1&gt;* /*moving*/,
                                          const itk::Image&lt;TPixelType2, VImageDimension2&gt;* /*target*/) const
<span style = "background-color:#fdd">  {</span>
    typedef itk::Image&lt;TPixelType1, VImageDimension1&gt; MovingImageType;
    typedef itk::Image&lt;TPixelType2, VImageDimension2&gt; TargetImageType;
    typedef itk::Image&lt;map::core::discrete::InternalPixelType, VImageDimension1&gt;
    InternalDefaultMovingImageType;
    typedef itk::Image&lt;map::core::discrete::InternalPixelType, VImageDimension2&gt;
    InternalDefaultTargetImageType;

    typedef ::map::algorithm::facet::ImageRegistrationAlgorithmInterface&lt;MovingImageType, TargetImageType&gt;
    ImageRegInterface;
    typedef ::map::algorithm::facet::ImageRegistrationAlgorithmInterface&lt;InternalDefaultMovingImageType, InternalDefaultTargetImageType&gt;
    DefaultImageRegInterface;

<span style = "background-color:#fdd">    ImageRegInterface* pImageInterface = dynamic_cast&lt;ImageRegInterface*&gt;(m_AlgorithmBase.GetPointer());
    DefaultImageRegInterface* pDefaultImageInterface = dynamic_cast&lt;DefaultImageRegInterface*&gt;</span>
        (m_AlgorithmBase.GetPointer());

<span style = "background-color:#fdd">    if (pImageInterface)</span>
    {
      //just set directly and you are done
<span style = "background-color:#fdd">      m_Error = CheckError::none;
    }
    else if (pDefaultImageInterface)</span>
    {
      //you may convert it to the default image type and use it then
<span style = "background-color:#fdd">      m_Error = CheckError::onlyByCasting;
    }</span>
    else
    {
<span style = "background-color:#fdd">      m_Error = CheckError::unsupportedDataType;</span>
    }
<span style = "background-color:#fdd">  }</span>


<span style = "background-color:#fdd">  mapGenerateAlgorithmUIDPolicyMacro(DummyRegIDPolicy, "de.dkfz.dipp", "Identity", "1.0.0", "");</span>

  mitk::MAPRegistrationWrapper::Pointer GenerateIdentityRegistration3D()
<span style = "background-color:#fdd">  {</span>
      typedef map::algorithm::DummyImageRegistrationAlgorithm&lt;map::core::discrete::Elements&lt;3&gt;::InternalImageType, map::core::discrete::Elements&lt;3&gt;::InternalImageType, DummyRegIDPolicy&gt;
          DummyRegType;
<span style = "background-color:#fdd">      DummyRegType::Pointer regAlg = DummyRegType::New();
      mitk::MAPAlgorithmHelper helper(regAlg);</span>

<span style = "background-color:#fdd">      map::core::discrete::Elements&lt;3&gt;::InternalImageType::Pointer dummyImg =</span>
          map::core::discrete::Elements&lt;3&gt;::InternalImageType::New();
<span style = "background-color:#fdd">      dummyImg-&gt;Allocate();
      regAlg-&gt;setTargetImage(dummyImg);
      regAlg-&gt;setMovingImage(dummyImg);</span>

<span style = "background-color:#fdd">      auto dummyReg = mitk::MAPRegistrationWrapper::New(regAlg-&gt;getRegistration());</span>

<span style = "background-color:#fdd">      return dummyReg;
  }</span>

}</pre>
	</body>
</html>