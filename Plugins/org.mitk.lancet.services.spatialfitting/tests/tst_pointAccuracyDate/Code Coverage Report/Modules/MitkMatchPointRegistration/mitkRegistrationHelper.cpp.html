<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkRegistrationHelper.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/


#include "mitkRegistrationHelper.h"
#include &lt;mitkNodePredicateDataType.h&gt;
#include &lt;mitkNodePredicateProperty.h&gt;
#include &lt;mitkNodePredicateAnd.h&gt;
#include &lt;mitkNodePredicateOr.h&gt;
#include &lt;mitkPointSet.h&gt;
#include &lt;mitkLabelSetImage.h&gt;

//MatchPoint
#include "mapRegistrationKernel.h"

namespace mitk
{
<span style = "background-color:#dfd">  mitk::TNodePredicateDataType&lt;mitk::MAPRegistrationWrapper&gt;::ConstPointer InternalRegNodePredicate = mitk::TNodePredicateDataType&lt;mitk::MAPRegistrationWrapper&gt;::New().GetPointer();
  mitk::TNodePredicateDataType&lt;mitk::Image&gt;::ConstPointer InternalImageNodePredicate = mitk::TNodePredicateDataType&lt;mitk::Image&gt;::New().GetPointer();
  mitk::TNodePredicateDataType&lt;mitk::PointSet&gt;::ConstPointer InternalPointSetNodePredicate = mitk::TNodePredicateDataType&lt;mitk::PointSet&gt;::New().GetPointer();</span>


  MITKRegistrationHelper::Affine3DTransformType::Pointer
  MITKRegistrationHelper::
  getAffineMatrix(const mitk::MAPRegistrationWrapper* wrapper, bool inverseKernel)
<span style = "background-color:#fdd">  {
    Affine3DTransformType::Pointer result = nullptr;</span>

<span style = "background-color:#fdd">    if (wrapper)</span>
      {
<span style = "background-color:#fdd">        result = getAffineMatrix(wrapper-&gt;GetRegistration(), inverseKernel);</span>
      }
<span style = "background-color:#fdd">    return result;
  }</span>

  MITKRegistrationHelper::Affine3DTransformType::Pointer
  MITKRegistrationHelper::
  getAffineMatrix(const RegistrationBaseType* registration, bool inverseKernel)
<span style = "background-color:#fdd">  {
    Affine3DTransformType::Pointer result = nullptr;</span>

<span style = "background-color:#fdd">    if (registration &amp;&amp; is3D(registration))</span>
      {
<span style = "background-color:#fdd">        const Registration3DType* pReg = dynamic_cast&lt;const Registration3DType*&gt;(registration);
        if (pReg)</span>
          {
<span style = "background-color:#fdd">            if (inverseKernel)</span>
              {
<span style = "background-color:#fdd">                result = getAffineMatrix(pReg-&gt;getInverseMapping());
              }</span>
            else
              {
<span style = "background-color:#fdd">                result = getAffineMatrix(pReg-&gt;getDirectMapping());</span>
              }
          }
      }
<span style = "background-color:#fdd">    return result;
  }</span>


  MITKRegistrationHelper::Affine3DTransformType::Pointer MITKRegistrationHelper::getAffineMatrix(const RegistrationKernel3DBase&amp; kernel)
<span style = "background-color:#fdd">  {
    Affine3DTransformType::Pointer result = nullptr;</span>

    typedef ::map::core::RegistrationKernel&lt;3,3&gt; KernelType;

<span style = "background-color:#fdd">    const KernelType* pModelKernel = dynamic_cast&lt;const KernelType*&gt;(&amp;kernel);</span>

<span style = "background-color:#fdd">    if (pModelKernel)</span>
      {

<span style = "background-color:#fdd">        KernelType::TransformType::MatrixType matrix;</span>
        KernelType::TransformType::OutputVectorType offset;

<span style = "background-color:#fdd">        if(pModelKernel-&gt;getAffineMatrixDecomposition(matrix,offset))</span>
          {
<span style = "background-color:#fdd">            result = Affine3DTransformType::New();
            Affine3DTransformType::MatrixType resultMatrix;</span>
            Affine3DTransformType::OffsetType resultOffset;

            /**@TODO If MatchPoint and MITK get same scalar
              values the casting of matrix and offset values is
              obsolete and should be removed.*/
            //The conversion of matrix and offset is needed
            //because mitk uses float and MatchPoint currently
            //double as scalar value.
<span style = "background-color:#fdd">            for (unsigned int i=0; i&lt;matrix.GetVnlMatrix().size(); ++i)</span>
              {
<span style = "background-color:#fdd">                resultMatrix.GetVnlMatrix().begin()[i] = static_cast&lt;mitk::ScalarType&gt;(matrix.GetVnlMatrix().begin()[i]);
              }
            resultOffset.CastFrom(offset); //needed because mitk uses float and MatchPoint currently double as scalar value</span>

<span style = "background-color:#fdd">            result-&gt;SetMatrix(resultMatrix);
            result-&gt;SetOffset(resultOffset);</span>
          }
      }
<span style = "background-color:#fdd">    return result;
  }</span>

  bool MITKRegistrationHelper::is3D(const mitk::MAPRegistrationWrapper* wrapper)
<span style = "background-color:#fdd">  {
    bool result = false;</span>

<span style = "background-color:#fdd">    if (wrapper)</span>
      {
<span style = "background-color:#fdd">        result = wrapper-&gt;GetMovingDimensions()==3 &amp;&amp; wrapper-&gt;GetTargetDimensions()==3;</span>
      }
<span style = "background-color:#fdd">    return result;
  }</span>

  bool MITKRegistrationHelper::is3D(const RegistrationBaseType* reBase)
<span style = "background-color:#fdd">  {
    bool result = false;</span>

<span style = "background-color:#fdd">    if (reBase)</span>
      {
<span style = "background-color:#fdd">        result = reBase-&gt;getMovingDimensions()==3 &amp;&amp; reBase-&gt;getTargetDimensions()==3;</span>
      }
<span style = "background-color:#fdd">    return result;
  }</span>

  bool MITKRegistrationHelper::IsRegNode(const mitk::DataNode* node)
<span style = "background-color:#fdd">  {
    if (!node) return false;</span>

<span style = "background-color:#fdd">    return InternalRegNodePredicate-&gt;CheckNode(node);
  }</span>

  NodePredicateBase::ConstPointer MITKRegistrationHelper::RegNodePredicate()
<span style = "background-color:#fdd">  {
    return InternalRegNodePredicate.GetPointer();
  }</span>

  NodePredicateBase::ConstPointer MITKRegistrationHelper::ImageNodePredicate()
<span style = "background-color:#fdd">  {
    return InternalImageNodePredicate.GetPointer();
  }</span>

  NodePredicateBase::ConstPointer MITKRegistrationHelper::PointSetNodePredicate()
<span style = "background-color:#fdd">  {
    return InternalPointSetNodePredicate.GetPointer();
  }</span>

  NodePredicateBase::ConstPointer MITKRegistrationHelper::MaskNodePredicate()
<span style = "background-color:#fdd">  {
    auto isLabelSetImage = mitk::TNodePredicateDataType&lt;mitk::LabelSetImage&gt;::New();
    auto hasBinaryProperty = mitk::NodePredicateProperty::New("binary", mitk::BoolProperty::New(true));
    auto isLegacyMask = mitk::NodePredicateAnd::New(ImageNodePredicate(), hasBinaryProperty);</span>

<span style = "background-color:#fdd">    auto isLabelSetOrLegacyMask = mitk::NodePredicateOr::New(isLabelSetImage, isLegacyMask);</span>

<span style = "background-color:#fdd">    return isLabelSetOrLegacyMask.GetPointer();
  }</span>

}</pre>
	</body>
</html>