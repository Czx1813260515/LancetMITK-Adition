<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkCESTImageNormalizationFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkCESTImageNormalizationFilter.h"

#include &lt;mitkCESTPropertyHelper.h&gt;
#include &lt;mitkExtractCESTOffset.h&gt;
#include &lt;mitkImage.h&gt;
#include &lt;mitkImageAccessByItk.h&gt;
#include &lt;mitkImageCast.h&gt;

#include &lt;boost/algorithm/string.hpp&gt;

mitk::CESTImageNormalizationFilter::CESTImageNormalizationFilter()
<span style = "background-color:#fdd">{
}</span>

mitk::CESTImageNormalizationFilter::~CESTImageNormalizationFilter()
<span style = "background-color:#fdd">{
}</span>

void mitk::CESTImageNormalizationFilter::GenerateData()
<span style = "background-color:#fdd">{
  mitk::Image::ConstPointer inputImage = this-&gt;GetInput(0);
  if ((inputImage-&gt;GetDimension() != 4))</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "mitk::CESTImageNormalizationFilter:GenerateData works only with 4D images, sorry.";
    return;</span>
  }

<span style = "background-color:#fdd">  auto resultMitkImage = this-&gt;GetOutput();
  AccessFixedDimensionByItk(inputImage, NormalizeTimeSteps, 4);</span>

<span style = "background-color:#fdd">  auto originalTimeGeometry = this-&gt;GetInput()-&gt;GetTimeGeometry();
  auto resultTimeGeometry = mitk::ProportionalTimeGeometry::New();</span>

<span style = "background-color:#fdd">  unsigned int numberOfNonM0s = m_NonM0Indices.size();
  resultTimeGeometry-&gt;Expand(numberOfNonM0s);</span>

<span style = "background-color:#fdd">  for (unsigned int index = 0; index &lt; numberOfNonM0s; ++index)</span>
  {
<span style = "background-color:#fdd">    resultTimeGeometry-&gt;SetTimeStepGeometry(originalTimeGeometry-&gt;GetGeometryCloneForTimeStep(m_NonM0Indices.at(index)), index);
  }
  resultMitkImage-&gt;SetTimeGeometry(resultTimeGeometry);</span>

<span style = "background-color:#fdd">  resultMitkImage-&gt;SetPropertyList(this-&gt;GetInput()-&gt;GetPropertyList()-&gt;Clone());
  resultMitkImage-&gt;GetPropertyList()-&gt;SetStringProperty(CEST_PROPERTY_NAME_OFFSETS().c_str(), m_RealOffsets.c_str());</span>
  // remove uids
<span style = "background-color:#fdd">  resultMitkImage-&gt;GetPropertyList()-&gt;DeleteProperty("DICOM.0008.0018");
  resultMitkImage-&gt;GetPropertyList()-&gt;DeleteProperty("DICOM.0020.000D");
  resultMitkImage-&gt;GetPropertyList()-&gt;DeleteProperty("DICOM.0020.000E");</span>

<span style = "background-color:#fdd">}</span>

template &lt;typename TPixel, unsigned int VImageDimension&gt;
void mitk::CESTImageNormalizationFilter::NormalizeTimeSteps(const itk::Image&lt;TPixel, VImageDimension&gt;* image)
<span style = "background-color:#fdd">{</span>
  typedef itk::Image&lt;TPixel, VImageDimension&gt; ImageType;
  typedef itk::Image&lt;double, VImageDimension&gt; OutputImageType;

<span style = "background-color:#fdd">  auto offsets = ExtractCESTOffset(this-&gt;GetInput());</span>

  // determine normalization images
<span style = "background-color:#fdd">  std::vector&lt;unsigned int&gt; mZeroIndices;
  std::stringstream offsetsWithoutM0;
  offsetsWithoutM0.imbue(std::locale("C"));
  m_NonM0Indices.clear();
  for (unsigned int index = 0; index &lt; offsets.size(); ++index)</span>
  {
<span style = "background-color:#fdd">    if ((offsets.at(index) &lt; -299) || (offsets.at(index) &gt; 299))</span>
    {
<span style = "background-color:#fdd">      mZeroIndices.push_back(index);
    }</span>
    else
    {
<span style = "background-color:#fdd">      offsetsWithoutM0 &lt;&lt; offsets.at(index) &lt;&lt; " ";
      m_NonM0Indices.push_back(index);</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  auto resultImage = OutputImageType::New();
  typename ImageType::RegionType targetEntireRegion = image-&gt;GetLargestPossibleRegion();
  targetEntireRegion.SetSize(3, m_NonM0Indices.size());
  resultImage-&gt;SetRegions(targetEntireRegion);
  resultImage-&gt;Allocate();
  resultImage-&gt;FillBuffer(0);</span>

<span style = "background-color:#fdd">  unsigned int numberOfTimesteps = image-&gt;GetLargestPossibleRegion().GetSize(3);</span>

<span style = "background-color:#fdd">  typename ImageType::RegionType lowerMZeroRegion = image-&gt;GetLargestPossibleRegion();
  lowerMZeroRegion.SetSize(3, 1);
  typename ImageType::RegionType upperMZeroRegion = image-&gt;GetLargestPossibleRegion();
  upperMZeroRegion.SetSize(3, 1);
  typename ImageType::RegionType sourceRegion = image-&gt;GetLargestPossibleRegion();
  sourceRegion.SetSize(3, 1);
  typename OutputImageType::RegionType targetRegion = resultImage-&gt;GetLargestPossibleRegion();
  targetRegion.SetSize(3, 1);
  unsigned int targetTimestep = 0;
  for (unsigned int sourceTimestep = 0; sourceTimestep &lt; numberOfTimesteps; ++sourceTimestep)</span>
  {
<span style = "background-color:#fdd">    unsigned int lowerMZeroIndex = mZeroIndices[0];
    unsigned int upperMZeroIndex = mZeroIndices[0];
    for (unsigned int loop = 0; loop &lt; mZeroIndices.size(); ++loop)</span>
    {
<span style = "background-color:#fdd">      if (mZeroIndices[loop] &lt;= sourceTimestep)</span>
      {
<span style = "background-color:#fdd">        lowerMZeroIndex = mZeroIndices[loop];</span>
      }
<span style = "background-color:#fdd">      if (mZeroIndices[loop] &gt; sourceTimestep)</span>
      {
<span style = "background-color:#fdd">        upperMZeroIndex = mZeroIndices[loop];
        break;</span>
      }
<span style = "background-color:#fdd">    }
    bool isMZero = (lowerMZeroIndex == sourceTimestep);</span>

<span style = "background-color:#fdd">    double weight = 0.0;
    if (lowerMZeroIndex == upperMZeroIndex)</span>
    {
<span style = "background-color:#fdd">      weight = 1.0;
    }</span>
    else
    {
<span style = "background-color:#fdd">      weight = 1.0 - double(sourceTimestep - lowerMZeroIndex) / double(upperMZeroIndex - lowerMZeroIndex);</span>
    }


<span style = "background-color:#fdd">    if (isMZero)</span>
    {
      //do nothing
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">      lowerMZeroRegion.SetIndex(3, lowerMZeroIndex);
      upperMZeroRegion.SetIndex(3, upperMZeroIndex);
      sourceRegion.SetIndex(3, sourceTimestep);
      targetRegion.SetIndex(3, targetTimestep);</span>

<span style = "background-color:#fdd">      itk::ImageRegionConstIterator&lt;ImageType&gt; lowerMZeroIterator(image, lowerMZeroRegion);
      itk::ImageRegionConstIterator&lt;ImageType&gt; upperMZeroIterator(image, upperMZeroRegion);
      itk::ImageRegionConstIterator&lt;ImageType&gt; sourceIterator(image, sourceRegion);
      itk::ImageRegionIterator&lt;OutputImageType&gt; targetIterator(resultImage.GetPointer(), targetRegion);</span>

<span style = "background-color:#fdd">      while (!sourceIterator.IsAtEnd())</span>
      {
<span style = "background-color:#fdd">        double normalizationFactor = weight * lowerMZeroIterator.Get() + (1.0 - weight) * upperMZeroIterator.Get();
        if (mitk::Equal(normalizationFactor, 0))</span>
        {
<span style = "background-color:#fdd">          targetIterator.Set(0);
        }</span>
        else
        {
<span style = "background-color:#fdd">          targetIterator.Set(double(sourceIterator.Get()) / normalizationFactor);</span>
        }

<span style = "background-color:#fdd">        ++lowerMZeroIterator;
        ++upperMZeroIterator;
        ++sourceIterator;
        ++targetIterator;
      }
      ++targetTimestep;
    }
  }</span>

  // get  Pointer to output image
<span style = "background-color:#fdd">  mitk::Image::Pointer resultMitkImage = this-&gt;GetOutput();</span>
  // write into output image
<span style = "background-color:#fdd">  mitk::CastToMitkImage&lt;OutputImageType&gt;(resultImage, resultMitkImage);</span>

<span style = "background-color:#fdd">  m_RealOffsets = offsetsWithoutM0.str();
}</span>

void mitk::CESTImageNormalizationFilter::GenerateOutputInformation()
<span style = "background-color:#fdd">{
  mitk::Image::ConstPointer input = this-&gt;GetInput();
  mitk::Image::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  itkDebugMacro(&lt;&lt; "GenerateOutputInformation()");
}</span>

bool mitk::IsNotNormalizedCESTImage(const Image* cestImage)
<span style = "background-color:#fdd">{
  auto offsets = ExtractCESTOffset(cestImage);</span>

<span style = "background-color:#fdd">  for (const auto&amp; offset : offsets)</span>
  {
<span style = "background-color:#fdd">    if (offset &lt; -299 || offset &gt; 299)</span>
    {
<span style = "background-color:#fdd">      return true;</span>
    }
<span style = "background-color:#fdd">  }
  return false;
};</span></pre>
	</body>
</html>