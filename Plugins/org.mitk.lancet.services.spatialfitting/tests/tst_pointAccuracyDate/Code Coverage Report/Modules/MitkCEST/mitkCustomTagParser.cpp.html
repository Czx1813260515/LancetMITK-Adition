<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkCustomTagParser.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkCustomTagParser.h"

#include &lt;mitkProperties.h&gt;
#include &lt;mitkStringProperty.h&gt;

#include "mitkCESTPropertyHelper.h"
#include "mitkIPropertyPersistence.h"

#include "usGetModuleContext.h"
#include "usModule.h"
#include "usModuleContext.h"
#include "usModuleResource.h"
#include "usModuleResourceStream.h"

#include &lt;itksys/SystemTools.hxx&gt;

#include &lt;Poco/Glob.h&gt;

#include &lt;boost/algorithm/string.hpp&gt;
#include &lt;boost/property_tree/json_parser.hpp&gt;
#include &lt;boost/property_tree/ptree.hpp&gt;
#include &lt;boost/tokenizer.hpp&gt;

#include &lt;algorithm&gt;
#include &lt;cstdint&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

namespace
{
  mitk::IPropertyPersistence *GetPersistenceService()
<span style = "background-color:#fdd">  {
    mitk::IPropertyPersistence *result = nullptr;</span>

<span style = "background-color:#fdd">    std::vector&lt;us::ServiceReference&lt;mitk::IPropertyPersistence&gt;&gt; persRegisters =</span>
      us::GetModuleContext()-&gt;GetServiceReferences&lt;mitk::IPropertyPersistence&gt;();
<span style = "background-color:#fdd">    if (!persRegisters.empty())</span>
    {
<span style = "background-color:#fdd">      if (persRegisters.size() &gt; 1)</span>
      {
<span style = "background-color:#fdd">        MITK_WARN &lt;&lt; "Multiple property description services found. Using just one.";</span>
      }
<span style = "background-color:#fdd">      result = us::GetModuleContext()-&gt;GetService&lt;mitk::IPropertyPersistence&gt;(persRegisters.front());</span>
    }

<span style = "background-color:#fdd">    return result;
  };</span>
}

<span style = "background-color:#dfd">const std::string mitk::CustomTagParser::m_CESTPropertyPrefix = "CEST.";
const std::string mitk::CustomTagParser::m_RevisionPropertyName = m_CESTPropertyPrefix + "Revision";
const std::string mitk::CustomTagParser::m_JSONRevisionPropertyName = m_CESTPropertyPrefix + "revision_json";</span>

<span style = "background-color:#dfd">const std::string mitk::CustomTagParser::m_RevisionIndependentMapping =</span>
"\n"
"  \"sProtConsistencyInfo.tSystemType\" : \"SysType\",\n"
"  \"sProtConsistencyInfo.flNominalB0\" : \"NominalB0\",\n"
"  \"sTXSPEC.asNucleusInfo[0].lFrequency\" : \"FREQ\",\n"
"  \"sTXSPEC.asNucleusInfo[0].flReferenceAmplitude\" : \"RefAmp\",\n"
"  \"alTR[0]\" : \"TR\",\n"
"  \"alTE[0]\" : \"TE\",\n"
"  \"lAverages\" : \"averages\",\n"
"  \"lRepetitions\" : \"repetitions\",\n"
"  \"adFlipAngleDegree[0]\" : \"ImageFlipAngle\",\n"
<span style = "background-color:#dfd">"  \"lTotalScanTimeSec\" : \"TotalScanTime\",";
const std::string mitk::CustomTagParser::m_DefaultJsonString =</span>
"{\n"
"  \"default mapping, corresponds to revision 1416\" : \"revision_json\",\n"
"  \"sWiPMemBlock.alFree[1]\" : \"AdvancedMode\",\n"
"  \"sWiPMemBlock.alFree[2]\" : \"RecoveryMode\",\n"
"  \"sWiPMemBlock.alFree[3]\" : \"DoubleIrrMode\",\n"
"  \"sWiPMemBlock.alFree[4]\" : \"BinomMode\",\n"
"  \"sWiPMemBlock.alFree[5]\" : \"MtMode\",\n"
"  \"sWiPMemBlock.alFree[6]\" : \"PreparationType\",\n"
"  \"sWiPMemBlock.alFree[7]\" : \"PulseType\",\n"
"  \"sWiPMemBlock.alFree[8]\" : \"SamplingType\",\n"
"  \"sWiPMemBlock.alFree[9]\" : \"SpoilingType\",\n"
"  \"sWiPMemBlock.alFree[10]\" : \"measurements\",\n"
"  \"sWiPMemBlock.alFree[11]\" : \"NumberOfPulses\",\n"
"  \"sWiPMemBlock.alFree[12]\" : \"NumberOfLockingPulses\",\n"
"  \"sWiPMemBlock.alFree[13]\" : \"PulseDuration\",\n"
"  \"sWiPMemBlock.alFree[14]\" : \"DutyCycle\",\n"
"  \"sWiPMemBlock.alFree[15]\" : \"RecoveryTime\",\n"
"  \"sWiPMemBlock.alFree[16]\" : \"RecoveryTimeM0\",\n"
"  \"sWiPMemBlock.alFree[17]\" : \"ReadoutDelay\",\n"
"  \"sWiPMemBlock.alFree[18]\" : \"BinomDuration\",\n"
"  \"sWiPMemBlock.alFree[19]\" : \"BinomDistance\",\n"
"  \"sWiPMemBlock.alFree[20]\" : \"BinomNumberofPulses\",\n"
"  \"sWiPMemBlock.alFree[21]\" : \"BinomPreRepetions\",\n"
"  \"sWiPMemBlock.alFree[22]\" : \"BinomType\",\n"
"  \"sWiPMemBlock.adFree[1]\" : \"Offset\",\n"
"  \"sWiPMemBlock.adFree[2]\" : \"B1Amplitude\",\n"
"  \"sWiPMemBlock.adFree[3]\" : \"AdiabaticPulseMu\",\n"
"  \"sWiPMemBlock.adFree[4]\" : \"AdiabaticPulseBW\",\n"
"  \"sWiPMemBlock.adFree[5]\" : \"AdiabaticPulseLength\",\n"
"  \"sWiPMemBlock.adFree[6]\" : \"AdiabaticPulseAmp\",\n"
"  \"sWiPMemBlock.adFree[7]\" : \"FermiSlope\",\n"
"  \"sWiPMemBlock.adFree[8]\" : \"FermiFWHM\",\n"
"  \"sWiPMemBlock.adFree[9]\" : \"DoubleIrrDuration\",\n"
"  \"sWiPMemBlock.adFree[10]\" : \"DoubleIrrAmplitude\",\n"
"  \"sWiPMemBlock.adFree[11]\" : \"DoubleIrrRepetitions\",\n"
"  \"sWiPMemBlock.adFree[12]\" : \"DoubleIrrPreRepetitions\"\n"
<span style = "background-color:#dfd">"}";</span>

<span style = "background-color:#fdd">mitk::CustomTagParser::CustomTagParser(std::string relevantFile) : m_ClosestInternalRevision(""), m_ClosestExternalRevision("")
{
  std::string pathToDirectory;
  std::string fileName;
  itksys::SystemTools::SplitProgramPath(relevantFile, pathToDirectory, fileName);
  m_DicomDataPath = pathToDirectory;
  m_ParseStrategy = "Automatic";
  m_RevisionMappingStrategy = "Fuzzy";
}</span>

std::string mitk::CustomTagParser::ExtractRevision(std::string sequenceFileName)
<span style = "background-color:#fdd">{</span>
  //all rules are case insesitive. Thus we convert everything to lower case
  //in order to check everything only once.
<span style = "background-color:#fdd">  std::string cestPrefix = "cest";
  std::string cestPrefix2 = "_cest";
  std::string cestPrefix3 = "\\cest"; //this version covers the fact that the strings extracted</span>
                                      //from the SIEMENS tag has an additional prefix that is seperated by backslash.
<span style = "background-color:#fdd">  std::string revisionPrefix = "_rev";
  std::transform(sequenceFileName.begin(), sequenceFileName.end(), sequenceFileName.begin(), ::tolower);</span>

<span style = "background-color:#fdd">  bool isCEST = sequenceFileName.compare(0, cestPrefix.length(), cestPrefix) == 0;
  std::size_t foundPosition = 0;</span>

<span style = "background-color:#fdd">  if (!isCEST)</span>
  {
<span style = "background-color:#fdd">    foundPosition = sequenceFileName.find(cestPrefix2);
    isCEST = foundPosition != std::string::npos;</span>
  }

<span style = "background-color:#fdd">  if (!isCEST)</span>
  {
<span style = "background-color:#fdd">    foundPosition = sequenceFileName.find(cestPrefix3);
    isCEST = foundPosition != std::string::npos;</span>
  }

<span style = "background-color:#fdd">  if (!isCEST)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Invalid CEST sequence file name. No CEST prefix found. Could not extract revision.";</span>
  }

<span style = "background-color:#fdd">  foundPosition = sequenceFileName.find(revisionPrefix, foundPosition);
  if (foundPosition == std::string::npos)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Invalid CEST sequence file name. No revision prefix was found in CEST sequence file name. Could not extract revision.";</span>
  }

<span style = "background-color:#fdd">  std::string revisionString = sequenceFileName.substr(foundPosition + revisionPrefix.length(), std::string::npos);
  std::size_t firstNoneNumber = revisionString.find_first_not_of("0123456789");
  if (firstNoneNumber != std::string::npos)</span>
  {
<span style = "background-color:#fdd">    revisionString.erase(firstNoneNumber, std::string::npos);</span>
  }

<span style = "background-color:#fdd">  return revisionString;
}</span>

bool mitk::CustomTagParser::IsT1Sequence(std::string preparationType,
  std::string recoveryMode,
  std::string spoilingType,
  std::string revisionString)
<span style = "background-color:#fdd">{
  bool isT1 = false;</span>

  // if a forced parse strategy is set, use that one
<span style = "background-color:#fdd">  if ("T1" == m_ParseStrategy)</span>
  {
<span style = "background-color:#fdd">    return true;</span>
  }
<span style = "background-color:#fdd">  if ("CEST/WASABI" == m_ParseStrategy)</span>
  {
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#fdd">  if (("T1Recovery" == preparationType) || ("T1Inversion" == preparationType))</span>
  {
<span style = "background-color:#fdd">    isT1 = true;</span>
  }

  // How to interpret the recoveryMode depends on the age of the sequence
  // older sequences use 0 = false and 1 = true, newer ones 1 = false and 2 = true.
  // A rough rule of thumb is to assume that if the SpoilingType is 0, then the first
  // convention is chosen, if it is 1, then the second applies. Otherwise
  // we assume revision 1485 and newer to follow the new convention.
  // This unfortunate heuristic is due to somewhat arbitrary CEST sequence implementations.
<span style = "background-color:#fdd">  if (!isT1)</span>
  {
<span style = "background-color:#fdd">    std::string thisIsTrue = "1";
    std::string thisIsFalse = "0";
    if ("0" == spoilingType)</span>
    {
<span style = "background-color:#fdd">      thisIsFalse = "0";
      thisIsTrue = "1";
    }
    else if ("1" == spoilingType)</span>
    {
<span style = "background-color:#fdd">      thisIsFalse = "1";
      thisIsTrue = "2";
    }</span>
    else
    {
<span style = "background-color:#fdd">      int revisionNrWeAssumeToBeDifferenciating = 1485;
      if (std::stoi(revisionString) - revisionNrWeAssumeToBeDifferenciating &lt; 0)</span>
      {
<span style = "background-color:#fdd">        thisIsFalse = "0";
        thisIsTrue = "1";
      }</span>
      else
      {
<span style = "background-color:#fdd">        thisIsFalse = "1";
        thisIsTrue = "2";</span>
      }
    }

<span style = "background-color:#fdd">    if (thisIsFalse == recoveryMode)</span>
    {
<span style = "background-color:#fdd">      isT1 = false;
    }
    else if (thisIsTrue == recoveryMode)</span>
    {
<span style = "background-color:#fdd">      isT1 = true;</span>
    }

<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return isT1;
}</span>

mitk::PropertyList::Pointer mitk::CustomTagParser::ParseDicomPropertyString(std::string dicomPropertyString)
<span style = "background-color:#fdd">{
  auto results = mitk::PropertyList::New();
  if ("" == dicomPropertyString)</span>
  {
    //MITK_ERROR &lt;&lt; "Could not parse empty custom dicom string";
<span style = "background-color:#fdd">    return results;</span>
  }

<span style = "background-color:#fdd">  auto comp = [](const std::string&amp; s1, const std::string&amp; s2)
  {
    return boost::algorithm::lexicographical_compare(s1, s2, boost::algorithm::is_iless());
  };</span>

<span style = "background-color:#fdd">  std::map&lt;std::string, std::string, decltype(comp)&gt; privateParameters(comp);</span>

  // The Siemens private tag contains information like "43\52\23\34".
  // We jump over each "\" and convert the number;
<span style = "background-color:#fdd">  std::string bytes;</span>

  {
<span style = "background-color:#fdd">    const std::size_t SUBSTR_LENGTH = 2;
    const std::size_t INPUT_LENGTH = dicomPropertyString.length();</span>

<span style = "background-color:#fdd">    if (INPUT_LENGTH &lt; SUBSTR_LENGTH)
      return results;</span>

<span style = "background-color:#fdd">    const std::size_t MAX_INPUT_OFFSET = INPUT_LENGTH - SUBSTR_LENGTH;
    bytes.reserve(INPUT_LENGTH / 3 + 1);</span>

    try
    {
<span style = "background-color:#fdd">      for (std::size_t i = 0; i &lt;= MAX_INPUT_OFFSET; i += 3)</span>
      {
<span style = "background-color:#fdd">        std::string byte_string = dicomPropertyString.substr(i, SUBSTR_LENGTH);
        int byte = static_cast&lt;std::string::value_type&gt;(std::stoi(byte_string.c_str(), nullptr, 16));
        bytes.push_back(byte);
      }</span>
    }
    catch (const std::invalid_argument&amp;) // std::stoi() could not perform conversion
<span style = "background-color:#fdd">    {
      return results;
    }</span>
  }

  // extract parameter list
<span style = "background-color:#fdd">  std::string parameterListString;</span>

  {
<span style = "background-color:#fdd">    const std::string ASCCONV_MARKER = "###";
    const std::string ASCCONV_BEGIN = "### ASCCONV BEGIN";
    const std::string ASCCONV_END = "### ASCCONV END";</span>

<span style = "background-color:#fdd">    auto ascconvBeginPos = bytes.find(ASCCONV_BEGIN);
    if (std::string::npos == ascconvBeginPos)
      return results;
    ascconvBeginPos += ASCCONV_BEGIN.length();</span>

<span style = "background-color:#fdd">    ascconvBeginPos = bytes.find(ASCCONV_MARKER, ascconvBeginPos);
    if (std::string::npos == ascconvBeginPos)
      return results;
    ascconvBeginPos += ASCCONV_MARKER.length(); // closing "###"</span>

<span style = "background-color:#fdd">    auto ascconvEndPos = bytes.find(ASCCONV_END, ascconvBeginPos);
    if (std::string::npos == ascconvEndPos)
      return results;</span>

<span style = "background-color:#fdd">    auto count = ascconvEndPos - ascconvBeginPos;</span>

<span style = "background-color:#fdd">    parameterListString = bytes.substr(ascconvBeginPos, count);
  }</span>

<span style = "background-color:#fdd">  boost::replace_all(parameterListString, "\r\n", "\n");
  boost::replace_all(parameterListString, "\t", "");
  boost::char_separator&lt;char&gt; newlineSeparator("\n");
  boost::tokenizer&lt;boost::char_separator&lt;char&gt;&gt; parameters(parameterListString, newlineSeparator);
  for (const auto &amp;parameter : parameters)</span>
  {
<span style = "background-color:#fdd">    std::vector&lt;std::string&gt; parts;
    boost::split(parts, parameter, boost::is_any_of("="));</span>

<span style = "background-color:#fdd">    if (parts.size() == 2)</span>
    {
<span style = "background-color:#fdd">      parts[0].erase(std::remove(parts[0].begin(), parts[0].end(), ' '), parts[0].end());
      parts[1].erase(parts[1].begin(), parts[1].begin() + 1); // first character is a space
      privateParameters[parts[0]] = parts[1];</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  std::string revisionString = "";</span>

  try
  {
<span style = "background-color:#fdd">    revisionString = ExtractRevision(privateParameters["tSequenceFileName"]);</span>
  }
  catch (const std::exception &amp;e)
<span style = "background-color:#fdd">  {
    MITK_ERROR &lt;&lt; "Cannot deduce revision information. Reason: "&lt;&lt; e.what();
    return results;
  }</span>

<span style = "background-color:#fdd">  results-&gt;SetProperty(m_RevisionPropertyName, mitk::StringProperty::New(revisionString));</span>

<span style = "background-color:#fdd">  std::string jsonString = GetRevisionAppropriateJSONString(revisionString);</span>

<span style = "background-color:#fdd">  boost::property_tree::ptree root;
  std::istringstream jsonStream(jsonString);</span>
  try
  {
<span style = "background-color:#fdd">    boost::property_tree::read_json(jsonStream, root);</span>
  }
  catch (const boost::property_tree::json_parser_error &amp;e)
<span style = "background-color:#fdd">  {
    mitkThrow() &lt;&lt; "Could not parse json file. Error was:\n" &lt;&lt; e.what();
  }</span>

<span style = "background-color:#fdd">  for (const auto &amp;it : root)</span>
  {
<span style = "background-color:#fdd">    if (it.second.empty())</span>
    {
<span style = "background-color:#fdd">      std::string propertyName = m_CESTPropertyPrefix + it.second.data();
      if (m_JSONRevisionPropertyName == propertyName)</span>
      {
<span style = "background-color:#fdd">        results-&gt;SetProperty(propertyName, mitk::StringProperty::New(it.first));
      }</span>
      else
      {
<span style = "background-color:#fdd">        results-&gt;SetProperty(propertyName, mitk::StringProperty::New(privateParameters[it.first]));</span>
      }
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Currently no support for nested dicom tag descriptors in json file.";</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  std::string offset = "";
  std::string measurements = "";
  results-&gt;GetStringProperty("CEST.Offset", offset);
  results-&gt;GetStringProperty("CEST.measurements", measurements);</span>

<span style = "background-color:#fdd">  if (measurements.empty())</span>
  {
<span style = "background-color:#fdd">    std::string stringRepetitions = "";
    results-&gt;GetStringProperty("CEST.repetitions", stringRepetitions);</span>

<span style = "background-color:#fdd">    std::string stringAverages = "";
    results-&gt;GetStringProperty("CEST.averages", stringAverages);</span>

<span style = "background-color:#fdd">    const auto ERROR_STRING = "Could not find measurements, fallback assumption of repetitions + averages could not be determined either.";</span>

<span style = "background-color:#fdd">    if (!stringRepetitions.empty() &amp;&amp; !stringAverages.empty())</span>
    {
<span style = "background-color:#fdd">      std::stringstream measurementStream;</span>

      try
      {
<span style = "background-color:#fdd">        measurementStream &lt;&lt; std::stoi(stringRepetitions) + std::stoi(stringAverages);
        measurements = measurementStream.str();
        MITK_INFO &lt;&lt; "Could not find measurements, assuming repetitions + averages. That is: " &lt;&lt; measurements;</span>
      }
      catch (const std::invalid_argument&amp;)
<span style = "background-color:#fdd">      {
        MITK_ERROR &lt;&lt; ERROR_STRING;
      }
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; ERROR_STRING;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  std::string preparationType = "";
  std::string recoveryMode = "";
  std::string spoilingType = "";
  results-&gt;GetStringProperty(CEST_PROPERTY_NAME_PREPERATIONTYPE().c_str(), preparationType);
  results-&gt;GetStringProperty(CEST_PROPERTY_NAME_RECOVERYMODE().c_str(), recoveryMode);
  results-&gt;GetStringProperty(CEST_PROPERTY_NAME_SPOILINGTYPE().c_str(), spoilingType);</span>

<span style = "background-color:#fdd">  if (this-&gt;IsT1Sequence(preparationType, recoveryMode, spoilingType, revisionString))</span>
  {
<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "Parsed as T1 image";</span>

<span style = "background-color:#fdd">    std::stringstream trecStream;</span>

<span style = "background-color:#fdd">    std::string trecPath = m_DicomDataPath + "/TREC.txt";
    auto trec = ReadListFromFile(trecPath);</span>

<span style = "background-color:#fdd">    if(trec.empty())</span>
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Assumed T1, but could not load TREC at " &lt;&lt; trecPath;</span>
    }

<span style = "background-color:#fdd">    results-&gt;SetStringProperty(CEST_PROPERTY_NAME_TREC().c_str(), trec.c_str());
  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_INFO &lt;&lt; "Parsed as CEST or WASABI image";
    std::string sampling = "";
    bool hasSamplingInformation = results-&gt;GetStringProperty("CEST.SamplingType", sampling);
    if (hasSamplingInformation)</span>
    {
<span style = "background-color:#fdd">      std::string offsets = GetOffsetString(sampling, offset, measurements);
      results-&gt;SetStringProperty(CEST_PROPERTY_NAME_OFFSETS().c_str(), offsets.c_str());
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_WARN &lt;&lt; "Could not determine sampling type.";</span>
    }
<span style = "background-color:#fdd">  }</span>


  //persist all properties
<span style = "background-color:#fdd">  mitk::IPropertyPersistence *persSrv = GetPersistenceService();
  if (persSrv)</span>
  {
<span style = "background-color:#fdd">    auto propertyMap = results-&gt;GetMap();
    for (auto const &amp;prop : *propertyMap)</span>
    {
<span style = "background-color:#fdd">      PropertyPersistenceInfo::Pointer info = PropertyPersistenceInfo::New();
      std::string key = prop.first;
      std::replace(key.begin(), key.end(), '.', '_');
      info-&gt;SetNameAndKey(prop.first, key);</span>

<span style = "background-color:#fdd">      persSrv-&gt;AddInfo(info);
    }</span>
  }

<span style = "background-color:#fdd">  return results;
}</span>

std::string mitk::CustomTagParser::ReadListFromFile(const std::string&amp; filePath)
<span style = "background-color:#fdd">{
  std::stringstream listStream;
  std::ifstream list(filePath.c_str());
  list.imbue(std::locale("C"));</span>

<span style = "background-color:#fdd">  if (list.good())</span>
  {
<span style = "background-color:#fdd">    std::string currentValue;
    while (std::getline(list, currentValue))</span>
    {
<span style = "background-color:#fdd">      listStream &lt;&lt; currentValue &lt;&lt; " ";
    }
  }
  return listStream.str();
}</span>

mitk::PropertyList::Pointer mitk::CustomTagParser::ParseDicomProperty(mitk::TemporoSpatialStringProperty *dicomProperty)
<span style = "background-color:#fdd">{
  if (!dicomProperty)</span>
  {
<span style = "background-color:#fdd">    MITK_ERROR &lt;&lt; "DICOM property empty";</span>
  }

<span style = "background-color:#fdd">  auto results = mitk::PropertyList::New();</span>

<span style = "background-color:#fdd">  if (dicomProperty)</span>
  {
<span style = "background-color:#fdd">    results = ParseDicomPropertyString(dicomProperty-&gt;GetValue());</span>
  }

<span style = "background-color:#fdd">  return results;
}</span>

std::vector&lt;int&gt; mitk::CustomTagParser::GetInternalRevisions()
<span style = "background-color:#fdd">{
  const std::vector&lt;us::ModuleResource&gt; configs =</span>
    us::GetModuleContext()-&gt;GetModule()-&gt;FindResources("/", "*.json", false);

<span style = "background-color:#fdd">  std::vector&lt;int&gt; availableRevisionsVector;</span>

<span style = "background-color:#fdd">  for (const auto&amp; resource : configs)</span>
  {
<span style = "background-color:#fdd">    availableRevisionsVector.push_back(std::stoi(resource.GetBaseName()));
  }</span>

<span style = "background-color:#fdd">  return availableRevisionsVector;
}</span>

std::vector&lt;int&gt; mitk::CustomTagParser::GetExternalRevisions()
<span style = "background-color:#fdd">{
  std::string stringToJSONDirectory = GetExternalJSONDirectory();</span>

<span style = "background-color:#fdd">  std::string prospectiveJsonsPath = stringToJSONDirectory + "/*.json";</span>

<span style = "background-color:#fdd">  std::set&lt;std::string&gt; JsonFiles;
  Poco::Glob::glob(prospectiveJsonsPath, JsonFiles, Poco::Glob::GLOB_CASELESS);</span>

<span style = "background-color:#fdd">  std::vector&lt;int&gt; availableRevisionsVector;</span>

<span style = "background-color:#fdd">  for (const auto&amp; jsonpath : JsonFiles)</span>
  {
<span style = "background-color:#fdd">    std::string jsonDir;
    std::string jsonName;
    itksys::SystemTools::SplitProgramPath(jsonpath, jsonDir, jsonName);
    std::string revision = itksys::SystemTools::GetFilenameWithoutExtension(jsonName);</span>

    // disregard jsons which contain letters in their name
<span style = "background-color:#fdd">    bool onlyNumbers = (revision.find_first_not_of("0123456789") == std::string::npos);</span>

<span style = "background-color:#fdd">    if(onlyNumbers)</span>
    {
<span style = "background-color:#fdd">      availableRevisionsVector.push_back(std::stoi(revision));</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return availableRevisionsVector;
}</span>

std::string mitk::CustomTagParser::GetClosestLowerRevision(std::string revisionString, std::vector&lt;int&gt; availableRevisionsVector)
<span style = "background-color:#fdd">{</span>

  // descending order
<span style = "background-color:#fdd">  std::sort(availableRevisionsVector.begin(), availableRevisionsVector.end(), std::greater&lt;&gt;());</span>

<span style = "background-color:#fdd">  int revision = std::stoi(revisionString);</span>

<span style = "background-color:#fdd">  int index = 0;
  int numberOfRevisions = availableRevisionsVector.size();</span>

<span style = "background-color:#fdd">  while (index &lt; numberOfRevisions)</span>
  {
    // current mapping still has a higher revision number
<span style = "background-color:#fdd">    if ((availableRevisionsVector[index] - revision) &gt; 0)</span>
    {
<span style = "background-color:#fdd">      ++index;
    }</span>
    else
    {
<span style = "background-color:#fdd">      break;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  if (index &lt; numberOfRevisions)</span>
  {
<span style = "background-color:#fdd">    std::stringstream foundRevisionStream;
    foundRevisionStream &lt;&lt; availableRevisionsVector[index];</span>

<span style = "background-color:#fdd">    return foundRevisionStream.str();</span>
  }

<span style = "background-color:#fdd">  return "";
}</span>

void mitk::CustomTagParser::GetClosestLowerRevision(std::string revisionString)
<span style = "background-color:#fdd">{
  m_ClosestInternalRevision = GetClosestLowerRevision(revisionString, GetInternalRevisions());
  m_ClosestExternalRevision = GetClosestLowerRevision(revisionString, GetExternalRevisions());</span>

<span style = "background-color:#fdd">  if ("Strict" == m_RevisionMappingStrategy &amp;&amp; !((0 == m_ClosestInternalRevision.compare(revisionString)) ||</span>
                                                 (0 == m_ClosestExternalRevision.compare(revisionString))))
  { // strict revision mapping and neither revision does match the dicom meta data
<span style = "background-color:#fdd">    std::stringstream errorMessageStream;
    errorMessageStream &lt;&lt; "\nCould not parse dicom data in strict mode, data revision " &lt;&lt; revisionString</span>
      &lt;&lt; " has no known matching parameter mapping. To use the closest known older parameter mapping select the "
      &lt;&lt; "\"Fuzzy\" revision mapping option when loading the data.\n"
      &lt;&lt; "\nCurrently known revision mappings are:\n  Precompiled:";
<span style = "background-color:#fdd">    for (const auto revision : GetInternalRevisions())</span>
    {
<span style = "background-color:#fdd">      errorMessageStream &lt;&lt; " " &lt;&lt; revision;
    }
    errorMessageStream &lt;&lt; "\n  External:";
    for (const auto revision : GetExternalRevisions())</span>
    {
<span style = "background-color:#fdd">      errorMessageStream &lt;&lt; " " &lt;&lt; revision;
    }
    errorMessageStream &lt;&lt; "\n\nExternal revision mapping descriptions should be located at\n\n";
    std::string stringToJSONDirectory = GetExternalJSONDirectory();
    errorMessageStream &lt;&lt; stringToJSONDirectory;</span>

<span style = "background-color:#fdd">    errorMessageStream &lt;&lt; "\n\nTo provide an external mapping for this revision create a " &lt;&lt; revisionString</span>
                       &lt;&lt; ".json there. You might need to create the directory first.";

<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; errorMessageStream.str();
  }
}</span>

std::string mitk::CustomTagParser::GetRevisionAppropriateJSONString(std::string revisionString)
<span style = "background-color:#fdd">{
  std::string returnValue = "";</span>

<span style = "background-color:#fdd">  if ("" == revisionString)</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Could not extract revision";
  }</span>
  else
  {
<span style = "background-color:#fdd">    GetClosestLowerRevision(revisionString);</span>

<span style = "background-color:#fdd">    bool useExternal = false;
    bool useInternal = false;</span>

<span style = "background-color:#fdd">    if ("" != m_ClosestExternalRevision)</span>
    {
<span style = "background-color:#fdd">      useExternal = true;</span>
    }
<span style = "background-color:#fdd">    if ("" != m_ClosestInternalRevision)</span>
    {
<span style = "background-color:#fdd">      useInternal = true;</span>
    }

<span style = "background-color:#fdd">    if (useExternal &amp;&amp; useInternal)</span>
    {
<span style = "background-color:#fdd">      if (std::stoi(m_ClosestInternalRevision) &gt; std::stoi(m_ClosestExternalRevision))</span>
      {
<span style = "background-color:#fdd">        useExternal = false;</span>
      }
    }

<span style = "background-color:#fdd">    if (useExternal)</span>
    {
<span style = "background-color:#fdd">      std::string stringToJSONDirectory = GetExternalJSONDirectory();</span>

<span style = "background-color:#fdd">      std::string prospectiveJsonPath = stringToJSONDirectory + "/" + m_ClosestExternalRevision + ".json";</span>

<span style = "background-color:#fdd">      std::ifstream externalJSON(prospectiveJsonPath.c_str());</span>

<span style = "background-color:#fdd">      if (externalJSON.good())</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "Found external json for CEST parameters at " &lt;&lt; prospectiveJsonPath;</span>

<span style = "background-color:#fdd">        std::stringstream buffer;
        buffer &lt;&lt; externalJSON.rdbuf();</span>

<span style = "background-color:#fdd">        returnValue = buffer.str();</span>

<span style = "background-color:#fdd">        useInternal = false;
      }
    }</span>

<span style = "background-color:#fdd">    if (useInternal)</span>
    {
<span style = "background-color:#fdd">      std::string filename = m_ClosestInternalRevision + ".json";
      us::ModuleResource jsonResource = us::GetModuleContext()-&gt;GetModule()-&gt;GetResource(filename);</span>

<span style = "background-color:#fdd">      if (jsonResource.IsValid() &amp;&amp; jsonResource.IsFile())</span>
      {
<span style = "background-color:#fdd">        MITK_INFO &lt;&lt; "Found no external json for CEST parameters. Closest internal mapping is for revision "</span>
                  &lt;&lt; m_ClosestInternalRevision;
<span style = "background-color:#fdd">        us::ModuleResourceStream jsonStream(jsonResource);
        std::stringstream buffer;
        buffer &lt;&lt; jsonStream.rdbuf();
        returnValue = buffer.str();
      }
    }</span>
  }

<span style = "background-color:#fdd">  if ("" == returnValue)</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Could not identify parameter mapping for the given revision " &lt;&lt; revisionString</span>
              &lt;&lt; ", using default mapping.";
<span style = "background-color:#fdd">    returnValue = m_DefaultJsonString;</span>
  }

  // inject the revision independent mapping before the first newline
  {
<span style = "background-color:#fdd">    returnValue.insert(returnValue.find("\n"), m_RevisionIndependentMapping);</span>
  }

<span style = "background-color:#fdd">  return returnValue;
}</span>

std::string mitk::CustomTagParser::GetOffsetString(std::string samplingType, std::string offset, std::string measurements)
<span style = "background-color:#fdd">{
  std::stringstream results;
  results.imbue(std::locale("C"));</span>

<span style = "background-color:#fdd">  std::string normalizationIndicatingOffset = "-300";</span>

<span style = "background-color:#fdd">  double offsetDouble = 0.0;
  int measurementsInt = 0;</span>

<span style = "background-color:#fdd">  bool validOffset = false;
  bool validMeasurements = false;</span>

<span style = "background-color:#fdd">  if ("" != offset)</span>
  {
<span style = "background-color:#fdd">    validOffset = true;
    offsetDouble = std::stod(offset);</span>
  }
<span style = "background-color:#fdd">  if ("" != measurements)</span>
  {
<span style = "background-color:#fdd">    validMeasurements = true;
    measurementsInt = std::stoi(measurements);</span>
  }

<span style = "background-color:#fdd">  std::vector&lt;double&gt; offsetVector;</span>

<span style = "background-color:#fdd">  if (validOffset &amp;&amp; validMeasurements)</span>
  {
<span style = "background-color:#fdd">    for (int step = 0; step &lt; measurementsInt -1; ++step)</span>
    {
<span style = "background-color:#fdd">      double currentOffset = -offsetDouble + 2 * step * offsetDouble / (measurementsInt - 2.0);
      offsetVector.push_back(currentOffset);
    }
  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Invalid offset or measurements, offset calculation will only work for list sampling type.";</span>
  }

<span style = "background-color:#fdd">  if (samplingType == "1" || samplingType == "Regular")</span>
  {
<span style = "background-color:#fdd">    if (validOffset &amp;&amp; validMeasurements)</span>
    {
<span style = "background-color:#fdd">      results &lt;&lt; normalizationIndicatingOffset &lt;&lt; " ";
      for (const auto&amp; entry : offsetVector)</span>
      {
<span style = "background-color:#fdd">        results &lt;&lt; entry &lt;&lt; " ";
      }</span>
    }
<span style = "background-color:#fdd">  }
  else if (samplingType == "2" || samplingType == "Alternating")</span>
  {
<span style = "background-color:#fdd">    if (validOffset &amp;&amp; validMeasurements)</span>
    {
<span style = "background-color:#fdd">      results &lt;&lt; normalizationIndicatingOffset &lt;&lt; " ";
      for (auto&amp; entry : offsetVector)</span>
      {
<span style = "background-color:#fdd">        entry = std::abs(entry);
      }</span>

<span style = "background-color:#fdd">      std::sort(offsetVector.begin(), offsetVector.end(), std::greater&lt;&gt;());</span>

<span style = "background-color:#fdd">      for (unsigned int index = 0; index &lt; offsetVector.size(); ++index)</span>
      {
<span style = "background-color:#fdd">        offsetVector[index] = std::pow(-1, index) * offsetVector[index];
      }</span>

<span style = "background-color:#fdd">      for (auto&amp; entry : offsetVector)</span>
      {
<span style = "background-color:#fdd">        results &lt;&lt; entry &lt;&lt; " ";
      }</span>
    }
<span style = "background-color:#fdd">  }
  else if (samplingType == "3" || samplingType == "List")</span>
  {
<span style = "background-color:#fdd">    std::string listPath = m_DicomDataPath + "/LIST.txt";</span>

<span style = "background-color:#fdd">    auto values = ReadListFromFile(listPath);</span>

<span style = "background-color:#fdd">    if (!values.empty())</span>
    {
<span style = "background-color:#fdd">      results &lt;&lt; values;
    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Could not load list at " &lt;&lt; listPath;</span>
    }
<span style = "background-color:#fdd">  }
  else if (samplingType == "4" || samplingType == "SingleOffset")</span>
  {
<span style = "background-color:#fdd">    if (validOffset &amp;&amp; validMeasurements)</span>
    {
<span style = "background-color:#fdd">      results &lt;&lt; normalizationIndicatingOffset &lt;&lt; " ";
      for (int step = 0; step &lt; measurementsInt - 1; ++step)</span>
      {
<span style = "background-color:#fdd">        results &lt;&lt; offsetDouble &lt;&lt; " ";
      }</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Encountered unknown sampling type.";</span>
  }

<span style = "background-color:#fdd">  std::string resultString = results.str();</span>
  // replace multiple spaces by a single space
<span style = "background-color:#fdd">  std::string::iterator newEnditerator =</span>
    std::unique(resultString.begin(), resultString.end(),
<span style = "background-color:#fdd">      [=](char lhs, char rhs) { return (lhs == rhs) &amp;&amp; (lhs == ' '); }</span>
  );
<span style = "background-color:#fdd">  resultString.erase(newEnditerator, resultString.end());</span>

<span style = "background-color:#fdd">  if ((resultString.length() &gt; 0) &amp;&amp; (resultString.at(resultString.length() - 1) == ' '))</span>
  {
<span style = "background-color:#fdd">    resultString.erase(resultString.end() - 1, resultString.end());</span>
  }

<span style = "background-color:#fdd">  if ((resultString.length() &gt; 0) &amp;&amp; (resultString.at(0) == ' '))</span>
  {
<span style = "background-color:#fdd">    resultString.erase(resultString.begin(), ++(resultString.begin()));</span>
  }

<span style = "background-color:#fdd">  return resultString;
}</span>

void mitk::CustomTagParser::SetParseStrategy(std::string parseStrategy)
<span style = "background-color:#fdd">{
  m_ParseStrategy = parseStrategy;
}</span>

void mitk::CustomTagParser::SetRevisionMappingStrategy(std::string revisionMappingStrategy)
<span style = "background-color:#fdd">{
  m_RevisionMappingStrategy = revisionMappingStrategy;
}</span>

std::string mitk::CustomTagParser::GetExternalJSONDirectory()
<span style = "background-color:#fdd">{
  std::string moduleLocation = us::GetModuleContext()-&gt;GetModule()-&gt;GetLocation();
  std::string stringToModule;
  std::string libraryName;
  itksys::SystemTools::SplitProgramPath(moduleLocation, stringToModule, libraryName);</span>

<span style = "background-color:#fdd">  std::stringstream jsonDirectory;
  jsonDirectory &lt;&lt; stringToModule &lt;&lt; "/CESTRevisionMapping";</span>

<span style = "background-color:#fdd">  return jsonDirectory.str();
}</span></pre>
	</body>
</html>