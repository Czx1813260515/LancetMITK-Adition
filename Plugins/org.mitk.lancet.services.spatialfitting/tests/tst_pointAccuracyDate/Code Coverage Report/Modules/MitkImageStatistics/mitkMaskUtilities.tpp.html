<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkMaskUtilities.tpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKMASKUTIL_TPP
#define MITKMASKUTIL_TPP

#include &lt;mitkMaskUtilities.h&gt;
#include &lt;mitkImageAccessByItk.h&gt;
#include &lt;itkExtractImageFilter.h&gt;
#include &lt;itkChangeInformationImageFilter.h&gt;
#include &lt;mitkITKImageImport.h&gt;

namespace mitk
{
    template &lt;class TPixel, unsigned int VImageDimension&gt;
    void MaskUtilities&lt;TPixel, VImageDimension&gt;::SetImage(ImageType* image)
<span style = "background-color:#fdd">    {
        if (image != m_Image)</span>
        {
<span style = "background-color:#fdd">            m_Image = image;</span>
        }
<span style = "background-color:#fdd">    }</span>

    template &lt;class TPixel, unsigned int VImageDimension&gt;
    void MaskUtilities&lt;TPixel, VImageDimension&gt;::SetMask(MaskType* mask)
<span style = "background-color:#fdd">    {
        if (mask != m_Mask)</span>
        {
<span style = "background-color:#fdd">            m_Mask = mask;</span>
        }
<span style = "background-color:#fdd">    }</span>

    template &lt;class TPixel, unsigned int VImageDimension&gt;
    bool MaskUtilities&lt;TPixel, VImageDimension&gt;::CheckMaskSanity()
<span style = "background-color:#fdd">        {
            if (m_Mask==nullptr || m_Image==nullptr)</span>
            {
<span style = "background-color:#fdd">                MITK_ERROR &lt;&lt; "Set an image and a mask first";</span>
            }

            typedef itk::Image&lt; TPixel, VImageDimension &gt; ImageType;
            typedef typename ImageType::PointType PointType;
            typedef typename ImageType::DirectionType DirectionType;

<span style = "background-color:#fdd">            bool maskSanity = true;</span>


<span style = "background-color:#fdd">            if (m_Mask==nullptr)</span>
            {
<span style = "background-color:#fdd">                MITK_ERROR &lt;&lt; "Something went wrong when casting the mitk mask image to an itk mask image. Do the mask and the input image have the same dimension?";</span>
                // note to self: We could try to convert say a 2d mask to a 3d mask if the image is 3d. (mask and image dimension have to match.)
            }
            // check direction
<span style = "background-color:#fdd">            DirectionType imageDirection = m_Image-&gt;GetDirection();
            DirectionType maskDirection = m_Mask-&gt;GetDirection();
            for(unsigned int i = 0; i &lt; imageDirection.ColumnDimensions; ++i )</span>
            {
<span style = "background-color:#fdd">              for(unsigned int j = 0; j &lt; imageDirection.ColumnDimensions; ++j )</span>
              {
<span style = "background-color:#fdd">                double differenceDirection = imageDirection[i][j] - maskDirection[i][j];
                if (fabs(differenceDirection) &gt; MASK_SUITABILITY_TOLERANCE_DIRECTION)</span>
                {
<span style = "background-color:#fdd">                  maskSanity = false;
                  MITK_INFO &lt;&lt; "Mask needs to have same direction as image! (Image direction: " &lt;&lt; imageDirection &lt;&lt; "; Mask direction: " &lt;&lt; maskDirection &lt;&lt; ")";</span>
                }
<span style = "background-color:#fdd">              }
            }</span>

            // check spacing
<span style = "background-color:#fdd">            PointType imageSpacing = m_Image-&gt;GetSpacing();
            PointType maskSpacing = m_Mask-&gt;GetSpacing();
            for (unsigned int i = 0; i &lt; VImageDimension; i++)</span>
            {
<span style = "background-color:#fdd">                if ( fabs( maskSpacing[i] - imageSpacing[i] ) &gt; MASK_SUITABILITY_TOLERANCE_COORDINATE )</span>
                {
<span style = "background-color:#fdd">                    maskSanity = false;
                    MITK_INFO &lt;&lt; "Spacing of mask and image is not equal. Mask: " &lt;&lt; maskSpacing &lt;&lt; " image: " &lt;&lt; imageSpacing;</span>
                }
<span style = "background-color:#fdd">            }</span>

            // check alignment
            // Make sure that the voxels of mask and image are correctly "aligned", i.e., voxel boundaries are the same in both images
<span style = "background-color:#fdd">            PointType imageOrigin = m_Image-&gt;GetOrigin();
            PointType maskOrigin = m_Mask-&gt;GetOrigin();</span>

            typedef itk::ContinuousIndex&lt;double, VImageDimension&gt; ContinousIndexType;
            ContinousIndexType maskOriginContinousIndex, imageOriginContinousIndex;

<span style = "background-color:#fdd">            m_Image-&gt;TransformPhysicalPointToContinuousIndex(maskOrigin, maskOriginContinousIndex);
            m_Image-&gt;TransformPhysicalPointToContinuousIndex(imageOrigin, imageOriginContinousIndex);</span>

<span style = "background-color:#fdd">            for ( unsigned int i = 0; i &lt; ImageType::ImageDimension; ++i )</span>
            {
<span style = "background-color:#fdd">              double misalignment = maskOriginContinousIndex[i] - floor( maskOriginContinousIndex[i] + 0.5 );</span>
              // misalignment must be a multiple (int) of spacing in that direction
<span style = "background-color:#fdd">              if (  fmod(misalignment,imageSpacing[i])  &gt; MASK_SUITABILITY_TOLERANCE_COORDINATE)</span>
              {
<span style = "background-color:#fdd">                  maskSanity = false;
                  MITK_INFO &lt;&lt; "Pixels/voxels of mask and image are not sufficiently aligned! (Misalignment: " &lt;&lt; fmod(misalignment,imageSpacing[i]) &lt;&lt; ")";</span>
              }
<span style = "background-color:#fdd">            }</span>

            // mask must be completely inside image region
            // Make sure that mask region is contained within image region
<span style = "background-color:#fdd">            if ( m_Mask!=nullptr &amp;&amp;</span>
              !m_Image-&gt;GetLargestPossibleRegion().IsInside( m_Mask-&gt;GetLargestPossibleRegion() ) )
            {
<span style = "background-color:#fdd">              maskSanity = false;
              MITK_INFO &lt;&lt; "Mask region needs to be inside of image region! (Image region: "</span>
                &lt;&lt; m_Image-&gt;GetLargestPossibleRegion() &lt;&lt; "; Mask region: " &lt;&lt; m_Mask-&gt;GetLargestPossibleRegion() &lt;&lt; ")";
            }
<span style = "background-color:#fdd">            return maskSanity;
        }</span>

    template &lt;class TPixel, unsigned int VImageDimension&gt;
    typename itk::Image&lt;TPixel, VImageDimension&gt;::Pointer MaskUtilities&lt;TPixel, VImageDimension&gt;::ExtractMaskImageRegion()
<span style = "background-color:#fdd">    {
        if (m_Mask==nullptr || m_Image==nullptr)</span>
        {
<span style = "background-color:#fdd">            MITK_ERROR &lt;&lt; "Set an image and a mask first";</span>
        }

<span style = "background-color:#fdd">        bool maskSanity = CheckMaskSanity();</span>

<span style = "background-color:#fdd">        if (!maskSanity)</span>
        {
<span style = "background-color:#fdd">            MITK_ERROR &lt;&lt; "Mask and image are not compatible";</span>
        }

        typedef itk::Image&lt; TPixel, VImageDimension &gt; ImageType;
        typedef itk::Image&lt; unsigned short, VImageDimension &gt; MaskType;
        typedef itk::ExtractImageFilter&lt; ImageType, ImageType &gt; ExtractImageFilterType;

<span style = "background-color:#fdd">        typename ImageType::SizeType imageSize = m_Image-&gt;GetBufferedRegion().GetSize();
        typename ImageType::SizeType maskSize = m_Mask-&gt;GetBufferedRegion().GetSize();</span>

<span style = "background-color:#fdd">        typename itk::Image&lt;TPixel, VImageDimension&gt;::Pointer extractedImg = itk::Image&lt;TPixel, VImageDimension&gt;::New();</span>

<span style = "background-color:#fdd">        bool maskSmallerImage = false;
        for ( unsigned int i = 0; i &lt; ImageType::ImageDimension; ++i )</span>
        {
<span style = "background-color:#fdd">          if ( maskSize[i] &lt; imageSize[i] )</span>
          {
<span style = "background-color:#fdd">            maskSmallerImage = true;</span>
          }
<span style = "background-color:#fdd">        }</span>

<span style = "background-color:#fdd">        if ( maskSmallerImage )</span>
        {
<span style = "background-color:#fdd">          typename ExtractImageFilterType::Pointer extractImageFilter = ExtractImageFilterType::New();
          typename MaskType::PointType maskOrigin = m_Mask-&gt;GetOrigin();
          typename ImageType::PointType imageOrigin = m_Image-&gt;GetOrigin();
          typename MaskType::SpacingType maskSpacing = m_Mask-&gt;GetSpacing();
          typename ImageType::RegionType extractionRegion;</span>
          typename ImageType::IndexType extractionRegionIndex;


<span style = "background-color:#fdd">          for (unsigned int i=0; i &lt; maskOrigin.GetPointDimension(); i++)</span>
          {
<span style = "background-color:#fdd">              extractionRegionIndex[i] = (maskOrigin[i] - imageOrigin[i]) / maskSpacing[i];
          }</span>

<span style = "background-color:#fdd">          extractionRegion.SetIndex(extractionRegionIndex);
          extractionRegion.SetSize(m_Mask-&gt;GetLargestPossibleRegion().GetSize());</span>

<span style = "background-color:#fdd">          extractImageFilter-&gt;SetInput( m_Image );
          extractImageFilter-&gt;SetExtractionRegion( extractionRegion );
          extractImageFilter-&gt;SetCoordinateTolerance(MASK_SUITABILITY_TOLERANCE_COORDINATE);
          extractImageFilter-&gt;SetDirectionTolerance(MASK_SUITABILITY_TOLERANCE_DIRECTION);
          extractImageFilter-&gt;Update();
          extractedImg = extractImageFilter-&gt;GetOutput();
          extractedImg-&gt;SetOrigin(m_Mask-&gt;GetOrigin());
          extractedImg-&gt;SetLargestPossibleRegion(m_Mask-&gt;GetLargestPossibleRegion());
          extractedImg-&gt;SetBufferedRegion(m_Mask-&gt;GetBufferedRegion());</span>

<span style = "background-color:#fdd">        }</span>
        else
        {
<span style = "background-color:#fdd">          extractedImg = m_Image;</span>
        }

<span style = "background-color:#fdd">        return extractedImg;
    }</span>

}

#endif</pre>
	</body>
</html>