<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkLabelStatisticsImageFilter.hxx</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef mitkLabelStatisticsImageFilter_hxx
#define mitkLabelStatisticsImageFilter_hxx

#include "mitkLabelStatisticsImageFilter.h"

#include &lt;mitkHistogramStatisticsCalculator.h&gt;

#include &lt;itkImageLinearConstIteratorWithIndex.h&gt;
#include &lt;itkImageScanlineConstIterator.h&gt;

template &lt;typename TInputImage&gt;
mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::LabelStatistics::LabelStatistics()
<span style = "background-color:#fdd">  : m_Count(0),
    m_CountOfPositivePixels(0),
    m_Min(itk::NumericTraits&lt;RealType&gt;::max()),
    m_Max(itk::NumericTraits&lt;RealType&gt;::NonpositiveMin()),
    m_Mean(0),
    m_Sum(0),
    m_SumOfPositivePixels(0),
    m_SumOfSquares(0),
    m_SumOfCubes(0),
    m_SumOfQuadruples(0),
    m_Sigma(0),
    m_Variance(0),
    m_MPP(0),
    m_Median(0),
    m_Uniformity(0),
    m_UPP(0),
    m_Entropy(0),
    m_Skewness(0),
    m_Kurtosis(0)
{
  m_BoundingBox.resize(ImageDimension * 2);</span>

<span style = "background-color:#fdd">  for (std::remove_const_t&lt;decltype(ImageDimension)&gt; i = 0; i &lt; ImageDimension * 2; i += 2)</span>
  {
<span style = "background-color:#fdd">    m_BoundingBox[i] = itk::NumericTraits&lt;itk::IndexValueType&gt;::max();
    m_BoundingBox[i + 1] = itk::NumericTraits&lt;itk::IndexValueType&gt;::NonpositiveMin();
  }
}</span>

template &lt;typename TInputImage&gt;
mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::LabelStatistics::LabelStatistics(unsigned int size, RealType lowerBound, RealType upperBound)
<span style = "background-color:#fdd">  : LabelStatistics()
{
  typename HistogramType::SizeType histogramSize;
  histogramSize.SetSize(1);
  histogramSize[0] = size;</span>

<span style = "background-color:#fdd">  typename HistogramType::MeasurementVectorType histogramLowerBound;
  histogramLowerBound.SetSize(1);
  histogramLowerBound[0] = lowerBound;</span>

<span style = "background-color:#fdd">  typename HistogramType::MeasurementVectorType histogramUpperBound;
  histogramUpperBound.SetSize(1);
  histogramUpperBound[0] = upperBound;</span>

<span style = "background-color:#fdd">  m_Histogram = HistogramType::New();
  m_Histogram-&gt;SetMeasurementVectorSize(1);
  m_Histogram-&gt;Initialize(histogramSize, histogramLowerBound, histogramUpperBound);
}</span>

template &lt;typename TInputImage&gt;
mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::LabelStatistics::~LabelStatistics()
<span style = "background-color:#fdd">{
}</span>

template &lt;typename TInputImage&gt;
mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::LabelStatisticsImageFilter()
<span style = "background-color:#fdd">  : m_ComputeHistograms(false)
{
  this-&gt;AddRequiredInputName("LabelInput");
}</span>

template &lt;typename TInputImage&gt;
mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::~LabelStatisticsImageFilter()
<span style = "background-color:#fdd">{
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::BeforeStreamedGenerateData() -&gt; void
<span style = "background-color:#fdd">{
  this-&gt;AllocateOutputs();
  m_LabelStatistics.clear();
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::ThreadedStreamedGenerateData(const RegionType&amp; region) -&gt; void
<span style = "background-color:#fdd">{
  if (0 == region.GetSize(0))
    return;</span>

<span style = "background-color:#fdd">  MapType localStats;</span>

<span style = "background-color:#fdd">  typename HistogramType::MeasurementVectorType histogramMeasurement(1);
  typename HistogramType::IndexType histogramIndex(1);</span>

  using TLabelImage = itk::Image&lt;LabelPixelType, ImageDimension&gt;;

<span style = "background-color:#fdd">  itk::ImageLinearConstIteratorWithIndex&lt;TInputImage&gt; it(this-&gt;GetInput(), region);
  itk::ImageScanlineConstIterator&lt;TLabelImage&gt; labelIt(this-&gt;GetLabelInput(), region);</span>

<span style = "background-color:#fdd">  auto mapIt = localStats.end();</span>

<span style = "background-color:#fdd">  while (!it.IsAtEnd())</span>
  {
<span style = "background-color:#fdd">    while (!it.IsAtEndOfLine())</span>
    {
<span style = "background-color:#fdd">      const auto&amp; value = static_cast&lt;RealType&gt;(it.Get());
      const auto&amp; index = it.GetIndex();
      const auto&amp; label = labelIt.Get();</span>

<span style = "background-color:#fdd">      mapIt = localStats.find(label);</span>

<span style = "background-color:#fdd">      if (mapIt == localStats.end())</span>
      {
<span style = "background-color:#fdd">        mapIt = m_ComputeHistograms</span>
          ? localStats.emplace(label, LabelStatistics(m_HistogramSizes[label], m_HistogramLowerBounds[label], m_HistogramUpperBounds[label])).first
          : localStats.emplace(label, LabelStatistics()).first;
      }

<span style = "background-color:#fdd">      auto&amp; labelStats = mapIt-&gt;second;</span>

<span style = "background-color:#fdd">      labelStats.m_Min = std::min(labelStats.m_Min, value);
      labelStats.m_Max = std::max(labelStats.m_Max, value);
      labelStats.m_Sum += value;
      auto squareValue = value * value;
      labelStats.m_SumOfSquares += squareValue;
      labelStats.m_SumOfCubes += squareValue * value;
      labelStats.m_SumOfQuadruples += squareValue * squareValue;
      ++labelStats.m_Count;</span>

<span style = "background-color:#fdd">      if (0 &lt; value)</span>
      {
<span style = "background-color:#fdd">        labelStats.m_SumOfPositivePixels += value;
        ++labelStats.m_CountOfPositivePixels;</span>
      }

<span style = "background-color:#fdd">      for (unsigned int i = 0; i &lt; (ImageDimension * 2); i += 2)</span>
      {
<span style = "background-color:#fdd">        labelStats.m_BoundingBox[i] = std::min(labelStats.m_BoundingBox[i], index[i / 2]);
        labelStats.m_BoundingBox[i + 1] = std::max(labelStats.m_BoundingBox[i + 1], index[i / 2]);
      }</span>

<span style = "background-color:#fdd">      if (m_ComputeHistograms)</span>
      {
<span style = "background-color:#fdd">        histogramMeasurement[0] = value;
        labelStats.m_Histogram-&gt;GetIndex(histogramMeasurement, histogramIndex);
        labelStats.m_Histogram-&gt;IncreaseFrequencyOfIndex(histogramIndex, 1);</span>
      }

<span style = "background-color:#fdd">      ++labelIt;
      ++it;
    }</span>

<span style = "background-color:#fdd">    labelIt.NextLine();
    it.NextLine();
  }</span>

  // Merge localStats and m_LabelStatistics concurrently safe in a local copy

<span style = "background-color:#fdd">  while (true)</span>
  {
<span style = "background-color:#fdd">    std::unique_lock&lt;std::mutex&gt; lock(m_Mutex);</span>

<span style = "background-color:#fdd">    if (m_LabelStatistics.empty())</span>
    {
<span style = "background-color:#fdd">      std::swap(m_LabelStatistics, localStats);
      break;
    }</span>
    else
    {
<span style = "background-color:#fdd">      MapType toMerge;
      std::swap(m_LabelStatistics, toMerge);
      lock.unlock();
      this-&gt;MergeMap(localStats, toMerge);
    }
  }
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::AfterStreamedGenerateData() -&gt; void
<span style = "background-color:#fdd">{
  Superclass::AfterStreamedGenerateData();</span>

<span style = "background-color:#fdd">  m_ValidLabelValues.clear();
  m_ValidLabelValues.reserve(m_LabelStatistics.size());</span>

<span style = "background-color:#fdd">  for (auto&amp; val : m_LabelStatistics)</span>
  {
<span style = "background-color:#fdd">    m_ValidLabelValues.push_back(val.first);
    auto&amp; stats = val.second;</span>

<span style = "background-color:#fdd">    const auto&amp; sum = stats.m_Sum.GetSum();
    const auto&amp; sumOfSquares = stats.m_SumOfSquares.GetSum();
    const auto&amp; sumOfCubes = stats.m_SumOfCubes.GetSum();
    const auto&amp; sumOfQuadruples = stats.m_SumOfQuadruples.GetSum();
    const auto&amp; sumOfPositivePixels = stats.m_SumOfPositivePixels.GetSum();</span>

<span style = "background-color:#fdd">    const RealType count = stats.m_Count;
    const RealType countOfPositivePixels = stats.m_CountOfPositivePixels;</span>

<span style = "background-color:#fdd">    stats.m_Mean = sum / count;
    const auto&amp; mean = stats.m_Mean;</span>

<span style = "background-color:#fdd">    if (count &gt; 1)</span>
    {
<span style = "background-color:#fdd">      auto sumSquared = sum * sum;
      stats.m_Variance = (sumOfSquares - sumSquared / count) / (count - 1.0);
    }</span>
    else
    {
<span style = "background-color:#fdd">      stats.m_Variance = 0.0;</span>
    }

<span style = "background-color:#fdd">    stats.m_Sigma = std::sqrt(stats.m_Variance);</span>

<span style = "background-color:#fdd">    const auto secondMoment = sumOfSquares / count;
    const auto thirdMoment = sumOfCubes / count;
    const auto fourthMoment = sumOfQuadruples / count;</span>

<span style = "background-color:#fdd">    stats.m_Skewness = (thirdMoment - 3 * secondMoment * mean + 2 * std::pow(mean, 3)) / std::pow(secondMoment - std::pow(mean, 2), 1.5);
    stats.m_Kurtosis = (fourthMoment - 4 * thirdMoment * mean + 6 * secondMoment * std::pow(mean, 2) - 3 * std::pow(mean, 4)) / std::pow(secondMoment - std::pow(mean, 2), 2);
    stats.m_MPP = sumOfPositivePixels / countOfPositivePixels;</span>

<span style = "background-color:#fdd">    if (m_ComputeHistograms)</span>
    {
<span style = "background-color:#fdd">      mitk::HistogramStatisticsCalculator histogramStatisticsCalculator;
      histogramStatisticsCalculator.SetHistogram(stats.m_Histogram);
      histogramStatisticsCalculator.CalculateStatistics();</span>

<span style = "background-color:#fdd">      stats.m_Entropy = histogramStatisticsCalculator.GetEntropy();
      stats.m_Uniformity = histogramStatisticsCalculator.GetUniformity();
      stats.m_UPP = histogramStatisticsCalculator.GetUPP();
      stats.m_Median = histogramStatisticsCalculator.GetMedian();
    }
  }
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::SetHistogramParameters(
  const std::unordered_map&lt;LabelPixelType, unsigned int&gt;&amp; sizes,
  const std::unordered_map&lt;LabelPixelType, RealType&gt;&amp; lowerBounds,
  const std::unordered_map&lt;LabelPixelType, RealType&gt;&amp; upperBounds) -&gt; void
<span style = "background-color:#fdd">{
  bool modified = false;</span>

<span style = "background-color:#fdd">  if (m_HistogramSizes != sizes)</span>
  {
<span style = "background-color:#fdd">    m_HistogramSizes = sizes;
    modified = true;</span>
  }

<span style = "background-color:#fdd">  if (m_HistogramLowerBounds != lowerBounds)</span>
  {
<span style = "background-color:#fdd">    m_HistogramLowerBounds = lowerBounds;
    modified = true;</span>
  }

<span style = "background-color:#fdd">  if (m_HistogramUpperBounds != upperBounds)</span>
  {
<span style = "background-color:#fdd">    m_HistogramUpperBounds = upperBounds;
    modified = true;</span>
  }

<span style = "background-color:#fdd">  m_ComputeHistograms = true;</span>

<span style = "background-color:#fdd">  if (modified)
    this-&gt;Modified();
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::MergeMap(MapType&amp; map1, MapType&amp; map2) const -&gt; void
<span style = "background-color:#fdd">{
  for (auto&amp; elem2 : map2)</span>
  {
<span style = "background-color:#fdd">    auto iter1 = map1.find(elem2.first);</span>

<span style = "background-color:#fdd">    if (map1.end() == iter1)</span>
    {
<span style = "background-color:#fdd">      map1.emplace(elem2.first, std::move(elem2.second));
    }</span>
    else
    {
<span style = "background-color:#fdd">      const auto label = iter1-&gt;first;
      auto&amp; stats1 = iter1-&gt;second;
      auto&amp; stats2 = elem2.second;</span>

<span style = "background-color:#fdd">      stats1.m_Min = std::min(stats1.m_Min, stats2.m_Min);
      stats1.m_Max = std::max(stats1.m_Max, stats2.m_Max);</span>

<span style = "background-color:#fdd">      stats1.m_Sum += stats2.m_Sum;
      stats1.m_SumOfSquares += stats2.m_SumOfSquares;
      stats1.m_SumOfCubes += stats2.m_SumOfCubes;
      stats1.m_SumOfQuadruples += stats2.m_SumOfQuadruples;
      stats1.m_Count += stats2.m_Count;
      stats1.m_SumOfPositivePixels += stats2.m_SumOfPositivePixels;
      stats1.m_CountOfPositivePixels += stats2.m_CountOfPositivePixels;</span>

<span style = "background-color:#fdd">      for (unsigned int i = 0; i &lt; (ImageDimension * 2); i += 2)</span>
      {
<span style = "background-color:#fdd">        stats1.m_BoundingBox[i] = std::min(stats1.m_BoundingBox[i], stats2.m_BoundingBox[i]);
        stats1.m_BoundingBox[i + 1] = std::max(stats1.m_BoundingBox[i + 1], stats2.m_BoundingBox[i + 1]);
      }</span>

<span style = "background-color:#fdd">      if (m_ComputeHistograms)</span>
      {
<span style = "background-color:#fdd">        typename HistogramType::IndexType index;
        index.SetSize(1);</span>

<span style = "background-color:#fdd">        const auto histogramSize = m_HistogramSizes.at(label);</span>

<span style = "background-color:#fdd">        for (unsigned int bin = 0; bin &lt; histogramSize; ++bin)</span>
        {
<span style = "background-color:#fdd">          index[0] = bin;
          stats1.m_Histogram-&gt;IncreaseFrequency(bin, stats2.m_Histogram-&gt;GetFrequency(bin));
        }
      }</span>
    }
<span style = "background-color:#fdd">  }
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::HasLabel(LabelPixelType label) const -&gt; bool
{
  return m_LabelStatistics.find(label) != m_LabelStatistics.end();
}

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetNumberOfObjects() const -&gt; unsigned int
{
  return static_cast&lt;unsigned int&gt;(m_LabelStatistics.size());
}

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetNumberOfLabels() const -&gt; unsigned int
{
  return this-&gt;GetNumberOfObjects();
}

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetValidLabelValues() const -&gt; const ValidLabelValuesContainerType&amp;
<span style = "background-color:#fdd">{
  return m_ValidLabelValues;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetLabelStatistics(LabelPixelType label) const -&gt; const LabelStatistics&amp;
<span style = "background-color:#fdd">{
  MapConstIterator it = m_LabelStatistics.find(label);</span>

<span style = "background-color:#fdd">  if (m_LabelStatistics.end() != it)
    return it-&gt;second;</span>

<span style = "background-color:#fdd">  mitkThrow() &lt;&lt; "Label " &lt;&lt; label &lt;&lt; " does not exist";
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetLabelHistogramStatistics(LabelPixelType label) const -&gt; const LabelStatistics&amp;
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);</span>

<span style = "background-color:#fdd">  if (m_ComputeHistograms &amp;&amp; labelStatistics.m_Histogram.IsNotNull())
    return labelStatistics;</span>

<span style = "background-color:#fdd">  mitkThrow() &lt;&lt; "Histogram was not computed for label " &lt;&lt; label;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetMinimum(LabelPixelType label) const -&gt; PixelType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_Min;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetMaximum(LabelPixelType label) const -&gt; PixelType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_Max;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetMean(LabelPixelType label) const -&gt; RealType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_Mean;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetSigma(LabelPixelType label) const -&gt; RealType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_Sigma;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetVariance(LabelPixelType label) const -&gt; RealType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_Variance;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetSkewness(LabelPixelType label) const -&gt;RealType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_Skewness;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetKurtosis(LabelPixelType label) const -&gt; RealType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_Kurtosis;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetMPP(LabelPixelType label) const -&gt; RealType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_MPP;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetCount(LabelPixelType label) const-&gt; itk::SizeValueType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_Count;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetHistogram(LabelPixelType label) const -&gt; HistogramPointer
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelHistogramStatistics(label);
  return labelStatistics.m_Histogram;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetEntropy(LabelPixelType label) const -&gt; RealType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelHistogramStatistics(label);
  return labelStatistics.m_Entropy;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetUniformity(LabelPixelType label) const -&gt; RealType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelHistogramStatistics(label);
  return labelStatistics.m_Uniformity;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetUPP(LabelPixelType label) const -&gt; RealType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelHistogramStatistics(label);
  return labelStatistics.m_UPP;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetMedian(LabelPixelType label) const -&gt; RealType
<span style = "background-color:#fdd">{
  const auto&amp; labelStatistics = this-&gt;GetLabelHistogramStatistics(label);
  return labelStatistics.m_Median;
}</span>

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetSum(LabelPixelType label) const -&gt; RealType
{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_Sum.GetSum();
}

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetSumOfSquares(LabelPixelType label) const -&gt; RealType
{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_SumOfSquares.GetSum();
}

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetSumOfCubes(LabelPixelType label) const -&gt; RealType
{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_SumOfCubes.GetSum();
}

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetSumOfQuadruples(LabelPixelType label) const -&gt; RealType
{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_SumOfQuadruples.GetSum();
}

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetBoundingBox(LabelPixelType label) const -&gt; BoundingBoxType
{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);
  return labelStatistics.m_BoundingBox;
}

template &lt;typename TInputImage&gt;
auto mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::GetRegion(LabelPixelType label) const -&gt; RegionType
{
  const auto&amp; labelStatistics = this-&gt;GetLabelStatistics(label);

  IndexType index;
  SizeType size;

  for (unsigned int i = 0; i &lt; ImageDimension; ++i)
  {
    index[i] = labelStatistics.m_BoundingBox[2 * i];
    size[i] = labelStatistics.m_BoundingBox[2 * i + 1] - labelStatistics.m_BoundingBox[2 * i] + 1;
  }

  RegionType region;
  region.SetIndex(index);
  region.SetSize(size);

  return region;
}

template &lt;typename TInputImage&gt;
void mitk::LabelStatisticsImageFilter&lt;TInputImage&gt;::PrintSelf(std::ostream&amp; os, itk::Indent indent) const
<span style = "background-color:#fdd">{
  Superclass::PrintSelf(os, indent);</span>

<span style = "background-color:#fdd">  os &lt;&lt; indent &lt;&lt; "Number of labels: " &lt;&lt; m_LabelStatistics.size() &lt;&lt; std::endl;
  os &lt;&lt; indent &lt;&lt; "Compute histograms: " &lt;&lt; m_ComputeHistograms &lt;&lt; std::endl;
}</span>

#endif</pre>
	</body>
</html>