<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkHotspotMaskGenerator.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKHOTSPOTCALCULATOR_H
#define MITKHOTSPOTCALCULATOR_H

#include &lt;itkObject.h&gt;
#include &lt;mitkImage.h&gt;
#include &lt;itkImage.h&gt;
#include &lt;itkTimeStamp.h&gt;
#include &lt;stdexcept&gt;
#include &lt;MitkImageStatisticsExports.h&gt;
#include &lt;mitkImageTimeSelector.h&gt;
#include &lt;mitkMaskGenerator.h&gt;


namespace mitk
{
/**
     * @brief The HotspotMaskGenerator class is used when a hotspot has to be found in an image. A hotspot is
     * the region of the image where the mean intensity is maximal (=brightest spot). It is usually used in PET scans.
     * The identification of the hotspot is done as follows: First a cubic (or circular, if image is 2d)
     * mask of predefined size is generated. This mask is then convolved with the input image (in fourier domain).
     * The maximum value of the convolved image then corresponds to the hotspot.
     * If a maskGenerator is set, only the pixels of the convolved image where the corresponding mask is == @a label
     * are searched for the maximum value.
     */
    class MITKIMAGESTATISTICS_EXPORT HotspotMaskGenerator: public MaskGenerator
    {
    public:
        /** Standard Self typedef */
        typedef HotspotMaskGenerator                Self;
        typedef MaskGenerator                       Superclass;
        typedef itk::SmartPointer&lt; Self &gt;           Pointer;
        typedef itk::SmartPointer&lt; const Self &gt;     ConstPointer;

        /** Method for creation through the object factory. */
<span style = "background-color:#fdd">        itkNewMacro(Self); /** Runtime information support. */
        itkTypeMacro(HotspotMaskGenerator, MaskGenerator);</span>

        /**
        @brief Set the input image. Required for this class
         */
        void SetInputImage(mitk::Image::Pointer inputImage);

        /**
        @brief Set a mask (can be nullptr if no mask is desired)
         */
        void SetMask(MaskGenerator::Pointer mask);

        /**
        @brief Set the radius of the hotspot (in MM)
         */
        void SetHotspotRadiusInMM(double radiusInMillimeter);

        const double&amp; GetHotspotRadiusinMM() const;

        /**
        @brief Define whether the hotspot must be completely inside the image. Default is true
         */
        void SetHotspotMustBeCompletelyInsideImage(bool hotspotCompletelyInsideImage);

        bool GetHotspotMustBeCompletelyInsideImage() const;

        /**
        @brief If a maskGenerator is set, this detemines which mask value is used
         */
        void SetLabel(unsigned short label);

        /**
        @brief Computes and returns the hotspot mask. The hotspot mask has the same size as the input image. The hopspot has value 1, the remaining pixels are set to 0
         */
        mitk::Image::Pointer GetMask() override;

        /**
        @brief Returns the image index where the hotspot is located
         */
        vnl_vector&lt;int&gt; GetHotspotIndex();

        /**
        @brief Returns the index where the convolution image is minimal (darkest spot in image)
         */
        vnl_vector&lt;int&gt; GetConvolutionImageMinIndex();

        /**
         * @brief SetTimeStep is used to set the time step for which the mask is to be generated
         * @param timeStep
         */
        void SetTimeStep(unsigned int timeStep) override;

    protected:
        HotspotMaskGenerator();

        ~HotspotMaskGenerator() override;

        class ImageExtrema
        {
        public:
          bool Defined;
          double Max;
          double Min;
          vnl_vector&lt;int&gt; MaxIndex;
          vnl_vector&lt;int&gt; MinIndex;

          ImageExtrema()
<span style = "background-color:#fdd">            :Defined(false)
            ,Max(itk::NumericTraits&lt;double&gt;::min())
            ,Min(itk::NumericTraits&lt;double&gt;::max())
          {
          }</span>
        };

    private:
        /** \brief Returns size of convolution kernel depending on spacing and radius. */
        template &lt;unsigned int VImageDimension&gt;
        itk::Size&lt;VImageDimension&gt;
          CalculateConvolutionKernelSize(double spacing[VImageDimension], double radiusInMM);

        /** \brief Generates image of kernel which is needed for convolution. */
        template &lt;unsigned int VImageDimension&gt;
        itk::SmartPointer&lt; itk::Image&lt;float, VImageDimension&gt; &gt;
          GenerateHotspotSearchConvolutionKernel(double spacing[VImageDimension], double radiusInMM);

        /** \brief Convolves image with spherical kernel image. Used for hotspot calculation.   */
        template &lt;typename TPixel, unsigned int VImageDimension&gt;
        itk::SmartPointer&lt; itk::Image&lt;TPixel, VImageDimension&gt; &gt;
          GenerateConvolutionImage( const itk::Image&lt;TPixel, VImageDimension&gt;* inputImage );


        /** \brief Fills pixels of the spherical hotspot mask. */
        template &lt; typename TPixel, unsigned int VImageDimension&gt;
        void
          FillHotspotMaskPixels( itk::Image&lt;TPixel, VImageDimension&gt;* maskImage,
          itk::Point&lt;double, VImageDimension&gt; sphereCenter,
          double sphereRadiusInMM);


        /** \brief */
        template &lt;typename TPixel, unsigned int VImageDimension&gt;
        void
          CalculateHotspotMask(itk::Image&lt;TPixel, VImageDimension&gt;* inputImage,
                               typename itk::Image&lt;unsigned short, VImageDimension&gt;::Pointer maskImage,
                               unsigned int label);


        template &lt;typename TPixel, unsigned int VImageDimension  &gt;
        ImageExtrema CalculateExtremaWorld( const itk::Image&lt;TPixel, VImageDimension&gt;* inputImage,
                                                        typename itk::Image&lt;unsigned short, VImageDimension&gt;::Pointer maskImage,
                                                        double neccessaryDistanceToImageBorderInMM,
                                                        unsigned int label);

        bool IsUpdateRequired() const;

        HotspotMaskGenerator(const HotspotMaskGenerator &amp;);
        HotspotMaskGenerator &amp; operator=(const HotspotMaskGenerator &amp;);

        MaskGenerator::Pointer m_Mask;
        mitk::Image::Pointer m_internalImage;
        itk::Image&lt;unsigned short, 2&gt;::Pointer m_internalMask2D;
        itk::Image&lt;unsigned short, 3&gt;::Pointer m_internalMask3D;
        double m_HotspotRadiusinMM;
        bool m_HotspotMustBeCompletelyInsideImage;
        unsigned short m_Label;
        vnl_vector&lt;int&gt; m_ConvolutionImageMinIndex, m_ConvolutionImageMaxIndex;
        unsigned long m_InternalMaskUpdateTime;
    };
}
#endif // MITKHOTSPOTCALCULATOR

</pre>
	</body>
</html>