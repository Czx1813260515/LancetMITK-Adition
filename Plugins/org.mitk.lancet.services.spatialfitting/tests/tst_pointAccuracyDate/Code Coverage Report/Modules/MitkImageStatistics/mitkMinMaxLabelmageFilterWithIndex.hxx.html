<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkMinMaxLabelmageFilterWithIndex.hxx</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
#ifndef MITK_MinMaxLabelImageFilterWithIndex_HXX
#define MITK_MinMaxLabelImageFilterWithIndex_HXX

#include &lt;mitkMinMaxLabelmageFilterWithIndex.h&gt;
#include &lt;limits&gt;

namespace itk
{


template&lt; typename TInputImage, typename TLabelImage &gt;
void MinMaxLabelImageFilterWithIndex&lt; TInputImage, TLabelImage &gt;::AllocateOutputs()
<span style = "background-color:#fdd">{</span>
  // Pass the input through as the output
<span style = "background-color:#fdd">  typename TInputImage::Pointer image =</span>
    const_cast&lt; TInputImage * &gt;( this-&gt;GetInput() );

<span style = "background-color:#fdd">  this-&gt;GraftOutput(image);</span>

  // Nothing that needs to be allocated for the remaining outputs
<span style = "background-color:#fdd">}</span>

template&lt; typename TInputImage, typename TLabelImage &gt;
void MinMaxLabelImageFilterWithIndex&lt; TInputImage, TLabelImage &gt;::ThreadedGenerateData(const RegionType &amp;
                                      outputRegionForThread,
                                      ThreadIdType threadId)
<span style = "background-color:#fdd">{
  const SizeValueType size0 = outputRegionForThread.GetSize(0);
  if( size0 == 0)</span>
    {
<span style = "background-color:#fdd">    return;</span>
    }
  PixelType value;
  LabelPixelType label;

<span style = "background-color:#fdd">  ExtremaMapType threadExtrema;
  ExtremaMapTypeIterator threadExtremaIt;</span>

<span style = "background-color:#fdd">  ImageRegionConstIteratorWithIndex&lt; TInputImage &gt; it (this-&gt;GetInput(), outputRegionForThread);
  ImageRegionConstIteratorWithIndex&lt; TLabelImage &gt; labelit (this-&gt;GetLabelInput(), outputRegionForThread);</span>

  // do the work
<span style = "background-color:#fdd">  while ( !it.IsAtEnd() )</span>
  {
<span style = "background-color:#fdd">    value = it.Get();
    label = labelit.Get();</span>

<span style = "background-color:#fdd">    threadExtremaIt = threadExtrema.find(label);</span>

    // if label does not exist yet, create a new entry in the map.
<span style = "background-color:#fdd">    if (threadExtremaIt == threadExtrema.end())</span>
    {
<span style = "background-color:#fdd">      threadExtremaIt = threadExtrema.insert( MapValueType(label, LabelExtrema()) ).first;</span>
    }

<span style = "background-color:#fdd">    if (value &lt; (*threadExtremaIt).second.m_Min)</span>
    {
<span style = "background-color:#fdd">      (*threadExtremaIt).second.m_Min = value;
      (*threadExtremaIt).second.m_MinIndex = it.GetIndex();</span>
    }
<span style = "background-color:#fdd">    if (value &gt; (*threadExtremaIt).second.m_Max)</span>
    {
<span style = "background-color:#fdd">      (*threadExtremaIt).second.m_Max = value;
      (*threadExtremaIt).second.m_MaxIndex = it.GetIndex();</span>
    }
<span style = "background-color:#fdd">    ++it;
    ++labelit;
  }</span>

<span style = "background-color:#fdd">  m_ThreadExtrema[threadId] = threadExtrema;
}</span>

template&lt; typename TInputImage, typename TLabelImage &gt;
void MinMaxLabelImageFilterWithIndex&lt; TInputImage, TLabelImage &gt;::BeforeThreadedGenerateData()
<span style = "background-color:#fdd">{
  ThreadIdType numberOfThreads = this-&gt;GetNumberOfWorkUnits();
  m_ThreadExtrema.resize(numberOfThreads);</span>

<span style = "background-color:#fdd">  for (unsigned int i =0; i &lt; numberOfThreads; i++)</span>
  {
<span style = "background-color:#fdd">    m_ThreadExtrema[i] = ExtremaMapType();
  }
}</span>

template&lt; typename TInputImage, typename TLabelImage &gt;
void MinMaxLabelImageFilterWithIndex&lt; TInputImage, TLabelImage &gt;::AfterThreadedGenerateData()
<span style = "background-color:#fdd">{
  ThreadIdType numberOfThreads = this-&gt;GetNumberOfWorkUnits();</span>

<span style = "background-color:#fdd">  m_GlobalMin = std::numeric_limits&lt;PixelType&gt;::max();
  m_GlobalMax = std::numeric_limits&lt;PixelType&gt;::min();</span>

<span style = "background-color:#fdd">  ExtremaMapTypeIterator it;</span>

<span style = "background-color:#fdd">  for (ThreadIdType i = 0; i &lt; numberOfThreads; i++)</span>
  {
<span style = "background-color:#fdd">    for (auto&amp;&amp; it2 : m_ThreadExtrema[i])</span>
    {
<span style = "background-color:#fdd">      it = m_LabelExtrema.find(it2.first);
      if (it == m_LabelExtrema.end())</span>
      {
<span style = "background-color:#fdd">        it = m_LabelExtrema.insert( MapValueType(it2.first, LabelExtrema()) ).first;</span>
      }

<span style = "background-color:#fdd">      if (it2.second.m_Min &lt; (*it).second.m_Min)</span>
      {
<span style = "background-color:#fdd">        (*it).second.m_Min = it2.second.m_Min;
        (*it).second.m_MinIndex = it2.second.m_MinIndex;
        if (it2.second.m_Min &lt; m_GlobalMin)</span>
        {
<span style = "background-color:#fdd">          m_GlobalMin = it2.second.m_Min;
          m_GlobalMinIndex = it2.second.m_MinIndex;</span>
        }
      }

<span style = "background-color:#fdd">      if (it2.second.m_Max &gt; (*it).second.m_Max)</span>
      {
<span style = "background-color:#fdd">        (*it).second.m_Max = it2.second.m_Max;
        (*it).second.m_MaxIndex = it2.second.m_MaxIndex;
        if (it2.second.m_Max &gt; m_GlobalMax)</span>
        {
<span style = "background-color:#fdd">          m_GlobalMax = it2.second.m_Max;
          m_GlobalMaxIndex = it2.second.m_MaxIndex;</span>
        }
      }
<span style = "background-color:#fdd">    }
  }
}</span>
}
#endif</pre>
	</body>
</html>