<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNavigationDataSliceVisualization.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/
#include "mitkNavigationDataSliceVisualization.h"

#include "mitkBaseRenderer.h"

<span style = "background-color:#fdd">mitk::NavigationDataSliceVisualization::NavigationDataSliceVisualization() : mitk::NavigationDataToNavigationDataFilter(),
  m_Renderer(nullptr),
  m_ViewDirection(Axial)
{
  m_TipOffset[0] = 0.0f;
  m_TipOffset[1] = 0.0f;
  m_TipOffset[2] = 0.0f;</span>

<span style = "background-color:#fdd">  m_ToolTrajectory[0] = 0;
  m_ToolTrajectory[1] = 0;
  m_ToolTrajectory[2] = -1;</span>

<span style = "background-color:#fdd">  m_WorldVerticalVector[0] = 0.0;
  m_WorldVerticalVector[1] = 1.0;
  m_WorldVerticalVector[2] = 0.0;
}</span>

void mitk::NavigationDataSliceVisualization::SetToolTrajectory(Vector3D direction)
<span style = "background-color:#fdd">{
  if (Equal(direction.GetNorm(), 0.0))</span>
  {
<span style = "background-color:#fdd">    MITK_WARN &lt;&lt; "Ignoring invalid direction of projection: " &lt;&lt; direction;
    return;</span>
  }

<span style = "background-color:#fdd">  if (m_ToolTrajectory != direction)</span>
  {
<span style = "background-color:#fdd">    m_ToolTrajectory = direction;
    this-&gt;SetViewDirection(Oblique);
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::NavigationDataSliceVisualization::GenerateData()
<span style = "background-color:#fdd">{</span>
  // check if renderer was set
<span style = "background-color:#fdd">  if (m_Renderer.IsNull())</span>
  {
<span style = "background-color:#fdd">    itkExceptionMacro(&lt;&lt; "Renderer was not properly set");</span>
  }

  /* update outputs with tracking data from tools */
<span style = "background-color:#fdd">  unsigned int numberOfInputs = this-&gt;GetNumberOfInputs();
  if (numberOfInputs == 0)</span>
  {
<span style = "background-color:#fdd">    return;</span>
  }
<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; numberOfInputs ; ++i)</span>
  {
<span style = "background-color:#fdd">    NavigationData* output = this-&gt;GetOutput(i);
    assert(output);
    const NavigationData* input = this-&gt;GetInput(i);
    assert(input);</span>

<span style = "background-color:#fdd">    if (!input-&gt;IsDataValid())
      continue;</span>

<span style = "background-color:#fdd">    output-&gt;Graft(input); // First, copy all information from input to output
  }</span>

  // Nothing left to do if we don't have an input with valid data
<span style = "background-color:#fdd">  if (numberOfInputs == 0 || !this-&gt;GetInput()-&gt;IsDataValid())
    return;</span>

  // get position from NavigationData to move the slice to this position
<span style = "background-color:#fdd">  Point3D slicePosition = this-&gt;GetInput()-&gt;GetPosition();</span>

  {
<span style = "background-color:#fdd">    NavigationData::OrientationType orientation = this-&gt;GetInput()-&gt;GetOrientation();</span>

<span style = "background-color:#fdd">    Vector3D transformedTipOffset;
    transformedTipOffset.SetVnlVector(orientation.rotate(m_TipOffset.GetVnlVector()).as_ref());</span>

<span style = "background-color:#fdd">    slicePosition += transformedTipOffset;</span>

<span style = "background-color:#fdd">    mitk::SliceNavigationController::Pointer snc = m_Renderer-&gt;GetSliceNavigationController();</span>

<span style = "background-color:#fdd">    if (Axial == m_ViewDirection)</span>
    {
<span style = "background-color:#fdd">      snc-&gt;SetViewDirection(mitk::SliceNavigationController::Axial);
      snc-&gt;SelectSliceByPoint(slicePosition);
    }
    else if (Sagittal == m_ViewDirection)</span>
    {
<span style = "background-color:#fdd">      snc-&gt;SetViewDirection(mitk::SliceNavigationController::Sagittal);
      snc-&gt;SelectSliceByPoint(slicePosition);
    }
    else if (Frontal == m_ViewDirection)</span>
    {
<span style = "background-color:#fdd">      snc-&gt;SetViewDirection(mitk::SliceNavigationController::Frontal);
      snc-&gt;SelectSliceByPoint(slicePosition);
    }
    else if (AxialOblique == m_ViewDirection || SagittalOblique == m_ViewDirection)</span>
    {
<span style = "background-color:#fdd">      const int slicingPlaneXAxis = AxialOblique == m_ViewDirection ? 0 : 2;</span>

      // The column 0 is the slicing plane's x-axis, column 1 is the slicing plane's y-axis
<span style = "background-color:#fdd">      const mitk::PlaneGeometry::TransformType::MatrixType &amp;m =</span>
            m_Renderer-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetIndexToWorldTransform()-&gt;GetMatrix();

      // Rotate the tool trajectory vector into world coordinate frame (assuming
      // NavigationData has passed through a NavigationDataTransformFilter to
      // convert it into world coordinate frame)
<span style = "background-color:#fdd">      Vector3D slicingPlaneYAxisVector;
      slicingPlaneYAxisVector.SetVnlVector(orientation.rotate(m_ToolTrajectory.GetVnlVector()).as_ref());</span>

      // Project the tool trajectory onto the plane normal to x-axis of this
      // oblique slicing. This defines the y-axis ("up") of the oblique slicing
      // plane
<span style = "background-color:#fdd">      slicingPlaneYAxisVector[slicingPlaneXAxis] = 0.0;</span>

      // Do nothing for ambigous/undefined cases:
      //   - the R-L component of the x-axis is zero (for AxialOblique)
      //   - the S-I component of the x-axis is zero (for SagittalOblique)
      //   - the A-P component of the y-axis is zero
      if ( m(slicingPlaneXAxis,0) == 0.0 ||
           m(1,1) == 0.0 ||
           (slicingPlaneXAxis != 0 &amp;&amp; slicingPlaneYAxisVector[0] == 0.0) ||
<span style = "background-color:#fdd">           (slicingPlaneXAxis != 1 &amp;&amp; slicingPlaneYAxisVector[1] == 0.0) ||</span>
           (slicingPlaneXAxis != 2 &amp;&amp; slicingPlaneYAxisVector[2] == 0.0) )
      {
<span style = "background-color:#fdd">        return;</span>
      }

      // Maintain the A-P orientation of the slice's y-axis regardless of what
      // direction the tool trajectory points
      /// @todo&lt;C++11&gt; Use std::signbit
<span style = "background-color:#fdd">      if ( (m(1,1) &gt; 0) != (slicingPlaneYAxisVector[1] &gt; 0) )</span>
      {
<span style = "background-color:#fdd">        slicingPlaneYAxisVector *= -1;</span>
      }

<span style = "background-color:#fdd">      Vector3D slicingPlaneXAxisVector;
      slicingPlaneXAxisVector.Fill(0.0);</span>
      // For AxialOblique: maintain the Left/Right direction of the slice's x-axis
      // For SagittalOblique: maintain the Superior/Inferior direction of the slice's x-axis
      /// @todo&lt;C++11&gt; Use std::copysign
<span style = "background-color:#fdd">      slicingPlaneXAxisVector[slicingPlaneXAxis] = m(slicingPlaneXAxis,0) &gt; 0 ? 1.0 : -1.0;</span>

<span style = "background-color:#fdd">      Point3D origin;
      FillVector3D(origin, 0.0, 0.0, 0.0);
      snc-&gt;ReorientSlices(origin, slicingPlaneXAxisVector, slicingPlaneYAxisVector);
      snc-&gt;SelectSliceByPoint(slicePosition);
    }
    else if (Oblique == m_ViewDirection)</span>
    {
<span style = "background-color:#fdd">      Vector3D slicingPlaneNormalVector;
      slicingPlaneNormalVector.SetVnlVector(orientation.rotate(m_ToolTrajectory.GetVnlVector()).as_ref());</span>

      // The second column of the Index-to-World matrix is the positive y-axis
      // of the current slicing plane in world coordinates.
<span style = "background-color:#fdd">      const mitk::PlaneGeometry::TransformType::MatrixType &amp;m =</span>
            m_Renderer-&gt;GetCurrentWorldPlaneGeometry()-&gt;GetIndexToWorldTransform()-&gt;GetMatrix();
<span style = "background-color:#fdd">      mitk::Vector3D currentSlicingPlaneUpVector;
      mitk::FillVector3D(currentSlicingPlaneUpVector, m[0][1], m[1][1], m[2][1]);
      mitk::Vector3D worldUpVector = m_WorldVerticalVector;
      if (angle(worldUpVector.GetVnlVector(), currentSlicingPlaneUpVector.GetVnlVector()) &gt; vnl_math::pi_over_2 )</span>
      {
<span style = "background-color:#fdd">        worldUpVector *= -1;</span>
      }

<span style = "background-color:#fdd">      mitk::PlaneGeometry::Pointer slicingPlane = mitk::PlaneGeometry::New();
      Point3D origin;
      FillVector3D(origin, 0.0, 0.0, 0.0);
      slicingPlane-&gt;InitializePlane(origin, slicingPlaneNormalVector);</span>

      // Now that we have the direction of WorldVerticalVector chosen to be the
      // most "up" direction, project it onto the slicing plane to define the
      // up vector (y-axis) of the reoriented slices
<span style = "background-color:#fdd">      mitk::Vector3D slicingPlaneUpVector;
      if ( slicingPlane-&gt;Project(worldUpVector, slicingPlaneUpVector) )</span>
      {
        // slicingPlaneUpVector CROSS slicingPlaneNormalVector -&gt; slicingPlaneRightVector
        // Math is done in double precision as much as possible to get more
        // orthogonal right and up vectors which fixes a VNL SVD error when
        // the WorldGeometry matrix is later inverted
        itk::Vector&lt;double,3&gt; slicingPlaneUpVector_double;
<span style = "background-color:#fdd">        FillVector3D(slicingPlaneUpVector_double,</span>
                     slicingPlaneUpVector[0], slicingPlaneUpVector[1], slicingPlaneUpVector[2]);
        itk::Vector&lt;double,3&gt; slicingPlaneNormalVector_double;
<span style = "background-color:#fdd">        FillVector3D(slicingPlaneNormalVector_double,</span>
                     slicingPlaneNormalVector[0], slicingPlaneNormalVector[1], slicingPlaneNormalVector[2]);
<span style = "background-color:#fdd">        itk::Vector&lt;double,3&gt; slicingPlaneRightVector_double = itk::CrossProduct(slicingPlaneUpVector_double,</span>
                                                                                 slicingPlaneNormalVector_double);

<span style = "background-color:#fdd">        mitk::Vector3D slicingPlaneRightVector;
        mitk::FillVector3D(slicingPlaneRightVector,</span>
                           slicingPlaneRightVector_double[0], slicingPlaneRightVector_double[1], slicingPlaneRightVector_double[2]);
<span style = "background-color:#fdd">        mitk::FillVector3D(slicingPlaneUpVector,</span>
                           slicingPlaneUpVector_double[0], slicingPlaneUpVector_double[1], slicingPlaneUpVector_double[2]);

<span style = "background-color:#fdd">        snc-&gt;ReorientSlices(origin, slicingPlaneRightVector, slicingPlaneUpVector);
        snc-&gt;SelectSliceByPoint(slicePosition);</span>
      }
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt; "Unsupported ViewDirection: " &lt;&lt; m_ViewDirection;</span>
    }

<span style = "background-color:#fdd">    m_Renderer-&gt;RequestUpdate();
  }
}</span>
</pre>
	</body>
</html>