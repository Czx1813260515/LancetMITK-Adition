<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNavigationDataLandmarkTransformFilter.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef MITKNavigationDataLandmarkTransformFilter_H_HEADER_INCLUDED_
#define MITKNavigationDataLandmarkTransformFilter_H_HEADER_INCLUDED_

#include &lt;mitkNavigationDataToNavigationDataFilter.h&gt;
#include &lt;mitkPointSet.h&gt;
#include &lt;itkLandmarkBasedTransformInitializer.h&gt;
#include &lt;itkQuaternionRigidTransform.h&gt;
#include &lt;itkImage.h&gt;


namespace mitk {

  /**Documentation
  * \brief NavigationDataLandmarkTransformFilter applies a itk-landmark-transformation
  * defined by source and target pointsets.
  *
  * Before executing the filter SetSourceLandmarks and SetTargetLandmarks must be called. Before both source
  * and target landmarks are set, the filter performs an identity transform.
  * If source or target points are changed after calling SetXXXPoints, the corresponding SetXXXPoints
  * method has to be called again to apply the changes.
  * If UseICPInitialization is false (standard value, or set with SetUseICPInitialization(false) or UseICPInitializationOff())
  * then source landmarks and target landmarks with the same ID must correspond to each other.
  * (--&gt; source landmark with ID x will be mapped to target landmark with ID x).
  * If you do not know the correspondences, call SetUseICPInitialization(true) or UseICPInitializationOn()
  * to let the filter guess the correspondences during initialization with an iterative closest point search.
  * This is only possible, if at least 6 source and target landmarks are available.
  *
  * \ingroup IGT
  */
  class MITKIGT_EXPORT NavigationDataLandmarkTransformFilter : public NavigationDataToNavigationDataFilter
  {
  public:
<span style = "background-color:#fdd">    mitkClassMacro(NavigationDataLandmarkTransformFilter, NavigationDataToNavigationDataFilter);
    itkFactorylessNewMacro(Self);
    itkCloneMacro(Self);</span>

    typedef std::vector&lt;mitk::ScalarType&gt; ErrorVector;
    typedef itk::VersorRigid3DTransform&lt; double &gt; LandmarkTransformType;

    /**
    *\brief Set points used as source points for landmark transform.
    *
    */
    virtual void SetSourceLandmarks(mitk::PointSet::Pointer sourcePointSet);

    /**
    *\brief Set points used as target points for landmark transform
    *
    */
    virtual void SetTargetLandmarks(mitk::PointSet::Pointer targetPointSet);

    virtual bool IsInitialized() const;

    /**
    *\brief Returns the Fiducial Registration Error
    *
    */
    mitk::ScalarType GetFRE() const;

    /**
    *\brief Returns the standard deviation of the Fiducial Registration Error
    *
    */
    mitk::ScalarType GetFREStdDev() const;

    /**
    *\brief Returns the Root Mean Square of the registration error
    *
    */
    mitk::ScalarType GetRMSError() const;

    /**
    *\brief Returns the minimum registration error / best fitting landmark distance
    *
    */
    mitk::ScalarType GetMinError() const;

    /**
    *\brief Returns the maximum registration error / worst fitting landmark distance
    *
    */
    mitk::ScalarType GetMaxError() const;

    /**
    *\brief Returns the absolute maximum registration error
    *
    */
    mitk::ScalarType GetAbsMaxError() const;

    /**
    *\brief Returns a vector with the euclidean distance of each transformed source point to its respective target point
    *
    */
    const ErrorVector&amp; GetErrorVector() const;

<span style = "background-color:#fdd">    itkSetMacro(UseICPInitialization, bool); ///&lt; If set to true, source and target point correspondences are established with iterative closest point optimization
    itkGetMacro(UseICPInitialization, bool); ///&lt; If set to true, source and target point correspondences are established with iterative closest point optimization
    itkBooleanMacro(UseICPInitialization);   ///&lt; If set to true, source and target point correspondences are established with iterative closest point optimization</span>

<span style = "background-color:#fdd">    itkGetConstObjectMacro(LandmarkTransform, LandmarkTransformType);  ///&lt; returns the current landmark transform</span>

  protected:
    typedef itk::Image&lt; signed short, 3&gt;  ImageType;       // only because itk::LandmarkBasedTransformInitializer must be templated over two imagetypes

    typedef itk::LandmarkBasedTransformInitializer&lt; LandmarkTransformType, ImageType, ImageType &gt; TransformInitializerType;
    typedef TransformInitializerType::LandmarkPointContainer LandmarkPointContainer;
    typedef itk::QuaternionRigidTransform&lt;double&gt; QuaternionTransformType;

    /**
    * \brief Constructor
    **/
    NavigationDataLandmarkTransformFilter();
    ~NavigationDataLandmarkTransformFilter() override;

    /**
    * \brief transforms input NDs according to the calculated LandmarkTransform
    *
    */
    void GenerateData() override;

    /**Documentation
    * \brief perform an iterative closest point matching to find corresponding landmarks that will be used for landmark transform calculation
    *
    * Perform ICP optimization to match source landmarks to target landmarks. Landmark containers must contain
    * at least 6 landmarks for the optimization.
    * after ICP, landmark correspondences are established and the source landmarks are sorted, so that
    * corresponding landmarks have the same indices.
    *
    * \param[in,out] sources Source landmarks that will be mapped to the target landmarks. The sources container will be sorted,
    *                        so that landmarks have the same index as their corresponding target landmarks.
    * \param[in] targets Target landmarks onto which the source landmarks will be mapped
    * \return true if ICP was successful and sources are sorted , false otherwise
    */
    bool FindCorrespondentLandmarks(LandmarkPointContainer&amp; sources, const LandmarkPointContainer&amp; targets) const;

    /**
    * \brief initializes the transform using source and target PointSets
    *
    * if UseICPInitialization is true, FindCorrespondentLandmarks() will be used to sort the source landmarks in order to
    * establish corresponding landmark pairs before the landmark transform is build
    */
    void InitializeLandmarkTransform(LandmarkPointContainer&amp; sources, const LandmarkPointContainer&amp; targets);

    /**
    * \brief calculates the transform using source and target PointSets
    */
    void UpdateLandmarkTransform(const LandmarkPointContainer &amp;sources, const  LandmarkPointContainer &amp;targets); ///&lt;
    void AccumulateStatistics(ErrorVector&amp; vector); ///&lt; calculate error metrics for the transforms.

    void PrintSelf( std::ostream&amp; os, itk::Indent indent ) const override;     ///&lt; print object info to ostream

    mitk::ScalarType m_ErrorMean;     ///&lt; Fiducial Registration Error
    mitk::ScalarType m_ErrorStdDev;   ///&lt; standard deviation of the Fiducial Registration Error
    mitk::ScalarType m_ErrorRMS;      ///&lt; Root Mean Square of the registration error
    mitk::ScalarType m_ErrorMin;      ///&lt; minimum registration error / best fitting landmark distance
    mitk::ScalarType m_ErrorMax;      ///&lt; maximum registration error / worst fitting landmark distance
    mitk::ScalarType m_ErrorAbsMax;   ///&lt; the absolute maximum registration error

    LandmarkPointContainer m_SourcePoints;      ///&lt;  positions of the source points
    LandmarkPointContainer m_TargetPoints;      ///&lt;  positions of the target points
    TransformInitializerType::Pointer m_LandmarkTransformInitializer;     ///&lt;  landmark based transform initializer
    LandmarkTransformType::Pointer m_LandmarkTransform;               ///&lt;  transform calculated from source and target points

    QuaternionTransformType::Pointer m_QuatLandmarkTransform; ///&lt; transform needed to rotate orientation
    QuaternionTransformType::Pointer m_QuatTransform;         ///&lt; further transform needed to rotate orientation

    ErrorVector m_Errors; ///&lt; stores the euclidean distance of each transformed source landmark and its respective target landmark
    bool m_UseICPInitialization; ///&lt; find source &lt;--&gt; target point correspondences with iterative closest point optimization
  };
} // namespace mitk
#endif /* MITKNavigationDataLandmarkTransformFilter_H_HEADER_INCLUDED_ */</pre>
	</body>
</html>