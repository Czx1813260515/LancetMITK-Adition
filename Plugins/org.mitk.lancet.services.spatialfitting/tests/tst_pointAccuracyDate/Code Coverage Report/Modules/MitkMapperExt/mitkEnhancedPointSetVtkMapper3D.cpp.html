<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkEnhancedPointSetVtkMapper3D.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkEnhancedPointSetVtkMapper3D.h"

//#include &lt;sstream&gt;
#include &lt;algorithm&gt;

#include "mitkDataNode.h"
#include "mitkLookupTables.h"
#include "mitkProperties.h"

#include "mitkColorProperty.h"
//#include "mitkVtkPropRenderer.h"

#include &lt;vtkActor.h&gt;

#include &lt;vtkAssembly.h&gt;
#include &lt;vtkProp3DCollection.h&gt;
#include &lt;vtkTubeFilter.h&gt;

#include &lt;vtkConeSource.h&gt;
#include &lt;vtkCubeSource.h&gt;
#include &lt;vtkCylinderSource.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkSphereSource.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;

#include &lt;vtkPolyDataAlgorithm.h&gt;

#include &lt;mitkLookupTableProperty.h&gt;

const mitk::PointSet *mitk::EnhancedPointSetVtkMapper3D::GetInput()
<span style = "background-color:#fdd">{
  return static_cast&lt;const mitk::PointSet *&gt;(GetDataNode()-&gt;GetData());
}</span>

mitk::EnhancedPointSetVtkMapper3D::EnhancedPointSetVtkMapper3D()
<span style = "background-color:#fdd">{
  m_Contour = vtkActor::New();
  m_ContourSource = vtkTubeFilter::New();
  m_PropAssembly = vtkAssembly::New();
}</span>

vtkProp *mitk::EnhancedPointSetVtkMapper3D::GetVtkProp(mitk::BaseRenderer * /*renderer*/)
<span style = "background-color:#fdd">{
  return m_PropAssembly;
}</span>

mitk::EnhancedPointSetVtkMapper3D::~EnhancedPointSetVtkMapper3D()
<span style = "background-color:#fdd">{
  m_Contour-&gt;Delete();
  m_ContourSource-&gt;Delete();
  m_PropAssembly-&gt;Delete();</span>

  // TODO: do cleanup correctly

  // Clean up all remaining actors and poly-data sources
  // std::for_each(m_PointActors.begin(), m_PointActors.end(), &amp;mitk::EnhancedPointSetVtkMapper3D::DeleteVtkObject);

  //  std::for_each(m_SphereSources.begin(), m_SphereSources.end(),
  //  &amp;mitk::EnhancedPointSetVtgkMapper3D::DeleteVtkObject);
  //  std::for_each(m_CubeSources.begin(), m_CubeSources.end(), &amp;mitk::EnhancedPointSetVtkMapper3D::DeleteVtkObject);
  //  std::for_each(m_ConeSources.begin(), m_ConeSources.end(), &amp;mitk::EnhancedPointSetVtkMapper3D::DeleteVtkObject);
  //  std::for_each(m_CylinderSources.begin(), m_CylinderSources.end(),
  //  &amp;mitk::EnhancedPointSetVtkMapper3D::DeleteVtkObject);
  //
<span style = "background-color:#fdd">}</span>

void mitk::EnhancedPointSetVtkMapper3D::UpdateVtkObjects()
<span style = "background-color:#fdd">{</span>
  // get and update the PointSet
<span style = "background-color:#fdd">  const mitk::PointSet *pointset = this-&gt;GetInput();</span>
  // pointset-&gt;Update();
<span style = "background-color:#fdd">  int timestep = this-&gt;GetTimestep();</span>

<span style = "background-color:#fdd">  mitk::PointSet::DataType *itkPointSet = pointset-&gt;GetPointSet(timestep);
  mitk::PointSet::PointsContainer *points = itkPointSet-&gt;GetPoints();
  mitk::PointSet::PointDataContainer *pointData = itkPointSet-&gt;GetPointData();</span>

<span style = "background-color:#fdd">  assert(points-&gt;Size() == pointData-&gt;Size());</span>

<span style = "background-color:#fdd">  mitk::PointSet::PointsIterator pIt;
  mitk::PointSet::PointDataIterator pdIt;</span>

  /* search removed points and delete the corresponding source/actor/mapper objects */
<span style = "background-color:#fdd">  for (auto it = m_PointActors.begin(); it != m_PointActors.end();)</span>
  {
<span style = "background-color:#fdd">    PointIdentifier id = it-&gt;first;
    if (!points-&gt;IndexExists(id))</span>
    {
<span style = "background-color:#fdd">      this-&gt;RemoveEntryFromSourceMaps(id);
      m_PropAssembly-&gt;GetParts()-&gt;RemoveItem(it-&gt;second.first); // remove from prop assembly
      if (it-&gt;second.first != nullptr)
        it-&gt;second.first-&gt;Delete(); // Delete actor, which deletes mapper too (reference count)
      auto er = it;   // save iterator for deleting
      ++it;                         // advance iterator to next object
      m_PointActors.erase(</span>
        er); // erase element from map. This invalidates er, therefore we had to advance it before deletion.
<span style = "background-color:#fdd">    }</span>
    else
<span style = "background-color:#fdd">      ++it;
  }</span>

  /* iterate over each point in the pointset and create corresponding vtk objects */
<span style = "background-color:#fdd">  for (pIt = points-&gt;Begin(), pdIt = pointData-&gt;Begin(); pIt != itkPointSet-&gt;GetPoints()-&gt;End(); ++pIt, ++pdIt)</span>
  {
<span style = "background-color:#fdd">    PointIdentifier pointID = pIt-&gt;Index();
    assert(pointID == pdIt-&gt;Index());</span>

<span style = "background-color:#fdd">    mitk::PointSet::PointDataType data = pdIt-&gt;Value();</span>

<span style = "background-color:#fdd">    auto aIt = m_PointActors.find(pointID); // Does an actor exist for the point?</span>

    /* Create/Update sources for the point */
<span style = "background-color:#fdd">    vtkActor *a = nullptr;
    bool newPoint = (aIt == m_PointActors.end());                           // current point is new
    bool specChanged = (!newPoint &amp;&amp; data.pointSpec != aIt-&gt;second.second); // point spec of current point has changed</span>

<span style = "background-color:#fdd">    if (newPoint) // point did not exist before, we have to create vtk objects for it</span>
    {             // create actor and mapper for the new point
<span style = "background-color:#fdd">      a = vtkActor::New();
      vtkPolyDataMapper *m = vtkPolyDataMapper::New();
      a-&gt;SetMapper(m);
      m-&gt;UnRegister(nullptr);
      aIt = m_PointActors.insert(std::make_pair(pointID, std::make_pair(a, data.pointSpec)))</span>
              .first; // insert element and update actormap iterator to point to new element
<span style = "background-color:#fdd">      m_PropAssembly-&gt;AddPart(a);
    }</span>
    else
    {
<span style = "background-color:#fdd">      a = aIt-&gt;second.first;
      if (specChanged) // point exists, but point spec has changed</span>
      {
<span style = "background-color:#fdd">        this-&gt;RemoveEntryFromSourceMaps(pointID);</span>
      }
    }
<span style = "background-color:#fdd">    if (newPoint || specChanged) // new point OR existing point but point spec changed</span>
    {
<span style = "background-color:#fdd">      vtkPolyDataAlgorithm *source = nullptr; // works only in VTK 5+
      switch (data.pointSpec)              // add to new map</span>
      {                                    // TODO: look up representation in a representationlookuptable
        case PTSTART:                      // cube
<span style = "background-color:#fdd">          m_CubeSources[pointID] = vtkCubeSource::New();
          source = m_CubeSources[pointID];
          break;</span>
        case PTCORNER: // cone
<span style = "background-color:#fdd">          m_ConeSources[pointID] = vtkConeSource::New();
          source = m_ConeSources[pointID];
          break;</span>
        case PTEDGE: // cylinder
<span style = "background-color:#fdd">          m_CylinderSources[pointID] = vtkCylinderSource::New();
          source = m_CylinderSources[pointID];
          break;</span>
        case PTUNDEFINED: // sphere
        case PTEND:
        default:
<span style = "background-color:#fdd">          m_SphereSources[pointID] = vtkSphereSource::New();
          source = m_SphereSources[pointID];</span>
          break;
      }
<span style = "background-color:#fdd">      auto *m = dynamic_cast&lt;vtkPolyDataMapper *&gt;(a-&gt;GetMapper());
      assert(m != nullptr);
      m-&gt;SetInputConnection(source-&gt;GetOutputPort());
      aIt-&gt;second.second = data.pointSpec; // update point spec in actormap</span>
    }
<span style = "background-color:#fdd">  } // for each point
}</span>

void mitk::EnhancedPointSetVtkMapper3D::ApplyColorAndOpacityProperties(mitk::BaseRenderer *renderer,
                                                                       vtkActor * /*actor*/)
<span style = "background-color:#fdd">{
  this-&gt;UpdateVtkObjects();</span>

  /* iterate over all points in pointset and apply properties to corresponding vtk objects */
  // get and update the PointSet
<span style = "background-color:#fdd">  const mitk::PointSet *pointset = this-&gt;GetInput();
  int timestep = this-&gt;GetTimestep();
  mitk::PointSet::DataType *itkPointSet = pointset-&gt;GetPointSet(timestep);
  mitk::PointSet::PointsContainer *points = itkPointSet-&gt;GetPoints();
  mitk::PointSet::PointDataContainer *pointData = itkPointSet-&gt;GetPointData();
  assert(points-&gt;Size() == pointData-&gt;Size());
  mitk::PointSet::PointsIterator pIt;
  mitk::PointSet::PointDataIterator pdIt;
  mitk::DataNode *n = this-&gt;GetDataNode();
  assert(n != nullptr);</span>

<span style = "background-color:#fdd">  for (pIt = points-&gt;Begin(), pdIt = pointData-&gt;Begin(); pIt != itkPointSet-&gt;GetPoints()-&gt;End();
       ++pIt, ++pdIt) // for each point in the pointset</span>
  {
<span style = "background-color:#fdd">    PointIdentifier pointID = pIt-&gt;Index();
    assert(pointID == pdIt-&gt;Index());</span>

<span style = "background-color:#fdd">    mitk::PointSet::PointDataType data = pdIt-&gt;Value();</span>

<span style = "background-color:#fdd">    auto aIt = m_PointActors.find(pointID); // Does an actor exist for the point?
    assert(aIt != m_PointActors.end());                   // UpdateVtkObjects() must ensure that actor exists</span>

<span style = "background-color:#fdd">    vtkActor *a = aIt-&gt;second.first;
    assert(a != nullptr);</span>

    /* update properties */
    // visibility
<span style = "background-color:#fdd">    bool pointVisibility = true;
    bool visValueFound = false;
    mitk::BaseProperty *visProp = n-&gt;GetProperty("visibility", renderer);
    auto *visLTProp = dynamic_cast&lt;mitk::BoolLookupTableProperty *&gt;(visProp);
    if (visLTProp != nullptr)</span>
    {
<span style = "background-color:#fdd">      mitk::BoolLookupTable visLookupTable = visLTProp-&gt;GetValue();</span>
      // if (visLookupTable != nullptr)
      //{
      try
      {
<span style = "background-color:#fdd">        pointVisibility = visLookupTable.GetTableValue(pointID);
        visValueFound = true;</span>
      }
      catch (...)
<span style = "background-color:#fdd">      {
      }</span>
      //}
<span style = "background-color:#fdd">    }
    if (visValueFound == false)</span>
    {
<span style = "background-color:#fdd">      pointVisibility = n-&gt;IsVisible(renderer, "show points"); // use BoolProperty instead</span>
    }
<span style = "background-color:#fdd">    a-&gt;SetVisibility(pointVisibility);</span>

    // opacity
<span style = "background-color:#fdd">    float opacity = 1.0;
    bool opValueFound = false;
    mitk::BaseProperty *opProp = n-&gt;GetProperty("opacity", renderer);
    auto *opLTProp = dynamic_cast&lt;mitk::FloatLookupTableProperty *&gt;(opProp);
    if (opLTProp != nullptr)</span>
    {
<span style = "background-color:#fdd">      mitk::FloatLookupTable opLookupTable = opLTProp-&gt;GetValue();</span>
      // if (opLookupTable != nullptr)
      //{
      try
      {
<span style = "background-color:#fdd">        opacity = opLookupTable.GetTableValue(pointID);
        opValueFound = true;</span>
      }
      catch (...)
<span style = "background-color:#fdd">      {
      }</span>
      //}
<span style = "background-color:#fdd">    }
    if (opValueFound == false)</span>
    {
<span style = "background-color:#fdd">      n-&gt;GetOpacity(opacity, renderer);</span>
    }
<span style = "background-color:#fdd">    a-&gt;GetProperty()-&gt;SetOpacity(opacity);</span>
    ////////////////////// continue here ///////////////////

    // pointsize &amp; point position
<span style = "background-color:#fdd">    float pointSize = 1.0;
    n-&gt;GetFloatProperty("pointsize", pointSize, renderer);
    switch (data.pointSpec)</span>
    {               // TODO: look up representation in a representationlookuptable
      case PTSTART: // cube
<span style = "background-color:#fdd">        m_CubeSources[pointID]-&gt;SetXLength(pointSize);
        m_CubeSources[pointID]-&gt;SetYLength(pointSize);
        m_CubeSources[pointID]-&gt;SetZLength(pointSize);</span>
        // m_CubeSources[pointID]-&gt;SetCenter(pos[0], pos[1], pos[2]);
<span style = "background-color:#fdd">        break;</span>
      case PTCORNER: // cone
<span style = "background-color:#fdd">        m_ConeSources[pointID]-&gt;SetRadius(pointSize / 2);
        m_ConeSources[pointID]-&gt;SetHeight(pointSize);
        m_ConeSources[pointID]-&gt;SetResolution(2); // two crossed triangles. Maybe introduce an extra property for</span>
        // m_ConeSources[pointID]-&gt;SetCenter(pos[0], pos[1], pos[2]);
<span style = "background-color:#fdd">        break;</span>
      case PTEDGE: // cylinder
<span style = "background-color:#fdd">        m_CylinderSources[pointID]-&gt;SetRadius(pointSize / 2);
        m_CylinderSources[pointID]-&gt;SetHeight(pointSize);
        m_CylinderSources[pointID]-&gt;CappingOn();
        m_CylinderSources[pointID]-&gt;SetResolution(6);</span>
        // m_CylinderSources[pointID]-&gt;SetCenter(pos[0], pos[1], pos[2]);
<span style = "background-color:#fdd">        break;</span>
      case PTUNDEFINED: // sphere
      case PTEND:
      default:
<span style = "background-color:#fdd">        m_SphereSources[pointID]-&gt;SetRadius(pointSize / 2);
        m_SphereSources[pointID]-&gt;SetThetaResolution(10);
        m_SphereSources[pointID]-&gt;SetPhiResolution(10);</span>
        // m_SphereSources[pointID]-&gt;SetCenter(pos[0], pos[1], pos[2]);
        break;
    }

    // set position
<span style = "background-color:#fdd">    mitk::Point3D pos = pIt-&gt;Value();
    aIt-&gt;second.first-&gt;SetPosition(pos[0], pos[1], pos[2]);</span>

    // selectedcolor &amp; color
    float color[3];
<span style = "background-color:#fdd">    if (data.selected)</span>
    {
<span style = "background-color:#fdd">      if (!n-&gt;GetColor(color, renderer, "selectedcolor"))
        n-&gt;GetColor(color, renderer);
    }</span>
    else
    {
<span style = "background-color:#fdd">      mitk::BaseProperty *a = n-&gt;GetProperty("colorLookupTable", renderer);
      auto *b = dynamic_cast&lt;mitk::LookupTableProperty *&gt;(a);
      if (b != nullptr)</span>
      {
<span style = "background-color:#fdd">        mitk::LookupTable::Pointer c = b-&gt;GetLookupTable();
        vtkLookupTable *d = c-&gt;GetVtkLookupTable();
        double *e = d-&gt;GetTableValue(pointID);
        color[0] = e[0];
        color[1] = e[1];
        color[2] = e[2];
      }</span>
      else
      {
<span style = "background-color:#fdd">        if (!n-&gt;GetColor(color, renderer, "unselectedcolor"))
          n-&gt;GetColor(color, renderer);</span>
      }
    }

    // TODO: What about "color" property? 2D Mapper only uses unselected and selected color properties
<span style = "background-color:#fdd">    a-&gt;GetProperty()-&gt;SetColor(color[0], color[1], color[2]);</span>

    // TODO: label property
<span style = "background-color:#fdd">  }</span>
  // TODO test different pointSpec
  // TODO "line width" "show contour" "contourcolor" "contoursize" "close contour" "show label", "label"
  // TODO "show points" vs "visibility"  - is visibility evaluated at all? in a superclass maybe?
  // TODO create lookup tables for all properties that should be evaluated per point. also create editor widgets for
  // these lookup tables!
  // TODO check if property changes and pointset changes are reflected in the render window immediately.
  // TODO check behavior with large PointSets
  // TODO check for memory leaks on adding/deleting points
<span style = "background-color:#fdd">}</span>

void mitk::EnhancedPointSetVtkMapper3D::GenerateDataForRenderer(mitk::BaseRenderer *renderer)
<span style = "background-color:#fdd">{
  BaseLocalStorage *ls = m_LSH.GetLocalStorage(renderer);
  bool needGenerateData = ls-&gt;IsGenerateDataRequired(renderer, this, GetDataNode());</span>

<span style = "background-color:#fdd">  if (needGenerateData)</span>
  {
<span style = "background-color:#fdd">    ls-&gt;UpdateGenerateDataTime();
    this-&gt;UpdateVtkObjects();</span>
  }

<span style = "background-color:#fdd">  ApplyColorAndOpacityProperties(renderer, nullptr);
}</span>

void mitk::EnhancedPointSetVtkMapper3D::UpdateVtkTransform(mitk::BaseRenderer * /*renderer*/)
<span style = "background-color:#fdd">{</span>
  // TODO: apply new transform if time step changed

  // vtkLinearTransform * vtktransform =
  //  this-&gt;GetDataNode()-&gt;GetVtkTransform(this-&gt;GetTimestep());

  // m_SelectedActor-&gt;SetUserTransform(vtktransform);
  // m_UnselectedActor-&gt;SetUserTransform(vtktransform);
  // m_ContourActor-&gt;SetUserTransform(vtktransform);
<span style = "background-color:#fdd">}</span>

void mitk::EnhancedPointSetVtkMapper3D::SetDefaultProperties(mitk::DataNode *node,
                                                             mitk::BaseRenderer *renderer,
                                                             bool overwrite)
<span style = "background-color:#fdd">{
  node-&gt;AddProperty("line width", mitk::IntProperty::New(2), renderer, overwrite);
  node-&gt;AddProperty("pointsize", mitk::FloatProperty::New(1.0), renderer, overwrite);
  node-&gt;AddProperty(</span>
    "selectedcolor", mitk::ColorProperty::New(1.0f, 1.0f, 0.0f), renderer, overwrite); // yellow for selected
<span style = "background-color:#fdd">  node-&gt;AddProperty(</span>
    "unselectedcolor", mitk::ColorProperty::New(0.5f, 1.0f, 0.5f), renderer, overwrite); // middle green for unselected
<span style = "background-color:#fdd">  node-&gt;AddProperty("color", mitk::ColorProperty::New(1.0f, 0.0f, 0.0f), renderer, overwrite); // red as standard
  node-&gt;AddProperty("show contour", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("contourcolor", mitk::ColorProperty::New(1.0f, 0.0f, 0.0f), renderer, overwrite);
  node-&gt;AddProperty("contoursize", mitk::FloatProperty::New(0.5), renderer, overwrite);
  node-&gt;AddProperty("show points", mitk::BoolProperty::New(true), renderer, overwrite);
  node-&gt;AddProperty("show label", mitk::BoolProperty::New(false), renderer, overwrite);
  node-&gt;AddProperty("label", mitk::StringProperty::New("P"), renderer, overwrite);
  node-&gt;AddProperty("opacity", mitk::FloatProperty::New(1.0), renderer, overwrite);
  Superclass::SetDefaultProperties(node, renderer, overwrite);
}</span>

void mitk::EnhancedPointSetVtkMapper3D::DeleteVtkObject(vtkObject *o)
<span style = "background-color:#fdd">{
  if (o != nullptr)
    o-&gt;Delete();
}</span>

void mitk::EnhancedPointSetVtkMapper3D::RemoveEntryFromSourceMaps(mitk::PointSet::PointIdentifier pointID)
<span style = "background-color:#fdd">{
  auto aIt = m_PointActors.find(pointID);
  if (aIt == m_PointActors.end())
    return;</span>

<span style = "background-color:#fdd">  switch (aIt-&gt;second.second) // erase in old map</span>
  {                           // TODO: look up representation in a representationlookuptable
    case PTSTART:             // cube
<span style = "background-color:#fdd">      m_CubeSources[pointID]-&gt;Delete();
      m_CubeSources.erase(pointID);
      break;</span>

    case PTCORNER: // cone
<span style = "background-color:#fdd">      m_ConeSources[pointID]-&gt;Delete();
      m_ConeSources.erase(pointID);
      break;</span>

    case PTEDGE: // cylinder
<span style = "background-color:#fdd">      m_CylinderSources[pointID]-&gt;Delete();
      m_CylinderSources.erase(pointID);
      break;</span>

    case PTUNDEFINED: // sphere
    case PTEND:
    default:
<span style = "background-color:#fdd">      m_SphereSources[pointID]-&gt;Delete();
      m_SphereSources.erase(pointID);</span>
      break;
  }
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>