<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkUnstructuredGridClusteringFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include &lt;mitkUnstructuredGridClusteringFilter.h&gt;

#include &lt;vector&gt;

#include &lt;vtkDataArray.h&gt;
#include &lt;vtkDelaunay3D.h&gt;
#include &lt;vtkDoubleArray.h&gt;
#include &lt;vtkPointData.h&gt;
#include &lt;vtkPointLocator.h&gt;
#include &lt;vtkPoints.h&gt;
#include &lt;vtkPolyVertex.h&gt;
#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkUnstructuredGrid.h&gt;
#include &lt;vtkVariant.h&gt;

mitk::UnstructuredGridClusteringFilter::UnstructuredGridClusteringFilter()
<span style = "background-color:#fdd">  : m_eps(5.0), m_MinPts(4), m_Meshing(false), m_DistCalc(false)
{
  this-&gt;m_UnstructGrid = mitk::UnstructuredGrid::New();
}</span>

mitk::UnstructuredGridClusteringFilter::~UnstructuredGridClusteringFilter()
<span style = "background-color:#fdd">{
}</span>

<span style = "background-color:#dfd">std::map&lt;int, bool&gt; visited;
std::map&lt;int, bool&gt; isNoise;
std::map&lt;int, bool&gt; clusterMember;
vtkSmartPointer&lt;vtkPointLocator&gt; pLocator;
std::vector&lt;vtkSmartPointer&lt;vtkPoints&gt;&gt; clusterVector;</span>

<span style = "background-color:#dfd">std::vector&lt;std::vector&lt;int&gt;&gt; clustersPointsIDs;</span>

void mitk::UnstructuredGridClusteringFilter::GenerateOutputInformation()
<span style = "background-color:#fdd">{
  m_UnstructGrid = this-&gt;GetOutput();
}</span>

void mitk::UnstructuredGridClusteringFilter::GenerateData()
<span style = "background-color:#fdd">{
  mitk::UnstructuredGrid::Pointer inputGrid = const_cast&lt;mitk::UnstructuredGrid *&gt;(this-&gt;GetInput());
  if (inputGrid.IsNull())
    return;</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkUnstructuredGrid&gt; vtkInpGrid = inputGrid-&gt;GetVtkUnstructuredGrid();
  vtkSmartPointer&lt;vtkPoints&gt; inpPoints = vtkInpGrid-&gt;GetPoints();
  pLocator = vtkSmartPointer&lt;vtkPointLocator&gt;::New();</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkDoubleArray&gt; distances = vtkSmartPointer&lt;vtkDoubleArray&gt;::New();
  if (inputGrid-&gt;GetVtkUnstructuredGrid()-&gt;GetPointData()-&gt;GetNumberOfArrays() &gt; 0)</span>
  {
<span style = "background-color:#fdd">    m_DistCalc = true;
    distances = dynamic_cast&lt;vtkDoubleArray *&gt;(vtkInpGrid-&gt;GetPointData()-&gt;GetArray(0));</span>
  }

<span style = "background-color:#fdd">  pLocator-&gt;SetDataSet(vtkInpGrid);
  pLocator-&gt;AutomaticOn();
  pLocator-&gt;SetNumberOfPointsPerBucket(2);
  pLocator-&gt;BuildLocator();</span>

  // fill the visited map with false for checking
<span style = "background-color:#fdd">  for (int i = 0; i &lt; inpPoints-&gt;GetNumberOfPoints(); i++)</span>
  {
<span style = "background-color:#fdd">    visited[i] = false;
    isNoise[i] = false;
    clusterMember[i] = false;
  }</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; inpPoints-&gt;GetNumberOfPoints(); i++)</span>
  {
<span style = "background-color:#fdd">    if (!visited[i])</span>
    {
<span style = "background-color:#fdd">      visited[i] = true;                                                       // mark P as visited
      vtkSmartPointer&lt;vtkIdList&gt; idList = vtkSmartPointer&lt;vtkIdList&gt;::New();   // represent N
      pLocator-&gt;FindPointsWithinRadius(m_eps, inpPoints-&gt;GetPoint(i), idList); // N = D.regionQuery(P, eps)
      if (idList-&gt;GetNumberOfIds() &lt; m_MinPts)                                 // if sizeof(N) &lt; MinPts</span>
      {
<span style = "background-color:#fdd">        isNoise[i] = true; // mark P as NOISE
      }</span>
      else
      {
<span style = "background-color:#fdd">        vtkSmartPointer&lt;vtkPoints&gt; cluster = vtkSmartPointer&lt;vtkPoints&gt;::New(); // represent a cluster
        clusterVector.push_back(cluster);                                       // C = next cluster
        this-&gt;ExpandCluster(</span>
          i, idList, cluster, inpPoints); // expandCluster(P, N, C, eps, MinPts) mod. the parameter list
<span style = "background-color:#fdd">      }
    }
  }</span>

  // OUTPUT LOGIC
<span style = "background-color:#fdd">  m_Clusters = clusterVector;
  int numberOfClusterPoints = 0;
  int IdOfBiggestCluster = 0;</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; m_Clusters.size(); i++)</span>
  {
<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkDoubleArray&gt; array = vtkSmartPointer&lt;vtkDoubleArray&gt;::New();
    vtkSmartPointer&lt;vtkPoints&gt; points = m_Clusters.at(i);
    if (m_DistCalc)</span>
    {
<span style = "background-color:#fdd">      array-&gt;SetNumberOfComponents(1);
      array-&gt;SetNumberOfTuples(points-&gt;GetNumberOfPoints());
      for (int j = 0; j &lt; points-&gt;GetNumberOfPoints(); j++)</span>
      {
        double point[3];
<span style = "background-color:#fdd">        points-&gt;GetPoint(j, point);
        if (clustersPointsIDs.at(i).at(j) &lt; inpPoints-&gt;GetNumberOfPoints())</span>
        {
<span style = "background-color:#fdd">          if (distances-&gt;GetValue(clustersPointsIDs.at(i).at(j)) &gt; 0.001)</span>
          {
<span style = "background-color:#fdd">            double dist[1] = {distances-&gt;GetValue(clustersPointsIDs.at(i).at(j))};
            array-&gt;SetTuple(j, dist);
          }</span>
          else
          {
<span style = "background-color:#fdd">            double dist[1] = {0.0};
            array-&gt;SetTuple(j, dist);</span>
          }
        }
<span style = "background-color:#fdd">      }
      m_DistanceArrays.push_back(array);</span>
    }
<span style = "background-color:#fdd">    if (points-&gt;GetNumberOfPoints() &gt; numberOfClusterPoints)</span>
    {
<span style = "background-color:#fdd">      numberOfClusterPoints = points-&gt;GetNumberOfPoints();
      IdOfBiggestCluster = i;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkUnstructuredGrid&gt; biggestCluster = vtkSmartPointer&lt;vtkUnstructuredGrid&gt;::New();</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPoints&gt; points = vtkSmartPointer&lt;vtkPoints&gt;::New();
  points = m_Clusters.at(IdOfBiggestCluster);</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPolyVertex&gt; verts = vtkSmartPointer&lt;vtkPolyVertex&gt;::New();
  verts-&gt;GetPointIds()-&gt;SetNumberOfIds(m_Clusters.at(IdOfBiggestCluster)-&gt;GetNumberOfPoints());
  for (int i = 0; i &lt; m_Clusters.at(IdOfBiggestCluster)-&gt;GetNumberOfPoints(); i++)</span>
  {
<span style = "background-color:#fdd">    verts-&gt;GetPointIds()-&gt;SetId(i, i);
  }</span>

<span style = "background-color:#fdd">  biggestCluster-&gt;Allocate(1);
  biggestCluster-&gt;InsertNextCell(verts-&gt;GetCellType(), verts-&gt;GetPointIds());
  biggestCluster-&gt;SetPoints(m_Clusters.at(IdOfBiggestCluster));</span>

<span style = "background-color:#fdd">  if (m_Meshing)</span>
  {
<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkDelaunay3D&gt; mesher = vtkSmartPointer&lt;vtkDelaunay3D&gt;::New();
    mesher-&gt;SetInputData(biggestCluster);
    mesher-&gt;SetAlpha(0.9);
    mesher-&gt;Update();</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkUnstructuredGrid&gt; output = mesher-&gt;GetOutput();
    m_UnstructGrid-&gt;SetVtkUnstructuredGrid(output);
  }</span>
  else
  {
<span style = "background-color:#fdd">    m_UnstructGrid-&gt;SetVtkUnstructuredGrid(biggestCluster);</span>
  }

<span style = "background-color:#fdd">  clusterVector.clear();
  clustersPointsIDs.clear();
}</span>

void mitk::UnstructuredGridClusteringFilter::ExpandCluster(int id,
                                                           vtkIdList *pointIDs,
                                                           vtkPoints *cluster,
                                                           vtkPoints *inpPoints)
<span style = "background-color:#fdd">{
  std::vector&lt;int&gt; x;
  x.push_back(id);
  cluster-&gt;InsertNextPoint(inpPoints-&gt;GetPoint(id)); // add P to cluster C
  clusterMember[id] = true;</span>

<span style = "background-color:#fdd">  vtkSmartPointer&lt;vtkPoints&gt; neighbours = vtkSmartPointer&lt;vtkPoints&gt;::New(); // same N as in other function
  inpPoints-&gt;GetPoints(pointIDs, neighbours);</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; pointIDs-&gt;GetNumberOfIds(); i++) // for each point P' in N</span>
  {
<span style = "background-color:#fdd">    if (!visited[pointIDs-&gt;GetId(i)]) // if P' is not visited</span>
    {
<span style = "background-color:#fdd">      visited[pointIDs-&gt;GetId(i)] = true;                                    // mark P' as visited
      vtkSmartPointer&lt;vtkIdList&gt; idList = vtkSmartPointer&lt;vtkIdList&gt;::New(); // represent N'
      pLocator-&gt;FindPointsWithinRadius(</span>
        m_eps, inpPoints-&gt;GetPoint(pointIDs-&gt;GetId(i)), idList); // N' = D.regionQuery(P', eps)

<span style = "background-color:#fdd">      if (idList-&gt;GetNumberOfIds() &gt;= m_MinPts) // if sizeof(N') &gt;= MinPts</span>
      {
<span style = "background-color:#fdd">        for (int j = 0; j &lt; idList-&gt;GetNumberOfIds(); j++) // N = N joined with N'</span>
        {
<span style = "background-color:#fdd">          if (idList-&gt;GetId(j) &lt; inpPoints-&gt;GetNumberOfPoints()) // a litte bit hacked ?!</span>
          {
<span style = "background-color:#fdd">            pointIDs-&gt;InsertNextId(idList-&gt;GetId(j));</span>
          }
<span style = "background-color:#fdd">        }</span>
      }
<span style = "background-color:#fdd">    }
    if (!clusterMember[pointIDs-&gt;GetId(i)]) // if P' is not yet member of any cluster</span>
    {
<span style = "background-color:#fdd">      if (pointIDs-&gt;GetId(i) &lt; inpPoints-&gt;GetNumberOfPoints())</span>
      {
<span style = "background-color:#fdd">        clusterMember[pointIDs-&gt;GetId(i)] = true;
        x.push_back(pointIDs-&gt;GetId(i));
        cluster-&gt;InsertNextPoint(inpPoints-&gt;GetPoint(pointIDs-&gt;GetId(i))); // add P' to cluster C</span>
      }
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  clustersPointsIDs.push_back(x);
}</span>

std::vector&lt;mitk::UnstructuredGrid::Pointer&gt; mitk::UnstructuredGridClusteringFilter::GetAllClusters()
<span style = "background-color:#fdd">{
  std::vector&lt;mitk::UnstructuredGrid::Pointer&gt; mitkUGridVector;</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; m_Clusters.size(); i++)</span>
  {
<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkUnstructuredGrid&gt; cluster = vtkSmartPointer&lt;vtkUnstructuredGrid&gt;::New();</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPoints&gt; points = m_Clusters.at(i);</span>

<span style = "background-color:#fdd">    vtkSmartPointer&lt;vtkPolyVertex&gt; verts = vtkSmartPointer&lt;vtkPolyVertex&gt;::New();</span>

<span style = "background-color:#fdd">    verts-&gt;GetPointIds()-&gt;SetNumberOfIds(points-&gt;GetNumberOfPoints());
    for (int j = 0; j &lt; points-&gt;GetNumberOfPoints(); j++)</span>
    {
<span style = "background-color:#fdd">      verts-&gt;GetPointIds()-&gt;SetId(j, j);
    }</span>

<span style = "background-color:#fdd">    cluster-&gt;Allocate(1);
    cluster-&gt;InsertNextCell(verts-&gt;GetCellType(), verts-&gt;GetPointIds());
    cluster-&gt;SetPoints(points);
    if (m_DistCalc)</span>
    {
<span style = "background-color:#fdd">      cluster-&gt;GetPointData()-&gt;AddArray(m_DistanceArrays.at(i));</span>
    }

<span style = "background-color:#fdd">    mitk::UnstructuredGrid::Pointer mitkGrid = mitk::UnstructuredGrid::New();</span>

<span style = "background-color:#fdd">    if (m_Meshing)</span>
    {
<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkDelaunay3D&gt; mesher = vtkSmartPointer&lt;vtkDelaunay3D&gt;::New();
      mesher-&gt;SetInputData(cluster);
      mesher-&gt;SetAlpha(0.9);
      mesher-&gt;Update();</span>

<span style = "background-color:#fdd">      vtkSmartPointer&lt;vtkUnstructuredGrid&gt; output = mesher-&gt;GetOutput();
      mitkGrid-&gt;SetVtkUnstructuredGrid(output);
    }</span>
    else
    {
<span style = "background-color:#fdd">      mitkGrid-&gt;SetVtkUnstructuredGrid(cluster);</span>
    }

<span style = "background-color:#fdd">    mitkUGridVector.push_back(mitkGrid);
  }</span>

<span style = "background-color:#fdd">  return mitkUGridVector;
}</span>

int mitk::UnstructuredGridClusteringFilter::GetNumberOfFoundClusters()
<span style = "background-color:#fdd">{
  return m_Clusters.size();
}</span></pre>
	</body>
</html>