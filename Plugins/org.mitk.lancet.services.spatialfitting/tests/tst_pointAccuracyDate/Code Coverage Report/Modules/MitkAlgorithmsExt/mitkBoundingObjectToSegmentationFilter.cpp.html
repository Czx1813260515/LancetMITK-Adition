<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkBoundingObjectToSegmentationFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/
#include "mitkBoundingObjectToSegmentationFilter.h"
#include "mitkImageCast.h"

#include &lt;itkImageRegionIteratorWithIndex.h&gt;

mitk::BoundingObjectToSegmentationFilter::BoundingObjectToSegmentationFilter()
<span style = "background-color:#fdd">{
  this-&gt;SetNumberOfRequiredInputs(1);
}</span>

mitk::BoundingObjectToSegmentationFilter::~BoundingObjectToSegmentationFilter()
<span style = "background-color:#fdd">{
}</span>

void mitk::BoundingObjectToSegmentationFilter::SetBoundingObject(mitk::BoundingObject::Pointer boundingObject)
<span style = "background-color:#fdd">{
  auto *testgroup = dynamic_cast&lt;mitk::BoundingObjectGroup *&gt;(boundingObject.GetPointer());
  if (testgroup)
    m_boundingObjectGroup = testgroup;</span>
  else
  {
<span style = "background-color:#fdd">    m_boundingObjectGroup = mitk::BoundingObjectGroup::New();
    m_boundingObjectGroup-&gt;AddBoundingObject(boundingObject);</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::BoundingObjectToSegmentationFilter::GenerateData()
<span style = "background-color:#fdd">{</span>
  typedef itk::Image&lt;unsigned char, 3&gt; itkImageType;
<span style = "background-color:#fdd">  mitk::Image::Pointer outputImage = this-&gt;GetOutput();
  mitk::Image::ConstPointer inputImage = this-&gt;GetInput();
  outputImage-&gt;Initialize(inputImage);</span>

<span style = "background-color:#fdd">  itkImageType::Pointer itkImage;
  CastToItkImage(outputImage, itkImage);
  itkImage-&gt;FillBuffer(0);</span>

<span style = "background-color:#fdd">  for (unsigned int i = 0; i &lt; m_boundingObjectGroup-&gt;GetCount(); i++)</span>
  {
    // create region for boundingobject
<span style = "background-color:#fdd">    mitk::BoundingObject::Pointer boundingObject = m_boundingObjectGroup-&gt;GetBoundingObjects().at(i);
    mitk::BaseGeometry::Pointer boGeometry = boundingObject-&gt;GetGeometry();
    mitk::BaseGeometry::Pointer inputImageGeometry = inputImage-&gt;GetSlicedGeometry();
    mitk::BoundingBox::Pointer boToIm =</span>
      boGeometry-&gt;CalculateBoundingBoxRelativeToTransform(inputImageGeometry-&gt;GetIndexToWorldTransform());

<span style = "background-color:#fdd">    mitk::BoundingBox::ConstPointer imgBB = inputImageGeometry-&gt;GetBoundingBox();
    mitk::BoundingBox::PointType minImg = imgBB-&gt;GetMinimum();
    mitk::BoundingBox::PointType maxImg = imgBB-&gt;GetMaximum();</span>

    itkImageType::IndexType boIndex;
    itkImageType::SizeType boSize;

<span style = "background-color:#fdd">    mitk::BoundingBox::PointType min = boToIm-&gt;GetMinimum();
    mitk::BoundingBox::PointType max = boToIm-&gt;GetMaximum();</span>

    // check if boundingbox is inside imageregion
<span style = "background-color:#fdd">    for (int i = 0; i &lt; 3; i++)</span>
    {
<span style = "background-color:#fdd">      if (min[i] &lt; minImg[i])
        min[i] = minImg[i];
      if (max[i] &lt; minImg[i])
        max[i] = minImg[i];
      if (max[i] &gt; maxImg[i])
        max[i] = maxImg[i];
      if (min[i] &gt; maxImg[i])
        min[i] = maxImg[i] - 1;
    }</span>

    // add 0.5 (boGeometry is no image geometry)
<span style = "background-color:#fdd">    boIndex[0] = (mitk::SlicedData::IndexType::IndexValueType)(min[0] + 0.5);
    boIndex[1] = (mitk::SlicedData::IndexType::IndexValueType)(min[1] + 0.5);
    boIndex[2] = (mitk::SlicedData::IndexType::IndexValueType)(min[2] + 0.5);</span>

    // add 1 because we need 0.5 for each index
<span style = "background-color:#fdd">    boSize[0] = (mitk::SlicedData::IndexType::IndexValueType)(max[0] - min[0]);
    boSize[1] = (mitk::SlicedData::IndexType::IndexValueType)(max[1] - min[1]);
    boSize[2] = (mitk::SlicedData::IndexType::IndexValueType)(max[2] - min[2]);</span>

<span style = "background-color:#fdd">    itkImageType::RegionType region(boIndex, boSize);</span>

    // create region iterator
<span style = "background-color:#fdd">    itk::ImageRegionIteratorWithIndex&lt;itkImageType&gt; itBoundingObject =</span>
      itk::ImageRegionIteratorWithIndex&lt;itkImageType&gt;(itkImage, region);
<span style = "background-color:#fdd">    itBoundingObject.GoToBegin();</span>

<span style = "background-color:#fdd">    while (!itBoundingObject.IsAtEnd())</span>
    {
<span style = "background-color:#fdd">      itkImageType::IndexType index = itBoundingObject.GetIndex();
      mitk::Point3D p;
      p[0] = index[0];
      p[1] = index[1];
      p[2] = index[2];
      inputImageGeometry-&gt;IndexToWorld(p, p);</span>

<span style = "background-color:#fdd">      if (boundingObject-&gt;IsInside(p) &amp;&amp; boundingObject-&gt;GetPositive())
        itBoundingObject.Set(1);
      else if (boundingObject-&gt;IsInside(p) &amp;&amp; !boundingObject-&gt;GetPositive())
        itBoundingObject.Set(0);</span>

<span style = "background-color:#fdd">      ++itBoundingObject;
    }
  }
  CastToMitkImage(itkImage, outputImage);
}</span></pre>
	</body>
</html>