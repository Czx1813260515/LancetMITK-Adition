<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkUnstructuredGridClusteringFilter.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef _MITKUNSTRUCTUREDGRIDCLUSTERINGFILTER_h__
#define _MITKUNSTRUCTUREDGRIDCLUSTERINGFILTER_h__

#include &lt;MitkAlgorithmsExtExports.h&gt;

#include &lt;mitkCommon.h&gt;

#include &lt;mitkUnstructuredGrid.h&gt;
#include &lt;mitkUnstructuredGridToUnstructuredGridFilter.h&gt;
#include &lt;vtkIdList.h&gt;
#include &lt;vtkPoints.h&gt;
#include &lt;vtkSmartPointer.h&gt;

namespace mitk
{
  /**
  * @brief This filter uses the DBSCAN algorithm for clustering an
  * mitk::UnstructuredGrid. "MinPts" defines the number of neighbours which are
  * required to be a kernel point if a point is in range of a kernel point
  * but hasnt enough neighbours this point is added to the cluster but is a
  * density reachable point and the cluster ends at this point. "eps" is the
  * range in which the neighbours are searched. If "Meshing" is set the
  * clusteres UnstructuredGrid is meshed and visible in 2D renderwindows.
  *
  * DBSCAN algorithm:
  *
  *     DBSCAN(D, eps, MinPts)
  *     C = 0
  *     for each unvisited point P in dataset D
  *       mark P as visited
  *       N = D.regionQuery(P, eps)
  *       if sizeof(N) &lt; MinPts
  *         mark P as NOISE
  *       else
  *         C = next cluster
  *         expandCluster(P, N, C, eps, MinPts)
  *
  *     expandCluster(P, N, C, eps, MinPts)
  *       add P to cluster C
  *       for each point P' in N
  *         if P' is not visited
  *           mark P' as visited
  *           N' = D.regionQuery(P', eps)
  *           if sizeof(N') &gt;= MinPts
  *             N = N joined with N'
  *         if P' is not yet member of any cluster
  *           add P' to cluster C
  */

  class MITKALGORITHMSEXT_EXPORT UnstructuredGridClusteringFilter : public UnstructuredGridToUnstructuredGridFilter
  {
  public:
<span style = "background-color:#fdd">    mitkClassMacro(UnstructuredGridClusteringFilter, UnstructuredGridToUnstructuredGridFilter);
    itkFactorylessNewMacro(Self);
    itkCloneMacro(Self);</span>

      /** Sets the distance for the neighbour search */
<span style = "background-color:#fdd">      itkSetMacro(eps, double);
      itkGetMacro(eps, double);</span>

      /** Sets the number of required neighbours */
<span style = "background-color:#fdd">      itkSetMacro(MinPts, int);
      itkGetMacro(MinPts, int);</span>

      /** If activated the clusteres UnstructuredGrid is meshed */
<span style = "background-color:#fdd">      itkSetMacro(Meshing, bool);</span>

      /** Returns all clusters as UnstructuredGrids which were found */
      virtual std::vector&lt;mitk::UnstructuredGrid::Pointer&gt; GetAllClusters();

    /** Returns the number of the clusters which were found */
    virtual int GetNumberOfFoundClusters();

  protected:
    /** Constructor */
    UnstructuredGridClusteringFilter();

    /** Destructor */
    ~UnstructuredGridClusteringFilter() override;

    /** Defines the output of the filter */
    void GenerateOutputInformation() override;

    /** Is called by the Update() method */
    void GenerateData() override;

  private:
    /** Used for the DBSCAN algorithm to expand a cluster and add more points to it */
    void ExpandCluster(int id, vtkIdList *pointIDs, vtkPoints *cluster, vtkPoints *inpPoints);

    /** The result main Cluster */
    mitk::UnstructuredGrid::Pointer m_UnstructGrid;

    /** All clusters which were found */
    std::vector&lt;vtkSmartPointer&lt;vtkPoints&gt;&gt; m_Clusters;

    /** The distances of the points from the input UnstructuredGrid*/
    std::vector&lt;vtkSmartPointer&lt;vtkDoubleArray&gt;&gt; m_DistanceArrays;

    /** The range for the neighbout search */
    double m_eps;

    /** The number of the required neighbours */
    int m_MinPts;

    /** Activates the meshing for the UnstructuredGrid clusters*/
    bool m_Meshing;

    /** If its activated the distance of the clusters is used instead of the
    * size */
    bool m_DistCalc;
  };

} // namespace mitk

#endif //_MITKUNSTRUCTUREDGRIDCLUSTERINGFILTER_h__</pre>
	</body>
</html>