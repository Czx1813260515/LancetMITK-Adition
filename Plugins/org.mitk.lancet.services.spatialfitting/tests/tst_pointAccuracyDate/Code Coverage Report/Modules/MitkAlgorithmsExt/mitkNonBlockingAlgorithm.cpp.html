<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkNonBlockingAlgorithm.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkNonBlockingAlgorithm.h"
#include "mitkCallbackFromGUIThread.h"
#include "mitkDataStorage.h"
#include &lt;itkCommand.h&gt;

namespace mitk
{
<span style = "background-color:#fdd">  NonBlockingAlgorithm::NonBlockingAlgorithm() : m_UpdateRequests(0), m_KillRequest(false)
  {
    m_Parameters = PropertyList::New();
  }</span>

  NonBlockingAlgorithm::~NonBlockingAlgorithm()
<span style = "background-color:#fdd">  {
    if (m_Thread.joinable())
      m_Thread.detach();
  }</span>

<span style = "background-color:#fdd">  void mitk::NonBlockingAlgorithm::SetDataStorage(DataStorage &amp;storage) { m_DataStorage = &amp;storage; }
  DataStorage *mitk::NonBlockingAlgorithm::GetDataStorage() { return m_DataStorage.Lock(); }</span>
  void NonBlockingAlgorithm::Initialize(const NonBlockingAlgorithm *itkNotUsed(other))
<span style = "background-color:#fdd">  {</span>
    // define one input, one output basedata object

    // some basedata input - image, surface, whatever
<span style = "background-color:#fdd">    BaseData::Pointer input;
    SetPointerParameter("Input", input);</span>

    // some basedata output
<span style = "background-color:#fdd">    BaseData::Pointer output;
    SetPointerParameter("Output", output);
  }</span>

  void NonBlockingAlgorithm::SetPointerParameter(const char *parameter, BaseData *value)
<span style = "background-color:#fdd">  {
    m_ParameterListMutex.lock();
    m_Parameters-&gt;SetProperty(parameter, SmartPointerProperty::New(value));
    m_ParameterListMutex.unlock();
  }</span>

  void NonBlockingAlgorithm::DefineTriggerParameter(const char *parameter)
<span style = "background-color:#fdd">  {
    BaseProperty *value = m_Parameters-&gt;GetProperty(parameter);
    if (value &amp;&amp; m_TriggerPropertyConnections.find(parameter) == m_TriggerPropertyConnections.end())</span>
    {
<span style = "background-color:#fdd">      itk::ReceptorMemberCommand&lt;NonBlockingAlgorithm&gt;::Pointer command =</span>
        itk::ReceptorMemberCommand&lt;NonBlockingAlgorithm&gt;::New();
<span style = "background-color:#fdd">      command-&gt;SetCallbackFunction(this, &amp;NonBlockingAlgorithm::TriggerParameterModified);</span>

<span style = "background-color:#fdd">      m_TriggerPropertyConnections[parameter] = value-&gt;AddObserver(itk::ModifiedEvent(), command);
    }
  }</span>

  void NonBlockingAlgorithm::UnDefineTriggerParameter(const char *parameter)
<span style = "background-color:#fdd">  {
    auto iter = m_TriggerPropertyConnections.find(parameter);</span>

<span style = "background-color:#fdd">    if (iter != m_TriggerPropertyConnections.end())</span>
    {
<span style = "background-color:#fdd">      BaseProperty *value = m_Parameters-&gt;GetProperty(parameter);</span>

<span style = "background-color:#fdd">      MITK_ERROR(!value) &lt;&lt; "NonBlockingAlgorithm::UnDefineTriggerProperty() in bad state." &lt;&lt; std::endl;</span>
      ;

<span style = "background-color:#fdd">      value-&gt;RemoveObserver(m_TriggerPropertyConnections[parameter]);
      m_TriggerPropertyConnections.erase(iter);</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  void NonBlockingAlgorithm::Reset() { Initialize(); }</span>
  void NonBlockingAlgorithm::StartBlockingAlgorithm()
<span style = "background-color:#fdd">  {
    StartAlgorithm();
    StopAlgorithm();
  }</span>

  void NonBlockingAlgorithm::StartAlgorithm()
<span style = "background-color:#fdd">  {
    if (!ReadyToRun())
      return; // let algorithm check if all input/parameters are ok
    if (m_KillRequest)
      return; // someone wants us to die</span>

<span style = "background-color:#fdd">    m_ParameterListMutex.lock();
    ++m_UpdateRequests;
    m_ParameterListMutex.unlock();
    if (m_Thread.joinable()) // thread already running. But something obviously wants us to recalculate the output</span>
    {
<span style = "background-color:#fdd">      return; // thread already running</span>
    }

    // spawn a thread that calls ThreadedUpdateFunction(), and ThreadedUpdateFinished() on us
<span style = "background-color:#fdd">    this-&gt;Register();
    m_Thread = std::thread(StaticNonBlockingAlgorithmThread, this);
  }</span>

  void NonBlockingAlgorithm::StopAlgorithm()
<span style = "background-color:#fdd">  {
    if (m_Thread.joinable())
      m_Thread.join(); // waits for the thread to terminate on its own
  }</span>

  // a static function to call a member of NonBlockingAlgorithm from inside a thread
  void NonBlockingAlgorithm::StaticNonBlockingAlgorithmThread(NonBlockingAlgorithm* algorithm)
<span style = "background-color:#fdd">  {
    algorithm-&gt;m_ParameterListMutex.lock();
    while (algorithm-&gt;m_UpdateRequests &gt; 0)</span>
    {
<span style = "background-color:#fdd">      algorithm-&gt;m_UpdateRequests = 0;
      algorithm-&gt;m_ParameterListMutex.unlock();</span>

      // actually call the methods that do the work
<span style = "background-color:#fdd">      if (algorithm-&gt;ThreadedUpdateFunction()) // returns a bool for success/failure</span>
      {
<span style = "background-color:#fdd">        auto command = itk::ReceptorMemberCommand&lt;NonBlockingAlgorithm&gt;::New();
        command-&gt;SetCallbackFunction(algorithm, &amp;NonBlockingAlgorithm::ThreadedUpdateSuccessful);
        CallbackFromGUIThread::GetInstance()-&gt;CallThisFromGUIThread(command);</span>

<span style = "background-color:#fdd">      }</span>
      else
      {
<span style = "background-color:#fdd">        auto command = itk::ReceptorMemberCommand&lt;NonBlockingAlgorithm&gt;::New();
        command-&gt;SetCallbackFunction(algorithm, &amp;NonBlockingAlgorithm::ThreadedUpdateFailed);
        CallbackFromGUIThread::GetInstance()-&gt;CallThisFromGUIThread(command);
      }</span>

<span style = "background-color:#fdd">      algorithm-&gt;m_ParameterListMutex.lock();
    }
    algorithm-&gt;m_ParameterListMutex.unlock();
  }</span>

<span style = "background-color:#fdd">  void NonBlockingAlgorithm::TriggerParameterModified(const itk::EventObject &amp;) { StartAlgorithm(); }</span>
  bool NonBlockingAlgorithm::ReadyToRun()
<span style = "background-color:#fdd">  {
    return true; // default is always ready
  }</span>

<span style = "background-color:#fdd">  bool NonBlockingAlgorithm::ThreadedUpdateFunction() { return true; }</span>
  // called from gui thread
  void NonBlockingAlgorithm::ThreadedUpdateSuccessful(const itk::EventObject &amp;)
<span style = "background-color:#fdd">  {
    ThreadedUpdateSuccessful();
  }</span>

  void NonBlockingAlgorithm::ThreadedUpdateSuccessful()
<span style = "background-color:#fdd">  {</span>
    // notify observers that a result is ready
<span style = "background-color:#fdd">    InvokeEvent(ResultAvailable(this));
    this-&gt;UnRegister();
  }</span>

  // called from gui thread
  void NonBlockingAlgorithm::ThreadedUpdateFailed(const itk::EventObject &amp;)
<span style = "background-color:#fdd">  {
    ThreadedUpdateFailed();
  }</span>

  void NonBlockingAlgorithm::ThreadedUpdateFailed()
<span style = "background-color:#fdd">  {</span>
    // notify observers that something went wrong
<span style = "background-color:#fdd">    InvokeEvent(ProcessingError(this));
    this-&gt;UnRegister();
  }</span>

} // namespace</pre>
	</body>
</html>