<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkMaskImageFilter.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkMaskImageFilter.h"
#include "mitkImageTimeSelector.h"
#include "mitkProperties.h"
#include "mitkTimeHelper.h"

#include "mitkImageAccessByItk.h"
#include "mitkImageToItk.h"

#include "itkImageRegionConstIterator.h"
#include "itkImageRegionIteratorWithIndex.h"

#include &lt;limits&gt;

<span style = "background-color:#fdd">mitk::MaskImageFilter::MaskImageFilter() : m_Mask(nullptr)
{
  this-&gt;SetNumberOfIndexedInputs(2);
  this-&gt;SetNumberOfRequiredInputs(2);
  m_InputTimeSelector = mitk::ImageTimeSelector::New();
  m_MaskTimeSelector = mitk::ImageTimeSelector::New();
  m_OutputTimeSelector = mitk::ImageTimeSelector::New();
  m_OverrideOutsideValue = false;
  m_OutsideValue = 0;
}</span>

mitk::MaskImageFilter::~MaskImageFilter()
<span style = "background-color:#fdd">{
}</span>

void mitk::MaskImageFilter::SetMask(const mitk::Image *mask)
<span style = "background-color:#fdd">{</span>
  // Process object is not const-correct so the const_cast is required here
<span style = "background-color:#fdd">  m_Mask = const_cast&lt;mitk::Image *&gt;(mask);
  this-&gt;ProcessObject::SetNthInput(1, m_Mask);
}</span>

const mitk::Image *mitk::MaskImageFilter::GetMask() const
<span style = "background-color:#fdd">{
  return m_Mask;
}</span>

void mitk::MaskImageFilter::GenerateInputRequestedRegion()
<span style = "background-color:#fdd">{
  Superclass::GenerateInputRequestedRegion();</span>

<span style = "background-color:#fdd">  mitk::Image *output = this-&gt;GetOutput();
  mitk::Image *input = this-&gt;GetInput();
  mitk::Image *mask = m_Mask;
  if ((output-&gt;IsInitialized() == false) || (mask == nullptr) || (mask-&gt;GetTimeGeometry()-&gt;CountTimeSteps() == 0))
    return;</span>

<span style = "background-color:#fdd">  input-&gt;SetRequestedRegionToLargestPossibleRegion();
  mask-&gt;SetRequestedRegionToLargestPossibleRegion();</span>

<span style = "background-color:#fdd">  GenerateTimeInInputRegion(output, input);
  GenerateTimeInInputRegion(output, mask);
}</span>

void mitk::MaskImageFilter::GenerateOutputInformation()
<span style = "background-color:#fdd">{
  mitk::Image::ConstPointer input = this-&gt;GetInput();
  mitk::Image::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  if ((output-&gt;IsInitialized()) &amp;&amp; (this-&gt;GetMTime() &lt;= m_TimeOfHeaderInitialization.GetMTime()))
    return;</span>

<span style = "background-color:#fdd">  itkDebugMacro(&lt;&lt; "GenerateOutputInformation()");</span>

<span style = "background-color:#fdd">  output-&gt;Initialize(input-&gt;GetPixelType(), *input-&gt;GetTimeGeometry());</span>

<span style = "background-color:#fdd">  output-&gt;SetPropertyList(input-&gt;GetPropertyList()-&gt;Clone());</span>

<span style = "background-color:#fdd">  m_TimeOfHeaderInitialization.Modified();
}</span>

template &lt;typename TPixel, unsigned int VImageDimension&gt;
void mitk::MaskImageFilter::InternalComputeMask(itk::Image&lt;TPixel, VImageDimension&gt; *inputItkImage)
<span style = "background-color:#fdd">{</span>
  // dirty quick fix, duplicating code so both unsigned char and unsigned short are supported
  // this should be changed once unsigned char segmentations can be converted to unsigned short
<span style = "background-color:#fdd">  mitk::PixelType pixelType =</span>
    m_MaskTimeSelector-&gt;GetOutput()-&gt;GetImageDescriptor()-&gt;GetChannelDescriptor().GetPixelType();
<span style = "background-color:#fdd">  if (pixelType.GetComponentType() == itk::IOComponentEnum::UCHAR)</span>
  {
    typedef itk::Image&lt;TPixel, VImageDimension&gt; ItkInputImageType;
    typedef itk::Image&lt;unsigned char, VImageDimension&gt; ItkMaskImageType;
    typedef itk::Image&lt;TPixel, VImageDimension&gt; ItkOutputImageType;

    typedef itk::ImageRegionConstIterator&lt;ItkInputImageType&gt; ItkInputImageIteratorType;
    typedef itk::ImageRegionConstIterator&lt;ItkMaskImageType&gt; ItkMaskImageIteratorType;
    typedef itk::ImageRegionIteratorWithIndex&lt;ItkOutputImageType&gt; ItkOutputImageIteratorType;

<span style = "background-color:#fdd">    typename mitk::ImageToItk&lt;ItkMaskImageType&gt;::Pointer maskimagetoitk = mitk::ImageToItk&lt;ItkMaskImageType&gt;::New();
    maskimagetoitk-&gt;SetInput(m_MaskTimeSelector-&gt;GetOutput());
    maskimagetoitk-&gt;Update();
    typename ItkMaskImageType::Pointer maskItkImage = maskimagetoitk-&gt;GetOutput();</span>

<span style = "background-color:#fdd">    typename mitk::ImageToItk&lt;ItkOutputImageType&gt;::Pointer outputimagetoitk =</span>
      mitk::ImageToItk&lt;ItkOutputImageType&gt;::New();
<span style = "background-color:#fdd">    outputimagetoitk-&gt;SetInput(m_OutputTimeSelector-&gt;GetOutput());
    outputimagetoitk-&gt;Update();
    typename ItkOutputImageType::Pointer outputItkImage = outputimagetoitk-&gt;GetOutput();</span>

    // create the iterators
<span style = "background-color:#fdd">    typename ItkInputImageType::RegionType inputRegionOfInterest = inputItkImage-&gt;GetLargestPossibleRegion();
    ItkInputImageIteratorType inputIt(inputItkImage, inputRegionOfInterest);
    ItkMaskImageIteratorType maskIt(maskItkImage, inputRegionOfInterest);
    ItkOutputImageIteratorType outputIt(outputItkImage, inputRegionOfInterest);</span>

    // typename ItkOutputImageType::PixelType outsideValue = itk::NumericTraits&lt;typename
    // ItkOutputImageType::PixelType&gt;::min();
<span style = "background-color:#fdd">    if (!m_OverrideOutsideValue)
      m_OutsideValue = itk::NumericTraits&lt;typename ItkOutputImageType::PixelType&gt;::min();</span>

<span style = "background-color:#fdd">    m_MinValue = std::numeric_limits&lt;mitk::ScalarType&gt;::max();
    m_MaxValue = std::numeric_limits&lt;mitk::ScalarType&gt;::min();</span>

<span style = "background-color:#fdd">    for (inputIt.GoToBegin(), maskIt.GoToBegin(), outputIt.GoToBegin(); !inputIt.IsAtEnd() &amp;&amp; !maskIt.IsAtEnd();
         ++inputIt, ++maskIt, ++outputIt)</span>
    {
<span style = "background-color:#fdd">      if (maskIt.Get() &gt; itk::NumericTraits&lt;typename ItkMaskImageType::PixelType&gt;::Zero)</span>
      {
<span style = "background-color:#fdd">        outputIt.Set(inputIt.Get());
        m_MinValue = std::min((float)inputIt.Get(), (float)m_MinValue);
        m_MaxValue = std::max((float)inputIt.Get(), (float)m_MaxValue);
      }</span>
      else
      {
<span style = "background-color:#fdd">        outputIt.Set(m_OutsideValue);</span>
      }
<span style = "background-color:#fdd">    }
  }</span>
  else
  {
    {
      typedef itk::Image&lt;TPixel, VImageDimension&gt; ItkInputImageType;
      typedef itk::Image&lt;unsigned short, VImageDimension&gt; ItkMaskImageType;
      typedef itk::Image&lt;TPixel, VImageDimension&gt; ItkOutputImageType;

      typedef itk::ImageRegionConstIterator&lt;ItkInputImageType&gt; ItkInputImageIteratorType;
      typedef itk::ImageRegionConstIterator&lt;ItkMaskImageType&gt; ItkMaskImageIteratorType;
      typedef itk::ImageRegionIteratorWithIndex&lt;ItkOutputImageType&gt; ItkOutputImageIteratorType;

<span style = "background-color:#fdd">      typename mitk::ImageToItk&lt;ItkMaskImageType&gt;::Pointer maskimagetoitk = mitk::ImageToItk&lt;ItkMaskImageType&gt;::New();
      maskimagetoitk-&gt;SetInput(m_MaskTimeSelector-&gt;GetOutput());
      maskimagetoitk-&gt;Update();
      typename ItkMaskImageType::Pointer maskItkImage = maskimagetoitk-&gt;GetOutput();</span>

<span style = "background-color:#fdd">      typename mitk::ImageToItk&lt;ItkOutputImageType&gt;::Pointer outputimagetoitk =</span>
        mitk::ImageToItk&lt;ItkOutputImageType&gt;::New();
<span style = "background-color:#fdd">      outputimagetoitk-&gt;SetInput(m_OutputTimeSelector-&gt;GetOutput());
      outputimagetoitk-&gt;Update();
      typename ItkOutputImageType::Pointer outputItkImage = outputimagetoitk-&gt;GetOutput();</span>

      // create the iterators
<span style = "background-color:#fdd">      typename ItkInputImageType::RegionType inputRegionOfInterest = inputItkImage-&gt;GetLargestPossibleRegion();
      ItkInputImageIteratorType inputIt(inputItkImage, inputRegionOfInterest);
      ItkMaskImageIteratorType maskIt(maskItkImage, inputRegionOfInterest);
      ItkOutputImageIteratorType outputIt(outputItkImage, inputRegionOfInterest);</span>

      // typename ItkOutputImageType::PixelType outsideValue = itk::NumericTraits&lt;typename
      // ItkOutputImageType::PixelType&gt;::min();
<span style = "background-color:#fdd">      if (!m_OverrideOutsideValue)
        m_OutsideValue = itk::NumericTraits&lt;typename ItkOutputImageType::PixelType&gt;::min();</span>

<span style = "background-color:#fdd">      m_MinValue = std::numeric_limits&lt;mitk::ScalarType&gt;::max();
      m_MaxValue = std::numeric_limits&lt;mitk::ScalarType&gt;::min();</span>

<span style = "background-color:#fdd">      for (inputIt.GoToBegin(), maskIt.GoToBegin(), outputIt.GoToBegin(); !inputIt.IsAtEnd() &amp;&amp; !maskIt.IsAtEnd();
           ++inputIt, ++maskIt, ++outputIt)</span>
      {
<span style = "background-color:#fdd">        if (maskIt.Get() &gt; itk::NumericTraits&lt;typename ItkMaskImageType::PixelType&gt;::Zero)</span>
        {
<span style = "background-color:#fdd">          outputIt.Set(inputIt.Get());
          m_MinValue = std::min((float)inputIt.Get(), (float)m_MinValue);
          m_MaxValue = std::max((float)inputIt.Get(), (float)m_MaxValue);
        }</span>
        else
        {
<span style = "background-color:#fdd">          outputIt.Set(m_OutsideValue);</span>
        }
<span style = "background-color:#fdd">      }
    }</span>
  }
<span style = "background-color:#fdd">}</span>

void mitk::MaskImageFilter::GenerateData()
<span style = "background-color:#fdd">{
  mitk::Image::ConstPointer input = this-&gt;GetInput();
  mitk::Image::Pointer mask = m_Mask;
  mitk::Image::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  if ((output-&gt;IsInitialized() == false) || (mask.IsNull()) || (mask-&gt;GetTimeGeometry()-&gt;CountTimeSteps() == 0))
    return;</span>

<span style = "background-color:#fdd">  m_InputTimeSelector-&gt;SetInput(input);
  m_MaskTimeSelector-&gt;SetInput(mask);
  m_OutputTimeSelector-&gt;SetInput(this-&gt;GetOutput());</span>

<span style = "background-color:#fdd">  mitk::Image::RegionType outputRegion = output-&gt;GetRequestedRegion();
  const mitk::TimeGeometry *outputTimeGeometry = output-&gt;GetTimeGeometry();
  const mitk::TimeGeometry *inputTimeGeometry = input-&gt;GetTimeGeometry();
  const mitk::TimeGeometry *maskTimeGeometry = mask-&gt;GetTimeGeometry();</span>
  ScalarType timeInMS;

<span style = "background-color:#fdd">  int timestep = 0;
  int tstart = outputRegion.GetIndex(3);
  int tmax = tstart + outputRegion.GetSize(3);</span>

  int t;
<span style = "background-color:#fdd">  for (t = tstart; t &lt; tmax; ++t)</span>
  {
<span style = "background-color:#fdd">    timeInMS = outputTimeGeometry-&gt;TimeStepToTimePoint(t);</span>

<span style = "background-color:#fdd">    timestep = inputTimeGeometry-&gt;TimePointToTimeStep(timeInMS);</span>

<span style = "background-color:#fdd">    m_InputTimeSelector-&gt;SetTimeNr(timestep);
    m_InputTimeSelector-&gt;UpdateLargestPossibleRegion();
    m_OutputTimeSelector-&gt;SetTimeNr(t);
    m_OutputTimeSelector-&gt;UpdateLargestPossibleRegion();</span>

<span style = "background-color:#fdd">    timestep = maskTimeGeometry-&gt;TimePointToTimeStep(timeInMS);
    m_MaskTimeSelector-&gt;SetTimeNr(timestep);
    m_MaskTimeSelector-&gt;UpdateLargestPossibleRegion();</span>

<span style = "background-color:#fdd">    AccessByItk(m_InputTimeSelector-&gt;GetOutput(), InternalComputeMask);
  }</span>

<span style = "background-color:#fdd">  m_TimeOfHeaderInitialization.Modified();
}</span></pre>
	</body>
</html>