<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkImageToItk.txx</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#ifndef IMAGETOITK_TXX_INCLUDED_C1C2FCD2
#define IMAGETOITK_TXX_INCLUDED_C1C2FCD2

#include "itkImportMitkImageContainer.h"
#include "mitkBaseProcess.h"
#include "mitkException.h"
#include "mitkImageReadAccessor.h"
#include "mitkImageToItk.h"
#include "mitkImageWriteAccessor.h"

#include &lt;memory&gt;

template &lt;typename TImageType&gt;
struct SetLengthHelper
{
  SetLengthHelper(TImageType *in) { m_Image = in; }
private:
  TImageType *m_Image;
};

template &lt;typename T, unsigned int VDimension&gt;
struct SetLengthHelper&lt;itk::Image&lt;T, VDimension&gt;&gt;
{
  typedef itk::Image&lt;T, VDimension&gt; TImageType;

<span style = "background-color:#fdd">  SetLengthHelper(TImageType *in) { m_Image = in; }
  void SetVectorLength(size_t) {}</span>
private:
  TImageType *m_Image;
};

template &lt;typename T, unsigned int VDimension&gt;
struct SetLengthHelper&lt;itk::VectorImage&lt;T, VDimension&gt;&gt;
{
  typedef itk::VectorImage&lt;T, VDimension&gt; TImageType;

<span style = "background-color:#fdd">  SetLengthHelper(TImageType *in) { m_Image = in; }
  void SetVectorLength(size_t len) { m_Image-&gt;SetVectorLength(len); }</span>
private:
  TImageType *m_Image;
};

template &lt;class TOutputImage&gt;
void mitk::ImageToItk&lt;TOutputImage&gt;::SetInput(mitk::Image *input)
<span style = "background-color:#fdd">{
  this-&gt;SetInput(static_cast&lt;const Image *&gt;(input));
  m_ConstInput = false;
}</span>

template &lt;class TOutputImage&gt;
void mitk::ImageToItk&lt;TOutputImage&gt;::SetInput(const mitk::Image *input)
<span style = "background-color:#fdd">{
  this-&gt;CheckInput(input);</span>
  // Process object is not const-correct so the const_cast is required here
<span style = "background-color:#fdd">  itk::ProcessObject::PushFrontInput(input);
  m_ConstInput = true;
}</span>

template &lt;class TOutputImage&gt;
mitk::Image *mitk::ImageToItk&lt;TOutputImage&gt;::GetInput(void)
<span style = "background-color:#fdd">{
  if (this-&gt;GetNumberOfInputs() &lt; 1)</span>
  {
<span style = "background-color:#fdd">    return nullptr;</span>
  }

<span style = "background-color:#fdd">  return static_cast&lt;mitk::Image *&gt;(itk::ProcessObject::GetInput(0));
}</span>

template &lt;class TOutputImage&gt;
const mitk::Image *mitk::ImageToItk&lt;TOutputImage&gt;::GetInput() const
{
  if (this-&gt;GetNumberOfInputs() &lt; 1)
  {
    return nullptr;
  }

  return static_cast&lt;const mitk::Image *&gt;(itk::ProcessObject::GetInput(0));
}

template &lt;class TOutputImage&gt;
void mitk::ImageToItk&lt;TOutputImage&gt;::GenerateData()
<span style = "background-color:#fdd">{</span>
  // Allocate output
<span style = "background-color:#fdd">  mitk::Image::Pointer input = this-&gt;GetInput();
  typename Superclass::OutputImageType::Pointer output = this-&gt;GetOutput();</span>

<span style = "background-color:#fdd">  unsigned long noBytes = input-&gt;GetDimension(0);
  for (unsigned int i = 1; i &lt; TOutputImage::GetImageDimension(); ++i)</span>
  {
<span style = "background-color:#fdd">    noBytes = noBytes * input-&gt;GetDimension(i);
  }
  const mitk::PixelType pixelType = input-&gt;GetPixelType();
  if (pixelType.GetPixelType() == itk::IOPixelEnum::VECTOR)</span>
  {
<span style = "background-color:#fdd">    noBytes *= pixelType.GetNumberOfComponents();
    SetLengthHelper&lt;typename Superclass::OutputImageType&gt; helper(output.GetPointer());
    helper.SetVectorLength(pixelType.GetNumberOfComponents());</span>
  }

<span style = "background-color:#fdd">  std::unique_ptr&lt;mitk::ImageAccessorBase&gt; imageAccess;
  if (m_ConstInput)</span>
  {
<span style = "background-color:#fdd">    imageAccess.reset(new mitk::ImageReadAccessor(input, nullptr, m_Options));
  }</span>
  else
  {
<span style = "background-color:#fdd">    imageAccess.reset(new mitk::ImageWriteAccessor(input, nullptr, m_Options));</span>
  }

  // hier wird momentan wohl nur der erste Channel verwendet??!!
<span style = "background-color:#fdd">  if (imageAccess-&gt;GetData() == nullptr)</span>
  {
<span style = "background-color:#fdd">    itkWarningMacro(&lt;&lt; "no image data to import in ITK image");</span>

<span style = "background-color:#fdd">    RegionType bufferedRegion;
    output-&gt;SetBufferedRegion(bufferedRegion);
    return;</span>
  }

<span style = "background-color:#fdd">  if (m_CopyMemFlag)</span>
  {
<span style = "background-color:#fdd">    itkDebugMacro("copyMem ...");</span>

<span style = "background-color:#fdd">    output-&gt;Allocate();</span>

<span style = "background-color:#fdd">    memcpy(output-&gt;GetBufferPointer(), imageAccess-&gt;GetData(), sizeof(InternalPixelType) * noBytes);
  }</span>
  else
  {
<span style = "background-color:#fdd">    itkDebugMacro("do not copyMem ...");</span>
    typedef itk::ImportMitkImageContainer&lt;itk::SizeValueType, InternalPixelType&gt; ImportContainerType;
<span style = "background-color:#fdd">    typename ImportContainerType::Pointer import;</span>

<span style = "background-color:#fdd">    import = ImportContainerType::New();
    import-&gt;Initialize();</span>

<span style = "background-color:#fdd">    itkDebugMacro(&lt;&lt; "size of container = " &lt;&lt; import-&gt;Size());</span>
    // import-&gt;SetImageDataItem(m_ImageDataItem);
<span style = "background-color:#fdd">    import-&gt;SetImageAccessor(imageAccess.release(), sizeof(InternalPixelType) * noBytes);</span>

<span style = "background-color:#fdd">    output-&gt;SetPixelContainer(import);
    itkDebugMacro(&lt;&lt; "size of container = " &lt;&lt; import-&gt;Size());
  }
}</span>

template &lt;class TOutputImage&gt;
void mitk::ImageToItk&lt;TOutputImage&gt;::UpdateOutputInformation()
<span style = "background-color:#fdd">{
  mitk::Image::Pointer input = this-&gt;GetInput();
  if (input.IsNotNull() &amp;&amp; (input-&gt;GetSource().IsNotNull()) &amp;&amp; input-&gt;GetSource()-&gt;Updating())</span>
  {
<span style = "background-color:#fdd">    typename Superclass::OutputImageType::Pointer output = this-&gt;GetOutput();
    unsigned long t1 = input-&gt;GetUpdateMTime() + 1;
    if (t1 &gt; this-&gt;m_OutputInformationMTime.GetMTime())</span>
    {
<span style = "background-color:#fdd">      output-&gt;SetPipelineMTime(t1);</span>

<span style = "background-color:#fdd">      this-&gt;GenerateOutputInformation();</span>

<span style = "background-color:#fdd">      this-&gt;m_OutputInformationMTime.Modified();</span>
    }
<span style = "background-color:#fdd">    return;</span>
  }
<span style = "background-color:#fdd">  Superclass::UpdateOutputInformation();
}</span>

template &lt;class TOutputImage&gt;
void mitk::ImageToItk&lt;TOutputImage&gt;::GenerateOutputInformation()
<span style = "background-color:#fdd">{
  mitk::Image::ConstPointer input = this-&gt;GetInput();
  typename Superclass::OutputImageType::Pointer output = this-&gt;GetOutput();</span>

  // allocate size, origin, spacing, direction in types of output image
  SizeType size;
<span style = "background-color:#fdd">  const unsigned int itkDimMin3 = (TOutputImage::ImageDimension &gt; 3 ? TOutputImage::ImageDimension : 3);
  const unsigned int itkDimMax3 = (TOutputImage::ImageDimension &lt; 3 ? TOutputImage::ImageDimension : 3);</span>
  typename Superclass::OutputImageType::PointType::ValueType origin[itkDimMin3];
  typename Superclass::OutputImageType::SpacingType::ComponentType spacing[itkDimMin3];
<span style = "background-color:#fdd">  typename Superclass::OutputImageType::DirectionType direction;</span>

  // copy as much information as possible into size and spacing
  unsigned int i;
<span style = "background-color:#fdd">  for (i = 0; i &lt; itkDimMax3; ++i)</span>
  {
<span style = "background-color:#fdd">    size[i] = input-&gt;GetDimension(i);
    spacing[i] = input-&gt;GetGeometry()-&gt;GetSpacing()[i];
  }
  for (; i &lt; TOutputImage::ImageDimension; ++i)</span>
  {
<span style = "background-color:#fdd">    origin[i] = 0.0;
    size[i] = input-&gt;GetDimension(i);
    spacing[i] = 1.0;
  }</span>

  // build region from size
  IndexType start;
<span style = "background-color:#fdd">  start.Fill(0);
  RegionType region;
  region.SetIndex(start);
  region.SetSize(size);</span>

  // copy as much information as possible into origin
<span style = "background-color:#fdd">  const mitk::Point3D &amp;mitkorigin = input-&gt;GetGeometry()-&gt;GetOrigin();
  itk2vtk(mitkorigin, origin);</span>

  // copy as much information as possible into direction
<span style = "background-color:#fdd">  direction.SetIdentity();</span>
  unsigned int j;
<span style = "background-color:#fdd">  const AffineTransform3D::MatrixType &amp;matrix = input-&gt;GetGeometry()-&gt;GetIndexToWorldTransform()-&gt;GetMatrix();</span>

  /// \warning 2D MITK images could have a 3D rotation, since they have a 3x3 geometry matrix.
  /// If it is only a rotation around the axial plane normal, it can be express with a 2x2 matrix.
  /// In this case, the ITK image conservs this information and is identical to the MITK image!
  /// If the MITK image contains any other rotation, the ITK image will have no rotation at all.
  /// Spacing is of course conserved in both cases.

  // the following loop devides by spacing now to normalize columns.
  // counterpart of InitializeByItk in mitkImage.h line 372 of revision 15092.

  // Check if information is lost
<span style = "background-color:#fdd">  if (TOutputImage::ImageDimension &lt;= 2)</span>
  {
<span style = "background-color:#fdd">    if ((TOutputImage::ImageDimension == 2) &amp;&amp; ((matrix[0][2] != 0) || (matrix[1][2] != 0) || (matrix[2][0] != 0) ||</span>
                                                (matrix[2][1] != 0) || ((matrix[2][2] != 1) &amp;&amp; (matrix[2][2] != -1))))
    {
      // The 2D MITK image contains 3D rotation information.
      // This cannot be expressed in a 2D ITK image, so the ITK image will have no rotation
<span style = "background-color:#fdd">    }</span>
    else
    {
      // The 2D MITK image can be converted to an 2D ITK image without information loss!
<span style = "background-color:#fdd">      for (i = 0; i &lt; itkDimMax3; ++i)
        for (j = 0; j &lt; itkDimMax3; ++j)
          direction[i][j] = matrix[i][j] / spacing[j];</span>
    }
<span style = "background-color:#fdd">  }</span>
  else
  {
    // Normal 3D image. Conversion possible without problem!
<span style = "background-color:#fdd">    for (i = 0; i &lt; itkDimMax3; ++i)
      for (j = 0; j &lt; itkDimMax3; ++j)
        direction[i][j] = matrix[i][j] / spacing[j];</span>
  }

  // set information into output image
<span style = "background-color:#fdd">  output-&gt;SetRegions(region);
  output-&gt;SetOrigin(origin);
  output-&gt;SetSpacing(spacing);
  output-&gt;SetDirection(direction);
}</span>

template &lt;class TOutputImage&gt;
void mitk::ImageToItk&lt;TOutputImage&gt;::CheckInput(const mitk::Image *input) const
<span style = "background-color:#fdd">{
  if (input == nullptr)</span>
  {
<span style = "background-color:#fdd">    itkExceptionMacro(&lt;&lt; "image is null");</span>
  }
<span style = "background-color:#fdd">  if (input-&gt;GetDimension() != TOutputImage::GetImageDimension())</span>
  {
<span style = "background-color:#fdd">    itkExceptionMacro(&lt;&lt; "image has dimension " &lt;&lt; input-&gt;GetDimension() &lt;&lt; " instead of "</span>
                      &lt;&lt; TOutputImage::GetImageDimension());
  }

<span style = "background-color:#fdd">  if (!(input-&gt;GetPixelType() == mitk::MakePixelType&lt;TOutputImage&gt;(input-&gt;GetPixelType().GetNumberOfComponents())))</span>
  {
<span style = "background-color:#fdd">    itkExceptionMacro(&lt;&lt; "image has wrong pixel type ");</span>
  }
<span style = "background-color:#fdd">}</span>

template &lt;class TOutputImage&gt;
void mitk::ImageToItk&lt;TOutputImage&gt;::PrintSelf(std::ostream &amp;os, itk::Indent indent) const
<span style = "background-color:#fdd">{
  Superclass::PrintSelf(os, indent);
}</span>

#endif // IMAGETOITK_TXX_INCLUDED_C1C2FCD2</pre>
	</body>
</html>