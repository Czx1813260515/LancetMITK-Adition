<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>CombinedApi.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
//----------------------------------------------------------------------------
//
//  Copyright (C) 2017, Northern Digital Inc. All rights reserved.
//
//  All Northern Digital Inc. ("NDI") Media and/or Sample Code and/or Sample Code
//  Documentation (collectively referred to as "Sample Code") is licensed and provided "as
//  is" without warranty of any kind. The licensee, by use of the Sample Code, warrants to
//  NDI that the Sample Code is fit for the use and purpose for which the licensee intends to
//  use the Sample Code. NDI makes no warranties, express or implied, that the functions
//  contained in the Sample Code will meet the licensee's requirements or that the operation
//  of the programs contained therein will be error free. This warranty as expressed herein is
//  exclusive and NDI expressly disclaims any and all express and/or implied, in fact or in
//  law, warranties, representations, and conditions of every kind pertaining in any way to
//  the Sample Code licensed and provided by NDI hereunder, including without limitation,
//  each warranty and/or condition of quality, merchantability, description, operation,
//  adequacy, suitability, fitness for particular purpose, title, interference with use or
//  enjoyment, and/or non infringement, whether express or implied by statute, common law,
//  usage of trade, course of dealing, custom, or otherwise. No NDI dealer, distributor, agent
//  or employee is authorized to make any modification or addition to this warranty.
//  In no event shall NDI nor any of its employees be liable for any direct, indirect,
//  incidental, special, exemplary, or consequential damages, sundry damages or any
//  damages whatsoever, including, but not limited to, procurement of substitute goods or
//  services, loss of use, data or profits, or business interruption, however caused. In no
//  event shall NDI's liability to the licensee exceed the amount paid by the licensee for the
//  Sample Code or any NDI products that accompany the Sample Code. The said limitations
//  and exclusions of liability shall apply whether or not any such damages are construed as
//  arising from a breach of a representation, warranty, guarantee, covenant, obligation,
//  condition or fundamental term or on any theory of liability, whether in contract, strict
//  liability, or tort (including negligence or otherwise) arising in any way out of the use of
//  the Sample Code even if advised of the possibility of such damage. In no event shall
//  NDI be liable for any claims, losses, damages, judgments, costs, awards, expenses or
//  liabilities of any kind whatsoever arising directly or indirectly from any injury to person
//  or property, arising from the Sample Code or any use thereof
//
//----------------------------------------------------------------------------

#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;

#include "BufferedReader.h"
#include "CombinedApi.h"
#include "ComConnection.h"
#include "GbfContainer.h"
#include "GbfFrame.h"
#include "SystemCRC.h"
#include "TcpConnection.h"

CombinedApi::CombinedApi()
<span style = "background-color:#fdd">{
	connection_ = NULL;
	crcValidator_ = new SystemCRC();
}</span>

CombinedApi::~CombinedApi()
<span style = "background-color:#fdd">{
	delete connection_;
	delete crcValidator_;
}</span>

int CombinedApi::connect(std::string hostname)
<span style = "background-color:#fdd">{
	std::cout &lt;&lt; "Connecting to " &lt;&lt; hostname &lt;&lt; " ..." &lt;&lt; std::endl;</span>

	// Delete any old connection
<span style = "background-color:#fdd">	if (connection_ != NULL)</span>
	{
<span style = "background-color:#fdd">		delete connection_;
		connection_ = NULL;</span>
	}

	// Determine if the device uses serial or ethernet communication
<span style = "background-color:#fdd">	int errorCode = 0;
	if (hostname.substr(0,3).compare("COM") == 0 || hostname.substr(0,4).compare("/dev") == 0)</span>
	{
		// Create a new ComConnection
<span style = "background-color:#fdd">		connection_ = new ComConnection(hostname);</span>

		// Once the connection is open, the host and device need to agree on a baud rate
<span style = "background-color:#fdd">		if (connection_-&gt;isConnected())</span>
		{
			// A serial break is sent to reset the device to the default 9600 baud rate
<span style = "background-color:#fdd">			static_cast&lt;ComConnection*&gt;(connection_)-&gt;sendSerialBreak();</span>

			// Wait for the system to reply RESET
<span style = "background-color:#fdd">			errorCode = getErrorCodeFromResponse(readResponse());</span>

			// Print the firmware version for debugging purposes
<span style = "background-color:#fdd">			std::cout &lt;&lt; "API Revision: " &lt;&lt; getApiRevision() &lt;&lt; std::endl;</span>

			// The host can now request the device go to a much faster baud rate...
<span style = "background-color:#fdd">			if (errorCode == 0)</span>
			{
<span style = "background-color:#fdd">				std::cout &lt;&lt; "Setting Baud921600 for compatibility. Check your API guide to see if this is optimal for your NDI device." &lt;&lt; std::endl;
				errorCode = setCommParams(CommBaudRateEnum::Baud921600);</span>
			}
		}
<span style = "background-color:#fdd">	}</span>
	else
	{
		// Create a new TcpConnection
<span style = "background-color:#fdd">		connection_ = new TcpConnection(hostname.c_str());
		errorCode = connection_-&gt;isConnected() ? 0 : -1;</span>
	}

<span style = "background-color:#fdd">	return errorCode;
}</span>

int CombinedApi::setCommParams(CommBaudRateEnum::value baudRate, int dataBits, int parity, int stopBits, int enableHandshake) const
<span style = "background-color:#fdd">{</span>
	// Send the COMM command
<span style = "background-color:#fdd">	std::string command =  std::string("COMM ").append(intToString(baudRate)).append(intToString(dataBits)).append(intToString(parity))</span>
											   .append(intToString(stopBits)).append(intToString(enableHandshake));
<span style = "background-color:#fdd">	sendCommand(command);</span>

	// Wait for the system to reply OKAY
<span style = "background-color:#fdd">	int errorCode = getErrorCodeFromResponse(readResponse());</span>

	// If the device agreed to change the baud rate as desired, set the baud rate on the host to match it
<span style = "background-color:#fdd">	if (errorCode == 0)</span>
	{
		// std::cout &lt;&lt; "Debug: configuring host baud rate..." &lt;&lt; std::endl;
<span style = "background-color:#fdd">		dynamic_cast&lt;ComConnection*&gt;(connection_)-&gt;setSerialPortParams(CommBaudRateEnum::toInt(baudRate), (dataBits &gt; 0 ? 7 : 8), parity, stopBits, enableHandshake);</span>
	}
<span style = "background-color:#fdd">	return errorCode;
}</span>

std::string CombinedApi::getApiRevision() const
<span style = "background-color:#fdd">{</span>
	// Send the APIREV command
<span style = "background-color:#fdd">	std::string command =  std::string("APIREV ");
	sendCommand(command);</span>

	// Return the raw string so the client can parse the version
<span style = "background-color:#fdd">	return readResponse();
}</span>

int CombinedApi::initialize() const
<span style = "background-color:#fdd">{</span>
	// Send the INIT command
<span style = "background-color:#fdd">	std::string command =  std::string("INIT ");
	sendCommand(command);
	return getErrorCodeFromResponse(readResponse());
}</span>

std::vector&lt;PortHandleInfo&gt; CombinedApi::portHandleSearchRequest(PortHandleSearchRequestOption::value option) const
<span style = "background-color:#fdd">{</span>
	// Send the PHSR command
<span style = "background-color:#fdd">	std::stringstream stream;
	stream &lt;&lt; "PHSR " &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int) option;
	std::string command = stream.str();
	sendCommand(command);</span>

	// If an error occurred, return an empty vector
<span style = "background-color:#fdd">	std::string response = readResponse();
	int errorCode = getErrorCodeFromResponse(response);
	std::vector&lt;PortHandleInfo&gt; portHandleInfoVector;
	if (errorCode != 0)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; response &lt;&lt; " - " &lt;&lt; errorToString(errorCode);
		return portHandleInfoVector;</span>
	}

	// Return the response as a std::vector of easy to use objects
<span style = "background-color:#fdd">	int numPortHandles = stringToInt(response.substr(0,2));
	for (int i = 0; i &lt; numPortHandles; i ++)</span>
	{
<span style = "background-color:#fdd">		portHandleInfoVector.push_back(PortHandleInfo(response.substr(i * 5 + 2, 2), (uint8_t) stringToInt(response.substr(i * 5 + 4, 3))));
	}</span>

<span style = "background-color:#fdd">	return portHandleInfoVector;
}</span>

int CombinedApi::portHandleFree(std::string portHandle) const
<span style = "background-color:#fdd">{</span>
	// If the port handle is invalid, print an error message and return
<span style = "background-color:#fdd">	if (portHandle.size() != 2)</span>
	{
<span style = "background-color:#fdd">		return -1;</span>
	}

	// Send the PHF command
<span style = "background-color:#fdd">	std::string command =  std::string("PHF ").append(portHandle);
	sendCommand(command);
	return getErrorCodeFromResponse(readResponse());
}</span>

int CombinedApi::portHandleRequest(std::string hardwareDevice, std::string systemType, std::string toolType, std::string portNumber, std::string dummyTool) const
<span style = "background-color:#fdd">{</span>
	// Send the PHRQ command
<span style = "background-color:#fdd">	std::string command =  std::string("PHRQ ").append(hardwareDevice).append(systemType).append(toolType).append(portNumber).append(dummyTool);
	sendCommand(command);</span>

	// Return the requested port handle or an error code
<span style = "background-color:#fdd">	std::string response = readResponse();
	int errorCode = getErrorCodeFromResponse(response);
	if (errorCode == 0)</span>
	{
<span style = "background-color:#fdd">		return stringToInt(response);
	}</span>
	else
	{
<span style = "background-color:#fdd">		return errorCode;</span>
	}
<span style = "background-color:#fdd">}</span>

int CombinedApi::portHandleInitialize(std::string portHandle) const
<span style = "background-color:#fdd">{</span>
	// If the port handle is invalid, print an error message and return
<span style = "background-color:#fdd">	if (portHandle.size() != 2)</span>
	{
<span style = "background-color:#fdd">		return -1;</span>
	}

	// Send the PINIT command
<span style = "background-color:#fdd">	std::string command =  std::string("PINIT ").append(portHandle);
	sendCommand(command);
	return getErrorCodeFromResponse(readResponse());
}</span>

int CombinedApi::portHandleEnable(std::string portHandle, ToolTrackingPriority::value priority) const
<span style = "background-color:#fdd">{</span>
	// If the port handle is invalid, print an error message and return
<span style = "background-color:#fdd">	if (portHandle.size() != 2)</span>
	{
<span style = "background-color:#fdd">		return -1;</span>
	}

	// Send the PENA command
<span style = "background-color:#fdd">	std::string command =  std::string("PENA ").append(portHandle);
	command += (char)priority;
	sendCommand(command);
	return getErrorCodeFromResponse(readResponse());
}</span>

PortHandleInfo CombinedApi::portHandleInfo(std::string portHandle) const
<span style = "background-color:#fdd">{</span>
	// If the port handle is invalid, print an error message and return
<span style = "background-color:#fdd">	if (portHandle.size() != 2)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "Invalid port handle: " &lt;&lt; portHandle &lt;&lt; std::endl;
		return PortHandleInfo(portHandle);</span>
	}

	// Send the PHINF command
<span style = "background-color:#fdd">	std::string command =  std::string("PHINF ").append(portHandle);
	sendCommand(command);</span>

	// If there is no tool loaded, return an empty PortHandleInfo
<span style = "background-color:#fdd">	std::string response = readResponse();
	int errorCode = getErrorCodeFromResponse(response);
	if (errorCode != 0)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; response &lt;&lt; " - " &lt;&lt; errorToString(errorCode);
		return PortHandleInfo(portHandle);
	}
	else if (response.substr(0,10).compare("UNOCCUPIED") == 0)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "No tool loaded at port: " &lt;&lt; portHandle &lt;&lt; std::endl;
		return PortHandleInfo(portHandle);</span>
	}

	// Parse the information from the response
<span style = "background-color:#fdd">	std::string toolType = response.substr(0,8);
	std::string toolId = response.substr(8,12);
	toolId.erase(toolId.find_last_not_of(" \n\r\t") + 1); // .trim() whitespace
	std::string revision = response.substr(20,3);
	std::string serialNumber = response.substr(23,8);
	uint8_t status = (uint8_t) stringToInt(response.substr(31,2));
	return PortHandleInfo(portHandle, toolType, toolId, revision, serialNumber, status);
}</span>

int CombinedApi::loadPassiveDummyTool() const
<span style = "background-color:#fdd">{
	return portHandleRequest("********", "*", "1", "00", "01");
}</span>

int CombinedApi::loadActiveWirelessDummyTool() const
<span style = "background-color:#fdd">{
	return portHandleRequest("********", "*", "1", "00", "02");
}</span>

int CombinedApi::loadActiveDummyTool() const
<span style = "background-color:#fdd">{
	return portHandleRequest("********", "*", "0", "00", "01");
}</span>

void CombinedApi::loadSromToPort(std::string romFilePath, int portHandle) const
<span style = "background-color:#fdd">{</span>
	// If the port handle is invalid, print an error message and return
<span style = "background-color:#fdd">	if (portHandle &lt; 0)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "Invalid port handle: " &lt;&lt; portHandle &lt;&lt; std::endl;
		return;</span>
	}

	// If the .rom file cannot be opened, print an error message and return
<span style = "background-color:#fdd">	std::ifstream inputFileStream(romFilePath.c_str(), std::ios_base::binary);
	if (!inputFileStream.is_open())</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "Cannot open file: " + romFilePath &lt;&lt; std::endl;
		return;</span>
	}

	// Read the entire file and convert it to ASCII hex characters
<span style = "background-color:#fdd">	std::stringstream romStream;
	romStream &lt;&lt; std::setfill('0') &lt;&lt; std::hex;
	while (!inputFileStream.eof())</span>
	{
<span style = "background-color:#fdd">		romStream &lt;&lt; std::setw(2)  &lt;&lt; inputFileStream.get();
	}
	inputFileStream.close();</span>

	// Tool data is sent in chunks of 128 hex characters (64-bytes).
	// It must be an integer number of chunks, padded with zeroes at the end.
<span style = "background-color:#fdd">	const int messageSizeChars = 128;
	const int messageSizeBytes = 64;
	std::string toolDefinition = romStream.str();
	int remainder = toolDefinition.size() % messageSizeChars;
	toolDefinition.append((messageSizeChars - remainder), '0');
	const int totalIterations =  (int)toolDefinition.size() / messageSizeChars;
	std::string command = "";
	int errorCode = 0;
	std::stringstream startAddressStream;
	startAddressStream &lt;&lt; std::setfill('0') &lt;&lt; std::hex;
	for (int i = 0; i &lt; totalIterations; i++)</span>
	{
		// Pass the startAddress as a fixed width four characters of hex padded with zeroes
<span style = "background-color:#fdd">		startAddressStream &lt;&lt; std::setw(4) &lt;&lt;  i * messageSizeBytes;</span>

		// Send the PVWR command
<span style = "background-color:#fdd">		command =  std::string("PVWR ").append(intToString(portHandle, 2));
		command += startAddressStream.str();
		command += toolDefinition.substr(i * messageSizeChars, messageSizeChars);
		sendCommand(command);</span>

		// If we run into an error, print something before exiting
<span style = "background-color:#fdd">		errorCode = getErrorCodeFromResponse(readResponse());
		if (errorCode != 0)</span>
		{
<span style = "background-color:#fdd">			std::cout &lt;&lt; "PVWR returned error: " &lt;&lt; errorToString(errorCode) &lt;&lt; std::endl;
			return;</span>
		}

		// Reset the stringstream used to print fixed width address sizes
<span style = "background-color:#fdd">		startAddressStream.str("");
	}
}</span>

int CombinedApi::startTracking() const
<span style = "background-color:#fdd">{</span>
	// Send the TSTART command
<span style = "background-color:#fdd">	std::string command =  std::string("TSTART ");
	sendCommand(command);
	return getErrorCodeFromResponse(readResponse());
}</span>

int CombinedApi::stopTracking() const
<span style = "background-color:#fdd">{</span>
	// Send the TSTOP command
<span style = "background-color:#fdd">	std::string command =  std::string("TSTOP ");
	sendCommand(command);
	return getErrorCodeFromResponse(readResponse());
}</span>

std::string CombinedApi::getTrackingDataTX(const uint16_t options) const
<span style = "background-color:#fdd">{</span>
	// Send the TX command
<span style = "background-color:#fdd">	std::string command =  std::string("TX ").append(intToHexString(options, 4));
	sendCommand(command);
	return readResponse();
}</span>

std::vector&lt;ToolData&gt; CombinedApi::getTrackingDataBX(const uint16_t options) const
<span style = "background-color:#fdd">{</span>
	// Send the BX command
<span style = "background-color:#fdd">	std::string command =  std::string("BX ").append(intToHexString(options, 4));
	sendCommand(command);</span>

	// Open a buffered reader on the connection to easily parse the binary reply
<span style = "background-color:#fdd">	BufferedReader reader(connection_);
	reader.readBytes(6);
	uint16_t startSequence = reader.get_uint16();
	uint16_t replyLengthBytes = reader.get_uint16();</span>

	// Verify the CRC16 of the header
<span style = "background-color:#fdd">	unsigned int headerCRC16 = (unsigned int) reader.get_uint16();
	unsigned int calculatedCRC16 = crcValidator_-&gt;calculateCRC16(reader.getData(0, 4).c_str(), 4);
	if (calculatedCRC16 != headerCRC16)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "CRC16 failed!" &lt;&lt; std::endl;
		return std::vector&lt;ToolData&gt;();</span>
	}

	// In the case of an unexpected binary header, return an empty vector
<span style = "background-color:#fdd">	if (startSequence != START_SEQUENCE)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "Unrecognized start sequence: " &lt;&lt; startSequence &lt;&lt; std::endl;
		return std::vector&lt;ToolData&gt;();</span>
	}

	// Get all of the data once we know how many bytes to read: replyLengthBytes + 2 bytes for trailing CRC16
<span style = "background-color:#fdd">	reader.readBytes(replyLengthBytes + 2);</span>

	// Verify the CRC16 of the data
<span style = "background-color:#fdd">	reader.skipBytes(replyLengthBytes);
	unsigned int dataCRC16 = reader.get_uint16();
	if (crcValidator_-&gt;calculateCRC16(reader.getData(6, replyLengthBytes).c_str(), replyLengthBytes) != dataCRC16)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "CRC16 failed!" &lt;&lt; std::endl;
		return std::vector&lt;ToolData&gt;();</span>
	}
<span style = "background-color:#fdd">	reader.skipBytes(-replyLengthBytes -2); // move the BufferedReader's pointer back so we can parse the data</span>

	// Debugging: print the raw binary and/or interpreted strings
	/*std::cout &lt;&lt; reader.toString() &lt;&lt; std::endl;
	std::cout &lt;&lt; "startSequence=" &lt;&lt; intToHexString(startSequence, 4) &lt;&lt; std::endl
		   &lt;&lt; "replyLengthBytes=" &lt;&lt; intToHexString(replyLengthBytes, 4) &lt;&lt; std::endl
		   &lt;&lt; "headerCRC16=" &lt;&lt; intToHexString(headerCRC16, 4) &lt;&lt; std::endl;*/

	// TODO: support all BX options. Just return if there are unexpected options, we will be binary misaligned anyway.
<span style = "background-color:#fdd">	if ((options &amp; ~(TrackingReplyOption::TransformData | TrackingReplyOption::AllTransforms)) != 0x0000)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "Reply parsing has not implemented options: " &lt;&lt; intToHexString(options, 4) &lt;&lt; std::endl;
		return std::vector&lt;ToolData&gt;();</span>
	}

<span style = "background-color:#fdd">	std::vector&lt;ToolData&gt; toolDataVector;
	uint8_t numHandles = reader.get_byte();
	for (uint8_t i = 0; i &lt; numHandles; i++)</span>
	{
		// Create a new ToolData
<span style = "background-color:#fdd">		toolDataVector.push_back(ToolData());</span>

		// From each two byte handle, extract the handle index and status
<span style = "background-color:#fdd">		toolDataVector.back().transform.toolHandle = (uint16_t) reader.get_byte();
		uint8_t handleStatus = reader.get_byte();</span>

		// Parse BX 0001 - See API guide for protocol details
<span style = "background-color:#fdd">		if (options &amp; TrackingReplyOption::TransformData)</span>
		{
			// The transform is not transmitted at all if it is missing
<span style = "background-color:#fdd">			switch (handleStatus)</span>
			{
				case 0x01: // Valid
<span style = "background-color:#fdd">					toolDataVector.back().transform.status = TransformStatus::Enabled;
					toolDataVector.back().transform.q0 = reader.get_double();
					toolDataVector.back().transform.qx = reader.get_double();
					toolDataVector.back().transform.qy = reader.get_double();
					toolDataVector.back().transform.qz = reader.get_double();
					toolDataVector.back().transform.tx = reader.get_double();
					toolDataVector.back().transform.ty = reader.get_double();
					toolDataVector.back().transform.tz = reader.get_double();
					toolDataVector.back().transform.error = reader.get_double();
				break;</span>
				case 0x04: // Disabled
					// Disabled markers have no transform, status, or frame number
<span style = "background-color:#fdd">					toolDataVector.pop_back(); // don't return a ToolData for it, there's nothing there
					continue;</span>
				default:
					// case 0x02: Missing or anything unexpected
					// do nothing --&gt; blank Transform object is already initialized as missing
				break;
			};

			// Regardless of transform status, there is info about the port and frame
<span style = "background-color:#fdd">			toolDataVector.back().portStatus = reader.get_uint32() &amp; 0x0000FFFF;
			toolDataVector.back().frameNumber = reader.get_uint32();</span>
		}
<span style = "background-color:#fdd">	}</span>

	// Add the systemStatus to each ToolData
<span style = "background-color:#fdd">	uint16_t systemStatus = reader.get_uint16();
	for (int t = 0; t &lt; toolDataVector.size(); t++)</span>
	{
<span style = "background-color:#fdd">		toolDataVector[t].systemStatus = systemStatus;
	}</span>

	// Return the tool data
<span style = "background-color:#fdd">	return toolDataVector;
}</span>

std::vector&lt;ToolData&gt; CombinedApi::getTrackingDataBX2(std::string options) const
<span style = "background-color:#fdd">{</span>
	// Send the BX2 command
<span style = "background-color:#fdd">	std::string command =  std::string("BX2 ").append(options);
	sendCommand(command);</span>

	// Open a buffered reader on the connection to easily parse the binary reply
<span style = "background-color:#fdd">	BufferedReader reader(connection_);</span>

	// The BX2 reply begins with a 6 byte header:
	// (2-bytes) StartSequence: indicates how to parse the reply. A5C4 (normal)
	// (2-bytes) ReplyLength: length of the reply in bytes
	// (2-bytes) CRC16
<span style = "background-color:#fdd">	reader.readBytes(6);
	uint16_t startSequence = reader.get_uint16();
	uint16_t replyLengthBytes = reader.get_uint16();</span>

	// Verify the CRC16 of the header
<span style = "background-color:#fdd">	unsigned int headerCRC16 = (unsigned int) reader.get_uint16();
	unsigned int calculatedCRC16 = crcValidator_-&gt;calculateCRC16(reader.getData(0, 4).c_str(), 4);
	if (calculatedCRC16 != headerCRC16)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "CRC16 failed!" &lt;&lt; std::endl;
		return std::vector&lt;ToolData&gt;();</span>
	}

	// TODO: handle all BX2 reply types?
<span style = "background-color:#fdd">	if (startSequence != START_SEQUENCE)</span>
	{
		// Return an empty vector if the binary response cannot be interpreted
<span style = "background-color:#fdd">		std::cout &lt;&lt; "Unrecognized BX2 reply header: " &lt;&lt; std::setw(4) &lt;&lt; startSequence &lt;&lt; " - Not implemented yet!" &lt;&lt; std::endl;
		return std::vector&lt;ToolData&gt;();</span>
	}

	// Get all of the data once we know how many bytes to read: replyLengthBytes + 2 bytes for trailing CRC16
<span style = "background-color:#fdd">	reader.readBytes(replyLengthBytes + 2);</span>

	// Verify the CRC16 of the data
<span style = "background-color:#fdd">	reader.skipBytes(replyLengthBytes);
	unsigned int dataCRC16 = reader.get_uint16();
	if (crcValidator_-&gt;calculateCRC16(reader.getData(6, replyLengthBytes).c_str(), replyLengthBytes) != dataCRC16)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "CRC16 failed!" &lt;&lt; std::endl;
		return std::vector&lt;ToolData&gt;();</span>
	}
<span style = "background-color:#fdd">	reader.skipBytes(-replyLengthBytes -2); // move the BufferedReader's pointer back so we can parse the data</span>

	// Parse the binary into meaningful objects
<span style = "background-color:#fdd">	GbfContainer container(reader);</span>

	// Debugging: print the raw binary and/or interpreted strings
	/*std::cout &lt;&lt; reader.toString() &lt;&lt; std::endl;
	std::cout &lt;&lt; "-----GbfHeader" &lt;&lt; std::endl
		      &lt;&lt; "startSequence=" &lt;&lt; std::setw(4) &lt;&lt; static_cast&lt;unsigned&gt;(startSequence) &lt;&lt; std::endl
		      &lt;&lt; "replyLengthBytes=" &lt;&lt; std::setw(4) &lt;&lt; static_cast&lt;unsigned&gt;(replyLengthBytes) &lt;&lt; std::endl
		      &lt;&lt; "headerCRC16=" &lt;&lt; std::setw(4) &lt;&lt; static_cast&lt;unsigned&gt;(headerCRC) &lt;&lt; std::endl
		      &lt;&lt; container.toString()
		      &lt;&lt; "dataCRC16=" &lt;&lt; std::setw(4) &lt;&lt; static_cast&lt;unsigned&gt;(reader.get_uint16()) &lt;&lt; std::endl &lt;&lt; std::endl;*/

	// Search the root GbfContainer to find the frame component
<span style = "background-color:#fdd">	std::vector&lt;ToolData&gt; retVal;
	for (int i = 0; i &lt; container.components.size(); i++)</span>
	{
<span style = "background-color:#fdd">		if (container.components[i]-&gt;componentType == GbfComponentType::Frame)</span>
		{
			// Every GBF frame has GbfFrameDataItems for each type of tool: Passive, ActiveWireless, Active
<span style = "background-color:#fdd">			GbfFrame* frame = static_cast&lt;GbfFrame*&gt;(container.components[i]);
			retVal = frame-&gt;getToolData();
      break;</span>
		}
<span style = "background-color:#fdd">	}</span>

	// If we didn't find any, then return an empty vector
<span style = "background-color:#fdd">	return retVal;
}</span>

std::string CombinedApi::intToString(int input, int width) const
<span style = "background-color:#fdd">{
	std::stringstream convert;
	convert &lt;&lt; std::dec &lt;&lt; std::setfill('0');
	convert &lt;&lt; std::setw(width) &lt;&lt; input;
	return convert.str();
}</span>

std::string CombinedApi::intToHexString(int input, int width) const
<span style = "background-color:#fdd">{
	std::stringstream convert;
	convert &lt;&lt; std::hex  &lt;&lt; std::setfill('0');
	convert &lt;&lt; std::setw(width) &lt;&lt; input;
	return convert.str();
}</span>

int CombinedApi::stringToInt(std::string input) const
<span style = "background-color:#fdd">{
	int retVal = 0;
	std::stringstream convert(input);
	convert &lt;&lt; std::hex;
	convert &gt;&gt; retVal;
	return retVal;
}</span>

char *CombinedApi::getConnectionName()
<span style = "background-color:#fdd">{
	if (!connection_)</span>
	{
<span style = "background-color:#fdd">		return NULL;</span>
	}
<span style = "background-color:#fdd">	return connection_-&gt;connectionName();
}</span>

int CombinedApi::getErrorCodeFromResponse(std::string response) const
<span style = "background-color:#fdd">{</span>
	// Parse the error code from the response string and return it
<span style = "background-color:#fdd">	int errorCode = 0;
	if (response.substr(0,5).compare("ERROR") == 0)</span>
	{
<span style = "background-color:#fdd">		errorCode = stringToInt(response.substr(5,2));
	}
	else if (response.substr(0,7).compare("WARNING") == 0)</span>
	{
<span style = "background-color:#fdd">		errorCode = stringToInt(response.substr(7,2)) + WARNING_CODE_OFFSET;</span>
	}

	// Use negative error codes to distinguish between port handles an errors.
<span style = "background-color:#fdd">	return errorCode * -1;
}</span>

std::string CombinedApi::readResponse() const
<span style = "background-color:#fdd">{</span>
	// Declare an empty string to hold the response
<span style = "background-color:#fdd">	std::string response = std::string("");
	char lastChar = '\0';</span>

	// Read from the device until we encounter a terminating carriage return (CR)
<span style = "background-color:#fdd">	while (lastChar != CR)</span>
	{
<span style = "background-color:#fdd">		connection_-&gt;read(&amp;lastChar, 1);
		response += lastChar;
	}</span>

	// Trim trailing CR and verify the CRC16
<span style = "background-color:#fdd">	response.erase(response.length() - 1); // strip CR (1 char)
	unsigned int replyCRC16 = (unsigned int) stringToInt(response.substr(response.length() - 4 , 4));
	response.erase(response.length() - 4, 4); // strip CRC16 (4 chars)
	if (crcValidator_-&gt;calculateCRC16(response.c_str(), (int) response.length()) != replyCRC16)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "CRC16 failed!" &lt;&lt; std::endl;</span>
	}
	
	// send response to terminal
<span style = "background-color:#fdd">	std::cout &lt;&lt; "&lt;&lt;" &lt;&lt; response &lt;&lt; std::endl;	</span>

	// Return whatever string the device responded with
<span style = "background-color:#fdd">	return response;
}</span>

int CombinedApi::sendCommand(std::string command) const
<span style = "background-color:#fdd">{</span>
	// Display an error message if there is no open socket
<span style = "background-color:#fdd">	if (!connection_-&gt;isConnected())</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "Cannot send command: " &lt;&lt; command &lt;&lt; "- No open socket!" &lt;&lt; std::endl;
		return -1;</span>
	}

	// Display the command that we're sending (except for BX, slows us down for real use)
<span style = "background-color:#fdd">	if (command.find("BX") == std::string::npos)</span>
	{
<span style = "background-color:#fdd">		std::cout &lt;&lt; "Sending command: " &lt;&lt; command &lt;&lt; " ..." &lt;&lt; std::endl;</span>
	}

	// Add CR character to command and write the command to the socket
<span style = "background-color:#fdd">	command += CR;
	return connection_-&gt;write(command.c_str(), (int)command.length());
}</span>

std::string CombinedApi::errorToString(int errorCode)
<span style = "background-color:#fdd">{
	errorCode *= -1; // restore the errorCode to a positive value
	if (errorCode &gt; WARNING_CODE_OFFSET)</span>
	{
<span style = "background-color:#fdd">		return getWarningString(errorCode - WARNING_CODE_OFFSET);
	}</span>
	else
	{
<span style = "background-color:#fdd">		return getErrorString(errorCode);</span>
	}
<span style = "background-color:#fdd">}</span>

std::string CombinedApi::getWarningString(int warnCode)
<span style = "background-color:#fdd">{
	if (warnCode &lt; 0 || warnCode &gt;= sizeof(warningStrings))</span>
	{
<span style = "background-color:#fdd">		return "Warning code not found.";
	}</span>
	else
	{
<span style = "background-color:#fdd">		return warningStrings[warnCode];</span>
	}
<span style = "background-color:#fdd">}</span>

std::string CombinedApi::getErrorString(int errorCode)
<span style = "background-color:#fdd">{
	if (errorCode &lt; 0 || errorCode &gt;= sizeof(errorStrings))</span>
	{
<span style = "background-color:#fdd">		return "Error code not found.";
	}</span>
	else
	{
<span style = "background-color:#fdd">		return errorStrings[errorCode];</span>
	}
<span style = "background-color:#fdd">}</span>

std::string CombinedApi::getUserParameter(std::string paramName) const
<span style = "background-color:#fdd">{</span>
	// Send the GET request
<span style = "background-color:#fdd">	std::string command = std::string("GET ").append(paramName);
	sendCommand(command);</span>

	// Return whatever the device responded with
<span style = "background-color:#fdd">	return readResponse();
}</span>

int CombinedApi::setUserParameter(std::string paramName, std::string value) const
<span style = "background-color:#fdd">{</span>
	// Send the SET request
<span style = "background-color:#fdd">	std::string command = std::string("SET ").append(paramName).append("=").append(value);
	sendCommand(command);
	return getErrorCodeFromResponse(readResponse());
}</span>

int CommBaudRateEnum::toInt(CommBaudRateEnum::value baudEnumValue)
<span style = "background-color:#fdd">{
	switch (baudEnumValue)</span>
	{
		case Baud1228739:
<span style = "background-color:#fdd">			return 1228739;</span>
		case Baud921600:
<span style = "background-color:#fdd">			return 921600;</span>
		case Baud115200:
<span style = "background-color:#fdd">			return 115200;</span>
		case Baud57600:
<span style = "background-color:#fdd">			return 57600;</span>
		case Baud38400:
<span style = "background-color:#fdd">			return 38400;</span>
		case Baud19200:
<span style = "background-color:#fdd">			return 19200;</span>
		case Baud14400:
<span style = "background-color:#fdd">			return 14400;</span>
		case Baud9600: // fall through
		default:
<span style = "background-color:#fdd">			return 9600;</span>
	};
<span style = "background-color:#fdd">}</span></pre>
	</body>
</html>