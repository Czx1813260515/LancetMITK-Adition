<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>mitkModelFitPlotDataHelper.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
/*============================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center (DKFZ)
All rights reserved.

Use of this source code is governed by a 3-clause BSD license that can be
found in the LICENSE file.

============================================================================*/

#include "mitkModelFitPlotDataHelper.h"

#include "mitkExceptionMacro.h"
#include "mitkImage.h"
#include "mitkModelFitParameterValueExtraction.h"
#include "mitkModelGenerator.h"

#include "mitkFormulaParser.h"

const std::string mitk::MODEL_FIT_PLOT_SAMPLE_NAME()
<span style = "background-color:#fdd">{
  return "Sample";
};</span>

const std::string mitk::MODEL_FIT_PLOT_SIGNAL_NAME()
<span style = "background-color:#fdd">{
  return "Signal";
}</span>

const std::string mitk::MODEL_FIT_PLOT_INTERPOLATED_SIGNAL_NAME()
<span style = "background-color:#fdd">{
  return "INTERP_Signal";
};</span>

void
mitk::PlotDataCurve::
SetValues(const PlotDataValues&amp; _arg)
<span style = "background-color:#fdd">{
  if (this-&gt;m_Values != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_Values = _arg;
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

void
mitk::PlotDataCurve::
SetValues(PlotDataValues&amp;&amp; _arg)
<span style = "background-color:#fdd">{
  if (this-&gt;m_Values != _arg)</span>
  {
<span style = "background-color:#fdd">    this-&gt;m_Values = std::move(_arg);
    this-&gt;Modified();</span>
  }
<span style = "background-color:#fdd">}</span>

mitk::PlotDataCurve &amp; mitk::PlotDataCurve::operator=(const PlotDataCurve&amp; rhs)
<span style = "background-color:#fdd">{
  this-&gt;m_Values = rhs.m_Values;
  this-&gt;SetTimeStamp(rhs.GetTimeStamp());
  return *this;
};</span>

mitk::PlotDataCurve&amp; mitk::PlotDataCurve::operator=(PlotDataCurve&amp;&amp; rhs) noexcept
<span style = "background-color:#fdd">{
  this-&gt;m_Values = std::move(rhs.m_Values);
  this-&gt;SetTimeStamp(rhs.GetTimeStamp());</span>

<span style = "background-color:#fdd">  return *this;
};</span>

void mitk::PlotDataCurve::Reset()
<span style = "background-color:#fdd">{
  this-&gt;m_Values.clear();
  this-&gt;Modified();
}</span>

mitk::PlotDataCurve::PlotDataCurve()
<span style = "background-color:#fdd">{
}</span>

const mitk::PlotDataCurve* GetPlotCurve(const mitk::PlotDataCurveCollection* collection, const std::string&amp; key)
<span style = "background-color:#fdd">{
  if (collection)</span>
  {
<span style = "background-color:#fdd">    auto iter = collection-&gt;find(key);
    if (iter != collection-&gt;end())</span>
    {
<span style = "background-color:#fdd">      return iter-&gt;second.GetPointer();</span>
    }
<span style = "background-color:#fdd">  }
  return nullptr;
};</span>

const mitk::PlotDataCurve* mitk::ModelFitPlotData::GetSamplePlot(const PlotDataCurveCollection* coll)
<span style = "background-color:#fdd">{
  if (coll)</span>
  {
<span style = "background-color:#fdd">    return GetPlotCurve(coll, MODEL_FIT_PLOT_SAMPLE_NAME());</span>
  }
<span style = "background-color:#fdd">  return nullptr;
};</span>

const mitk::PlotDataCurve* mitk::ModelFitPlotData::GetSignalPlot(const PlotDataCurveCollection* coll)
<span style = "background-color:#fdd">{
  if (coll)</span>
  {
<span style = "background-color:#fdd">    return GetPlotCurve(coll, MODEL_FIT_PLOT_SIGNAL_NAME());</span>
  }
<span style = "background-color:#fdd">  return nullptr;
};</span>

const mitk::PlotDataCurve* mitk::ModelFitPlotData::GetInterpolatedSignalPlot(const PlotDataCurveCollection* coll)
<span style = "background-color:#fdd">{
  if (coll)</span>
  {
<span style = "background-color:#fdd">    return GetPlotCurve(coll, MODEL_FIT_PLOT_INTERPOLATED_SIGNAL_NAME());</span>
  }
<span style = "background-color:#fdd">  return nullptr;
};</span>

std::string mitk::ModelFitPlotData::GetPositionalCollectionName(const PositionalCollectionMap::value_type&amp; mapValue)
<span style = "background-color:#fdd">{
  std::ostringstream nameStrm;
  nameStrm.imbue(std::locale("C"));
  nameStrm &lt;&lt; "Pos " &lt;&lt; mapValue.first &lt;&lt; std::endl &lt;&lt; std::setprecision(3) &lt;&lt; "(" &lt;&lt; mapValue.second.first[0] &lt;&lt; "|" &lt;&lt; mapValue.second.first[1] &lt;&lt; "|" &lt;&lt; mapValue.second.first[2] &lt;&lt; ")";
  return nameStrm.str();
};</span>


const mitk::PlotDataCurveCollection* mitk::ModelFitPlotData::GetPositionalPlot(const mitk::Point3D&amp; point) const
<span style = "background-color:#fdd">{
  auto predicate = [point](const PositionalCollectionMap::value_type&amp; value) {return value.second.first == point; };</span>

<span style = "background-color:#fdd">  auto iter = std::find_if(std::begin(this-&gt;positionalPlots), std::end(this-&gt;positionalPlots), predicate);
  if (iter != positionalPlots.end())</span>
  {
<span style = "background-color:#fdd">    return iter-&gt;second.second.GetPointer();</span>
  }
<span style = "background-color:#fdd">  return nullptr;
};</span>

const mitk::PlotDataCurveCollection* mitk::ModelFitPlotData::GetPositionalPlot(mitk::PointSet::PointIdentifier id) const
<span style = "background-color:#fdd">{
  auto iter = this-&gt;positionalPlots.find(id);
  if (iter != positionalPlots.end())</span>
  {
<span style = "background-color:#fdd">    return iter-&gt;second.second.GetPointer();</span>
  }
<span style = "background-color:#fdd">  return nullptr;
};</span>


mitk::PlotDataValues::value_type mitk::ModelFitPlotData::GetXMinMax() const
<span style = "background-color:#fdd">{
  double max = itk::NumericTraits&lt;double&gt;::NonpositiveMin();
  double min = itk::NumericTraits&lt;double&gt;::max();</span>

  //currently we assume that within a model fit, plot data does not exceed
  //the sample/signale on the x axis.
<span style = "background-color:#fdd">  auto sample = this-&gt;GetSamplePlot(this-&gt;currentPositionPlots);
  if (sample)</span>
  {
<span style = "background-color:#fdd">    CheckXMinMaxFromPlotDataValues(sample-&gt;GetValues(), min, max);</span>
  }
<span style = "background-color:#fdd">  for (const auto&amp; posCollection : this-&gt;positionalPlots)</span>
  {
<span style = "background-color:#fdd">    auto sample = this-&gt;GetSamplePlot(posCollection.second.second);
    if (sample)</span>
    {
<span style = "background-color:#fdd">      CheckXMinMaxFromPlotDataValues(sample-&gt;GetValues(), min, max);</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return std::make_pair(min, max);
};</span>

mitk::PlotDataValues::value_type mitk::ModelFitPlotData::GetYMinMax() const
<span style = "background-color:#fdd">{
  double max = itk::NumericTraits&lt;double&gt;::NonpositiveMin();
  double min = itk::NumericTraits&lt;double&gt;::max();</span>

<span style = "background-color:#fdd">  for (const auto&amp; plot : *(this-&gt;currentPositionPlots.GetPointer()))</span>
  {
<span style = "background-color:#fdd">    CheckYMinMaxFromPlotDataValues(plot.second-&gt;GetValues(), min, max);
  }</span>

<span style = "background-color:#fdd">  for (const auto&amp; posCollection : this-&gt;positionalPlots)</span>
  {
<span style = "background-color:#fdd">    for (const auto&amp; plot : *(posCollection.second.second))</span>
    {
<span style = "background-color:#fdd">      CheckYMinMaxFromPlotDataValues(plot.second-&gt;GetValues(), min, max);
    }
  }</span>

<span style = "background-color:#fdd">  for (const auto&amp; plot : *(this-&gt;staticPlots))</span>
  {
<span style = "background-color:#fdd">    CheckYMinMaxFromPlotDataValues(plot.second-&gt;GetValues(), min, max);
  }</span>

<span style = "background-color:#fdd">  return std::make_pair(min, max);
};</span>

mitk::ModelFitPlotData::ModelFitPlotData()
<span style = "background-color:#fdd">{
  this-&gt;currentPositionPlots = PlotDataCurveCollection::New();
  this-&gt;staticPlots = PlotDataCurveCollection::New();
};</span>

void mitk::CheckYMinMaxFromPlotDataValues(const PlotDataValues&amp; data, double&amp; min, double&amp; max)
<span style = "background-color:#fdd">{
  for (const auto &amp; pos : data)</span>
  {
<span style = "background-color:#fdd">    if (max &lt; pos.second)</span>
    {
<span style = "background-color:#fdd">      max = pos.second;</span>
    }

<span style = "background-color:#fdd">    if (min &gt; pos.second)</span>
    {
<span style = "background-color:#fdd">      min = pos.second;</span>
    }
<span style = "background-color:#fdd">  }
}</span>

void mitk::CheckXMinMaxFromPlotDataValues(const PlotDataValues&amp; data, double&amp; min, double&amp; max)
<span style = "background-color:#fdd">{
  for (const auto &amp; pos : data)</span>
  {
<span style = "background-color:#fdd">    if (max &lt; pos.first)</span>
    {
<span style = "background-color:#fdd">      max = pos.first;</span>
    }

<span style = "background-color:#fdd">    if (min &gt; pos.first)</span>
    {
<span style = "background-color:#fdd">      min = pos.first;</span>
    }
<span style = "background-color:#fdd">  }
}</span>

/** Helper function that generates the curve based on a stored and on the fly parsed function string.*/
mitk::PlotDataCurve::Pointer
CalcSignalFromFunction(const mitk::Point3D&amp; position, const mitk::modelFit::ModelFitInfo* fitInfo, const mitk::ModelBase::TimeGridType&amp; timeGrid)
<span style = "background-color:#fdd">{
  if (!fitInfo)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot calc model curve from function for given fit. Passed ModelFitInfo instance is nullptr.";</span>
  }

<span style = "background-color:#fdd">  assert(fitInfo-&gt;inputImage.IsNotNull());</span>

<span style = "background-color:#fdd">  mitk::PlotDataCurve::Pointer result = mitk::PlotDataCurve::New();
  mitk::PlotDataCurve::ValuesType values;
  values.reserve(timeGrid.size());</span>

  // Calculate index
  ::itk::Index&lt;3&gt; index;
<span style = "background-color:#fdd">  mitk::BaseGeometry::Pointer geometry = fitInfo-&gt;inputImage-&gt;GetTimeGeometry()-&gt;GetGeometryForTimeStep(0);</span>

<span style = "background-color:#fdd">  geometry-&gt;WorldToIndex(position, index);</span>

<span style = "background-color:#fdd">  mitk::ParameterValueMapType parameterMap = mitk::ExtractParameterValueMapFromModelFit(fitInfo, position);</span>

<span style = "background-color:#fdd">  mitk::FormulaParser parser(&amp;parameterMap);</span>

<span style = "background-color:#fdd">  for (unsigned int t = 0; t &lt; timeGrid.size(); ++t)</span>
  {
    // Set up static parameters
<span style = "background-color:#fdd">    for (const auto&amp; var : fitInfo-&gt;staticParamMap)</span>
    {
<span style = "background-color:#fdd">      const auto&amp; list = var.second;</span>

<span style = "background-color:#fdd">      if (list.size() == 1)</span>
      {
<span style = "background-color:#fdd">        parameterMap[var.first] = list.front();
      }</span>
      else
      {
<span style = "background-color:#fdd">        parameterMap[var.first] = list.at(t);
      }
    }</span>

    // Calculate curve data
<span style = "background-color:#fdd">    double x = timeGrid[t];
    parameterMap[fitInfo-&gt;x] = x;</span>

<span style = "background-color:#fdd">    double y = parser.parse(fitInfo-&gt;function);
    values.emplace_back(std::make_pair(x, y));
  }</span>

<span style = "background-color:#fdd">  result-&gt;SetValues(std::move(values));
  return result;
}</span>

/** Helper function that generates the curve based on the model specified by the fit info.*/
mitk::PlotDataCurve::Pointer
CalcSignalFromModel(const mitk::Point3D&amp; position, const mitk::modelFit::ModelFitInfo* fitInfo, const mitk::ModelParameterizerBase* parameterizer = nullptr)
<span style = "background-color:#fdd">{
  assert(fitInfo);</span>

<span style = "background-color:#fdd">  if (!parameterizer)</span>
  {
<span style = "background-color:#fdd">    parameterizer = mitk::ModelGenerator::GenerateModelParameterizer(*fitInfo);</span>
  }

<span style = "background-color:#fdd">  assert(fitInfo-&gt;inputImage.IsNotNull());</span>

  // Calculate index
  ::itk::Index&lt;3&gt; index;
<span style = "background-color:#fdd">  mitk::BaseGeometry::Pointer geometry = fitInfo-&gt;inputImage-&gt;GetTimeGeometry()-&gt;GetGeometryForTimeStep(0);</span>

<span style = "background-color:#fdd">  geometry-&gt;WorldToIndex(position, index);</span>

  //model generation
<span style = "background-color:#fdd">  mitk::ModelBase::Pointer model = parameterizer-&gt;GenerateParameterizedModel(index);</span>

<span style = "background-color:#fdd">  mitk::ParameterValueMapType parameterMap = mitk::ExtractParameterValueMapFromModelFit(fitInfo, position);</span>

<span style = "background-color:#fdd">  mitk::ModelBase::ParametersType paramArray = mitk::ConvertParameterMapToParameterVector(parameterMap, model);</span>

<span style = "background-color:#fdd">  mitk::ModelBase::ModelResultType curveDataY = model-&gt;GetSignal(paramArray);
  mitk::PlotDataCurve::Pointer result = mitk::PlotDataCurve::New();</span>

<span style = "background-color:#fdd">  mitk::ModelBase::TimeGridType timeGrid = model-&gt;GetTimeGrid();
  mitk::PlotDataCurve::ValuesType values;
  values.reserve(timeGrid.size());</span>

<span style = "background-color:#fdd">  for (unsigned int t = 0; t &lt; timeGrid.size(); ++t)</span>
  {
<span style = "background-color:#fdd">    double x = timeGrid[t];
    double y = curveDataY[t];
    values.emplace_back(std::make_pair(x, y));
  }</span>

<span style = "background-color:#fdd">  result-&gt;SetValues(std::move(values));
  return result;
}</span>

mitk::PlotDataCurve::Pointer
mitk::GenerateModelSignalPlotData(const mitk::Point3D&amp; position, const mitk::modelFit::ModelFitInfo* fitInfo, const mitk::ModelBase::TimeGridType&amp; timeGrid, mitk::ModelParameterizerBase* parameterizer)
<span style = "background-color:#fdd">{
  if (!fitInfo)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot calc model curve from function for given fit. Passed ModelFitInfo instance is nullptr.";</span>
  }

<span style = "background-color:#fdd">  mitk::PlotDataCurve::Pointer result;</span>

<span style = "background-color:#fdd">  if (!parameterizer)</span>
  {
<span style = "background-color:#fdd">    parameterizer = ModelGenerator::GenerateModelParameterizer(*fitInfo);</span>
  }

<span style = "background-color:#fdd">  if (parameterizer)</span>
  {
    // Use model instead of formula parser
<span style = "background-color:#fdd">    parameterizer-&gt;SetDefaultTimeGrid(timeGrid);
    result = CalcSignalFromModel(position, fitInfo, parameterizer);
  }</span>
  else
  {
    // Use formula parser to parse function string
    try
    {
<span style = "background-color:#fdd">      result = CalcSignalFromFunction(position, fitInfo, timeGrid);</span>
    }
    catch (const mitk::FormulaParserException&amp; e)
<span style = "background-color:#fdd">    {
      MITK_ERROR &lt;&lt; "Error while parsing modelfit function: " &lt;&lt; e.what();
    }</span>
  }

<span style = "background-color:#fdd">  return result;
}</span>

mitk::PlotDataCurveCollection::Pointer
mitk::GenerateAdditionalModelFitPlotData(const mitk::Point3D&amp; /*position*/, const mitk::modelFit::ModelFitInfo* fitInfo, const mitk::ModelBase::TimeGridType&amp; timeGrid)
<span style = "background-color:#fdd">{
  if (!fitInfo)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot calc model curve from function for given fit. Passed ModelFitInfo instance is nullptr.";</span>
  }

<span style = "background-color:#fdd">  mitk::PlotDataCurveCollection::Pointer result = mitk::PlotDataCurveCollection::New();</span>

<span style = "background-color:#fdd">  for (const auto&amp; additionalInput : fitInfo-&gt;inputData.GetLookupTable())</span>
  {
<span style = "background-color:#fdd">    if (additionalInput.second.size() != timeGrid.size())</span>
    {
<span style = "background-color:#fdd">      MITK_ERROR &lt;&lt;</span>
        "Error while refreshing input data for visualization. Size of data and input image time grid differ. Invalid data name: "
        &lt;&lt; additionalInput.first;
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">      mitk::PlotDataCurve::Pointer pointData = mitk::PlotDataCurve::New();;
      mitk::PlotDataCurve::ValuesType values;
      values.reserve(timeGrid.size());</span>

<span style = "background-color:#fdd">      for (unsigned int t = 0; t &lt; timeGrid.size(); ++t)</span>
      {
<span style = "background-color:#fdd">        const double x = timeGrid[t];
        const double y = additionalInput.second[t];
        values.emplace_back(std::make_pair(x, y));
      }
      pointData-&gt;SetValues(std::move(values));
      result-&gt;CastToSTLContainer().emplace(additionalInput.first, std::move(pointData));
    }
  }</span>

<span style = "background-color:#fdd">  return result;
}</span>

mitk::PlotDataCurve::Pointer
mitk::GenerateImageSamplePlotData(const mitk::Point3D&amp; position, const mitk::Image* image, const mitk::ModelBase::TimeGridType&amp; timeGrid)
<span style = "background-color:#fdd">{
  if (!image)</span>
  {
<span style = "background-color:#fdd">    mitkThrow() &lt;&lt; "Cannot generate sample plot data. Passed image instance is nullptr.";</span>
  }

<span style = "background-color:#fdd">  mitk::PlotDataCurve::Pointer result = mitk::PlotDataCurve::New();
  mitk::PlotDataCurve::ValuesType values;
  values.reserve(timeGrid.size());</span>

<span style = "background-color:#fdd">  for (unsigned int t = 0; t &lt; timeGrid.size(); ++t)</span>
  {
<span style = "background-color:#fdd">    const double x = timeGrid[t];
    const double y = ReadVoxel(image, position, t);
    values.emplace_back(std::make_pair(x, y));
  }</span>

<span style = "background-color:#fdd">  result-&gt;SetValues(std::move(values));
  return result;
}</span></pre>
	</body>
</html>